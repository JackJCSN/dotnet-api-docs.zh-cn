<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e41cffa3a1b13a25652c91a03e7221646dfa1da1" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70525738" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示任意大的带符号整数。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>类型是一个不可变类型，表示其值在理论上没有上限或下限的任意大整数。 <xref:System.Numerics.BigInteger>类型的成员与其他整型<xref:System.Byte>类型（ <xref:System.Int64> <xref:System.SByte>、 <xref:System.Int32>  <xref:System.Int16> 、 、、 、、和 <xref:System.UInt32> 类型 <xref:System.UInt64>  ）紧密并行。 <xref:System.UInt16> 此类型不同于中的其他整型类型[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，该类型的范围由其`MinValue`和`MaxValue`属性指示。  
  
> [!NOTE]
>  因为类型<xref:System.Numerics.BigInteger>是不可变的（请参阅[可变性和 BigInteger 结构](#mutability)），并且因为它没有上限或<xref:System.OutOfMemoryException>下限，所以，对于导致<xref:System.Numerics.BigInteger>值增长太大的任何操作，可能会引发。  
  
## <a name="instantiating-a-biginteger-object"></a>实例化 BigInteger 对象  
 可以通过多种方式<xref:System.Numerics.BigInteger>实例化对象：  
  
-   您可以使用`new`关键字并提供任何整型或浮点值作为<xref:System.Numerics.BigInteger>构造函数的参数。 （浮点值在赋给<xref:System.Numerics.BigInteger>之前会被截断。）下面的示例演示如何使用`new`关键字实例化<xref:System.Numerics.BigInteger>值。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   您可以声明一个<xref:System.Numerics.BigInteger>变量，并为其分配一个值，就像对任何数值类型一样，前提是该值是整数类型。 下面的示例使用赋值<xref:System.Numerics.BigInteger> <xref:System.Int64>从中创建值。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   如果你强制转换值或先转换值，则可以<xref:System.Numerics.BigInteger>为该对象分配一个十进制或浮点值。 下面的示例显式强制转换（ C#在中）或将<xref:System.Double> <xref:System.Decimal>值（在 Visual Basic）和值转换<xref:System.Numerics.BigInteger>为。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 利用这些方法，您可以实例<xref:System.Numerics.BigInteger>化一个对象，该对象的值只在一个现有的数值类型的范围内。 可以通过以下三<xref:System.Numerics.BigInteger>种方式之一实例化其值可以超出现有数值类型范围的对象：  
  
-   可以使用`new`关键字，并<xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType>向构造函数提供任意大小的字节数组。 例如:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   可以调用<xref:System.Numerics.BigInteger.Parse%2A>或<xref:System.Numerics.BigInteger.TryParse%2A>方法，将数字的字符串表示形式转换为<xref:System.Numerics.BigInteger>。 例如:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   您可以调用`static` （`Shared`在 Visual Basic） <xref:System.Numerics.BigInteger>方法，该方法对数值表达式执行某种操作并返回计算所得<xref:System.Numerics.BigInteger>的结果。 下面的示例通过多维数据集<xref:System.UInt64.MaxValue?displayProperty=nameWithType>并将结果赋<xref:System.Numerics.BigInteger>给来实现此功能。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 的未初始化的值<xref:System.Numerics.BigInteger>为<xref:System.Numerics.BigInteger.Zero%2A>。  
  
## <a name="performing-operations-on-biginteger-values"></a>对 BigInteger 值执行操作  
 可以像使用任何<xref:System.Numerics.BigInteger>其他整型一样使用实例。 <xref:System.Numerics.BigInteger>重载标准数字运算符，以使您能够执行基本的数学运算，如加法、减法、除法、乘法、减法、求反和一元求反。 还可以使用标准数值运算符来比较两个<xref:System.Numerics.BigInteger>值。 与其他整型类型类似， <xref:System.Numerics.BigInteger>还支持按位`And`、 `Or`、 `XOr`、左移和右移运算符。 对于不支持自定义运算符的语言，该<xref:System.Numerics.BigInteger>结构还提供了执行数学运算的等效方法。 其中包括<xref:System.Numerics.BigInteger.Add%2A> <xref:System.Numerics.BigInteger.Divide%2A> 、 <xref:System.Numerics.BigInteger.Negate%2A> 、、 、 <xref:System.Numerics.BigInteger.Subtract%2A> 和多个其他。 <xref:System.Numerics.BigInteger.Multiply%2A>  
  
 <xref:System.Numerics.BigInteger>结构的许多成员直接与其他整型类型的成员相对应。 此外， <xref:System.Numerics.BigInteger>添加如下成员：  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>，它返回一个指示<xref:System.Numerics.BigInteger>值的符号的值。  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>，它返回<xref:System.Numerics.BigInteger>值的绝对值。  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>，它返回除法运算的商和余数。  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>，它返回两个<xref:System.Numerics.BigInteger>值的最大公因数。  
  
 其中许多附加成员与<xref:System.Math>类的成员相对应，后者提供了用于处理基元数值类型的功能。  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>可变性和 BigInteger 结构  
 下面的示例实例化<xref:System.Numerics.BigInteger>一个对象，然后将其值递增1。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 虽然此示例似乎用于修改现有对象的值，但这不是这种情况。 <xref:System.Numerics.BigInteger>对象是不可变的，这意味着，公共语言运行时实际上会创建一个<xref:System.Numerics.BigInteger>新的对象，并为其分配一个大于先前值的值。 然后，此新对象将返回到调用方。  
  
> [!NOTE]
>  .NET Framework 中的其他数字类型也是不可变的。 但是，因为该<xref:System.Numerics.BigInteger>类型没有上限或下限，所以它的值可能会变得非常大，并对性能产生显著影响。  
  
 尽管此过程对调用方是透明的，但它确实会导致性能下降。 在某些情况下，尤其是在非常大<xref:System.Numerics.BigInteger>的值的循环中执行重复的操作时，性能损失可能会很大。 例如，在下面的示例中，操作重复执行了一百万次， <xref:System.Numerics.BigInteger>每次操作成功时，值会递增1。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 在这种情况下，您可以通过对<xref:System.Int32>变量执行所有中间分配来提高性能。 然后，在循环退出时，可以将该变量的<xref:System.Numerics.BigInteger>最终值分配给该对象。 下面的示例进行了这方面的演示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>处理字节数组和十六进制字符串  
 如果将值<xref:System.Numerics.BigInteger>转换为字节数组，或将字节数组转换为<xref:System.Numerics.BigInteger>值，则必须考虑字节的顺序。 <xref:System.Numerics.BigInteger>结构要求字节数组中的单个字节以小字节序顺序显示（即，值的低序位字节优先于高阶字节之前）。 可以通过<xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToByteArray%2A>调用方法来往返值，然后将<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>生成的字节数组传递给构造函数，如下面的示例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 若要从<xref:System.Numerics.BigInteger>表示某个其他整型值的字节数组中实例化某个值，你可以将整数值传递<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>给方法，然后将<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>生成的字节数组传递到构造函数。 下面的示例实例化<xref:System.Numerics.BigInteger>一个<xref:System.Int16>表示值的字节数组中的一个值。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger>结构假定负值是使用两个补数表示形式存储的。 由于结构表示一个没有固定长度的数值<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> ，因此构造函数始终将数组中最后一个字节的最高有效位解释为符号位。 <xref:System.Numerics.BigInteger> 如果为， <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>则阻止构造函数混淆具有正值的符号和数量级表示形式的负值的两个补数表示形式，其中最后一个字节在字节数组中的最高有效位为正值通常情况下，将设置的值应为0。 例如，0xC0 0xBD 0xF0 0xFF 是-1000000 或4293967296的小字节序十六进制表示形式。 由于此数组中最后一个字节的最高有效位为 on，因此该字节数组的值将由<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数解释为-1000000。 若要实例<xref:System.Numerics.BigInteger>化其值为正的，则必须将其元素为 0xC0 0xBD 0xF0 0xff 0x00 的字节数组传递到构造函数。 下面的示例阐释了这一点。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 通过<xref:System.Numerics.BigInteger.ToByteArray%2A>正值从正值创建的字节数组包括此额外的零值字节。 因此，该<xref:System.Numerics.BigInteger>结构可以通过将值分配到并从字节数组中恢复它们来成功往返值，如下例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 但是，你可能需要将此额外的零值字节添加到由开发人员动态创建的字节数组中，或由将无符号整数转换为字节数组（如<xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>、 <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>和<xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>）的方法返回。  
  
 在分析十六进制字符串时， <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>和<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法假定如果设置了字符串中第一个字节的最高有效位，或者字符串的第一个十六进制数字表示字节值的下四位，则该值为使用两个的补码表示形式表示。 例如，"FF01" 和 "F01" 都表示十进制值-255。 若要将正值与负值区分开来，正值应包括前导零。 <xref:System.Numerics.BigInteger.ToString%2A>方法的相关重载在传递 "X" 格式字符串时，将前导零添加到正值的返回十六进制字符串。 这样就可以<xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToString%2A>使用和<xref:System.Numerics.BigInteger.Parse%2A>方法来往返值，如下面的示例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 但是，通过调用`ToString`其他整数类型的方法或包含`toBase`参数的<xref:System.Convert.ToString%2A>方法的重载创建的十六进制字符串并不表示值或源数据类型的符号，十六进制字符串是派生的。 成功实例化<xref:System.Numerics.BigInteger>此类字符串的值需要一些额外的逻辑。 下面的示例提供了一个可能的实现。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">顺序为 little-endian 的字节值的数组。</param>
        <summary>使用字节数组中的值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`数组中的每个字节应采用小字节序顺序，即从最低序位字节到最高序位字节。 例如，数字值1000000000000如下表中所示：  
  
|||  
|-|-|  
|十六进制字符串|E8D4A51000|  
|字节数组（首先为最低索引）|00 10 A5 D4 E8 00|  
  
 将数值转换为字节数组的大多数方法（如<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>和<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>）将返回以小字节序顺序返回的字节数组。  
  
 构造函数需要字节数组中的正值才能使用符号和量的表示形式，而负值则使用两个补数表示形式。 换言之，如果在中`value`设置了最高序位字节的最高序位，则生成<xref:System.Numerics.BigInteger>的值为负。 这可能会导致将正值错误解释为负值，这取决于字节数组的源。 字节数组通常按以下方式生成：  
  
-   通过调用<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>方法。 因为此方法返回一个字节数组，该数组的数组中最高序位字节的最高序位为正值，所以没有可能将正值错误解释为负值。 当方法传递<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>给构造函数<xref:System.Numerics.BigInteger.ToByteArray%2A>时，由方法创建的未修改字节数组始终会成功往返。  
  
-   调用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法并向其传递一个有符号整数作为参数。 由于有符号整数处理的是符号和量的表示形式和两个补码表示形式，因此没有任何可能将正值错误解释为负数。  
  
-   调用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法并向其传递无符号整数作为参数。 因为无符号整数仅按其大小表示，所以可以将正值错误解释为负值。 若要防止这种误解，可以将零字节值添加到数组的末尾。 下一节中的示例提供了一个图例。  
  
-   通过动态或静态方式创建字节数组，无需调用上述任何方法，或通过修改现有的字节数组。 若要防止将正值错误解释为负值，可以将零字节值添加到数组的末尾。  
  
 如果`value`为空<xref:System.Byte>数组，则新<xref:System.Numerics.BigInteger>的对象将初始化为的<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>值。 如果`value`为`null` ，则 <xref:System.ArgumentNullException> 构造函数引发。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Numerics.BigInteger>一个5元素字节数组，其值为 {5，4，3，2，1}。 然后，它会<xref:System.Numerics.BigInteger>将表示为小数和十六进制数字的值显示到控制台。 使用文本输出比较输入数组，使此<xref:System.Numerics.BigInteger>类构造函数的此重载创建的<xref:System.Numerics.BigInteger>对象的值为4328719365（或0x102030405）。 字节数组中第一个元素的值为5，它定义了<xref:System.Numerics.BigInteger>对象的最低序位字节的值，这是0x05。 字节数组的第二个元素的值为4，它定义<xref:System.Numerics.BigInteger>对象的第二个字节的值，即0x04，依此类推。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 下面的示例实例化一个正值和负值<xref:System.Numerics.BigInteger> ，将它们传递<xref:System.Numerics.BigInteger.ToByteArray%2A>给方法，然后从生成的字节数组<xref:System.Numerics.BigInteger>还原原始值。 请注意，这两个值由相同的字节数组表示。 它们之间唯一的区别在于字节数组中最后一个元素的最高有效位。 如果从负值<xref:System.Numerics.BigInteger>创建数组，则设置此位（字节的值为0xff）。 如果从正值<xref:System.Numerics.BigInteger>创建数组，则不设置位（字节的值为零）。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 下面的示例演示如何通过将值为零的字节添加到数组的末尾，来确保不将正值错误地实例化为负值。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">十进制数。</param>
        <summary>使用 <see cref="T:System.Numerics.BigInteger" /> 值初始化 <see cref="T:System.Decimal" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此构造函数的结果与显式<xref:System.Decimal>将值赋<xref:System.Numerics.BigInteger>给变量的结果相同。  
  
 调用此构造函数可能会导致数据丢失;`value` 在 <xref:System.Numerics.BigInteger> 实例化对象时，的任何小数部分都将被截断。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>构造函数来<xref:System.Numerics.BigInteger>实例化对象。 它定义值的<xref:System.Decimal>数组，然后将每个值传递<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>给构造函数。 请注意， <xref:System.Decimal>在将值分配<xref:System.Numerics.BigInteger>给对象时，该值将被截断，而不是舍入。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">一个双精度浮点值。</param>
        <summary>使用双精度浮点值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 在 <xref:System.Numerics.BigInteger> 实例化对象时，将截断参数的任何小数部分。  
  
 由于缺少<xref:System.Double>数据类型的精度，调用此构造函数可能会导致数据丢失。  
  
 调用此构造函数生成的<xref:System.Double> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值显式赋值给而产生的值相同。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29>构造函数来<xref:System.Numerics.BigInteger>实例化对象。 它还说明了在使用<xref:System.Double>数据类型时可能会发生的精度损失。 为分配一个较大的值，然后将其分配<xref:System.Numerics.BigInteger>给对象。 <xref:System.Double> 如输出所示，此分配涉及精度损失。 然后，这两个值将递增1。 输出显示<xref:System.Numerics.BigInteger>该对象反映了更改后的值，而该<xref:System.Double>对象却没有。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 为 <see cref="F:System.Double.NaN" />、<see cref="F:System.Double.NegativeInfinity" /> 或 <see cref="F:System.Double.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32 位带符号整数。</param>
        <summary>使用 32 位带符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数实例化<xref:System.Numerics.BigInteger>对象时不会损失精度。  
  
 调用此构造函数生成的<xref:System.Int32> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值赋值给得出的值相同。  
  
 <xref:System.Byte> <xref:System.Int16>结构不包含具有、 <xref:System.SByte> 、或 <xref:System.UInt16> 类型的参数的构造函数。 <xref:System.Numerics.BigInteger> 但是， <xref:System.Int32>类型支持将8位和16位有符号和无符号整数隐式转换为有符号的32位整数。 因此，如果`value`是这四个整型类型中的任意一种，就会调用此构造函数。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29>构造函数来实例化<xref:System.Numerics.BigInteger> 32 位整数数组中的值。 它还使用隐式转换将每个32位整数值分配给<xref:System.Numerics.BigInteger>变量。 然后，它对两个值进行比较以确定<xref:System.Numerics.BigInteger>生成的值相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64 位带符号整数。</param>
        <summary>使用 64 位带符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数实例化<xref:System.Numerics.BigInteger>对象时不会损失精度。  
  
 调用此构造函数生成的<xref:System.Int64> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值赋值给得出的值相同。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29>构造函数来实例化<xref:System.Numerics.BigInteger> 64 位整数数组中的值。 它还使用隐式转换将每个64位整数值分配给<xref:System.Numerics.BigInteger>变量。 然后，它对两个值进行比较以确定<xref:System.Numerics.BigInteger>生成的值相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">单精度浮点值。</param>
        <summary>使用单精度浮点值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 在 <xref:System.Numerics.BigInteger> 实例化对象时，将截断参数的任何小数部分。  
  
 由于缺少<xref:System.Single>数据类型的精度，调用此构造函数可能会导致数据丢失。  
  
 调用此构造函数生成的<xref:System.Single> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值显式赋值给而产生的值相同。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29>构造函数来<xref:System.Numerics.BigInteger>实例化对象。 它还说明了在使用<xref:System.Single>数据类型时可能会发生的精度损失。 为分配了一个大负值，然后将其分配<xref:System.Numerics.BigInteger>给对象。 <xref:System.Single> 如输出所示，此分配涉及精度损失。 然后，这两个值将递增1。 输出显示<xref:System.Numerics.BigInteger>该对象反映了更改后的值，而该<xref:System.Single>对象却没有。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 为 <see cref="F:System.Single.NaN" />、<see cref="F:System.Single.NegativeInfinity" /> 或 <see cref="F:System.Single.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">32 位无符号整数值。</param>
        <summary>使用 32 位无符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>使用此构造函数实例化时，精度不会损失。  
  
 调用此构造函数生成的<xref:System.UInt32> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值赋值给得出的值相同。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29>构造函数和赋值语句来初始化<xref:System.Numerics.BigInteger>一个无符号32位整数数组中的值。 然后，它对两个值进行比较，以演示初始化<xref:System.Numerics.BigInteger>值的两种方法生成相同的结果。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64 位无符号整数。</param>
        <summary>使用 64 位无符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>使用此构造函数实例化时，精度不会损失。  
  
 调用此构造函数生成的<xref:System.UInt64> <xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>值与通过将值赋值给得出的值相同。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29>构造函数<xref:System.Numerics.BigInteger>实例化<xref:System.UInt64.MaxValue>其值等于的对象。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">数字。</param>
        <summary>获取 <see cref="T:System.Numerics.BigInteger" /> 对象的绝对值。</summary>
        <returns><paramref name="value" /> 的绝对值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数字的绝对值是没有符号的数字，如下表所示。  
  
|`value` 参数|返回值|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 方法等效于基元数值类型<xref:System.Math.Abs%2A?displayProperty=nameWithType>的方法。 <xref:System.Numerics.BigInteger.Abs%2A>  
  
   
  
## Examples  
 下面的<xref:System.Numerics.BigInteger.Abs%2A>示例使用方法，在将其<xref:System.Numerics.BigInteger>序列化为文件之前，将值从两个补数表示形式转换为签名和量表示形式。 然后，将对文件中的数据进行反序列化<xref:System.Numerics.BigInteger>并将其分配给新的对象。  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一个值。</param>
        <param name="right">要相加的第二个值。</param>
        <summary>将两个 <see cref="T:System.Numerics.BigInteger" /> 值相加，并返回结果。</summary>
        <returns><paramref name="left" /> 与 <paramref name="right" /> 的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支持运算符重载或自定义运算符的语言可以使用<xref:System.Numerics.BigInteger.Add%2A>方法执行使用<xref:System.Numerics.BigInteger>值的加法运算。  
  
 在实例化变量时，方法是加法运算符的有用替代方法，方法是对变量赋值，并为其分配加法，如下面的示例中所示。 <xref:System.Numerics.BigInteger.Add%2A> <xref:System.Numerics.BigInteger>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>比较两个 <see cref="T:System.Numerics.BigInteger" /> 值，并返回一个整数，该整数指示第一个值是小于、等于还是大于第二个值。</summary>
        <returns>一个有符号整数，指示 <paramref name="left" /> 和 <paramref name="right" /> 的相对值，如下表所示。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="left" /> 小于 <paramref name="right" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="left" /> 等于 <paramref name="right" />。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="left" /> 大于 <paramref name="right" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管该<xref:System.Numerics.BigInteger>类型没有固定范围，但<xref:System.Numerics.BigInteger>值的比较并不是以反映浮点数比较的精度所引起的。 下面的示例比较两<xref:System.Numerics.BigInteger>个不同的值，每个值都有1896位数。 <xref:System.Numerics.BigInteger.Compare%2A>方法会正确报告两个值不相等。  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值与另一个值进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于另一个值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位带符号整数。</param>
        <summary>将此实例与 64 位带符号整数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于 64 位带符号整数的值。</summary>
        <returns>一个带符号整数值，指示此实例与 <paramref name="other" /> 的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 说明 
 </description></listheader><item><term> 小于零 
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other` 为 <xref:System.Int16> 、、 、、 <xref:System.Int32> 或值，则 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> 当调用方法时，它将<xref:System.Int64>隐式转换为值。 <xref:System.UInt32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
   
  
## Examples  
 下面的示例演示了调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>具有整数值的方法的结果。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比较的对象。</param>
        <summary>将此实例与另一个 <see cref="T:System.Numerics.BigInteger" /> 进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号整数值，指示此实例与 <paramref name="other" /> 的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 说明 
 </description></listheader><item><term> 小于零 
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Numerics.BigInteger.CompareTo%2A>方法的重载<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>实现方法。 泛型集合对象使用它对集合中的项进行排序。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>方法对`StarInfo`对象列表进行排序。 每`StarInfo`个对象提供有关星形名称及其与地球距离的信息（英里）。 `StarInfo`实现接口，该接口使`StarInfo`对象能够按泛型集合类进行排序。 <xref:System.IComparable%601> 其<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>实现仅包装对<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>的调用。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 然后，以下代码实例化`StarInfo`四个对象，并将它们<xref:System.Collections.Generic.List%601>存储在泛型对象中。 调用方法后， `StarInfo`按与地球距离的顺序显示对象。 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">要比较的对象。</param>
        <summary>将此实例与指定对象进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号整数，指示当前实例与 <paramref name="obj" /> 参数的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 说明 
 </description></listheader><item><term> 小于零 
 </term><description> 当前实例小于 <paramref name="obj" />。  
  
 </description></item><item><term> 零 
 </term><description> 当前实例等于 <paramref name="obj" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 当前实例大于 <paramref name="obj" />，或者 <paramref name="obj" /> 参数为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Numerics.BigInteger.CompareTo%2A>方法的重载<xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType>实现方法。 它由非泛型集合对象用于对集合中的项进行排序。  
  
 `obj`参数必须是下列其中一项：  
  
-   一个其运行时类型为<xref:System.Numerics.BigInteger>的对象。  
  
-   值为 `null` 的变量。 <xref:System.Object> 如果`obj`参数的值为`null`，则该方法返回1，指示`obj`当前实例大于。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>方法将<xref:System.Numerics.BigInteger>值与对象数组中的每个元素进行比较  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> 不是 <see cref="T:System.Numerics.BigInteger" />。</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位无符号整数。</param>
        <summary>将此实例与 64 位无符号整数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于 64 位无符号整数的值。</summary>
        <returns>一个带符号整数，指示此实例和 <paramref name="other" /> 的相对值，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 说明 
 </description></listheader><item><term> 小于零 
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>用另一个值除 <see cref="T:System.Numerics.BigInteger" /> 值并返回结果。</summary>
        <returns>相除后的商。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A>方法执行整数除法运算，将放弃由相除产生的任何余数。 若要在保留余数的同时执行整数除法， <xref:System.Numerics.BigInteger.DivRem%2A>请调用方法。 若要仅检索余数，请调用<xref:System.Numerics.BigInteger.Remainder%2A>方法。  
  
 <xref:System.Numerics.BigInteger.Divide%2A>方法可由不支持运算符重载的语言使用。 其行为与使用除法运算符的除法相同。  
  
   
  
## Examples  
 下面的示例创建值的<xref:System.Numerics.BigInteger>数组。 然后，它将每个元素用作除法运算中使用<xref:System.Numerics.BigInteger.Divide%2A>方法、除法运算符（/） <xref:System.Numerics.BigInteger.DivRem%2A>和方法的商。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <param name="remainder">当此方法返回时，包含一个表示相除余数的 <see cref="T:System.Numerics.BigInteger" /> 值。 此参数未经初始化即被传递。</param>
        <summary>用另一个值除一个 <see cref="T:System.Numerics.BigInteger" /> 值，返回结果，并在输出参数中返回余数。</summary>
        <returns>相除后的商。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法保留整数相除产生的商和余数。 如果不感兴趣，请使用<xref:System.Numerics.BigInteger.Divide%2A>方法或除法运算符; 如果只对剩余部分感兴趣，请<xref:System.Numerics.BigInteger.Remainder%2A>使用方法。  
  
 返回`remainder`值的符号与`dividend`参数的符号相同。  
  
 <xref:System.Numerics.BigInteger.DivRem%2A>方法的行为与<xref:System.Math.DivRem%2A?displayProperty=nameWithType>方法的行为相同。  
  
   
  
## Examples  
 下面的示例创建值的<xref:System.Numerics.BigInteger>数组。 然后，它将每个元素用作除法运算中使用<xref:System.Numerics.BigInteger.Divide%2A>方法、除法运算符（/） <xref:System.Numerics.BigInteger.DivRem%2A>和方法的商。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0（零）。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个数值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位带符号整数值。</param>
        <summary>返回一个值，该值指示当前实例与 64 位带符号整数是否具有相同的值。</summary>
        <returns>如果 64 位带符号整数与当前实例具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other` 为 <xref:System.Int16> 、、 、、 <xref:System.SByte> 或<xref:System.Int64>值，则当调用方法时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Int32> <xref:System.Byte> <xref:System.UInt16>  
  
 若要确定两个对象之间的关系，而不是仅测试相等性<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> ，请调用方法。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Numerics.BigInteger>除之外<xref:System.UInt64>的每个整型类型的对象。 然后，它调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29>方法，将<xref:System.Numerics.BigInteger>值与传递给<xref:System.Numerics.BigInteger>构造函数的原始整数值进行比较。 如输出所示，每种情况下的值都相等。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比较的对象。</param>
        <summary>返回一个值，该值指示当前实例与指定的 <see cref="T:System.Numerics.BigInteger" /> 对象是否具有相同的值。</summary>
        <returns>如果此 <see cref="T:System.Numerics.BigInteger" /> 对象与 <paramref name="other" /> 具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现<xref:System.IEquatable%601>接口并略好于<xref:System.Numerics.BigInteger.Equals%28System.Object%29> ，因为它不必<xref:System.Numerics.BigInteger>将`other`参数转换为对象。  
  
 若要确定两个<xref:System.Numerics.BigInteger>对象之间的关系，而不是仅测试相等性，请<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType>调用方法。  
  
   
  
## Examples  
 下面的示例将地球上几个星的近似距离与来自地球的 Epsilon 指明的距离进行比较，以确定它们是否相等。 该示例使用<xref:System.Numerics.BigInteger.Equals%2A>方法的每个重载来测试是否相等。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比较的对象。</param>
        <summary>返回一个值，该值指示当前实例与指定的对象是否具有相同的值。</summary>
        <returns>如果 <paramref name="obj" /> 参数是 <see cref="T:System.Numerics.BigInteger" /> 对象，并且其值等于当前 <see cref="T:System.Numerics.BigInteger" /> 实例的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果参数不是值，则该方法将返回 `false` 。  <xref:System.Numerics.BigInteger> `obj` 仅当`true` `obj`是一个 <xref:System.Numerics.BigInteger> 其值等于当前实例的实例时，该方法才会返回。  
  
 若要确定两个对象之间的关系，而不是仅测试相等性<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> ，请调用方法。  
  
   
  
## Examples  
 下面的示例定义了<xref:System.Object>并行<xref:System.Numerics.BigInteger>和数组。 一个数组的每个元素与第二个数组的相应元素具有相同的值。 如示例的输出所示，仅<xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger>当数组中的实例为并且其值相等时，才会将<xref:System.Object>该实例视为等于数组中的实例。  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位无符号整数。</param>
        <summary>返回一个值，该值指示当前实例与 64 位无符号整数是否具有相同的值。</summary>
        <returns>如果当前实例与 64 位无符号整数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定两个对象之间的关系，而不是仅测试相等性<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> ，请调用方法。  
  
   
  
## Examples  
 下面的示例将地球上几个星的近似距离与来自地球的 Epsilon 指明的距离进行比较，以确定它们是否相等。 该示例使用<xref:System.Numerics.BigInteger.Equals%2A>方法的每个重载来测试是否相等。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">如果使用无符号编码，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>获取将由 <see cref="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" /> 和 <see cref="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" /> 输出的字节数。</summary>
        <returns>字节数。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.Numerics.BigInteger" /> 对象的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>查找两个 <see cref="T:System.Numerics.BigInteger" /> 值的最大公约数。</summary>
        <returns><paramref name="left" /> 和 <paramref name="right" /> 的最大公约数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最大公因数是在不返回余数的情况下<xref:System.Numerics.BigInteger> ，可以将两个值相除为的最大数目。  
  
 `left`如果和`right`参数为非零数字，则此方法始终返回至少1个值，因为所有数字都可以除以1。 如果任一参数为零，则该方法将返回非零参数的绝对值。 如果两个值都为零，则该方法返回零。  
  
> [!NOTE]
>  计算非常大的值`left`的最大公约数， `right`这可能是一项非常耗时的操作。  
  
 无论<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> `left`和参数 `right` 的符号如何，方法返回的值始终为正值。  
  
   
  
## Examples  
 下面的示例演示对<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>方法的调用，以及提供有关的<xref:System.ArgumentOutOfRangeException>有用信息所需的异常处理。 结果指示这两个数字的最大公因数为1。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是偶数。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是偶数，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是一项便利功能，可指示<xref:System.Numerics.BigInteger>值是否被两整除。 它等效于以下表达式：  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 如果当前<xref:System.Numerics.BigInteger>对象的值为<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>，则属性将返回`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 <see cref="P:System.Numerics.BigInteger.One" />。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 <see cref="P:System.Numerics.BigInteger.One" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性比其他比较（如`thisBigInteger.Equals(BigInteger.One)`）提供了明显更好的性能。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 2 的幂。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 2 的幂，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性确定某个<xref:System.Numerics.BigInteger>值是否设置了单非零位。 这意味着，如果当前`true` <xref:System.Numerics.BigInteger>对象的值为1（即 2<sup>0</sup>）或二者的任何更大的幂，则返回。 如果当前`false` <xref:System.Numerics.BigInteger>对象的值为0，则返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 <see cref="P:System.Numerics.BigInteger.Zero" />。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 <see cref="P:System.Numerics.BigInteger.Zero" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供`BigInteger.Equals(BigInteger.Zero)`的性能明显优于。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回指定数字的对数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <summary>返回指定数字的自然对数（底为 <see langword="e" />）。</summary>
        <returns><paramref name="value" /> 的自然对数（底为 <see langword="e" />），如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数被指定为以10为基数的数字。  
  
 此方法的准确返回值取决于的符号`value`，如下表所示。  
  
|参数的`value`符号|返回值|  
|-------------------------------|------------------|  
|正|的自然对数`value`，即 ln `value`或 log e`value`。|  
|零|<xref:System.Double.NegativeInfinity>。|  
|负数|<xref:System.Double.NaN>。|  
  
 若要计算某个<xref:System.Numerics.BigInteger>值以10为底的对数，请<xref:System.Numerics.BigInteger.Log10%2A>调用方法。 若要计算某个数在另一个基中的对数， <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29>请调用方法。  
  
 可以通过调用<xref:System.Numerics.BigInteger.Log%2A>方法以及<xref:System.Math.Exp%2A?displayProperty=nameWithType>方法来查找数字的平方根。 请注意，如果结果<xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType>大于，则结果为。 下面的示例计算<xref:System.Numerics.BigInteger>值数组中每个元素的平方根。  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 此方法对应于基元<xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的自然对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <param name="baseValue">对数的底。</param>
        <summary>返回指定数字在使用指定底时的对数。</summary>
        <returns><paramref name="baseValue" /> 的以 <paramref name="value" /> 为底的对数，如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 和 `baseValue` 参数指定为以10为基数的数字。  
  
 此方法的准确返回值取决于的符号和`value` `baseValue`的符号，如下表所示。  
  
|`value` 参数|`baseValue` 参数|返回值|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|（0 < `baseValue` < 1）-或-（`baseValue` > 1）|logbaseValue （`value`）|  
|`value` < 0|（任意值）|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 若要计算某个<xref:System.Numerics.BigInteger>值以10为底的对数，请<xref:System.Numerics.BigInteger.Log10%2A>调用方法。 若要计算某个数的自然对数，请调用<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29>方法。  
  
 此方法对应于基元<xref:System.Math.Log%2A?displayProperty=nameWithType>数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <summary>返回指定数字以 10 为底的对数。</summary>
        <returns><paramref name="value" /> 的以 10 为底的对数，如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数被指定为以10为基数的数字。  
  
 此方法的准确返回值取决于的符号`value`，如下表所示。  
  
|值参数的符号|返回值|  
|-----------------------------|------------------|  
|正|以 10 `value`为底的对数，即 log10`value`。|  
|零|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。|  
|负数|<xref:System.Double.NaN?displayProperty=nameWithType>。|  
  
 若要计算某个<xref:System.Numerics.BigInteger>值的自然对数，请<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType>调用方法。 若要计算某个数在另一个基中的对数， <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType>请调用方法。  
  
 此方法对应于基元<xref:System.Math.Log10%2A?displayProperty=nameWithType>数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的以 10 为底的对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值中的较大者。</summary>
        <returns><paramref name="left" /> 或 <paramref name="right" /> 参数中较大的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对应于基元<xref:System.Math.Max%2A?displayProperty=nameWithType>数值类型的方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Max%2A>方法来选择<xref:System.Numerics.BigInteger>值数组中的最大数字。  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值中的较小者。</summary>
        <returns><paramref name="left" /> 或 <paramref name="right" /> 参数中较小的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对应于基元<xref:System.Math.Min%2A?displayProperty=nameWithType>数值类型的方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Min%2A>方法来选择<xref:System.Numerics.BigInteger>值数组中的最小数字。  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字负一 (-1) 的值。</summary>
        <value>其值为负一 (-1) 的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性用于将<xref:System.Numerics.BigInteger>值与-1 进行比较，或将-1 <xref:System.Numerics.BigInteger>赋给对象。 <xref:System.Numerics.BigInteger.MinusOne%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要计算 <paramref name="exponent" /> 次幂的数字。</param>
        <param name="exponent">对 <paramref name="value" /> 进行幂运算的指数。</param>
        <param name="modulus"><paramref name="value" /> 的 <paramref name="exponent" /> 次幂要除以的数值。</param>
        <summary>对以某个数为底、以另一个数为指数的幂执行模数除法。</summary>
        <returns>将 <paramref name="value" /><sup>exponent</sup> 除以 <paramref name="modulus" /> 后的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A>方法计算以下表达式：  
  
 （接受 basevalue ^ 指数）Mod 取模  
  
 若要对没有<xref:System.Numerics.BigInteger>模数除法的值执行幂运算<xref:System.Numerics.BigInteger.Pow%2A> ，请使用方法。  
  
   
  
## Examples  
 下面的示例提供了调用<xref:System.Numerics.BigInteger.ModPow%2A>方法的简单阐释。  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> 为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> 为负数。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一个数。</param>
        <param name="right">要相乘的第二个数。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值的乘积。</summary>
        <returns><paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A>方法是为不支持运算符重载的语言实现的。 它的行为与使用乘法运算符的乘法相同。 此外，在<xref:System.Numerics.BigInteger>实例<xref:System.Numerics.BigInteger.Multiply%2A>化变量时，方法是乘法运算符的有用替代方法，方法是将变量分配给乘法运算，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 如有必要，此方法会自动执行其他整型类型到<xref:System.Numerics.BigInteger>对象的隐式转换。 下一节中的示例对此进行了说明，其中<xref:System.Numerics.BigInteger.Multiply%2A>方法传递了两<xref:System.Int64>个值。  
  
   
  
## Examples  
 下面的示例尝试通过两个长整数执行乘法运算。 由于结果超出了长整数的范围， <xref:System.OverflowException>因此将引发， <xref:System.Numerics.BigInteger.Multiply%2A>并调用方法来处理乘法。 请注意C# ，需要使用`checked`关键字（如本`/checked+`示例所示）或编译器选项，以确保在数值溢出时引发异常。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要求反的值。</param>
        <summary>对指定的 <see cref="T:System.Numerics.BigInteger" /> 值求反。</summary>
        <returns><paramref name="value" /> 参数乘以负一 (-1) 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 求反会获得数字的加法逆值。 数字的加法反数值是在将其添加到原始数字时产生零值的数字。  
  
 <xref:System.Numerics.BigInteger.Negate%2A>方法是为不支持自定义运算符的语言实现的。 它的行为等同于使用一元求反运算符的求反。 此外， <xref:System.Numerics.BigInteger.Negate%2A>在<xref:System.Numerics.BigInteger>实例化变量时，方法是否定运算符的有用替换，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 下面的示例演示了用于否定<xref:System.Numerics.BigInteger>对象的值的三种方法。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字一 (1) 的值。</summary>
        <value>其值为一 (1) 的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性通常用于将<xref:System.Numerics.BigInteger>值与1进行比较，或将 1 <xref:System.Numerics.BigInteger>赋给对象。 <xref:System.Numerics.BigInteger.One%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一个值。</param>
        <param name="right">要相加的第二个值。</param>
        <summary>将两个指定的 <see cref="T:System.Numerics.BigInteger" /> 对象的值相加。</summary>
        <returns><paramref name="left" /> 与 <paramref name="right" /> 的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的加法运算。 <xref:System.Numerics.BigInteger.op_Addition%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Add%2A>调用方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位 <see langword="And" /> 运算。</summary>
        <returns>按位 <see langword="And" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法`And`为值 <xref:System.Numerics.BigInteger> 定义按位运算。 仅当`And`同时设置了和`right`中`left`的相应位时，按位运算才设置结果位，如下表所示。  
  
|位在`left`|位在`right`|结果中的位|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法启用如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 方法对两个`And` <xref:System.Numerics.BigInteger>值执行按位运算，就好像它们都是两个具有虚符号扩展的补码表示形式。 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位 <see langword="Or" /> 运算。</summary>
        <returns>按位 <see langword="Or" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法`Or`为值 <xref:System.Numerics.BigInteger> 定义按位运算。 仅当`Or`设置了和`right`中`left`的一个或两个对应位时，按位运算才设置结果位，如下表所示。  
  
|位在`left`|位在`right`|结果中的位|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法启用如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 方法对两个`Or` <xref:System.Numerics.BigInteger>值执行按位运算，就好像它们都是两个具有虚符号扩展的补码表示形式。 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要递减的值。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值减 1。</summary>
        <returns><paramref name="value" /> 参数减 1 后的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的减量运算。 <xref:System.Numerics.BigInteger.op_Decrement%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Subtract%2A>调用方法。 例如:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 由于<xref:System.Numerics.BigInteger>对象是不可变的<xref:System.Numerics.BigInteger.op_Decrement%2A> ，因此运算符会<xref:System.Numerics.BigInteger>创建一个新的<xref:System.Numerics.BigInteger>对象，其值小于表示`value`的对象。 这意味着对<xref:System.Numerics.BigInteger.op_Decrement%2A>的重复调用可能会消耗大量资源。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>通过使用整除，将指定的 <see cref="T:System.Numerics.BigInteger" /> 值除以另一个指定的 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>相除的整数结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A>方法为 <xref:System.Numerics.BigInteger> 值定义除法运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 不支持自定义运算符和运算符重载的语言可以改为<xref:System.Numerics.BigInteger.Divide%2A>调用方法。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例创建值的<xref:System.Numerics.BigInteger>数组。 然后，它将每个元素用作除法运算中使用<xref:System.Numerics.BigInteger.Divide%2A>方法、除法运算符（/） <xref:System.Numerics.BigInteger.DivRem%2A>和方法的商。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示带符号长整数值与 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29>方法为 <xref:System.Numerics.BigInteger> 值定义相等比较运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>调用实例方法。  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与带符号长整数值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29>方法为 <xref:System.Numerics.BigInteger> 值定义相等比较运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>调用实例方法。  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的相等运算符的运算。 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>调用实例方法。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与无符号长整数值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法为 <xref:System.Numerics.BigInteger> 值定义相等比较运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>调用实例方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示无符号长整数值与 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法为 <xref:System.Numerics.BigInteger> 值定义相等比较运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>调用实例方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位异 <see langword="Or" /> (<see langword="XOr" />) 运算。</summary>
        <returns>按位 <see langword="Or" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个位的值不同`Or` ，则按位 "异`false`运算" 的结果为; 否则为。 `true` 下表说明了独占`Or`操作。  
  
|位 x 在`left`|位 x 在`right`|返回值|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>方法启用如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 方法对两个`Or` <xref:System.Numerics.BigInteger>值执行按位 "异或" 运算，就像它们在两个具有虚符号扩展的补码表示形式中一样。 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定义 <see cref="T:System.Numerics.BigInteger" /> 对象与其他类型之间的显式转换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Decimal" /> 对象到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在转换前截断`value`参数的任何小数部分。

 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 由于从<xref:System.Decimal>到<xref:System.Numerics.BigInteger>的转换可能涉及截断的`value`任何小数部分，因此语言编译器不会自动执行此转换。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。   

 对于不支持自定义运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>。


## Examples
 下面的示例将<xref:System.Decimal>值数组中的单个元素转换为<xref:System.Numerics.BigInteger>对象，然后显示每个转换的结果。 请注意，在转换过程中<xref:System.Decimal> ，值的任何小数部分都将被截断。   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Double" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在转换前截断`value`参数的任何小数部分。

 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 由于从<xref:System.Double>到<xref:System.Numerics.BigInteger>的转换可能涉及截断的`value`任何小数部分，因此语言编译器不会自动执行此转换。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。

 对于不支持自定义运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>。


## Examples
 下面的示例将<xref:System.Double>值数组中的单个元素转换为<xref:System.Numerics.BigInteger>对象，然后显示每个转换的结果。 请注意，在转换过程中<xref:System.Double> ，值的任何小数部分都将被截断。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 为 <see cref="F:System.Double.NaN" />、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Byte" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到无符号字节值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CByte` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。   

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.Byte>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.Byte>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Byte>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.Byte>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.Byte.MinValue" /> 或大于 <see cref="F:System.Byte.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Decimal" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 <see cref="T:System.Decimal" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CDec` Visual Basic）时，它们才执行转换。   

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.Decimal>超出数据类型范围，它可能会在运行时引发。 

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Decimal>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.Decimal>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.Decimal.MinValue" /> 或大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Double" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 <see cref="T:System.Double" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CDbl` Visual Basic）时，它们才执行转换。   

 由于值可以超出<xref:System.Double>数据类型的范围，因此此操作是收缩转换。 <xref:System.Numerics.BigInteger> 如果转换失败，则不会引发<xref:System.OverflowException>。 相反，如果<xref:System.Numerics.BigInteger>值<xref:System.Double.MinValue?displayProperty=nameWithType>小于，则生成<xref:System.Double>的值为<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。 如果该值大于，则生成<xref:System.Double>的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。  <xref:System.Double.MaxValue?displayProperty=nameWithType> <xref:System.Numerics.BigInteger>
 
 将转换<xref:System.Numerics.BigInteger> <xref:System.Double>为可能会导致精度损失。 在某些情况下，丢失精度可能导致强制转换或转换操作成功，即使<xref:System.Numerics.BigInteger>值超出了<xref:System.Double>数据类型的范围。 下面的示例进行了这方面的演示。 它将最大值<xref:System.Double>分配给两个<xref:System.Numerics.BigInteger>变量，通过 9.999 e291 递增一个<xref:System.Numerics.BigInteger>变量，并测试这两个变量是否相等。 与预期一样，对<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法的调用显示它们不相等。 但是， <xref:System.Numerics.BigInteger>将更大的值转换回后<xref:System.Double>会成功，但<xref:System.Numerics.BigInteger>现在该值会超出<xref:System.Double.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Double>值的转换。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 16 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 16 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CShort` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。   

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.Int16>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.Int16>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Int16>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.Int16>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.Int16.MinValue" /> 或大于 <see cref="F:System.Int16.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 32 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 32 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CInt` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。   

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.Int32>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.Int16>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Int32>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.Int32>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.Int32.MinValue" /> 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 64 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 64 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CLng` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。  

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.Int64>超出数据类型范围，它可能会在运行时引发。 

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Int64>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.Int64>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.Int64.MinValue" /> 或大于 <see cref="F:System.Int64.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 8 位带符号值的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 8 位带符号值的显式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int16" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CSByte` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。  

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.SByte>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.SByte>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.SByte>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.SByte>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.SByte.MinValue" /> 或大于 <see cref="F:System.SByte.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为单精度浮点值的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到单精度浮点值的显式转换。</summary>
        <returns>一个对象，包含 <paramref name="value" /> 参数的尽可能精确的表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为它可能涉及到数据丢失或精度损失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CSng` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。    

 由于值可以超出<xref:System.Single>数据类型的范围，因此此操作是收缩转换。 <xref:System.Numerics.BigInteger> 如果转换失败，则不会引发<xref:System.OverflowException>。 相反，如果<xref:System.Numerics.BigInteger>值<xref:System.Single.MinValue?displayProperty=nameWithType>小于，则生成<xref:System.Single>的值为<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。 如果该值大于，则生成<xref:System.Single>的值为 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 。  <xref:System.Single.MaxValue?displayProperty=nameWithType> <xref:System.Numerics.BigInteger>

 将转换<xref:System.Numerics.BigInteger> <xref:System.Single>为可能会导致精度损失。 在某些情况下，丢失精度可能导致强制转换或转换操作成功，即使<xref:System.Numerics.BigInteger>值超出了<xref:System.Single>数据类型的范围。 下面的示例进行了这方面的演示。 它将最大值<xref:System.Single>分配给两个<xref:System.Numerics.BigInteger>变量，通过 9.999 e291 递增一个<xref:System.Numerics.BigInteger>变量，并测试这两个变量是否相等。 与预期一样，对<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法的调用显示它们不相等。 但是， <xref:System.Numerics.BigInteger>将更大的值转换回后<xref:System.Single>会成功，但<xref:System.Numerics.BigInteger>现在该值会超出<xref:System.Single.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.Single>值的转换。   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 16 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 16 位无符号整数值的显式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int32" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CUShort` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。    

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.UInt16>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.UInt16>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.UInt16>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.UInt16>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.UInt16.MinValue" /> 或大于 <see cref="F:System.UInt16.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 32 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 32 位无符号整数值的显式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int64" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CUInt` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。    

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.UInt32>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.UInt32>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.UInt32>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.UInt32>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.UInt32.MinValue" /> 或大于 <see cref="F:System.UInt32.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 64 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 64 位无符号整数值的显式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Double" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 语言编译器不会自动执行此转换，因为这可能会导致数据丢失。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` `CULng` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。    

 由于此操作定义收缩转换，因此<xref:System.OverflowException> <xref:System.Numerics.BigInteger>如果值<xref:System.UInt64>超出数据类型范围，它可能会在运行时引发。 如果转换成功，则结果<xref:System.UInt64>值中没有精度损失。

## Examples
 下面的示例阐释了<xref:System.Numerics.BigInteger>到<xref:System.UInt64>值的转换。 它还处理<xref:System.OverflowException>引发的， <xref:System.Numerics.BigInteger>因为值<xref:System.UInt64>超出了数据类型的范围。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小于 <see cref="F:System.UInt64.MinValue" /> 或大于 <see cref="F:System.UInt64.MaxValue" />。</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Single" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在转换前截断`value`参数的任何小数部分。
 
 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法的重载定义可以从<xref:System.Numerics.BigInteger>其转换对象的类型。 由于从<xref:System.Single>到<xref:System.Numerics.BigInteger>的转换可能涉及截断的`value`任何小数部分，因此语言编译器不会自动执行此转换。 相反，仅当使用强制转换运算符（在中C#）或转换函数（如`CType` Visual Basic）时，它们才执行转换。 否则，它们会显示编译器错误。

 对于不支持自定义运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>。


## Examples
 下面的示例将<xref:System.Single>值数组中的单个元素转换为<xref:System.Numerics.BigInteger>对象，然后显示每个转换的结果。 请注意，在转换过程中<xref:System.Single> ，值的任何小数部分都将被截断。
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 为 <see cref="F:System.Single.NaN" />、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否大于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否大于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用实例方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 是否大于 64 位带符号整数值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于 64 位无符号整数。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于 64 位无符号整数。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否大于等于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否大于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于或等于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于 64 位带符号整数值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于或等于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于或等于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于 64 位无符号整数值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于或等于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否大于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法为 <xref:System.Numerics.BigInteger> 值定义大于或等于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定义 <see cref="T:System.Numerics.BigInteger" /> 对象与其他类型之间的隐式转换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从无符号字节到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在转换前截断`value`参数的任何小数部分。

 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.Byte> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 16 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.Int16> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 32 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。  

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.Int32> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 64 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>。   
 
 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.Int64> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 8 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.SByte> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 16 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.UInt16> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 32 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.UInt32> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 64 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Double" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法为<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>。   

 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法的重载定义了这样的类型：编译器无需显式强制转换运算符（在中<xref:System.Numerics.BigInteger> C#）或调用转换函数（Visual Basic）即可自动转换值。 它们是不涉及数据丢失的扩大转换，不会引发<xref:System.OverflowException>。 此重载使编译器<xref:System.UInt64> <xref:System.Numerics.BigInteger>能够处理从值到值的转换，如下面的示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要递增的值。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值加 1。</summary>
        <returns><paramref name="value" /> 参数加 1 后的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A>方法为 <xref:System.Numerics.BigInteger> 值定义增量运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 缺少增量运算符或不支持运算符重载的某些语言（如 Visual Basic）可以直接调用<xref:System.Numerics.BigInteger.op_Increment%2A>方法，如下面的示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 由于<xref:System.Numerics.BigInteger>对象是不可变的<xref:System.Numerics.BigInteger.op_Increment%2A> ，因此运算符会<xref:System.Numerics.BigInteger>创建一个新的<xref:System.Numerics.BigInteger>对象，其值比表示`value`的对象多一个。 因此，对的<xref:System.Numerics.BigInteger.op_Increment%2A>重复调用可能会消耗大量资源。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个数值是否不相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数与 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法为 <xref:System.Numerics.BigInteger> 值定义不相等运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 不支持自定义运算符的语言可以通过使用以下方法之一来测试是否不相等：  
  
-   调用实例方法，该方法指示<xref:System.Numerics.BigInteger>与有符号长整数值之间的关系。 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>  
  
-   <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>调用实例方法并反转其值。  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与 64 位带符号整数是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法为 <xref:System.Numerics.BigInteger> 值定义不相等运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 不支持自定义运算符的语言可以通过使用以下方法之一来测试是否不相等：  
  
-   调用方法，它指示<xref:System.Numerics.BigInteger>与有符号长整数值之间的关系。 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>  
  
-   <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>调用方法并反转其值。  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个 <see cref="T:System.Numerics.BigInteger" /> 对象是否具有不同的值。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法为 <xref:System.Numerics.BigInteger> 值定义不相等运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 不支持自定义运算符的语言可以通过使用以下方法之一来测试是否不相等：  
  
-   调用方法，它指示两个<xref:System.Numerics.BigInteger>对象之间的关系。 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>  
  
-   <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>调用方法并反转其值。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与 64 位无符号整数是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法为 <xref:System.Numerics.BigInteger> 值定义不相等运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 不支持自定义运算符的语言可以通过使用以下方法之一来测试是否不相等：  
  
-   调用方法，它指示<xref:System.Numerics.BigInteger>与无符号长整数值之间的关系。 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>  
  
-   <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>调用方法并反转其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数与 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法为 <xref:System.Numerics.BigInteger> 值定义不相等运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 不支持自定义运算符的语言可以通过使用以下方法之一来测试是否不相等：  
  
-   调用方法，它指示<xref:System.Numerics.BigInteger>与无符号长整数值之间的关系。 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>  
  
-   <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>调用方法并反转其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要移动其位的值。</param>
        <param name="shift">将 <paramref name="value" /> 向左移动的位数。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值向左移动指定的位数。</summary>
        <returns>一个已向左移动指定位数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A>方法为 <xref:System.Numerics.BigInteger> 值定义按位左移运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  不同于按位左移运算和整数基元， <xref:System.Numerics.BigInteger.op_LeftShift%2A>方法保留原始<xref:System.Numerics.BigInteger>值的符号。  
  
 不支持自定义运算符的语言可以通过乘以`value` `BigInteger.Pow(2, shift)`来执行按位左移运算。 下面的示例演示结果与使用此运算符的结果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否小于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否小于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义小于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于 64 位带符号整数。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义小于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义小于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>调用方法。 某些语言还可以直接调用<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于 64 位无符号整数。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义小于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否小于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法为 <xref:System.Numerics.BigInteger> 值定义小于运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否小于等于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否小于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的小于或等于运算符的运算。 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 如果`left` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于 64 位带符号整数。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的小于或等于运算符的运算。 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 如果`right` 为 <xref:System.Int16> 、 、、 <xref:System.SByte> 、或<xref:System.Int64>值，则在执行操作时，它将隐式转换为值。 <xref:System.UInt32> <xref:System.Byte> <xref:System.Int32> <xref:System.UInt16>  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的小于或等于运算符的运算。 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Compare%2A>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于 64 位无符号整数。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的小于或等于运算符的运算。 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否小于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的小于或等于运算符的运算。 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>调用方法。 它们还可以直接调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法，如下例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>返回两个指定 <see cref="T:System.Numerics.BigInteger" /> 值相除所得的余数。</summary>
        <returns>相除所得的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A>方法为 <xref:System.Numerics.BigInteger> 值定义取模运算符的操作。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType>调用方法。  
  
 取模操作返回的值的符号取决于的符号`dividend`：如果`dividend`为正，则取模运算返回正的结果; 如果为负，则取模操作返回一个负的结果。 具有<xref:System.Numerics.BigInteger>值的取模运算的行为与其他整型的取模运算的行为相同。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一个值。</param>
        <param name="right">要相乘的第二个值。</param>
        <summary>两个指定的 <see cref="T:System.Numerics.BigInteger" /> 值相乘。</summary>
        <returns><paramref name="left" /> 与 <paramref name="right" /> 的乘积。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的乘法运算符的运算。 <xref:System.Numerics.BigInteger.op_Multiply%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">一个整数值。</param>
        <summary>返回 <see cref="T:System.Numerics.BigInteger" /> 值的按位二进制反码。</summary>
        <returns><paramref name="value" /> 的按位二进制反码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法为 <xref:System.Numerics.BigInteger> 值定义按位求补运算符的运算。 按位1的补数运算符反转数值中的每个位。 也就是说，结果中`value`的位为0的位设置为1，结果中的位设置为0。 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法启用如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 不支持自定义运算符的语言可以直接调用方法，以<xref:System.Numerics.BigInteger.op_OnesComplement%2A>执行按位 "的求补运算。 例如:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要移动其位的值。</param>
        <param name="shift">将 <paramref name="value" /> 向右移动的位数。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值向右移动指定的位数。</summary>
        <returns>一个已向右移动指定位数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了<xref:System.Numerics.BigInteger>值的按位右移运算符的运算。 <xref:System.Numerics.BigInteger.op_RightShift%2A> 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 不支持自定义运算符的语言可以通过除以`value` `BigInteger.Pow(2, shift)`并将负值减1次`shift`来执行按位右移运算。 下面的示例演示结果与使用此运算符的结果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 如果`shift`大于或等于正值<xref:System.Numerics.BigInteger>中的位数，则右移操作的结果为<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>。 如果`shift`大于负值<xref:System.Numerics.BigInteger>中的位数，则右移操作的结果为<xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要从中减去的值（被减数）。</param>
        <param name="right">要减去的值（减数）。</param>
        <summary>从另一个 <see cref="T:System.Numerics.BigInteger" /> 值中减去 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A>方法为 <xref:System.Numerics.BigInteger> 值定义减法运算符的运算。 它可以实现如下所示的代码：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType>调用方法。  
  
 此运算符的等效方法为<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要求反的值。</param>
        <summary>对指定的 BigInteger 值求反。</summary>
        <returns><paramref name="value" /> 参数乘以负一 (-1) 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法定义了用于<xref:System.Numerics.BigInteger>值的一元求反运算符（或加法反运算符）的运算。 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> 操作将生成一个值，该值将在添加到原始数字时导致为0（零）。 不支持自定义运算符的语言可以改为<xref:System.Numerics.BigInteger.Negate%2A>调用方法。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示了使用三种不同的方法来否定<xref:System.Numerics.BigInteger>对象的值。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">一个整数值。</param>
        <summary>返回 <see cref="T:System.Numerics.BigInteger" /> 操作数的值。 （操作数的符号不变。）</summary>
        <returns><paramref name="value" /> 操作数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A>方法为 <xref:System.Numerics.BigInteger> 值定义一元正运算符的运算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" /> 表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <summary>将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" /> 表示形式。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数应为以下形式的数字的字符串表示形式。  
  
 [*ws*][*sign*]*位数*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。|  
|*sign*|一个可选的符号。 有效的符号字符由当前区域性<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>的<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>和属性确定。|  
|*digits*|介于0到9之间的一系列数字。 任何前导零都将被忽略。|  
  
> [!NOTE]
>  由`value`参数指定的字符串<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>使用样式来进行解释。 它不能包含任何组分隔符或小数分隔符，也不能包含小数部分。  
  
 通过使用为当前系统区域性初始化的<xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType>对象中的格式设置信息来分析参数。 `value` 有关详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要通过使用特定区域性的格式设置信息分析字符串，请使用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>方法。  
  
> [!IMPORTANT]
>  如果使用<xref:System.Numerics.BigInteger.Parse%2A>方法往返<xref:System.Numerics.BigInteger.ToString%2A>方法输出的<xref:System.Numerics.BigInteger>值的字符串表示形式，则应将<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>方法与 "R" 格式说明符一起使用，以生成的字符串表示形式。<xref:System.Numerics.BigInteger>值。 否则，的字符串表示形式将<xref:System.Numerics.BigInteger>只保留原始值的50最高有效位，并且当你<xref:System.Numerics.BigInteger.Parse%2A>使用方法还原<xref:System.Numerics.BigInteger>该值时，数据可能会丢失。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法实例化两个<xref:System.Numerics.BigInteger>对象。 它将每个对象乘以另一个数字，然后<xref:System.Numerics.BigInteger.Compare%2A>调用方法来确定这两个值之间的关系。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 的格式不正确。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，这些枚举值指定 <paramref name="value" /> 所允许的格式。</param>
        <summary>将指定样式的数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数定义`value`参数中允许的样式元素（如空格、正号或负号符号、组分隔符符号或小数点符号），以便分析操作成功。 `style` `styles`必须是<xref:System.Globalization.NumberStyles>枚举中位标志的组合。 当包含十六进制值的字符串表示形式时，此`value` 参数会使此方法重载非常有用，当表示的数字系统（十进制或十六进制）仅在运行时已知，或者当你 `style`  `value`要禁止在中`value`使用空格或符号符号。  
  
 根据的值`style` `value` ，参数可能包括以下元素：  
  
 [*ws*][*$*] [*sign*] [*数字*，]*位数*[。*fractional_digits*] [E [*sign*]*exponential_digits*] [*ws*]  
  
 如果`style`包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>，则 `value` 参数可能包含以下元素：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>如果包含 `style`  标志，则空格可以出现在的开头，如果包含标志，则可以在 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 的末尾出现空白。|  
|*$*|区域性特定的货币符号。 其在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>当前区域性的和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>属性定义。 如果`value` `style`包含标志，则当前区域性的货币符号可以出现在中。 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|  
|*sign*|一个可选的符号。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>如果包含 `style`  标志，则符号可以出现在的开头，如果包含标志，则它可以 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 出现在的结尾。 如果包含`value` `style`标志，则可以在中使用括号来表示负值。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|介于0到9之间的一系列数字。 对于*fractional_digits*，只有数字0有效。|  
|*，*|区域性特定的组分隔符符号。 如果`value` `style`包含标志，则当前区域性的组分隔符可以出现在中。 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|  
|*.*|区域性特定的小数点符号。 如果`value` `style`包含标志，则当前区域性的小数点符号可以出现在中。 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 只有数字0才能作为小数位出现，以便分析操作成功;如果*fractional_digits*包含任何其他数字， <xref:System.FormatException>则会引发。|  
|E|"E" 或 "E" 字符，指示值以指数（科学型）表示法表示。 如果`value` 包含标志 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>  ，则参数可以表示指数表示法中的数字。 `style`|  
|*hexdigits*|从0到 f 的十六进制数字序列，或者从0到 F。|  
  
> [!NOTE]
> 无论`style`参数的值如何，分析操作都将`s`忽略中的任何终止 NUL （U + 0000）字符。

 只包含数字的字符串（对应<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>于样式）始终会成功分析。 大多数剩余<xref:System.Globalization.NumberStyles>成员控件可能存在但不需要存在于输入字符串中的元素。 下表指示各个<xref:System.Globalization.NumberStyles>成员如何影响可能出现在中`value`的元素。  
  
|`NumberStyles` 值|中允许`value`的元素以及数字|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅限*数字*元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点（.）和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 或 "E" 字符（指示指数表示法）以及*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头 `value` 的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾 `value` 处的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|开头 `value` 的*sign*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|末尾 `value` 的*sign*元素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的*符号*元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符（，）元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币符号（$）。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是， `value`不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|开头或结尾`value`处的 ws 元素，在的 `value`开头处进行签名，然后是小数点（*.*）符号。 `value`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|、、组分隔符（*、*）和小数点（.）元素。 `ws` `sign`|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是， `value`不能表示十六进制数。|  
  
> [!IMPORTANT]
>  如果使用<xref:System.Numerics.BigInteger.Parse%2A>方法往返<xref:System.Numerics.BigInteger.ToString%2A>方法输出的<xref:System.Numerics.BigInteger>值的字符串表示形式，则应将<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>方法与 "R" 格式说明符一起使用，以生成的字符串表示形式。<xref:System.Numerics.BigInteger>值。 否则，的字符串表示形式将<xref:System.Numerics.BigInteger>只保留原始值的50最高有效位，并且当你<xref:System.Numerics.BigInteger.Parse%2A>使用方法还原<xref:System.Numerics.BigInteger>该值时，数据可能会丢失。  
  
 与其他<xref:System.Globalization.NumberStyles>值不同，它们允许但不需要，在中`value`存在特定样式元素， <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>样式值意味着中`value`的单个数字字符始终解释为十六进制字符。 有效的十六进制字符为0-9、A-f 和 a-f。 只能与`style`参数组合的其他标志是<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 （枚举包含复合数字样式， <xref:System.Globalization.NumberStyles.HexNumber>其中包含两个空白标志。） <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  如果`value`是十六进制数的字符串表示形式，则它的前面不能有任何将其视为`0x`十六进制`&h`数的修饰（如或）。 这将导致转换失败。  
  
 如果`value`是一个十六进制字符串，则<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>该方法`value`会将解释为一个负数，其中使用两个补数表示形式，前提是它的前两个`0x80`十六进制数字大于或等于。 换言之，该方法将中`value`第一个字节的最高序位解释为符号位。 若要确保十六进制字符串正确地解释为正数，则中`value`的第一个数字的值必须为零。 例如，方法将解释`0x80`为负值，但会将`0x080`或`0x0080`解释为正值。 下面的示例演示表示负值和正值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 通过使用为当前系统区域性初始化的<xref:System.Globalization.NumberFormatInfo>对象中的格式设置信息来分析参数。 `value` 若要指定其格式设置信息用于分析操作的区域性，请调用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>重载。  
  
   
  
## Examples  
 下面的示例演示对<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法的调用，其中包含`style`参数的多个可能的值。 它演示如何将字符串解释为十六进制值，以及如何禁止空格和符号符号。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
或 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 不符合由 <see cref="T:System.Globalization.NumberStyles" /> 指定的输入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="provider">一个对象，提供有关 <paramref name="value" /> 的区域性特定格式设置信息。</param>
        <summary>将指定的区域性特定格式的数字字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数应为以下形式的数字的字符串表示形式：  
  
 [*ws*][*sign*]*位数*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。|  
|*sign*|一个可选的符号。 有效的符号字符<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>由`provider`对象的<xref:System.IFormatProvider.GetFormat%2A>方法<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>返回的<xref:System.Globalization.NumberFormatInfo>对象的和属性确定。|  
|*digits*|介于0到9之间的一系列数字。 任何前导零都将被忽略。|  
  
> [!NOTE]
>  `value`参数指定的字符串<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>使用样式来进行解释。 它不能包含任何组分隔符或小数分隔符，也不能包含小数部分。  
  
> [!IMPORTANT]
>  如果使用<xref:System.Numerics.BigInteger.Parse%2A>方法往返<xref:System.Numerics.BigInteger.ToString%2A>方法输出的<xref:System.Numerics.BigInteger>值的字符串表示形式，则应将<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>方法与 "R" 格式说明符一起使用，以生成的字符串表示形式。<xref:System.Numerics.BigInteger>值。 否则，的字符串表示形式将<xref:System.Numerics.BigInteger>只保留原始值的50最高有效位，并且当你<xref:System.Numerics.BigInteger.Parse%2A>使用方法还原<xref:System.Numerics.BigInteger>该值时，数据可能会丢失。  
  
 参数是一个<xref:System.IFormatProvider> 实现， <xref:System.IFormatProvider.GetFormat%2A> 其方法返回提供区域性特定格式设置信息的对象。 <xref:System.Globalization.NumberFormatInfo>  `provider` <xref:System.IFormatProvider.GetFormat%2A> <xref:System.Type> <xref:System.Globalization.NumberFormatInfo>调用方法时，它`provider`调用参数的方法并向其传递一个表示类型的对象。 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> 然后<xref:System.IFormatProvider.GetFormat%2A> ，方法<xref:System.Globalization.NumberFormatInfo>返回对象，该对象提供`value`有关参数格式的信息。 使用`provider`参数为分析操作提供自定义格式设置信息的方法有三种：  
  
-   可以传递一个<xref:System.Globalization.CultureInfo>对象，该对象表示提供格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A> 方法 <xref:System.Globalization.NumberFormatInfo> 返回对象，该对象提供该区域性的数字格式设置信息。  
  
-   可以传递提供数字格式<xref:System.Globalization.NumberFormatInfo>设置信息的实际对象。 （其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回自身。）  
  
-   可以传递实现<xref:System.IFormatProvider>的自定义对象。 它<xref:System.IFormatProvider.GetFormat%2A>的方法实例化并<xref:System.Globalization.NumberFormatInfo>返回提供格式设置信息的对象。  
  
 如果`provider` `value`为`null`，则基于 <xref:System.Globalization.NumberFormatInfo> 当前区域性的对象解释的格式设置。  
  
   
  
## Examples  
 下面的示例演示了两种将颚化符（~）定义为格式<xref:System.Numerics.BigInteger>值的负号的方法。 请注意，若要<xref:System.Numerics.BigInteger>以与原始字符串相同的格式来显示值，你的代码必须<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>调用方法并向其<xref:System.Globalization.NumberFormatInfo>传递提供格式设置信息的对象。  
  
 第一个示例定义实现<xref:System.IFormatProvider>并<xref:System.IFormatProvider.GetFormat%2A>使用方法返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象的类。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 然后，可以使用以下代码对对象进行实例化： <xref:System.Numerics.BigInteger>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 第二个示例更简单。 它将提供<xref:System.Globalization.NumberFormatInfo>格式设置信息的对象传递`provider`给参数。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 的格式不正确。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，这些枚举值指定 <paramref name="value" /> 所允许的格式。</param>
        <param name="provider">一个对象，提供有关 <paramref name="value" /> 的区域性特定格式设置信息。</param>
        <summary>将指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数定义`value`参数中允许的样式元素（如空格、正号或负号符号、组分隔符符号或小数点符号），以便分析操作成功。 `style` `styles`必须是<xref:System.Globalization.NumberStyles>枚举中位标志的组合。 当包含十六进制值的字符串表示形式时，此`value` 参数会使此方法重载非常有用，当表示的数字系统（十进制或十六进制）仅在运行时已知，或者当你 `style`  `value`要禁止在中`value`使用空格或符号符号。  
  
 根据的值`style` `value` ，参数可能包括以下元素：  
  
 [*ws*][*$*] [*sign*] [*数字*，]*位数*[*. fractional_digits*] [E [*sign*]*exponential_digits*] [*ws*]  
  
 如果`style`包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>，则 `value` 参数可能包括以下元素：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>如果包含 `style`  标志，则空格可以出现在的开头，如果包含标志，则可以在 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 的末尾出现空白。|  
|*$*|区域性特定的货币符号。 其在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> `provider`参数指示的<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>区域性的和属性定义。 如果`value` `style`包含标志，则当前区域性的货币符号可以出现在中。 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|  
|*sign*|一个可选的符号。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>如果包含 `style`  标志，则符号可以出现在的开头，如果包含标志，则它可以 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 出现在的结尾。 如果包含`value` `style`标志，则可以在中使用括号来表示负值。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|介于0到9之间的一系列数字。 对于*fractional_digits*，只有数字0有效。|  
|*，*|区域性特定的组分隔符符号。 `provider` `value`如果包含 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 标志，则所指定的区域性的组分隔符符号可以出现在中。 `style`|  
|*.*|区域性特定的小数点符号。 `provider` `value`如果包含 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 标志，则指定的区域性的小数点符号可以出现在中。 `style` 只有数字0才能作为小数位出现，以便分析操作成功;如果*fractional_digits*包含任何其他数字， <xref:System.FormatException>则会引发。|  
|E|"E" 或 "E" 字符，指示值以指数（科学型）表示法表示。 如果`value` 包含标志 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>  ，则参数可以表示指数表示法中的数字。 `style`|  
|*hexdigits*|从0到 f 的十六进制数字序列，或者从0到 F。|  
  
> [!NOTE]
> 无论`style`参数的值如何，分析操作都将`s`忽略中的任何终止 NUL （U + 0000）字符。

 只包含数字的字符串（对应<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>于样式）始终会成功分析。 大多数剩余<xref:System.Globalization.NumberStyles>成员控件可能存在但不需要存在于输入字符串中的元素。 下表指示各个<xref:System.Globalization.NumberStyles>成员如何影响可能出现在中`value`的元素。  
  
|NumberStyles 值|除了数字以外，还允许在值中使用元素|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅限*数字*元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点（.）和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 或 "E" 字符，指示指数表示法。 连同*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头 `value` 的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾 `value` 处的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|开头 `value` 的*sign*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|末尾 `value` 的*sign*元素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的*符号*元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符（，）元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币符号（$）。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是， `value`不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|开头或结尾`value`处的 ws 元素，在的 `value`开头处进行签名，然后是小数点（.）符号。 `value`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws` 、 `sign` 、组分隔符（、）和小数点（.）元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是， `value`不能表示十六进制数。|  
  
> [!IMPORTANT]
>  如果使用<xref:System.Numerics.BigInteger.Parse%2A>方法往返<xref:System.Numerics.BigInteger.ToString%2A>方法输出的<xref:System.Numerics.BigInteger>值的字符串表示形式，则应将<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>方法与 "R" 格式说明符一起使用，以生成的字符串表示形式。<xref:System.Numerics.BigInteger>值。 否则，的字符串表示形式将<xref:System.Numerics.BigInteger>只保留原始值的50最高有效位，并且当你<xref:System.Numerics.BigInteger.Parse%2A>使用方法还原<xref:System.Numerics.BigInteger>该值时，数据可能会丢失。  
  
 与其他<xref:System.Globalization.NumberStyles>值不同，它们允许但不要求在中`value`存在特定样式元素， <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>样式值意味着中`value`的单个数字字符始终解释为十六进制字符。 有效的十六进制字符为0-9、A-f 和 a-f。 只能与`style`参数组合的其他标志是<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 （枚举包含复合数字样式， <xref:System.Globalization.NumberStyles.HexNumber>其中包含两个空白标志。） <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  如果`value`是十六进制数的字符串表示形式，则它的前面不能有任何将其视为`0x`十六进制`&h`数的修饰（如或）。 这将导致转换失败。  
  
 如果`value`是一个十六进制字符串，则<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>该方法`value`会将解释为一个负数，其中使用两个补数表示形式，前提是它的前两个`0x80`十六进制数字大于或等于。 换言之，该方法将中`value`第一个字节的最高序位解释为符号位。 若要确保十六进制字符串正确地解释为正数，则中`value`的第一个数字的值必须为零。 例如，方法将解释`0x80`为负值，但会将`0x080`或`0x0080`解释为正值。 下面的示例演示表示负值和正值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 参数是一个 <xref:System.IFormatProvider> 实现。 `provider` 其<xref:System.IFormatProvider.GetFormat%2A>方法返回一个<xref:System.Globalization.NumberFormatInfo>对象，该对象提供有关格式的`value`区域性特定信息。 通常， `provider`可以是以下任一项：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，该对象表示提供数字格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回提供<xref:System.Globalization.NumberFormatInfo>数字格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。 （其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回自身。）  
  
-   一个自定义对象， <xref:System.IFormatProvider>它实现并<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>使用方法<xref:System.Globalization.NumberFormatInfo>来实例化和返回提供格式设置信息的对象。  
  
 如果`provider`为`null` ， <xref:System.Globalization.NumberFormatInfo> 则使用当前区域性的对象。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> `style`和`provider`参数的值的各种组合对方法进行多次调用。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 对<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法的单个调用会传递以下`BigIntegerFormatProvider`类的实例，该实例将颚化符（~）定义为负号。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
或 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 不符合由 <paramref name="style" /> 指定的输入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要计算 <paramref name="exponent" /> 次幂的数字。</param>
        <param name="exponent">对 <paramref name="value" /> 进行幂运算的指数。</param>
        <summary>求以 <see cref="T:System.Numerics.BigInteger" /> 值为底、以指定的值为指数的幂。</summary>
        <returns><paramref name="value" /> 的 <paramref name="exponent" /> 次幂的计算结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Numerics.BigInteger.Pow%2A>指数参数的值为0，或者`value`和`exponent`参数的值均为0，则此方法返回1。 如果`exponent`为1，则<xref:System.Numerics.BigInteger.Pow%2A>该方法`value`返回。 如果`value`为负，则该方法返回一个负面结果。  
  
 此方法对应于基元<xref:System.Math.Pow%2A?displayProperty=nameWithType>数值类型的方法。  
  
   
  
## Examples  
 下面的示例演示了使用<xref:System.Numerics.BigInteger>值和其值范围从0到10的指数的幂运算。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> 为负数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行整除并返回余数。</summary>
        <returns>将 <paramref name="dividend" /> 除以 <paramref name="divisor" /> 后的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 余数的符号是`dividend`参数的符号。  
  
 <xref:System.Numerics.BigInteger.Remainder%2A>方法是为不支持自定义运算符的语言实现的。 它的行为与使用取模运算符的除法相同。  
  
 如有必要，此方法会在执行取模操作之前自动<xref:System.Numerics.BigInteger>执行其他整型类型到对象的隐式转换。  
  
   
  
## Examples  
 下面的示例将<xref:System.Numerics.BigInteger.DivRem%2A>方法的余数与<xref:System.Numerics.BigInteger.Remainder%2A>方法的余数进行比较，以确定两个方法计算的余数是相同的。  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个数字，该数字指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的符号（负、正或零）。</summary>
        <value>一个指示 <see cref="T:System.Numerics.BigInteger" /> 对象的符号的数字，如下表所示。  
  
 <list type="table"><listheader><term> 数字 
 </term><description> 说明 
 </description></listheader><item><term> -1 
 </term><description> 此对象的值为负。  
  
 </description></item><item><term> 0 
 </term><description> 此对象的值为 0（零）。  
  
 </description></item><item><term> 1 
 </term><description> 此对象的值为正。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性等效于基元数值类型<xref:System.Math.Sign%2A?displayProperty=nameWithType>的方法。 <xref:System.Numerics.BigInteger.Sign%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要从中减去的值（被减数）。</param>
        <param name="right">要减去的值（减数）。</param>
        <summary>从另一个值中减去一个 <see cref="T:System.Numerics.BigInteger" /> 值并返回结果。</summary>
        <returns><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支持自定义运算符的语言可以使用<xref:System.Numerics.BigInteger.Subtract%2A>方法通过<xref:System.Numerics.BigInteger>值执行减法运算。  
  
 <xref:System.Numerics.BigInteger.Subtract%2A> 在 <xref:System.Numerics.BigInteger> 实例化变量时，此方法是一种有用的替代方法，该方法通过将其分配给减法运算符来实现，如以下示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值转换为字节数组。</summary>
        <returns>转换为字节数组的当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的数组中的单个字节以小字节序顺序显示。 也就是说，值的低序位字节优先于高阶字节。 数组的第一个字节反映<xref:System.Numerics.BigInteger>值的前八位，第二个字节反映后八位，依此类推。 例如，值1024或0x0400 存储为以下两个字节的数组：  
  
|元素|字节值|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 负值将使用最简洁形式的2的补码表示形式写入数组。 例如，-1 表示为单个字节`0xFF` ，其值为`0xFF` `0xFF` `0xFF` `0xFF` `0xFF`，而不是具有多个元素的数组，例如、、、和。 `0xFF`  
  
 由于两个补数表示法始终解释数组中最后一个字节（位置<xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`处的字节）的最高序位，因此该方法返回一个字节数组，该数组包含一个值为零的附加元素消除可解释为设置其符号位的正值。 例如，值120或`0x78`表示为单字节数组：。 `0x78` 但是，128或`0x80`，表示为一个2字节的数组： `0x80`、 `0x00`。  
  
 可以通过将<xref:System.Numerics.BigInteger>值存储到字节数组中来往返值，然后<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>使用构造函数还原该值。  
  
> [!CAUTION]
>  如果代码在恢复值之前修改此方法返回的数组中的单个字节的值，则必须确保不会意外更改符号位。 例如，如果您的修改增加了一个正值，使字节数组的最后一个元素中的最高序位成为集，则可以将其值为零的新字节添加到数组的末尾。  
  
   
  
## Examples  
 下面的示例演示如何在<xref:System.Numerics.BigInteger>字节数组中表示某些值。  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">如果使用无符号编码，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="isBigEndian">如果以大端字节顺序写入字节，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用尽可能少的字节数返回此 <see cref="T:System.Numerics.BigInteger" /> 的值作为字节数组。 如果值为零，则返回一个字节（其元素为 0x00）的数组。</summary>
        <returns>转换为字节数组的当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

可在四`33022`个不同的数组中导出整数值：

| 属性                           | 结果                          |
|--------------------------------------|---------------------------------|
| `isUnsigned: false, isBigEndian: false` | `new byte[] { 0xFE, 0x80, 0x00 }` |
| `isUnsigned: false, isBigEndian: true`  | `new byte[] { 0x00, 0x80, 0xFE }` |
| `isUnsigned: true, isBigEndian: false`  | `new byte[] { 0xFE, 0x80 } `      |
| `isUnsigned: true, isBigEndian: true`   | `new byte[] { 0x80, 0xFE }`       |

          ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">如果 <paramref name="isUnsigned" /> 为 <see langword="true" /> 且 <see cref="P:System.Numerics.BigInteger.Sign" /> 为负。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为其等效字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为其等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法设置当前区域性<xref:System.Numerics.BigInteger>的 "R" 或往返行程格式中的值的格式。 <xref:System.Numerics.BigInteger.ToString> 如果要指定其他格式或区域性，请使用<xref:System.Numerics.BigInteger.ToString%2A>方法的其他重载，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|往返（"R"）格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%2A>|  
|特定格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|特定格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <xref:System.Numerics.BigInteger>值的字符串表示形式包括负号（如果其值为负）和一系列从0到9之间的数字（不带前导零）。 负号由当前区域性的<xref:System.Globalization.NumberFormatInfo>对象定义。  
  
   
  
## Examples  
 下面的示例使用默认<xref:System.Numerics.BigInteger> <xref:System.Numerics.BigInteger.ToString>方法显示一个值。 它还显示使用某些标准格式说明符<xref:System.Numerics.BigInteger>生成的值的字符串表示形式。 这些示例使用 en-us 区域性的格式设置约定来显示。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式设置信息将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式，该值使用 <paramref name="provider" /> 参数指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用指定区域性<xref:System.Numerics.BigInteger>的对象设置 "R" 或往返行程格式中的值的格式。 <xref:System.Globalization.NumberFormatInfo>  <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> 如果要指定其他格式或当前区域性，请使用<xref:System.Numerics.BigInteger.ToString%2A>方法的其他重载，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|往返（"R"）格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString>|  
|特定格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|特定格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 参数是一个 <xref:System.IFormatProvider> 实现。 `provider` 其<xref:System.IFormatProvider.GetFormat%2A>方法返回一个<xref:System.Globalization.NumberFormatInfo>对象，该对象提供有关此方法返回的字符串格式的区域性特定信息。 如果`provider` <xref:System.Numerics.BigInteger>为`null`，则使用 <xref:System.Globalization.NumberFormatInfo> 当前区域性的对象设置值的格式。 使用常规格式说明符控制<xref:System.Globalization.NumberFormatInfo> <xref:System.Numerics.BigInteger>值的字符串表示形式的对象的唯一属性为<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，该属性定义表示负号的字符。  
  
 `provider`参数可以是以下项之一：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，该对象表示提供格式设置信息的区域性。  
  
-   提供<xref:System.Globalization.NumberFormatInfo>格式设置信息的对象。  
  
-   实现<xref:System.IFormatProvider>的自定义对象。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回提供<xref:System.Globalization.NumberFormatInfo>格式设置信息的对象。  
  
   
  
## Examples  
 下面的示例实例化一个<xref:System.Globalization.NumberFormatInfo>自定义对象，该对象将波形符（~）定义为负号。 然后<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> ，方法使用自定义<xref:System.Globalization.NumberFormatInfo>对象来显示负值<xref:System.Numerics.BigInteger> 。  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义的数值格式字符串。</param>
        <summary>使用指定的格式将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式，该值使用 <paramref name="format" /> 参数指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用表示当前<xref:System.Numerics.BigInteger>区域性约定的<xref:System.Globalization.NumberFormatInfo>对象来设置指定格式的值的格式。 <xref:System.Numerics.BigInteger.ToString%28System.String%29> 如果要使用 "R" 或往返行程、格式或指定不同的区域性，请使用<xref:System.Numerics.BigInteger.ToString%2A>方法的其他重载，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|往返（"R"）格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString>|  
|往返（"R"）格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|特定格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 参数可以是任何有效的[标准数值字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)或[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)的任意组合。 `format` 如果`format` <xref:System.Numerics.BigInteger>等于或为`null`，则当前对象的返回值用往返格式说明符（"R"）进行格式设置。 <xref:System.String.Empty?displayProperty=nameWithType> 如果`format`是其他任何值，则该方法将<xref:System.FormatException>引发。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关 .NET Framework 中的格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
 返回字符串的格式由当前区域性的<xref:System.Globalization.NumberFormatInfo>对象确定。 `format`根据参数，此对象控制输出字符串中的符号，如负号、组分隔符和小数点符号。 若要为当前区域性以外的区域性提供格式设置信息，请<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>调用重载。  
  
   
  
## Examples  
 下面的示例通过使用<xref:System.Numerics.BigInteger>每个标准格式字符串和一些自定义格式字符串来初始化值并显示值。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的格式字符串。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义的数值格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>由 <paramref name="format" /> 和 <paramref name="provider" /> 参数指定的当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用指定的<xref:System.Numerics.BigInteger>区域性的<xref:System.Globalization.NumberFormatInfo>对象设置指定格式的值的格式。 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 如果要使用往返格式或默认区域性设置，请使用<xref:System.Numerics.BigInteger.ToString%2A>方法的其他重载，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|往返（"R"）格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString>|  
|往返（"R"）格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|特定格式|默认（当前）区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 参数可以是任何有效的[标准数值字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)或[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)的任意组合。 `format` 如果`format` <xref:System.Numerics.BigInteger>等于或为`null`，则当前对象的返回值用往返格式说明符（"R"）进行格式设置。 <xref:System.String.Empty?displayProperty=nameWithType> 如果`format`是其他任何值，则该方法将<xref:System.FormatException>引发。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关 .NET Framework 中的格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
 参数是一个 <xref:System.IFormatProvider> 实现。 `provider` 其<xref:System.IFormatProvider.GetFormat%2A>方法返回一个<xref:System.Globalization.NumberFormatInfo>对象，该对象提供有关此方法返回的字符串格式的区域性特定信息。 <xref:System.IFormatProvider.GetFormat%2A> <xref:System.Type> <xref:System.Globalization.NumberFormatInfo>调用方法时，它`provider`调用参数的方法并向其传递一个表示类型的对象。 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 然后， <xref:System.Globalization.NumberFormatInfo> `value`方法返回对象，该对象提供用于设置参数格式的信息，如负号符号、组分隔符符号或小数点符号。 <xref:System.IFormatProvider.GetFormat%2A> 使用`provider`参数为<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>方法提供格式设置信息的方法有三种：  
  
-   可以传递一个<xref:System.Globalization.CultureInfo>对象，该对象表示提供格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A> 方法 <xref:System.Globalization.NumberFormatInfo> 返回对象，该对象提供该区域性的数字格式设置信息。  
  
-   可以传递提供数字格式<xref:System.Globalization.NumberFormatInfo>设置信息的实际对象。 （其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回自身。）  
  
-   可以传递实现<xref:System.IFormatProvider>的自定义对象。 它<xref:System.IFormatProvider.GetFormat%2A>的方法实例化并<xref:System.Globalization.NumberFormatInfo>返回提供格式设置信息的对象。  
  
 如果`provider` <xref:System.Globalization.NumberFormatInfo>为`null`，则返回的字符串的格式基于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例<xref:System.Numerics.BigInteger>使用标准格式字符串<xref:System.Globalization.NumberFormatInfo>和将波形符（~）定义为负号的对象将值显示到控制台。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的格式字符串。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />，并返回一个指示转换是否成功的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">数字的字符串表示形式。</param>
        <param name="result">当此方法返回时，包含与 <paramref name="value" /> 中所包含的数字等效的 <see cref="T:System.Numerics.BigInteger" />；如果转换失败，则包含零 (0)。 如果 <paramref name="value" /> 参数为 <see langword="null" />，或者其格式不正确，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>尝试将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />，并返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法与<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法类似，不同之处在于它不会在转换失败时引发异常。 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> 此方法无需使用异常处理来测试<xref:System.FormatException> if `value`是否无效且无法成功分析。  
  
 `value`参数应为以下形式的十进制数的字符串表示形式：  
  
 [*ws*][*sign*]*位数*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。|  
|*sign*|一个可选的符号。 有效的符号字符由当前区域性<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>的<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>和属性确定。|  
|*digits*|十进制数字的序列，范围为0到9。|  
  
> [!NOTE]
>  `value`参数指定的字符串不能包含任何组分隔符或小数分隔符，也不能包含小数部分。  
  
 使用样式对`value` <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>参数进行解释。 除十进制数字外，只允许使用前导符号和尾随空格。 若要显式定义具有可在中`value`存在的区域性特定格式设置信息的样式元素，请<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>调用方法。  
  
 使用当前区域性的<xref:System.Globalization.NumberFormatInfo>对象中的格式设置信息分析参数。 `value` 有关详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。  
  
 此重载将参数中的`value`所有数字解释为十进制数字。 若要分析十六进制数的字符串表示形式，请改<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>为调用重载。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>方法实例化两个<xref:System.Numerics.BigInteger>对象。 如果转换成功，则它会将每个对象乘以另一个数字， <xref:System.Numerics.BigInteger.Compare%2A>然后调用方法来确定两个对象之间的关系。  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">数字的字符串表示形式。 该字符串使用由 <paramref name="style" /> 指定的样式来进行解释。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="value" /> 中的样式元素。 要指定的一个典型值为 <see cref="F:System.Globalization.NumberStyles.Integer" />。</param>
        <param name="provider">一个对象，提供有关 <paramref name="value" /> 的区域性特定格式设置信息。</param>
        <param name="result">当此方法返回时，包含与 <paramref name="value" /> 中所包含的数字等效的 <see cref="T:System.Numerics.BigInteger" />；如果转换失败，则包含 <see cref="P:System.Numerics.BigInteger.Zero" />。 如果 <paramref name="value" /> 参数为 <see langword="null" /> 或其格式不符合 <paramref name="style" />，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>尝试将指定样式和区域性特定格式的数字的字符串表示形式转换为其 <see cref="T:System.Numerics.BigInteger" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 参数成功转换，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法与<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法类似，不同之处在于它不会在转换失败时引发异常。 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 此方法无需使用异常处理来测试<xref:System.FormatException> `value`是否无效，并且无法成功分析。  
  
 参数定义`value`参数中允许的样式元素（如空格或正号或负号），以便分析操作成功。 `style` 它必须是<xref:System.Globalization.NumberStyles>枚举中的位标志的组合。 根据的值`style` `value` ，参数可能包括以下元素：  
  
 [*ws*][*$*] [*sign*] [*数字*，]*位数*[。*fractional_digits*] [E [*sign*]*exponential_digits*] [*ws*]  
  
 如果参数包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier> ， `value` 参数可能包括以下元素： `style`  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*ws*|可选空白。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>如果包含 `style`  标志，则可以在的开头出现空格; 如果包含标志， <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 则为末尾处。|  
|*$*|区域性特定的货币符号。 其在字符串中的<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A>位置由`provider`参数<xref:System.IFormatProvider.GetFormat%2A>方法返回的<xref:System.Globalization.NumberFormatInfo>对象的属性定义。 如果`value` `style`包含标志，则货币符号可以出现在中。 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|  
|*sign*|一个可选的符号。 `value` `value` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>如果包含 `style`  标志，则符号可以出现在的开头，如果包含标志，则它可以 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 出现在的结尾。 如果包含`value` `style`标志，则可以在中使用括号来表示负值。 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|  
|*digits*|介于0到9之间的一系列数字。|  
|*，*|区域性特定的组分隔符。 `provider` `value`如果包含 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 标志，则所指定的区域性的组分隔符可以出现在中。 `style`|  
|*.*|区域性特定的小数点符号。 `provider` `value`如果包含 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 标志，则指定的区域性的小数点符号可以出现在中。 `style`|  
|*fractional_digits*|数字0的一个或多个匹配项。 仅当包含`value`  `style` 标志时， 小数位才能出现在中 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>  。|  
|E|"E" 或 "E" 字符，指示值以指数（科学型）表示法表示。 如果`value` 包含标志 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>  ，则参数可以表示指数表示法中的数字。 `style`|  
|*exponential_digits*|介于0到9之间的一系列数字。 如果`value` 包含标志 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>  ，则参数可以表示指数表示法中的数字。 `style`|  
|*hexdigits*|从0到 f 的十六进制数字序列，或者从0到 F。|  
  
> [!NOTE]
> 无论`style`参数的值如何，分析操作都将`s`忽略中的任何终止 NUL （U + 0000）字符。

 只包含十进制数字的字符串（对应<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>于标志）始终会成功分析。 大多数其余<xref:System.Globalization.NumberStyles>成员控件在此输入字符串中可能存在但并不需要存在的元素。 下表指示各个<xref:System.Globalization.NumberStyles>成员如何影响可能出现在中`value`的元素。  
  
|非复合`NumberStyles`值|除了数字以外，还允许在值中使用元素|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅十进制数字。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点（*.*）和*fractional_digits*元素。 但是， *fractional_digits*必须只包含一个或多个0位数字，否则该方法`false`将返回。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 或 "E" 字符（指示指数表示法）以及*exponential_digits*。 如果`value`表示指数表示法中的数字，则它不能包含非零的小数部分。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头 `value` 的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾 `value` 处的*ws*元素。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*数字*前面的*sign*元素。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*数字*后的*符号*元素。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的*符号*元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符（*，*）元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Currency （*$*）元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是， `value`不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|开头或结尾`value`处的 ws 元素，在的 `value`开头处进行签名，然后是小数点（*.*）符号。 `value`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*、 *sign*、group 分隔符（*，*）和小数点（*.*）元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是， `value`不能表示十六进制数。|  
  
> [!IMPORTANT]
>  如果使用<xref:System.Numerics.BigInteger.TryParse%2A>方法往返<xref:System.Numerics.BigInteger.ToString%2A>方法输出的<xref:System.Numerics.BigInteger>值的字符串表示形式，则应将<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>方法与 "R" 格式说明符一起使用，以生成的字符串表示形式。<xref:System.Numerics.BigInteger>值。 否则，的字符串表示形式将<xref:System.Numerics.BigInteger>只保留原始值的50最高有效位，并且当你<xref:System.Numerics.BigInteger.TryParse%2A>使用方法还原<xref:System.Numerics.BigInteger>该值时，数据可能会丢失。  
  
 如果使用`value`标志，则必须是十六进制值。 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 中`style`可以存在的唯一其他标志是<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 （枚举具有复合样式， <xref:System.Globalization.NumberStyles.HexNumber>其中包含两个空白标志。） <xref:System.Globalization.NumberStyles>  
  
> [!NOTE]
>  如果`value`是十六进制数的字符串表示形式，则它的前面不能有任何将其视为`0x`十六进制`&h`数的修饰（如或）。 这将导致转换失败。  
  
 如果`value`是一个十六进制字符串，则<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>该方法`value`会将解释为一个负数，其中使用两个补数表示形式，前提是它的前两个`0x80`十六进制数字大于或等于。 换言之，该方法将中`value`第一个字节的最高序位解释为符号位。 若要确保十六进制字符串正确地解释为正数，则中`value`的第一个数字的值必须为零。 例如，方法将解释`0x80`为负值，但会将`0x080`或`0x0080`解释为正值。 下面的示例演示表示负值和正值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 参数是一个 <xref:System.IFormatProvider> 实现。 `provider` 其<xref:System.IFormatProvider.GetFormat%2A>方法返回一个<xref:System.Globalization.NumberFormatInfo>对象，该对象提供有关格式的`value`区域性特定信息。 `provider`参数可以是以下任一项：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，该对象表示提供格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A> 方法 <xref:System.Globalization.NumberFormatInfo> 返回对象，该对象提供该区域性的数字格式设置信息。  
  
-   提供数字格式设置信息的对象。 <xref:System.Globalization.NumberFormatInfo> （其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回自身。）  
  
-   实现<xref:System.IFormatProvider>的自定义对象。 它<xref:System.IFormatProvider.GetFormat%2A>的方法实例化并<xref:System.Globalization.NumberFormatInfo>返回提供格式设置信息的对象。  
  
 如果`provider`为`null` ， <xref:System.Globalization.NumberFormatInfo> 则使用当前区域性的对象。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> `style`和`provider`参数的值的各种组合对方法进行一些调用。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 对<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法的单个调用会传递以下`BigIntegerFormatProvider`类的实例，该实例将颚化符（~）定义为负号。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
或 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">应写入生成字节的目标跨度。</param>
        <param name="bytesWritten">写入到 <paramref name="destination" /> 的字节数。</param>
        <param name="isUnsigned">如果使用无符号编码，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="isBigEndian">如果以大端字节顺序写入字节，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用尽可能少的字节数将此 <see cref="T:System.Numerics.BigInteger" /> 的值复制为小端二进制补码字节。 如果值为零，则输入其元素为 0x00 的字节。</summary>
        <returns>如果字节满足 <paramref name="destination" />，则为 <see langword="true" />；如果由于空间不足而无法写入所有字节，则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><paramref name="isUnsigned" /> 为 <see langword="true" /> 且 <see cref="P:System.Numerics.BigInteger.Sign" /> 为负。</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字 0（零）的值。</summary>
        <value>其值为 0（零）的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的对象提供了一个用于赋值和比较的零值的方便源。 <xref:System.Numerics.BigInteger>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
