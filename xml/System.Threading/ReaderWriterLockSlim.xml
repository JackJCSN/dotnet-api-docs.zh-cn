<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c3e503580cc18f61ffa36ad86b1bdd97a305369d" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243326" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.ReaderWriterLockSlim>保护是由多个线程读取，并由一个线程一次写入到的资源。 <xref:System.Threading.ReaderWriterLockSlim> 允许多个线程处于读取模式，允许一个线程处于写入模式并独占锁，并允许具有读取访问权限是在可升级的读取模式下，线程可以升级为写入模式，而无需放弃它的一个线程s 读取资源的访问权限。  
  
> [!NOTE]
>  虽然 <xref:System.Threading.ReaderWriterLockSlim> 类似于 <xref:System.Threading.ReaderWriterLock>，但不同之处在于，前者简化了递归规则以及锁状态的升级和降级规则。 <xref:System.Threading.ReaderWriterLockSlim> 避免了许多潜在的死锁情况。 另外，<xref:System.Threading.ReaderWriterLockSlim> 的性能显著优于 <xref:System.Threading.ReaderWriterLock>。 建议对所有新开发的项目使用 <xref:System.Threading.ReaderWriterLockSlim>。  
  
 默认情况下的新实例<xref:System.Threading.ReaderWriterLockSlim>使用创建<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>标记并不允许递归。 对于所有新开发，建议，此默认策略，因为递归带来不必要的复杂情况，使您的代码更容易出现死锁。 若要简化迁移的现有项目，使用<xref:System.Threading.Monitor>或<xref:System.Threading.ReaderWriterLock>，可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>标志，用于创建的实例<xref:System.Threading.ReaderWriterLockSlim>允许递归。  
  
 一个线程可以进入锁定状态三种模式： 模式、 写入模式，并进入可升级的读取的模式，请阅读。 (在本主题的其余部分，"升级的读取的模式"称为"可升级模式"，并且"输入`x`模式下"使用优先于较长的短语"输入中的锁`x`模式"。)  
  
 无论递归策略只有一个线程可以在任何时间是在写模式下。 当线程在写模式下，没有其他线程可以在任何模式下输入该锁。 只有一个线程可以在任何时间是可升级模式。 读取模式，可以为任意数量的线程中, 可以有一个线程进入可升级模式虽然其他线程处于读取模式。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用对象实现 IDisposable"一节<xref:System.IDisposable>接口主题。  
  
 <xref:System.Threading.ReaderWriterLockSlim> 具有托管线程关联;也就是说，每个<xref:System.Threading.Thread>对象必须使其自己的方法调用以进入和退出锁模式。 没有线程可以更改另一个线程的模式。  
  
 如果<xref:System.Threading.ReaderWriterLockSlim>不允许递归中，线程尝试进入锁定可阻止有几个原因：  
  
-   尝试进入读取的模式块，如果有多个线程等待进入写入模式也写模式时出现一个线程的线程。  
  
    > [!NOTE]
    >  编写器进行排队时阻止新的读取器是偏向写入器锁公平性策略。 当前的公平性策略平衡到读取器和编写器，以提升的最常见的方案中的吞吐量的公平性。 未来版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能会引入新的公平性策略。  
  
-   尝试进入可升级模式块写入模式在单个线程是否中已存在一个线程进入可升级模式，如果有多个线程等待进入写入模式，或者一个线程。  
  
-   尝试进入写入模式块是否存在三种模式之一中的线程的线程。  
  
## <a name="upgrading-and-downgrading-locks"></a>升级和降级锁  
 可升级模式适用于在其中一个线程通常读取从受保护资源的情况下，但可能需要满足某些条件时才向其写入。 线程已进入<xref:System.Threading.ReaderWriterLockSlim>进入可升级模式中具有读取访问权限受保护的资源，并可进行升级，通过调用写入模式<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。 中可以有只有一个线程进入可升级模式一次，因为升级为写入模式不能发生死锁时不允许递归，这是默认策略。  
  
> [!IMPORTANT]
>  无论递归策略，最初进入的线程读取模式下不允许，升级到可升级模式或写入模式，因为这种方式导致死锁的概率。 例如，如果两个线程在读取模式下都尝试进入写入模式，它们将死锁。 可升级模式旨在避免这类死锁。  
  
 如果在读取模式下，升级块的线程有其他线程。 虽然线程被阻塞，将阻止其他线程尝试进入读取的模式。 当所有线程均都退出读取模式时，可升级的阻塞的线程进入写入模式。 如果有其他线程等待进入写入模式，则它们保持阻止状态，因为可升级模式在单个线程使它们无法访问资源的独占权限。  
  
 可升级模式中的线程退出时写入模式，正等待进入读取的模式的其他线程可以执行操作，因此除非有线程正等待进入写入模式。 可升级模式中的线程可以升级和降级无限期，只要它是将写入到受保护资源的唯一线程。  
  
> [!IMPORTANT]
>  如果允许多个线程进入写入模式或可升级模式，必须允许一个线程以独占进入可升级模式。 否则，线程尝试进入写入模式下直接将无限期阻塞，和其他线程而阻塞，将不能进入读取的模式。  
  
 可升级模式中的线程可以降级到读取模式下的第一个调用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然后再调用<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。 此降级模式允许针对所有锁定递归策略甚至<xref:System.Threading.LockRecursionPolicy.NoRecursion>。  
  
 降级为读取模式之后, 在线程不能重新输入进入可升级模式直到它已退出读取模式。  
  
## <a name="entering-the-lock-recursively"></a>输入锁以递归方式  
 您可以创建<xref:System.Threading.ReaderWriterLockSlim>通过使用支持递归锁条目<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>构造函数来指定锁定策略，并指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。  
  
> [!NOTE]
>  对于新开发，不建议使用递归，因为它引入了不必要的复杂性，并使代码更容易出现死锁。  
  
 有关<xref:System.Threading.ReaderWriterLockSlim>，允许使用递归，以下可以认为可以进入的模式：  
  
-   读取模式中的线程可以输入以递归方式读取的模式，但不能进入写入模式或可升级模式。 如果它尝试为此，<xref:System.Threading.LockRecursionException>引发。 进入读取模式后再进入写入模式或可升级模式是一种模式有死锁的可能性会强，因此不允许。 如前面所述，对于锁升级所需的情况提供可升级模式。  
  
-   可升级模式中的线程可以进入写入模式和/或读取的模式，而且可以进入三种模式以递归方式。 但是，尝试进入写入模式块读取模式中是否有其他线程。  
  
-   写入模式中的线程读取的模式和/或可升级模式，可以输入，并且可以输入任意三种模式以递归方式。  
  
-   线程没有进入该锁可以输入任何模式。 此尝试也可能阻塞尝试输入非递归锁的原因相同。  
  
 线程可以退出其已进入任意顺序的模式，只要它退出完全按照无数次，它进入该模式每种模式。 如果一个线程尝试退出模式的次数过多，或若要退出它没有进入，模式<xref:System.Threading.SynchronizationLockException>引发。  
  
## <a name="lock-states"></a>锁定状态  
 您可能会发现其状态的锁的想象。 一个<xref:System.Threading.ReaderWriterLockSlim>可以是四种状态之一： 不进入、 读取、 升级和写入。  
  
-   未输入：在此状态下，没有线程已进入锁定状态 （或所有线程均已都退出锁）。  
  
-   读取：在此状态下，一个或多个线程进入锁定用于读访问到受保护的资源。  
  
    > [!NOTE]
    >  一个线程可以通过使用读取模式中输入该锁<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或可升级模式从其降级。  
  
-   升级：在此状态下，一个线程已进入锁定状态进行读访问，将无法升级，以写入访问权限 （即，在进入可升级模式下），以及零个或多个线程进入锁定用于读访问。 一次最多一个线程可以输入选项以升级; 使用锁尝试进入可升级模式的其他线程被阻止。  
  
-   写入：在此状态下，一个线程已进入的锁定以进行写访问到受保护的资源。 该线程有锁的独占所有权。 尝试进入锁定状态出于任何原因的其他任何线程被阻止。  
  
 下表描述了锁定状态，不允许递归中，当一个线程的锁之间的转换`t`采用的最左侧列中描述的操作。 在时它会执行的操作，`t`具有无模式。 (特殊情况其中`t`中表脚注中介绍了可升级模式。)最上面一行描述该锁的起始状态。 单元格描述线程，会发生什么情况，并在括号中显示为锁定状态的更改。  
  
||未输入 (N)|Read (R)|升级 (U)|写入 (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` 进入读取的模式|`t` 进入 (R)。|`t` 如果多个线程处于等待状态的写入模式，则，阻塞否则为`t`进入。|`t` 如果多个线程处于等待状态的写入模式，则，阻塞否则为`t`进入。<sup>1</sup>|`t` 块。|  
|`t` 进入可升级模式|`t` 进入 (U)。|`t` 如果多个线程等待阻塞进入写入模式或升级模式;否则为`t`进入 (U)。|`t` 块。|`t` 块。|  
|`t` 进入写入模式|`t` 输入 (W)。|`t` 块。|`t` blocks.<sup>2</sup>|`t` 块。|  
  
 <sup>1</sup>如果`t`启动出可升级模式，在进入读取的模式。 此操作永远不会阻止。 锁定状态不会更改。 （在线程可以完成降级模式下读取退出可升级模式）。  
  
 <sup>2</sup>如果`t`初始进入可升级模式，它将阻塞多个线程处于读取模式。 否则它将升级为写入模式。 锁定状态将更改写入 (W)。 如果`t`块中，因为多个线程处于读取模式，它将进入写入模式，只要在最后一个线程退出读取的模式，即使有线程正等待进入写入模式。  
  
 因为在线程退出锁定状态更改时下, 一个线程被唤醒，选中，如下所示：  
  
-   首先，正在等待的线程写入模式，并已在进入可升级模式 （可以有最多一个此类线程）。  
  
-   如果没有，正在等待写入模式的线程。  
  
-   如果没有，正在等待进入可升级模式的线程。  
  
-   如果没有，正在等待读取模式下的所有线程。  
  
 后续状态的锁始终为写入 (W) 中的第一个的两个用例和升级 (U) 中的第三个的情况下，而不考虑现有线程触发状态更改时的锁定状态。 在最后一种情况下，锁的状态是升级 (U)，如果一个线程中没有进入可升级模式后的状态更改和 Read (R) 否则，而不考虑以前的状态。  
  
   
  
## Examples  
 下面的示例演示使用整数键包含字符串的简单同步的缓存。 实例<xref:System.Threading.ReaderWriterLockSlim>用于同步对<xref:System.Collections.Generic.Dictionary%602>可用作内部缓存。  
  
 该示例包含将添加到缓存、 从缓存中删除和从缓存中读取的简单方法。 为了演示超时，该示例包含仅当它可以指定超时内执行此操作将添加到缓存的方法。  
  
 为了演示可升级模式，该示例包括检索与键关联的值的方法，并将其与新值进行比较。 如果值保持不变，该方法将返回状态指示没有变化。 如果键不找到任何值，则插入键/值对。 如果值已更改，将其更新。 可升级模式允许从读取访问权限来写入访问权限，根据需要而无需导致死锁升级的线程。  
  
 该示例包含嵌套的枚举，用于指定演示了可升级模式的方法的返回值。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>是更简单且更不易出错，当锁不允许递归。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个蔬菜到数组中存储的文件名写入`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜，按降序排序的第二个 （从低到高索引的索引） 升序排序的第一个的名称。 最后一项任务搜索字符串"cucumber"，并找到的话，当调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法来替换字符串"绿色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用默认属性值初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Threading.ReaderWriterLockSlim>初始化与此构造函数不允许使用递归。 也就是说，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 属性将返回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。  
  
 有关递归策略及其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
   
  
## Examples  
 下面的示例演示使用整数键包含字符串的简单同步的缓存。 实例<xref:System.Threading.ReaderWriterLockSlim>用于同步对<xref:System.Collections.Generic.Dictionary%602>可用作内部缓存。 无参数构造函数用于创建该锁。  
  
 该示例包含将添加到缓存、 从缓存中删除和从缓存中读取的简单方法。 为了演示超时，该示例包含仅当它可以指定超时内执行此操作将添加到缓存的方法。  
  
 为了演示可升级模式，该示例包括检索与键关联的值的方法，并将其与新值进行比较。 如果值保持不变，该方法将返回状态指示没有变化。 如果键不找到任何值，则插入键/值对。 如果值已更改，将其更新。 可升级模式允许从读取访问权限来写入访问权限，根据需要而无需导致死锁升级的线程。  
  
 该示例包含嵌套的枚举，用于指定演示了可升级模式的方法的返回值。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>是更简单且更不易出错，当锁不允许递归。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个蔬菜到数组中存储的文件名写入`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜，按降序排序的第二个 （从低到高索引的索引） 升序排序的第一个的名称。 最后一项任务搜索字符串"cucumber"，并找到的话，当调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法来替换字符串"绿色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">枚举值之一，用于指定锁定递归策略。</param>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例，从而指定锁定递归策略。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 递归策略用于确定在多次输入锁的线程上的限制。 例如，如果在创建时锁定<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>和一个线程已进入读取模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试以重新输入该锁在读取模式下，将引发。 同样，如果线程已进入写入模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试以重新输入该锁在任何模式下，将引发。  
  
> [!NOTE]
>  可升级模式中的线程可以升级为写入模式或降级为读取模式而不考虑锁定递归策略设置。  
  
 无论递归策略，最初进入的线程读取模式下不允许，升级到可升级模式或写入模式，因为这种方式导致死锁的概率。  
  
 有关递归策略及其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
   
  
## Examples  
 下面的示例演示两个异常情况，一种取决于<xref:System.Threading.LockRecursionPolicy>设置，并且其中一个却没有。  
  
 在第一个方案中，线程进入读取的模式，并尝试以递归方式进入读取的模式。 如果<xref:System.Threading.ReaderWriterLockSlim>使用默认构造函数，它将递归策略设置为创建<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，将引发异常。 如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用于创建<xref:System.Threading.ReaderWriterLockSlim>，不会引发异常。  
  
 在第二个方案中，线程进入读取的模式，然后尝试进入写入模式。 <xref:System.Threading.LockRecursionException> 是引发而不考虑锁定递归策略。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个蔬菜到数组中存储的文件名写入`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜，按降序排序的第二个 （从低到高索引的索引） 升序排序的第一个的名称。 最后一项任务搜索字符串"cucumber"，并找到的话，当调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法来替换字符串"绿色 bean"。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已进入读取模式锁定状态的独有线程的总数。</summary>
        <value>已进入读取模式锁定状态的独有线程的数量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程只计算一次，即使该锁允许递归和线程已进入读取的模式多次。  
  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>属性生成一个事件日志条目，如果在读取模式中的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 后，应调用 <xref:System.Threading.ReaderWriterLockSlim>。 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法使 <xref:System.Threading.ReaderWriterLockSlim> 处于不可用状态。 在调用<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，必须释放对所有引用<xref:System.Threading.ReaderWriterLockSlim>这样垃圾回收器才能收回内存的<xref:System.Threading.ReaderWriterLockSlim>占用。 有关详细信息，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)并[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  始终调用<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>发布到最后一个引用之前<xref:System.Threading.ReaderWriterLockSlim>对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大于零。  
  
- 或 - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大于零。  
  
- 或 - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入读取模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将阻塞，直到调用线程进入锁，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法来阻止指定的间隔时间，并返回调用线程不具有已进入读取模式，在此间隔期间。  
  
 多个线程可以在同一时间进入读取的模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法受到阻止，直到这些线程超时或已进入写入模式，然后从其已退出。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程正在等待进入写入模式。  
  
 当其他线程处于读取模式时，最多一个线程可以处于可升级模式。 如果其他线程等待进入可升级模式，并且有没有线程在等待进入写入模式，线程调用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法进入读取模式锁定。 在示例中所示的方法检索与键关联的值。 如果未找到键，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 一个`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，从而调用方退出读取的模式。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有读取锁定时已尝试获取读取锁定。  
  
- 或 - 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有写入锁定时已尝试获取读取锁定。  
  
- 或 - 
递归数将超出计数器的容量。 此限值很大，因此应用程序应该不会遇到此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入可升级模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将阻塞，直到调用线程进入锁，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法来阻止指定的间隔时间，并返回如果调用线程在此间隔期间未进入可升级模式。  
  
 如果线程通常访问的受保护的资源使用可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要满足某些条件时进入写入模式。 可升级模式中的线程可以降级到读取模式或升级，以写入模式。  
  
 只有一个线程可以在任何给定时间进入可升级模式。 如果某个线程处于可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以输入读取的模式，即使线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法受到阻止，直到这些线程超时或已进入写入模式，然后从其已退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入可升级模式锁定可以输入以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法进入可升级模式锁定。 一个`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，从而调用方退出可升级模式。  
  
 在示例中所示的方法检索与键关联的值，并将其与新值进行比较。 如果值保持不变，该方法将返回状态指示没有变化。 没有值找到的密钥，将插入键/值对。 如果值已更改，将其更新。 可升级模式允许升级读取的锁定，根据需要而无需导致死锁的线程。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>是更简单且更不易出错，当锁不允许递归。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
- 或 - 
当前线程已进入读取模式，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入写入模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将阻塞，直到调用线程进入锁，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法来阻止指定的间隔时间，并返回如果调用线程在此间隔期间未进入写入模式。  
  
 如果其他线程已进入读取模式锁定线程的调用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法受到阻止，直到这些线程均已退出读取模式。 有线程在等待进入写入模式，其他线程尝试进入读取的模式或可升级模式块之前等待进入写入模式的所有线程的超时或已进入写入模式，然后又从中退出。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入写入模式锁定可以递归方式进入写入模式，即使其他线程正在等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法进入写入模式锁定。 在示例中所示的方法将新的键/值对添加到已同步的缓存。 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 一个`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而调用方退出写入模式。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
- 或 - 
当前线程已进入读取模式且尚无写锁定，因此尝试进入写入模式锁定状态将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式中的锁，然后进入读取模式锁定的顺序在线程退出两种模式不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定状态，然后输入它以递归方式在读取模式下;线程退出读取模式和写入模式下并不重要的顺序。  
  
 退出锁可能会向其他等待线程发出信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，从而调用方退出读取的模式。 在示例中所示的方法检索与键关联的值。 如果未找到键，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用于进入读取的模式。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入读取模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式中的锁，然后进入写入模式锁定的顺序在线程退出两种模式不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定，然后输入它以递归方式进入可升级模式; 中在其中在线程退出可升级模式和写入模式的顺序不重要。  
  
 退出锁可能会向其他等待线程发出信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，从而调用方退出可升级模式。  
  
 在示例中所示的方法检索与键关联的值，并将其与新值进行比较。 如果值保持不变，该方法将返回状态指示没有变化。 没有值找到的密钥，将插入键/值对。 如果值已更改，将其更新。 可升级模式允许升级读取的锁定，根据需要而无需导致死锁的线程。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>是更简单且更不易出错，当锁不允许递归。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入可升级模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式中的锁，然后进入写入模式锁定的顺序在线程退出两种模式不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定状态，然后输入它以递归方式在读取模式下;线程退出读取模式和写入模式下并不重要的顺序。  
  
 退出锁可能会向其他等待线程发出信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而调用方退出写入模式。 在示例中所示的方法将新的键/值对添加到已同步的缓存。 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用于进入写入模式锁定。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入写入模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。</summary>
        <value>如果当前线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或用于其他调试目的。 不要使用它来控制控制程序执行流。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>属性生成断言，如果当前线程已进入读取模式意外。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入可升级模式的锁定状态。</summary>
        <value>如果当前线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或用于其他调试目的。 不要使用它来控制控制程序执行流。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>生成断言，如果当前线程已进入可升级模式意外的属性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。</summary>
        <value>如果当前线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或用于其他调试目的。 不要使用它来控制控制程序执行流。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>生成断言，如果当前线程已进入写入模式意外的属性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象的递归策略。</summary>
        <value>枚举值之一，用于指定锁定递归策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 递归策略用于确定在多次输入锁的线程上的限制。 例如，如果在创建时锁定<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>和一个线程已进入读取模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试以重新输入该锁在读取模式下，将引发。  
  
> [!NOTE]
>  可升级模式中的线程可以升级为写入模式或降级为读取模式而不考虑锁定递归策略设置。  
  
 无论递归策略，最初进入的线程读取模式下不允许，升级到可升级模式或写入模式，因为这种方式导致死锁的概率。  
  
 有关递归策略及其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入读取模式锁定状态的次数，用于指示递归。</summary>
        <value>0 （零），如果当前线程未进入读取模式，它以递归方式，1; 如果线程已进入读取的模式但却不进入或*n*如果线程已进入锁定以递归方式*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入可升级模式锁定状态的次数，用于指示递归。</summary>
        <value>如果当前线程没有进入可升级模式，如果线程已进入可升级模式，但不是进入则以递归方式，则为 1，则为 0 或*n*如果线程已进入可升级模式以递归方式*n* -1时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入写入模式锁定状态的次数，用于指示递归。</summary>
        <value>0，如果当前线程没有进入写入模式下，如果线程已进入写入模式却不进入则为 1 以递归方式，或*n*如果线程已进入写入模式下以递归方式*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入读取模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数；或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入读取模式锁定状态，可以选择整数超时时间。</summary>
        <returns>如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 多个线程可以在同一时间进入读取的模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法进行阻止，直到这些线程已是超时或已进入写入模式，然后退出，或调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程正在等待进入写入模式。  
  
 一个线程可以是可升级模式，而其他线程都在读取模式下。 如果其他线程等待进入可升级模式，并且有没有线程在等待进入写入模式，线程调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入读取模式锁定状态，可以选择超时时间。</summary>
        <returns>如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 同时，多个线程可以在读取模式下输入该锁。  
  
 如果一个或多个线程排队等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法进行阻止，直到这些线程已是超时或已进入写入模式，然后退出，或调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程正在等待进入写入模式。  
  
 一个线程可以是可升级模式，而其他线程都在读取模式下。 如果其他线程等待进入可升级模式，并且有没有线程在等待进入写入模式，线程调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数；或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
        <returns>如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果线程通常访问的受保护的资源使用可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要满足某些条件时进入写入模式。 可升级模式中的线程可以升级为写入模式或降级为读取模式。  
  
 在任何给定时间，只有一个线程可以进入可升级模式中输入一个锁。 如果某个线程处于可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以输入读取的模式，即使线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法进行阻止，直到这些线程已是超时或已进入写入模式，然后退出，或调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入可升级模式锁定可以输入以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
        <returns>如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果线程通常访问所保护的资源使用可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要满足某些条件时进入写入模式。 可升级模式中的线程可以升级为写入模式或降级为读取模式。  
  
 在任何给定时间，只有一个线程可以进入可升级模式中输入一个锁。 如果某个线程处于可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以输入读取的模式，即使线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法进行阻止，直到这些线程已是超时或已进入写入模式，然后退出，或调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入可升级模式锁定可以输入以递归方式进入可升级模式，即使其他线程正在等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数；或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
        <returns>如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果其他线程已进入读取模式锁定线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法进行阻止，直到这些线程均已退出读取的模式或超时间隔已过去。 尽管等待进入写入模式，将阻止线程，尝试进入读取的模式或可升级模式的其他线程阻塞，直到所有线程正等待进入都写入模式，具有任一超时或已进入都写入模式，然后从其退出。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入写入模式锁定可以递归方式进入写入模式，即使其他线程正在等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法进入写入模式下，超时时间的锁定。在示例中所示的方法将新的键/值对添加到已同步的缓存。 如果指定的超时间隔结束线程进入锁定之前，该方法返回`false`。 该方法将返回`true`如果添加键/值对。  
  
 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 一个`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而调用方退出锁。  
  
 此代码是为提供一个更大示例的一部分<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
        <returns>如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），则此方法检查锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果其他线程已进入读取模式锁定线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法进行阻止，直到这些线程均已退出读取的模式或超时间隔已过去。 尽管等待进入写入模式，将阻止线程，尝试进入读取的模式或可升级模式的其他线程阻塞，直到所有线程正等待进入都写入模式，具有任一超时或已进入都写入模式，然后从其退出。  
  
> [!NOTE]
>  如果锁允许使用递归，线程已进入写入模式锁定可以递归方式进入写入模式，即使其他线程正在等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
- 或 - 
递归数将超出计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入读取模式锁定状态的线程总数。</summary>
        <value>等待进入读取模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入读取的模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入可升级模式锁定状态的线程总数。</summary>
        <value>等待进入可升级模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入可升级模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入写入模式锁定状态的线程总数。</summary>
        <value>等待进入写入模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性仅用于调试、 分析和日志记录目的，而不适用于控制算法的行为。 一旦计算完，可以更改结果。 因此，不安全地做出决策基于此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入写入模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>