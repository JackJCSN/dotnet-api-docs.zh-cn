<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e91f598b6b6c1baa4b3ad266724134e296b516a2" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70654379" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">集合中的键的类型。</typeparam>
    <typeparam name="TItem">集合中的项的类型。</typeparam>
    <summary>提供集合键嵌入在值中的集合的抽象基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602>类提供 o （1）索引的检索和加密方法（1）的加密方法。 它是抽象类型，或者更准确地说是一组无限抽象类型，因为其构造的泛型类型都是抽象基类。 若要<xref:System.Collections.ObjectModel.KeyedCollection%602>使用，请从适当的构造类型中派生集合类型。  
  
 类是基于<xref:System.Collections.Generic.IList%601>泛型接口的集合和基于<xref:System.Collections.Generic.IDictionary%602>泛型接口的集合之间的混合。 <xref:System.Collections.ObjectModel.KeyedCollection%602> 类似于基于<xref:System.Collections.Generic.IList%601>泛型接口的集合， <xref:System.Collections.ObjectModel.KeyedCollection%602>是项的索引列表。 与基于<xref:System.Collections.Generic.IDictionary%602>泛型接口的集合类似， <xref:System.Collections.ObjectModel.KeyedCollection%602>具有与每个元素相关联的键。  
  
 与字典不同，的<xref:System.Collections.ObjectModel.KeyedCollection%602>元素不是键/值对，而是整个元素是值并且该键嵌入在值中。  例如，派生自`KeyedCollection\<String,String>`的集合的元素（`KeyedCollection(Of String, String)`在 Visual Basic 中）可能是 "John Doe Jr"。 其中，值为 "John Doe Jr"。 密钥为 "Doe";或包含整数键的雇员记录的集合可以从`KeyedCollection\<int,Employee>`派生。 Abstract <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>方法从元素中提取键。  
  
 默认情况下， <xref:System.Collections.ObjectModel.KeyedCollection%602>包括一个可<xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A>使用属性获取的查找字典。  向添加项后<xref:System.Collections.ObjectModel.KeyedCollection%602>，该项的键将被提取一次并保存在查找字典中，以加快搜索速度。 当你创建<xref:System.Collections.ObjectModel.KeyedCollection%602>时，将通过指定字典创建阈值来重写此行为。 第一次元素数目超过该阈值时，会创建查找字典。  如果指定-1 作为阈值，则永远不会创建查找字典。  
  
> [!NOTE]
>  当使用内部查找字典时，如果`TItem`为引用类型，则包含对集合中所有项的引用; 如果`TItem`是值类型，则包含集合中所有项的副本。 因此，如果`TItem`是值类型，则使用查找字典可能不适合。  
  
 可以通过使用<xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>属性访问项的索引或键。 可以添加没有键的项，但随后只能通过索引访问这些项。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的最小代码，并演示了许多继承的方法。 第二个示例演示如何重写的受保护<xref:System.Collections.ObjectModel.KeyedCollection%602>方法以提供自定义行为。  
  
 **示例1**  
  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **示例2**  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化使用默认相等比较器的 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Collections.ObjectModel.KeyedCollection%602>此构造函数创建的使用从<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>获取的键类型的默认泛型相等比较器。 若要指定不同的泛型相等比较器， <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29>请使用构造<xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>函数或构造函数。  
  
 默认情况下， <xref:System.Collections.ObjectModel.KeyedCollection%602>包括添加第一项时创建的查找字典。 向添加项后<xref:System.Collections.ObjectModel.KeyedCollection%602>，该项的键将被提取一次并保存在查找字典中，以加快搜索速度。 可以使用<xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>构造函数并指定字典创建阈值来重写此行为。  
  
> [!NOTE]
>  因为类<xref:System.Collections.ObjectModel.KeyedCollection%602>是抽象的（`MustInherit`在 Visual Basic），所以必须从派生该类才能使用。 在派生类型的构造函数中，调用相应<xref:System.Collections.ObjectModel.KeyedCollection%602>的构造函数。 不需要公开功能，如相等比较器或构造函数中的字典创建阈值。  
  
 此构造函数的运算复杂度为 O （1）。  
  
   
  
## Examples  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">比较键时要使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 泛型接口的实现，如果为 <see langword="null" />，则使用从 <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> 获取的该类型的键的默认相等比较器。</param>
        <summary>初始化使用指定相等比较器的 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下， <xref:System.Collections.ObjectModel.KeyedCollection%602>包括添加第一项时创建的查找字典。 向添加项后<xref:System.Collections.ObjectModel.KeyedCollection%602>，该项的键将被提取一次并保存在查找字典中，以加快搜索速度。 可以使用<xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>构造函数并指定字典创建阈值来重写此行为。  
  
> [!NOTE]
>  因为类<xref:System.Collections.ObjectModel.KeyedCollection%602>是抽象的（`MustInherit`在 Visual Basic），所以必须从派生该类才能使用。 在派生类型的构造函数中，调用相应<xref:System.Collections.ObjectModel.KeyedCollection%602>的构造函数。 不需要公开功能，如相等比较器或构造函数中的字典创建阈值。  
  
 此构造函数的运算复杂度为 O （1）。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">比较键时要使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 泛型接口的实现，如果为 <see langword="null" />，则使用从 <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> 获取的该类型的键的默认相等比较器。</param>
        <param name="dictionaryCreationThreshold">在不创建查找字典的情况下集合可容纳的元素的数目（0 表示添加第一项时创建查找字典）；或者为 -1，表示指定永远不会创建查找字典。</param>
        <summary>初始化 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 类的新实例，该新实例使用指定的相等比较器并在超过指定阈值时创建一个查找字典。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下， <xref:System.Collections.ObjectModel.KeyedCollection%602>包括添加第一项时创建的查找字典。 向添加项后<xref:System.Collections.ObjectModel.KeyedCollection%602>，该项的键将被提取一次并保存在查找字典中，以加快搜索速度。 此构造函数允许你重写该行为。 指定0将在添加第一个元素时创建字典，1则在添加第二个元素时创建字典，依此类推。 如果指定-1 作为阈值，则永远不会创建查找字典。  
  
 对于非常小的集合，查找字典提供的检索速度改进可能不值得字典所需的额外内存。 通过设置阈值，您可以决定何时进行权衡。  
  
> [!NOTE]
>  因为类<xref:System.Collections.ObjectModel.KeyedCollection%602>是抽象的（`MustInherit`在 Visual Basic），所以必须从派生该类才能使用。 在派生类型的构造函数中，调用相应<xref:System.Collections.ObjectModel.KeyedCollection%602>的构造函数。 不需要公开功能，如相等比较器或构造函数中的字典创建阈值。  
  
 此构造函数的运算复杂度为 O （1）。  
  
   
  
## Examples  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例使用<xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>阈值为0的构造函数，以便在第一次将对象添加到集合时创建内部字典。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" /> 小于 -1。</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">要更改其键的元素。</param>
        <param name="newKey"><paramref name="item" /> 的新键。</param>
        <summary>更改与查找字典中指定元素相关联的键。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会修改嵌入在中`item`的键; 它只是替换查找字典中保存的键。  因此，如果`newKey`不同于中`item`嵌入的键，则不能使用返回<xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>的`item`键访问。  
  
 如果<xref:System.Collections.ObjectModel.KeyedCollection%602>没有查找字典，则此方法不执行任何操作。  
  
 中的每个<xref:System.Collections.ObjectModel.KeyedCollection%602>键都必须是唯一的。 键不能为`null`。  
  
 此方法为 O （1）操作。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 在修改项目中嵌入的键之前，必须调用此方法以更新查找字典中的键。 如果字典创建阈值为-1，则不需要调用此方法。  
  
 不要将<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>方法公开为派生类的公共方法。 此方法误用会使查找字典与项键不同步。 例如，如果将键设置为`null` ，然后将其设置为另一个值，则会将一个项的多个键添加到查找字典中。 在内部公开此方法以允许可变项键：当项的键发生更改时，此方法用于更改查找字典中的键。  
  
   
  
## Examples  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="key" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 未找到。  
  
或 
 <paramref name="key" /> 在 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 中已存在。</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有查找字典，此方法会将其清除，但不会将其删除。  
  
 如果元素数已超过字典创建阈值，并且<xref:System.Collections.ObjectModel.KeyedCollection%602>使用的是查找字典，则它将继续使用查找字典，即使元素数在阈值下也是如此。  
  
 此方法是 O （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 重写此方法以提供<xref:System.Collections.ObjectModel.Collection%601.Clear%2A> <xref:System.Collections.ObjectModel.Collection%601>从泛型类继承的方法的自定义行为。  
  
 调用此方法的基类实现以清除基础集合并清除查找字典。  
  
   
  
## Examples  
 本节包含两个代码示例，这些代码示例<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>演示如何重写方法以提供从集合中清除所有对象的自定义行为。 第一个示例添加了一个自定义通知事件，第二个示例为具有可变键的对象集合提供支持。  
  
 示例 1  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于确定集合中的键是否相等的泛型相等比较器。</summary>
        <value>用于确定集合中的键是否相等的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 泛型接口的实现。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">要在 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 中定位的键。</param>
        <summary>确定集合是否包含具有指定键的元素。</summary>
        <returns>如果 <see langword="true" /> 包含具有指定键的元素，则为 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具有查找字典， `key`则用于搜索字典。 <xref:System.Collections.ObjectModel.KeyedCollection%602> 如果没有查找字典，则使用<xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>方法提取每个元素的键，并与指定键进行比较。  
  
 如果<xref:System.Collections.ObjectModel.KeyedCollection%602>具有查找字典，则此方法为 o （1）操作; 否则为 o （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。  
  
   
  
## Examples  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 的查找字典。</summary>
        <value><see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 的查找字典（如果存在），否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下， <xref:System.Collections.ObjectModel.KeyedCollection%602>包括添加第一项时创建的查找字典。 向添加项后<xref:System.Collections.ObjectModel.KeyedCollection%602>，该项的键将被提取一次并保存在查找字典中，以加快搜索速度。 可以使用<xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>构造函数并指定字典创建阈值来重写此行为。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">从中提取键的元素。</param>
        <summary>在派生类中实现时，将从指定元素提取键。</summary>
        <returns>指定元素的键。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果查找字典中的键不同于中嵌入`item`的键，则不能<xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>使用返回的键`item`访问。  
  
 您可以实现此方法以便为`null`包含没有键的项的集合返回，在这种情况下，只能通过索引来访问项。 此方法为 O （1）操作。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 必须重写此方法以提供一种方法，以便从字典中的项中提取键。  
  
 此方法在内部调用。 它不是公共的。  
  
   
  
## Examples  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="item" /> 的从零开始的索引。</param>
        <param name="item">要插入的对象。</param>
        <summary>将元素插入 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`index` <xref:System.Collections.ObjectModel.KeyedCollection%602>等于，则 `item` 将添加到的末尾。 <xref:System.Collections.ObjectModel.Collection%601.Count%2A>  
  
 此方法是 O （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>由<xref:System.Collections.ObjectModel.Collection%601.Add%2A> 和 <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> 方法调用。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 重写此方法，以便为和<xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> <xref:System.Collections.ObjectModel.Collection%601>方法提供自定义的行为，这些行为是从泛型类继承的。  
  
 调用此方法的基类实现，将项插入到基础集合中并更新查找字典。  
  
   
  
## Examples  
 本节包含两个代码示例，这些代码示例<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>演示如何重写方法，以提供用于在集合中添加或插入对象的自定义行为。 第一个示例添加了一个自定义通知事件，第二个示例为具有可变键的对象集合提供支持。  
  
 示例 1  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
或 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />。</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">要获取的元素的键。</param>
        <summary>获取具有指定键的元素。</summary>
        <value>带有指定键的元素。 如果未找到具有指定键的元素，则引发异常。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供了使用以下语法访问集合中的特定元素的功能： `myCollection[key]` （`myCollection(key)`在 Visual Basic 中）。  
  
> [!NOTE]
>  此属性不同于继承<xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>属性，后者按数值索引获取和设置元素。 但是，如果`TKey`的类型<xref:System.Int32>为，则此属性将掩盖继承的属性。 在这种情况下，你可以通过将继承的<xref:System.Collections.ObjectModel.KeyedCollection%602>属性强制转换为其基类型来访问它。 `KeyedCollection<int, MyType>`例如，在中`KeyedCollection(Of Integer, MyType)` ， `KeyedCollection<int, MyType^>`可以将（ C++在中为 Visual Basic） `Collection<MyType>`转换`Collection(Of MyType)`为（在`Collection<MyType^>` Visual Basic C++中）。  
  
 如果具有查找字典， `key`则用于从字典中检索元素。 <xref:System.Collections.ObjectModel.KeyedCollection%602>  如果没有查找字典，则使用<xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>方法提取每个元素的键，并与指定键进行比较。  
  
 该C#语言使用[this](~/docs/csharp/language-reference/keywords/this.md)关键字来定义索引器，而不是实现<xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>属性。 Visual Basic 实现<xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>为[默认属性](~/docs/visual-basic/language-reference/modifiers/default.md)，该属性提供相同的索引功能。  
  
 如果<xref:System.Collections.ObjectModel.KeyedCollection%602>具有查找字典，则检索此属性的值是一个 o （1）操作; 否则为 o （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。

## Examples  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 此代码示例调用<xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>属性，该属性是只读的并且按键进行检索，并且是可设置的并且按索引进行检索的<xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>属性。 它演示当派生集合中的对象具有整数键时如何访问后者属性，这与用于索引检索的整数不区分。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">集合中不存在具有指定键的元素。</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">要移除的元素的键。</param>
        <summary>从 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 中移除包含指定键的元素。</summary>
        <returns>如果该元素已成功移除，则为 <see langword="true" />；否则为 <see langword="false" />。  如果在 <see langword="false" /> 中没有找到 <paramref name="key" />，则此方法也会返回 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还将从查找字典中删除元素的键。  
  
 如果元素数已超过字典创建阈值，并且<xref:System.Collections.ObjectModel.KeyedCollection%602>使用的是查找字典，则它将继续使用查找字典，即使元素数在阈值下也是如此。  
  
> [!NOTE]
>  若要自定义此方法的行为，请<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>重写方法。  
  
 此方法是 O （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。  
  
   
  
## Examples  
 此代码示例演示从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生集合类所需的最少代码： <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>重写方法，并提供委托给基类构造函数的公共构造函数。 此代码示例还演示了继承自<xref:System.Collections.ObjectModel.KeyedCollection%602>和<xref:System.Collections.ObjectModel.Collection%601>类的多个属性和方法。  
  
 该示例演示<xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>从<xref:System.Collections.ObjectModel.KeyedCollection%602>继承的方法，该方法将移除具有指定<xref:System.Collections.ObjectModel.Collection%601.Remove%2A>键的项，以及从<xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> <xref:System.Collections.ObjectModel.Collection%601>继承的和方法，分别按对象和索引删除。  
  
 类是一个非常简单的请求列表`OrderItem` ，其中每个对象都表示顺序中的行项。 `SimpleOrder` 的键`OrderItem`是不可变的，它是派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>的类的重要注意事项。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的索引。</param>
        <summary>移除 <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 还将从查找字典中删除元素的键。  
  
 如果元素数已超过字典创建阈值，并且<xref:System.Collections.ObjectModel.KeyedCollection%602>使用的是查找字典，则它将继续使用查找字典，即使元素数在阈值下也是如此。  
  
 此方法是 O （`n`）运算，其中`n`是<xref:System.Collections.ObjectModel.Collection%601.Count%2A>。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 重写此方法以<xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29>提供和<xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> <xref:System.Collections.ObjectModel.Collection%601>方法的自定义行为，继承自泛型类和<xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29>方法。  
  
 调用此方法的基类实现，以从基础集合中删除该项并更新查找字典。  
  
   
  
## Examples  
 本节包含两个代码示例，这些示例演示<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>如何重写方法以提供从集合中移除对象的自定义行为。 第一个示例添加了一个自定义通知事件，第二个示例为具有可变键的对象集合提供支持。  
  
 示例 1  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">要替换的项的从零开始的索引。</param>
        <param name="item">新项目。</param>
        <summary>使用指定项替换指定索引处的项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 查找字典会相应地进行更新。 也就是说，将从查找字典中删除要替换的项的键，并添加新项的键。  
  
 此方法为 O （1）操作。  
  
## <a name="notes-for-implementers"></a>实施者注意事项  
 重写此方法以提供自定义的行为<xref:System.Collections.ObjectModel.Collection%601.Item%2A> ，用于设置<xref:System.Collections.ObjectModel.Collection%601>从泛型类继承的属性。  
  
> [!NOTE]
>  此方法不会影响<xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>属性的行为，该属性是只读的。  
  
 调用此方法的基类实现，以设置基础集合中的项并更新查找字典。  
  
   
  
## Examples  
 本节包含两个代码示例，这些示例演示<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>如何重写方法以提供<xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>设置属性的自定义行为。 第一个示例添加了一个自定义通知事件，第二个示例为具有可变键的对象集合提供支持。  
  
 示例 1  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、和<xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>方法，以便为<xref:System.Collections.ObjectModel.Collection%601.Add%2A>、 <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>、和<xref:System.Collections.ObjectModel.Collection%601.Clear%2A>方法提供自定义行为，并为设置默认<xref:System.Collections.ObjectModel.Collection%601.Item%2A>属性（中C#的索引器）。 在此示例中提供的自定义行为是一个名`Changed`为的通知事件，它在每个重写的方法的末尾引发。  
  
 此代码示例创建`SimpleOrder`类，该类派生自<xref:System.Collections.ObjectModel.KeyedCollection%602>并表示一个简单的订单窗体。 订单窗体包含`OrderItem`表示排序项的对象。 此代码示例还创建了`SimpleOrderChangedEventArgs`一个包含事件信息的类，以及一个用于标识更改类型的枚举。  
  
 此代码示例通过在`Main` `Demo`类的方法中调用派生类的属性和方法，演示了自定义行为。  
  
 此代码示例使用具有不可变键的对象。 有关使用可变键的代码示例，请参见<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>。  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例演示如何重写受保护<xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>的方法以支持可变键，以及如何重写受<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>保护<xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>的<xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>、、 <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>和方法以维护密钥的完整性和集合。  
  
 此代码示例创建`MutableKeys`从<xref:System.Collections.ObjectModel.KeyedCollection%602>派生的集合，以及`MutableKey`类。 类具有可设置`Key`的属性。 `MutableKey` 将新键分配给属性后，属性 setter 将调用`internal`集合的（`Friend`在 Visual Basic 中） `ChangeKey`方法，以测试新的键是否与现有的键冲突。 如果是这样，则会引发异常，并且不会更改属性值。  
  
 `MutableKey`为了保持`Friend`对象`MutableKeys`和集合之间的连接，并阻止将对象插入两个集合中， `MutableKey`类具有一个`internal` （在 Visual Basic 中）  `Collection`字段。 此字段由受保护的方法维护，这些方法提供了用于在集合中添加和移除项的自定义<xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>行为，例如方法。 在将项添加到集合并在移除该项时清除此字段。  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
