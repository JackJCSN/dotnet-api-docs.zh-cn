<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28286c826bff3f763da1cd6ebc352fc8ee8a0d3b" /><Meta Name="ms.sourcegitcommit" Value="727af77f0b7ae2636efa3bc47000697540084461" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/15/2019" /><Meta Name="ms.locfileid" Value="67877111" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>表示运行时绑定范围的概念。 此类为抽象类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Loader.AssemblyLoadContext>表示加载上下文。 从概念上讲，加载上下文创建和加载、 解析时，可能会卸载一组程序集的作用域。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext> 是一个抽象类。 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>需要实现创建一个具体类。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext>存在主要是为了提供程序集绑定隔离。 它允许在单个进程中加载同一程序集的多个版本。 它取代了由多个提供的隔离机制<xref:System.AppDomain>.NET Framework 中的实例。
 
 > [!NOTE]
 > <xref:System.Runtime.Loader.AssemblyLoadContext> 不提供任何安全功能。 所有代码都具有完全权限的过程。

### <a name="usage-in-the-runtime"></a>在运行时中的使用情况
 在运行时实现两个程序集加载上下文：
 * <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 表示用于应用程序主程序集及其依赖静态运行时的默认绑定上下文。
 * <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType>方法将它加载通过实例化的最基本的程序集隔离开来<xref:System.Runtime.Loader.AssemblyLoadContext>。 具有此操作将加载其自身中的每个程序集的简单隔离方案<xref:System.Runtime.Loader.AssemblyLoadContext>没有依赖关系得到解决。
 
### <a name="application-usage"></a>应用程序使用情况
 应用程序可以创建其自己<xref:System.Runtime.Loader.AssemblyLoadContext>创建自定义解决方案的高级绑定方案。 自定义项侧重于定义依赖关系解决机制。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext>提供了两个扩展点，以实现托管程序集解析：
 1. <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>提供的第一次机会<xref:System.Runtime.Loader.AssemblyLoadContext>若要解决该程序集，将其加载，并将其返回。 如果<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>将返回`null`，则加载程序将尝试加载到程序集<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。
 2. 如果<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>无法解析的程序集，原始<xref:System.Runtime.Loader.AssemblyLoadContext>获取第二个机会解决该程序集。 运行时将引发<xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>事件。
 
 此外<xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType>虚方法允许自定义默认的非托管程序集解析。 默认实现返回`null`，这将导致运行时搜索要使用其默认搜索策略，这对于大多数情况下已足够。

### <a name="technical-challenges"></a>技术挑战
 * 不能加载多个版本在单个进程中运行时。
     > [!CAUTION]
     > 正在加载多个副本或不同版本的 framework 程序集可能会导致意外且难以诊断的行为。
     
     > [!TIP]
     > 使用远程处理和/或进程间通信使用进程边界来解决此隔离问题。
 
 * 程序集加载时间会使测试和调试困难。 程序集是通常加载，而无需立即解决其依赖项。 在需要进行加载依赖项：
     * 当代码分支到的从属程序集。
     * 当代码加载资源。
     * 当代码显式加载程序集。
 
 * 实现<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>可以添加新依赖项可能需要进行隔离，以允许存在的不同版本。 最简单的实现会在默认上下文中将这些依赖关系。 精心的设计可以隔离的新的依赖项。
 
 * 绑定隔离进程创建多个类型具有相同的类型名称。
     * 这可能会导致令人混淆的错误消息，例如"Foo.Foo 无法将类型转换为类型 Foo.Foo。"
     * 跨隔离边界封送处理是重要的。 典型的解决方案是使用仅加载到默认加载上下文的程序集中定义的接口。
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md">AssemblyLoadContext CoreCLR 的设计文档</related>
    <related type="Article" href="~/docs/standard/assembly/unloadability-howto.md">如何使用和调试.NET Core 中的程序集 unloadability</related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md">AssemblyLoadContext unloadability 设计文档</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此构造函数受到保护。 仅从调用<xref:System.Runtime.Loader.AssemblyLoadContext>类或其派生的类。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible">要启用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />，因为启用卸载会产生性能成本。</param>
        <summary>使用一个指示是否启用卸载的值来初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此构造函数受到保护。 仅从调用<xref:System.Runtime.Loader.AssemblyLoadContext>类或其派生的类。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyLoadContext (string name, bool isCollectible = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional isCollectible As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : string * bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext (name, isCollectible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isCollectible" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">新实例中 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.Name" /> 的值。 其值可为 <see langword="null" />。</param>
        <param name="isCollectible">要启用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />，因为启用卸载会产生性能成本。</param>
        <summary>使用名称和指示是否启用卸载的值来初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt; All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; All" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property All As IEnumerable(Of AssemblyLoadContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ All { System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : seq&lt;System.Runtime.Loader.AssemblyLoadContext&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个包含所有 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 实例的集合。</summary>
        <value>所有的集合<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />实例。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; Assemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; Assemblies" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assemblies As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ Assemblies { System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : seq&lt;System.Reflection.Assembly&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个集合，它包含在 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 中加载的 <see cref="T:System.Reflection.Assembly" /> 实例。</summary>
        <value>一系列<see cref="T:System.Reflection.Assembly" />中加载实例<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentContextualReflectionContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContextualReflectionContext As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ CurrentContextualReflectionContext { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContextualReflectionContext : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由最近调用 <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" /> 而设置的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</summary>
        <value><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />到最新的调用设置<see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />。 此值可为 <see langword="null" />。 值存储在<see cref="T:System.Threading.AsyncLocal`1" />，因此，值是唯一的每个异步上下文。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
有关详细信息，请参阅[AssemblyLoadContext.CurrentContextualReflectionContext.NET Core 中的设计文档](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取默认的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。 默认上下文包含主应用程序程序集及其静态依赖项。</summary>
        <value>默认程序集加载上下文。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />
      <MemberSignature Language="VB.NET" Value="Public Function EnterContextualReflection () As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection();" />
      <MemberSignature Language="F#" Value="member this.EnterContextualReflection : unit -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="assemblyLoadContext.EnterContextualReflection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 设置为 <see langword="this" /><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</summary>
        <returns>一个对象，它用于还原 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 的先前值。 它将作为 <see cref="T:System.IDisposable" /> 在 <see langword="using" /> 块中使用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
有关详细信息，请参阅[AssemblyLoadContext.CurrentContextualReflectionContext.NET Core 中的设计文档](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection (System.Reflection.Assembly activating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection(class System.Reflection.Assembly activating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnterContextualReflection (activating As Assembly) As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection(System::Reflection::Assembly ^ activating);" />
      <MemberSignature Language="F#" Value="static member EnterContextualReflection : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection activating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activating" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activating">用于确定请求的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 实例的程序集。</param>
        <summary>将 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 设置为加载了程序集的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</summary>
        <returns>一个对象，它用于还原 <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" /> 的先前值。 它将作为 <see cref="T:System.IDisposable" /> 在 <see langword="using" /> 块中使用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
有关详细信息，请参阅[AssemblyLoadContext.CurrentContextualReflectionContext.NET Core 中的设计文档](https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md)。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">程序集的路径。</param>
        <summary>获取 <see cref="T:System.Reflection.AssemblyName" /> 的程序集路径。</summary>
        <returns>一个对象，该对象包含 <paramref name="assemblyPath" /> 处的程序集的完全解析的程序集名称。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
        <exception cref="T:System.BadImageFormatException">该程序集不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">程序集。</param>
        <summary>获取包含指定 <see cref="T:System.Reflection.Assembly" /> 的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</summary>
        <returns>包含 <paramref name="assembly" /> 的程序集加载上下文。 如果在运行时未提供 <paramref name="assembly" />，此方法会返回 NULL。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 是否可回收。</summary>
        <value><see langword="true" /> 如果此<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />可回收; 否则为<see langword="false" />。 如果未在构造函数中指定一个值，该值是<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
有关详细信息，请参阅[如何使用和调试.NET Core 中的程序集 unloadability](~/docs/standard/assembly/unloadability-howto.md)。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">描述要加载的程序集的对象。</param>
        <summary>当在派生类中重写时，允许根据其 <see cref="T:System.Reflection.AssemblyName" /> 解析和加载程序集。</summary>
        <returns>已加载程序集或为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 在程序集解析期间<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>方法具有程序集名称解析为加载的程序集的第一次机会。 它可以加载程序集，也可以返回`null`。 如果它返回`null`，解析过程将继续。 请参阅<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>为完整的过程的描述。
 
 > [!IMPORTANT]
 > 若要防止递归堆栈溢出，不要调用此实例的<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>从此方法的方法。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">描述要加载的程序集的对象。</param>
        <summary>根据 <see cref="T:System.Reflection.AssemblyName" /> 解析并加载程序集。</summary>
        <returns>已加载程序集或引发事件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> 加载程序集通过解决<xref:System.Reflection.AssemblyName>。 这会触发完整的解决方法。 解析回退序列执行此过程：

1. 方法调用<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>。

   > [!IMPORTANT]
   > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> 必须调用此方法，以防止递归堆栈溢出。

2. 除非加载程序集或引发异常，该方法会尝试加载程序集在默认<xref:System.Runtime.Loader.AssemblyLoadContext>。
3. 除非加载程序集或引发异常，该方法将触发<xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>事件。
4. 除非加载程序集或引发异常，该方法将触发<xref:System.AppDomain.AssemblyResolve>事件。
 
> [!NOTE]
> <xref:System.IO.FileLoadException> 如果引发`assemblyRef`指定完整的程序集名称和匹配的简单名称的第一个程序集具有不兼容的版本或区域性。 加载程序不会继续探测的其他程序集的简单名称相匹配。
 
每个<xref:System.Runtime.Loader.AssemblyLoadContext>可以仅加载：
 
* 可执行程序集的一个版本。
* 每个区域性的附属程序集的一个版本。
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">加载了与 <paramref name="assemblyName" /> 不匹配的程序集或模块。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">要加载的文件的完全限定路径。</param>
        <summary>加载指定路径上的程序集文件的内容。</summary>
        <returns>加载的程序集。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyPath" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyPath" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyPath" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath">要加载的文件的完全限定路径。</param>
        <param name="assemblyPath">要加载的文件的 IL 版本的完全限定路径，或为 <see langword="null" />。</param>
        <summary>在指定路径上加载托管程序集文件的本机映像的内容。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 托管程序集的本机映像是预实时编译以优化特定平台上运行。
 
 程序集路径指向的 IL 版本的程序集的路径。 因为 IL 通常包含在本机映像，它是一个可选参数。 它可由运行时作为回退如果找不到本机映像。
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nativeImagePath" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyPath" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="nativeImagePath" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="nativeImagePath" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">字节数组，它是包含托管程序集的基于 COFF 的映像。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含托管程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">字节数组，它是包含托管程序集的基于 COFF 的映像。</param>
        <param name="assemblySymbols">包含表示程序集符号的原始字节的字节数组。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含托管程序集，并且还可以选择包括程序集的符号。</summary>
        <returns>加载的程序集。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName">非托管库的名称。 这通常是不带路径或扩展名的文件名。</param>
        <summary>允许派生的类按名称加载非托管库。</summary>
        <returns>已加载库的句柄或为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认实现始终返回`null`。 当`null`返回，则在运行时加载的库使用其默认策略。
 
 可以重写此虚拟方法，以自定义的非托管的库搜索算法。 在重写时可以使用名称来标识库。 已加载的库不需要匹配所请求名称，但可以根据需要转换。 这可能包括调整平台特定命名的名称。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath">非托管库的路径。</param>
        <summary>从指定路径加载非托管库。</summary>
        <returns>已加载库的句柄。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="unmanagedDllPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unmanagedDllPath" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到非托管库。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的名称。</summary>
        <value><see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的名称。 其值可为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在尝试加载到此程序集加载上下文时，程序集解析失败时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要返回的程序集的指定，或返回此事件的处理程序负责`null`如果无法识别该程序集。
 
 > [!IMPORTANT]
 >  如果此事件注册了多个事件处理程序，直到事件处理程序返回值不是按顺序调用事件处理程序`null`。 后续的事件处理程序将被忽略。
 
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。
 
 它是值得注意的内容是否可以对任何此事件添加处理程序<xref:System.Runtime.Loader.AssemblyLoadContext>，包括默认上下文。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在解析本机库失败时发生。</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

如果本机库无法解析由默认的解析逻辑将引发此事件 (包括<xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll%2A>)。

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始卸载此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ 如果它是可回收 AssemblyLoadContext 只能是卸载。
+ 卸载将以异步方式发生。
+ 卸载不会发生时对 AssemblyLoadContext 的引用。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">不允许卸载。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>卸载 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>