<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11d1dcdc13c51bdaa8cc20ca875fe44319edf7da" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64192416" /></Metadata><TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含支持导航的各种方法、属性和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 封装下载内容的浏览器样式导航上下文中的功能。  
  
 内容可以是任何类型的.NET Framework 对象和 HTML 文件。 一般情况下，但是，页是首选作为导航的包内容的方式 (请参阅<xref:System.Windows.Controls.Page>)。  
  
 通过提供对象的实例并调用重载的情况下，内容可以导航到<xref:System.Windows.Navigation.NavigationService.Navigate%2A>接受对象的方法：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 或者，可以将导航到内容通过将相对或绝对 URI 传递给之一<xref:System.Windows.Navigation.NavigationService.Navigate%2A>接受 URI 的方法重载：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 URI，通过导航到内容<xref:System.Windows.Navigation.NavigationService>将返回包含内容的对象。  
  
 导航的生存期可以通过以下事件跟踪：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>。  
  
 并非所有事件都发生导航; 每次都引发（已取消、 已停止或失败），将由导航时发生 （内容或内容片段） 和如何完成导航的类型确定引发的事件集。  
  
 下图说明了会引发这些事件的序列：  
  
 ![页面导航流程图](~/add/media/navigationoverviewfigure11.png "页面导航流程图")  
  
 期间或之后导航栏中，<xref:System.Windows.Navigation.NavigationService>提供，其中包括要导航到的内容的 URI 导航目标的内容有关的信息 (<xref:System.Windows.Navigation.NavigationService.Source%2A>)，当前内容的 URI (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>)，并包含的对象导航到的内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>)。  
  
 当内容导航到，<xref:System.Windows.Navigation.NavigationService>导航历史记录中记录一个条目作为导航。 新导航时，通过调用后退导航历史记录中添加一个条目<xref:System.Windows.Navigation.NavigationService.Navigate%2A>方法，或通过调用导航到前进导航历史记录中的条目<xref:System.Windows.Navigation.NavigationService.GoForward%2A>。 通过导航到一个条目后退导航历史记录，通过调用将条目添加到前进导航历史记录<xref:System.Windows.Navigation.NavigationService.GoBack%2A>。 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 和<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>报告是否存在条目后退和前进导航历史记录，分别。 此外，最新的条目后退导航历史记录可以通过调用删除<xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>。  
  
 默认情况下，<xref:System.Windows.Navigation.NavigationService>不导航历史记录中存储内容的对象的实例。 相反，<xref:System.Windows.Navigation.NavigationService>创建每次使用导航历史记录导航到的内容对象的新实例。 此行为旨在避免占用过多内存时要导航到较大数字和大段内容。 因此，内容的状态并不会保留从一个导航到下一步。 但是，WPF 提供了几种方法，使您可以导航历史记录中存储的一条内容为一段的状态。  
  
 使用<xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>，您还可以保留多个集的单个页面实例的状态。  
  
 <xref:System.Windows.Navigation.NavigationService> 是`sealed`类，因此不能被实例化; 相反，<xref:System.Windows.Navigation.NavigationService>导航器用于启用导航。 在 WPF 中，有两个导航器：<xref:System.Windows.Navigation.NavigationWindow>和<xref:System.Windows.Controls.Frame>。  
  
 直观地[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]使用[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]作为导航器，以提供集成的用户体验。 以物理方式，但[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]实际使用<xref:System.Windows.Navigation.NavigationWindow>像导航;<xref:System.Windows.Application.MainWindow%2A>属性[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]中运行[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]将返回到引用<xref:System.Windows.Navigation.NavigationWindow>，并由导航历史记录<xref:System.Windows.Navigation.NavigationWindow>与导航历史记录管理的集成[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]以下方面：  
  
-   当导航到内容后通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>， <xref:System.Windows.Navigation.NavigationService.GoBack%2A>，并<xref:System.Windows.Navigation.NavigationService.GoForward%2A>内[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]相关的导航历史记录条目也会添加到[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导航历史记录。  
  
-   时中的条目[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]所选[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导致<xref:System.Windows.Navigation.NavigationService>以后或向前导航到与这些条目相关联的内容。  
  
> [!NOTE]
>  一个<xref:System.Windows.Controls.Frame>可以提供自己的导航历史记录，或使用承载它的导航器的导航历史记录。 如果<xref:System.Windows.Controls.Frame>提供了自己的导航历史记录，它可以显示自己的导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]导航历史记录; 中的条目中导航这些条目不会添加到主机导航器的导航历史记录 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>， [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)])，因此，无法导航到从导航栏[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]每个 (请参阅<xref:System.Windows.Controls.Frame.JournalOwnership%2A>)。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象，该对象表示与特定内容片段关联的应用程序定义的状态。</param>
        <summary>向包含 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象的后退导航历史记录中添加一个条目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A><xref:System.Windows.Navigation.CustomContentState>，和<xref:System.Windows.Navigation.IProvideCustomContentState>可用来帮助记住多个集的当前内容的状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="state" /> 为 <see langword="null" />，并且 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象不是从 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> 返回的对象。</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示后退导航历史记录中是否至少有一个条目。</summary>
        <value>如果后退导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 若要确定后退导航历史记录中是否存在至少一个条目。 此属性应检查，然后再调<xref:System.Windows.Navigation.NavigationService.GoBack%2A>; 如果<xref:System.Windows.Navigation.NavigationService.GoBack%2A>称为和后退导航历史记录中没有任何条目<xref:System.InvalidOperationException>引发。  
  
> [!NOTE]
>  如果导航历史记录共享的多个导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)、 最新的条目后退导航历史记录可能不具有已添加的<xref:System.Windows.Navigation.NavigationService>为当前导航器。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示前进导航历史记录中是否至少有一个条目。</summary>
        <value>如果前进导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 若要确定前进导航历史记录中是否存在至少一个条目。 此属性应检查，然后再调<xref:System.Windows.Navigation.NavigationService.GoForward%2A>; 如果<xref:System.Windows.Navigation.NavigationService.GoForward%2A>称为和前进导航历史记录中没有任何条目<xref:System.InvalidOperationException>引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含当前内容的对象的引用。</summary>
        <value>一个对象，它是对包含当前内容的对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内容可以设置两种方法之一：  
  
-   直接使用，方式将其设置为对对象的引用。  
  
-   通过调用间接<xref:System.Windows.Navigation.NavigationService.Navigate%2A>， <xref:System.Windows.Navigation.NavigationService.GoBack%2A>，或<xref:System.Windows.Navigation.NavigationService.GoForward%2A>。  
  
 设置<xref:System.Windows.Navigation.NavigationService>由于导航是异步的因此启动一个新的导航;<xref:System.Windows.Navigation.NavigationService.Content%2A>不会返回一个值，如果在设置之后立即检查。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次导航到的内容的 URI。</summary>
        <value>一个<see cref="T:System.Uri" />内容的上次导航到，如果导航到使用 URI; 否则为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>之前已成功完成到不同的 URI 的导航属性不会更改。  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 可以使用仅限片段的 URI 设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当开始导航到某个内容片段时发生，如果所需片段位于当前内容中，它会立即发生；或者，如果所需片段位于不同内容中，它会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，内容片段是内容，它是所包含的命名<xref:System.Windows.UIElement>，即<xref:System.Windows.UIElement>其<xref:System.Windows.FrameworkElement.Name%2A>设置属性，例如：  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 导航到[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]通过采用以下格式为后缀提供 URI 的片段：  
  
 \#*FragmentName*  
  
 下面显示了一个 URI，引用内容片段的示例：  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 在源页面加载后 (后<xref:System.Windows.Navigation.NavigationService.LoadCompleted>引发事件)，片段导航开始并<xref:System.Windows.Navigation.NavigationService>尝试定位[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]片段。 如果[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]找到片段，则<xref:System.Windows.Navigation.NavigationService>指示内容导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 以显示该片段。 如果需要更改此行为，则可以处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>提供您自己的片段导航行为。 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 传递<xref:System.Windows.Navigation.FragmentNavigationEventArgs>参数公开为此，有用的属性包括：  
  
-   拥有此导航服务的导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   片段名称。  
  
 您可以处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>重写默认 WPF 片段实现与自定义实现。 如果这样做，需要设置<xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A>到`true`; 否则为为应用处理行为的默认 WPF 片段。  
  
 应避免直接初始化中的导航<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>事件处理程序。 由于<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>在现有的导航，启动从新的导航过程中引发<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>事件处理程序将创建嵌套的导航，这可能会导致<xref:System.ExecutionEngineException>引发。 相反，可以间接启动导航通过创建一个异步工作项使用<xref:System.Windows.Threading.Dispatcher>。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>，它还会发出<xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
> [!IMPORTANT]
>  片段导航不支持对松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页 (仅标记[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]文件的工具`Page`作为根元素) 在以下情况下：  
>   
>  • 导航到松散中的片段时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页。  
>   
>  • 时导航从一个松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页中另一个松散的片段[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页。  
>   
>  但是，松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页可以导航到自己的片段。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>以提供自定义的片段导航行为。 在这种情况下，该示例打开出错[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]页上，如果源中的片段[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]找不到页面。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">由导航器承载的内容中的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>获取对导航器的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用，该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>对导航器（该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />）的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用在某些情况下可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器具有<xref:System.Windows.Navigation.NavigationService>处理内容导航。 WPF 具有两个导航器：<xref:System.Windows.Navigation.NavigationWindow>和<xref:System.Windows.Controls.Frame>。 若要处理导航请求和管理导航生存期，导航器将使用 WPF 导航服务，它将作为实现<xref:System.Windows.Navigation.NavigationService>类。 通过导航器承载的内容可以获取对导航器的引用<xref:System.Windows.Navigation.NavigationService>通过调用<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>方法。  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 返回`null`时`dependencyObject`:  
  
-   是<xref:System.Windows.Navigation.NavigationWindow>。  
  
-   是<xref:System.Windows.Controls.Frame>的：  
  
    1.  由另一个导航器承载。  
  
    2.  具有其<xref:System.Windows.Controls.Frame.JournalOwnership%2A>属性设置为<xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>。  
  
-   不是内容的由导航器承载的一部分。  
  
 WPF 提供了两个快捷方式来获取对引用<xref:System.Windows.Navigation.NavigationService>:  
  
-   <xref:System.Windows.Navigation.NavigationService>处理到导航<xref:System.Windows.Controls.Page>可以从访问<xref:System.Windows.Controls.Page>本身通过获取的值及其<xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType>属性。  
  
-   <xref:System.Windows.Navigation.NavigationService>所使用的<xref:System.Windows.Controls.Frame>来处理导航可以访问通过获取的值<xref:System.Windows.Controls.Frame.NavigationService%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Windows.Controls.UserControl>可以通过调用检索导航服务<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>。  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到后退导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然后再调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>，则<xref:System.Windows.Navigation.NavigationService.CanGoBack%2A>属性进行检查，以确定后退导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到最新条目后退导航历史记录，如果存在。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> 时后退导航历史记录中没有条目。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到前进导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然后再调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>，则<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>属性进行检查，以确定前进导航历史记录中是否存在条目。  
  
   
  
## Examples  
 如果存在，下面的示例导航到前进导航历史记录中的最新条目。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果前进导航历史记录中没有任何条目，则调用 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当已加载、分析并开始呈现目标导航内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>如果你需要了解有关在加载完成后将导航请求的信息。 此信息位于<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.LoadCompleted>事件处理程序，并包括：  
  
-   内容和它的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 无法找到或加载在这种情况下，源页时则不会引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.LoadCompleted>，它还会发出<xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步导航到指定的源内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <summary>异步导航到某个对象中包含的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到<xref:System.Object>指定的`root`如果满足以下条件：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件不会被取消。  
  
-   Web 请求 (请参阅<xref:System.Windows.Navigation.NavigationService.Navigating>) 可以创建。  
  
 如果`root`是`null`，现有内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 被清除。  
  
> [!NOTE]
>  当下载 Web 内容时，可能会收到 Web 异常 (例如，404:找不到文件）。 你可以处理此类异常从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>对象，其中包含源内容树。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <summary>异步导航到由 URI 指定的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`source`可以是一个[!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]或有效的包 URI (请参阅[WPF 中的 Pack Uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md))。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到指定的 URI`source`如果满足以下条件：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件不会被取消。  
  
-   Web 请求 (请参阅<xref:System.Windows.Navigation.NavigationService.Navigating>) 可以创建。  
  
 如果`source`是`null`，现有内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 被清除。  
  
> [!NOTE]
>  当下载 Web 内容时，可能会收到 Web 异常 (例如，404:找不到文件）。 你可以处理此类异常从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 可以使用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>以导航到内容片段。 如果由 URI 标识的内容为当前内容，它不再次下载。  
  
   
  
## Examples  
 下面的示例演示如何导航到的 URI。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航某个对象包含的内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有相同的行为<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>，尽管对象传递而不是一个 URI。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>对象包含的源内容，并传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航到位于某个 URI 中的源内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于导航是异步的就可以进行多个导航正在进行的一次。 例如，如果在单个页面上有两个子框架，可以浏览这两个框架。 在此情况下，引发的各种导航事件<xref:System.Windows.Navigation.NavigationService>可能会引发多个时间，一个用于每段内容要导航到，而不一定代表以便导航请求。 因此，如果某个特定导航请求需要处理特定于单个请求的数据，它不能使用适用于所有导航请求的数据。 相反，可以使用`navigationState`要处理的导航是特定于一个导航请求传递数据。  
  
 以下事件自变量提供对导航状态的访问：  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (传递给<xref:System.Windows.Navigation.NavigationService.Navigating>事件)。  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (传递给<xref:System.Windows.Navigation.NavigationService.Navigated>， <xref:System.Windows.Navigation.NavigationService.NavigationStopped>，<xref:System.Windows.Navigation.NavigationService.LoadCompleted>事件处理程序)。  
  
   
  
## Examples  
 下面的示例演示如何导航到的 URI，并传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <param name="sandboxExternalContent">将内容下载到部分信任的安全沙盒中（如果为 <see langword="true" />，则具有默认的 Internet 区域权限集）。 默认值为 <see langword="false" />。</param>
        <summary>异步导航到位于某个 URI 中的源内容，传递一个对象（其中包含在导航过程中进行处理的导航状态），并沙盒处理内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于独立应用程序和[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]内容。  
  
 此方法能够提供相同的行为<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>，并将其扩展通过确保正在下载的内容置于一个部分信任安全沙盒 (具有默认 Internet 区域集的权限-请参阅[WPF 部分信任安全](~/docs/framework/wpf/wpf-partial-trust-security.md))。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>找到导航的目标内容且可通过 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 属性得到这些内容时发生，即使尚未加载完毕也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您处理<xref:System.Windows.Navigation.NavigationService.Navigated>如果您需要下载开始时发现导航请求有关的信息。 此信息位于<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.Navigated>事件处理程序，并包括：  
  
-   源页中。 当<xref:System.Windows.Navigation.NavigationService.Navigated>引发，则至少属于源页面的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]树已分析，并附加到目标内容控件。  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> 无法找到或加载在这种情况下，源页时则不会引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>，它还会发出<xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigated>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 当请求一个新导航时发生，但在源之前请求内容，包括何时引发：  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 或<xref:System.Windows.Navigation.NavigationService.GoForward%2A>称为 (或从导航栏中选择一个条目[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)])。  
  
-   内容片段导航到。  
  
 您处理<xref:System.Windows.Navigation.NavigationService.Navigating>如果你需要了解有关在导航开始前导航请求的信息。 此信息位于<xref:System.Windows.Navigation.NavigatingCancelEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.Navigating>事件处理程序。  
  
 一个<xref:System.Net.WebRequest>对象的导航已创建，并从可用<xref:System.Windows.Navigation.NavigatingCancelEventArgs>参数，则实际请求未在这里进行，因为你可以重新配置<xref:System.Net.WebRequest>对象，如有必要。  
  
 你还处理<xref:System.Windows.Navigation.NavigatingCancelEventArgs>取消导航栏中，如果需要，通过设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>为 true。 如果取消导航，则会不引发任何其他导航事件。  
  
> [!NOTE]
>  如果你的应用程序托管在浏览器中，您不能离开你的应用程序通过取消阻止用户<xref:System.Windows.Navigation.NavigationService.Navigating>事件。  
  
 通过导航器导航到内容的第一条后 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)，每个段导航离开的内容添加到导航历史记录。 如果需要保存在导航离开的内容有关的状态信息，您可以将状态添加到该内容的日记条目通过设置<xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A>与<xref:System.Windows.Navigation.CustomContentState>对象。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.Navigating>，它还会发出<xref:System.Windows.Application.Navigating?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigating>以检测是否发出请求以刷新静态内容，如果是这样，若要取消请求。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在导航到所请求内容出错时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当要么<xref:System.Net.WebException>或<xref:System.IO.IOException>导航期间引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发事件。 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 传递<xref:System.Windows.Navigation.NavigationFailedEventArgs>封装有关异常和导致异常的导航的详细信息的信息。  
  
 时异常结果因导航失败，并且未经处理，按所列顺序引发以下事件：  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 如果导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 由一个或多个导航器承载`NavigationFailed`其中任何一个不引发。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在下载过程中定期发生，用于提供定位进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 传递<xref:System.Windows.Navigation.NavigationProgressEventArgs>公开以下进度信息：  
  
-   到目前为止下载的字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>)。  
  
-   若要下载的总字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>)。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 引发的每个 1024 个字节的内容下载之后，并一次的剩余字节数是否过小于 1024 个字节。 出于此原因，处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>提供有用的方式来跟踪和显示当前下载的进度。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 将不会引发在某些情况下，例如当相同内容的片段导航到，或当内容片段导航到当前加载的内容 (即，值<xref:System.Windows.Navigation.NavigationService.Content%2A>属性)。  
  
 导航到已编译的 XAML 资源最终时<xref:System.Windows.Navigation.NavigationService.NavigationProgress>可能不会引发事件。 这意味着，在下载结束时，最后一个报告<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>值可能不等于<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>值。 处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>导航已完成时要通知的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.NavigationProgress>，它还会发出<xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 方法时发生，或者在当前导航正处于进行过程中时又请求一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您处理<xref:System.Windows.Navigation.NavigationService.NavigationStopped>如果您需要下载停止时发现导航请求有关的信息。 此信息位于<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.NavigationStopped>事件处理程序，并包括：  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>将引发<xref:System.Windows.Navigation.NavigationService.NavigationStopped>，它还会发出<xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationStopped>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前的内容 (指定的值<xref:System.Windows.Navigation.NavigationService.Source%2A>属性) 再次，导航到<xref:System.Windows.Navigation.NavigationService>不会下载内容。 若要强制<xref:System.Windows.Navigation.NavigationService>若要重新导航到内容，请调用<xref:System.Windows.Navigation.NavigationService.Refresh%2A>。  
  
 请注意，如果当前内容导航到同样，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Refresh%2A>，新的条目不会添加到导航历史记录。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除后退历史记录中的最新日记条目。</summary>
        <returns>后退导航历史记录中的最新 <see cref="T:System.Windows.Navigation.JournalEntry" />（如果有）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个或多个导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 共享相同的导航历史记录，可以使用一个导航器<xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>检索发生在另一个导航器中导航的后退导航历史记录条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前内容的 URI，或当前正在导航到的新内容的 URI。</summary>
        <value>一个<see cref="T:System.Uri" />，其中包含当前内容或当前正在导航到的内容 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为不同的 URI 与当前正在显示，导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 导航到指定的 URI。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 除非取消导航，则从 URI 导航到，加载的内容设置。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 可以设置使用仅限片段的 URI，并可以将设置为`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止为当前导航请求下载更多内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 可以调用就立即<xref:System.Windows.Navigation.NavigationService.Navigate%2A>返回，并停止正在子帧中进行导航。  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 调用<xref:System.Windows.Navigation.NavigationService.StopLoading%2A>方法将引发<xref:System.Windows.Navigation.NavigationService.NavigationStopped>事件。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 必须在启动了导航的同一线程上调用。  
  
   
  
## Examples  
 下面的示例演示如何停止加载。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>