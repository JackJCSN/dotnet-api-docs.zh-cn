<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1f84f52231ece11b707a1aa6e4c5c58702947e56" /><Meta Name="ms.sourcegitcommit" Value="6b9d64332f31de312efea785fbb19e4d80f544d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/12/2019" /><Meta Name="ms.locfileid" Value="67027211" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用作 Web 部件控件集的中心类，管理所有的 Web 部件控件、功能和网页上发生的事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件充当中心或控制中心的 Web 部件应用程序。 必须有一个-且只有一个-<xref:System.Web.UI.WebControls.WebParts.WebPartManager>使用 Web 部件控件的每一页上的控件实例。 与 Web 部件应用程序的大多数方面一样<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件仅适用于身份验证的用户。 此外，其功能几乎完全与继承的 Web 部件区域中驻留的服务器控件的工作原理<xref:System.Web.UI.WebControls.WebParts.WebZone>类。 驻留在这些区域之外的页的服务器控件可以具有很少的 Web 部件的功能或与的交互<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 在页上，Web 部件功能的中心作为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可执行的下表中所述的任务类型。  
  
|任务类别|控件的作用|  
|-------------------|---------------------------|  
|跟踪 Web 部件控件|跟踪的页面上提供了 Web 部件功能，包括的控件的许多不同类型<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 连接、 区域和其他人。|  
|添加和删除 Web 部件控件|提供用于添加、 删除和关闭方法<xref:System.Web.UI.WebControls.WebParts.WebPart>页面上的控件。|  
|管理连接|创建控件之间的连接并监视连接，以及添加和删除它们的进程。|  
|个性化设置控件和页面|使用户能够在页上，将控件移动到不同位置，并启动外观、 属性和控件的行为，用户可以编辑的视图。 维护每个页面上的特定于用户的个性化设置。|  
|不同的页面视图之间切换|将页的页上，不同的专用视图之间切换，以便用户可以执行某些任务，例如更改页面布局或编辑控件。|  
|引发 Web 部件生命周期事件|定义，将引发，并使开发人员能够处理的 Web 部件控件，如当控件正在添加、 移动、 已连接，或已删除的生命周期事件。|  
|启用导入和导出的控件|导出包含的属性的状态的 XML 流<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并允许用户导入的文件为方便起见，在个性化其他页面或站点中的复杂控件。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类有大量的属性。 与一致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>跟踪其他控件的角色，它具有多个引用的 Web 部件控件或其他特殊的 Web 部件对象集合的属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>，并且<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性都是由所有集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager>其跟踪和其他控件管理任务。  
  
 属性的另一个组包含可自定义 Web 部件应用程序中发生某些方案中应用的警告。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>，则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类重写一些由很多 Web 服务器控件使用其基继承属性。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。  
  
 最后，没有可用于访问应用程序的当前状态的一组属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性指示的页是中的当前显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性指示是否允许控件呈现客户端脚本，与其中的用户可能具有不同的功能的浏览器或者是否关闭了脚本的情况。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性可用于引用包含对大量重要的可扩展性情况下使用的 Web 部件方法调用的实用工具类。 通过隐藏对一个单独的类中的这些方法的调用 (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类)，则<xref:System.Web.UI.WebControls.WebParts.WebPartManager>简化类自己的 API。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性提供对存储用户的个性化设置和数据保存到永久存储的个性化设置对象的访问。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性指示其<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在页面上的当前选定的用户或应用程序。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性指示是否在自定义个性化设置数据<xref:System.Web.UI.WebControls.WebParts.WebPart>控制已更改。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件包含五个内置的显示模式或网页的视图。 开发人员可以扩展此功能，如扩展类型创建自定义显示模式<xref:System.Web.UI.WebControls.WebParts.WebZone>类或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类。 用户可切换到各种显示模式下，一个页面，前提是适当类型的对应于给定的显示模式的控件存在于页面上。  
  
> [!NOTE]
>  它是可以扩展此功能，以便用户可以切换到自定义显示模式，而无需页上的相应区域。 但是，默认行为是显示模式对应区域。  
  
 标准显示模式都是公共字段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。 下表总结了字段和其引用的显示模式。 当前显示模式的页上，如上所述，始终中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性，并可以在给定类型的区域在页上，存在的特定页面的显示模式集包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
|字段|显示模式的详细信息|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web 页面; 在普通用户视图默认值和最常见的显示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|用户可以重新排列或删除控件，若要更改页面布局视图。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|该视图在其中编辑用户界面 (UI) 变得可见，则用户可以编辑外观、 属性和在正常浏览模式中可见的控件的行为。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|该视图中的目录用户界面变得可见，则用户可以从目录的可用控件，向页面添加控件。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|该视图在其中连接用户界面变得可见，则用户可以连接、 管理或断开连接控件之间的连接。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件也包含在 Web 部件页面和控件的生命周期中，至关重要的事件数。 这些事件提供精确控制以编程方式 Web 部件控件的行为。 大多数方法适用于<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或位于其他服务器或用户控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，以便它们可充当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。 但是，一些事件有关的页或页上的连接状态。 下表列出了可用的事件，并总结了它们的用途。  
  
> [!NOTE]
>  在下表中的所有情况下，"控制"一词是指<xref:System.Web.UI.WebControls.WebParts.WebPart>控件或驻留在一个区域，并且使用封装任何服务器控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在运行时对象。  
  
|事件|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|一个控件添加到页以验证对其进行授权之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|已激活页上的所有连接后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|激活页上的所有连接的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|页的当前显示模式更改之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|更改页面的显示模式的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|已取消所选控件的内容之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|取消选择的控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|一个控件添加到区域之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|将控件添加到区域的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|控件已关闭 （从页中移除） 后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|恰好在关闭一个控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|永久删除动态控件 （一种以编程方式创建或添加从目录中） 的实例后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|删除动态控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控件在其区域内或另一个区域已移动后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|移动控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|选择来参与连接的两个控件已建立连接之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|连接两个控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|已断开连接的两个控件后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|只需在断开连接两个控件的过程之前发生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有许多用于管理 Web 部件页方法。 方法，但此处未列出一大组是其名称采用以下形式的方法*EventName*。 通常引发其关联的事件，这些方法并为事件提供类型的处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>。 继承自开发人员可以重写这些方法中的大多数<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。 此外，页面开发人员可以使用这些方法相关联的事件提供自定义处理程序。 例如，在中的情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件，可以添加页面开发人员`OnWebPartAdded`属性为`<asp:webpartmanager>`Web 页面，然后将分配自定义方法名称添加到该属性以提供自定义事件处理的标记中元素。 属性对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法和事件处理适用于大多数 Web 部件事件和其关联的方法的此基本模式。  
  
 此外，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有方法特定于管理的任务<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (和服务器或用户控件用作<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。 这些方法包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 方法的另一组专用于连接。 这包括方法，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>。  
  
 最后，一些<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法专注于个性化设置功能。 它们包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 有关其他详细信息<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法可通过访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类。  
  
   
  
## Examples  
 下面的代码示例演示如何声明和以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 用户控件具有显示可能的显示模式在页上，给定页上存在的 Web 部件控件的下拉列表控件。 在此代码示例 Web 页中，此用户控件声明正下方<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在页面的标记中，并且没有`Register`指令要注册该控件的 Web 页的顶部附近。 有关详细信息显示在此控件模式和对源代码的说明，请参见[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web 页的声明性标记包含`Register`为用户控件和自定义控件的指令。 没有`<asp:webpartmanager>`元素中，`<asp:webpartzone>`元素以包含自定义控件和一个`<asp:connectionszone>`元素。 此页还包含一些处理与连接相关的事件的内联代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制; 随着连接和断开连接的控件，可以看到此代码的作用。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 请注意，没有名为的接口`IZipCode`，并在中实现此接口`ZipCodeWebPart`类。 此类有一个名为特殊的回调方法`ProvideIZipCode`可用作提供程序。 其他类型，名为`WeatherWebPart`，还使用名为的特殊方法实现`GetIZipCode`，这使得控件可以充当其他控件的使用者。  
  
 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此代码示例假定你具有源代码编译到程序集和`Register`指令在网页中的引用的程序集名称。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面显示后，单击**创建连接到使用者**链接。 单元格将显示具有下拉列表控件。 选择**天气控件**在下拉列表中，然后单击**Connect**来完成两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表，以将页返回到正常浏览模式。 可以输入邮政编码，并将使用你输入的值更新的使用者控件。 因为`ZipCode`属性标记有`Personalizable`属性中的源代码，此属性的值将一直保持跨浏览器会话，从而节省了由用户输入的值。 更复杂的使用者控件无法执行邮政编码信息、 查找天气信息基于代码，以及向用户显示。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件旨在进行扩展。 因为它是，因此必须还扩展到 Web 部件应用程序中，你想要扩展某种特定类型或在 Web 部件控件集，在许多情况下控制中部<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，因为可能有一些属性或使所需的方法 自定义类型的 Web 部件应用程序上下文中工作。 Web 部件，请参阅文档 (请参阅<see cref="N:System.Web.UI.WebControls.WebParts" />)，讨论了如何扩展 Web 部件类型时，经常需要进行扩展的内容的提及<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，或显示了如何扩展中的代码示例。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>构造函数初始化几个重要的变量由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 一个直接影响所有 Web 部件页的分配是默认页面显示模式设置为浏览模式的事实 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活网页上当前所有非活动连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>到页面的每个请求，以激活之间的现有连接上调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>和驻留在其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。 在某些情况下，例如时则会发生冲突的连接被激活，此方法中依次调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法来结束有问题的连接。 断开连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件。 通常，开发人员可以取消此事件，但在这种情况在此方法不能取消的连接之间的冲突，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件需要解决该冲突以完成激活连接的过程。 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要添加至网页或在页上打开的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或服务器或用户控件）。</param>
        <param name="zone">向其添加 <paramref name="webPart" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，表示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中占用的序号位置（相对于 <paramref name="zone" /> 中的其他控件）。</param>
        <summary>提供向网页添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的标准编程方法。</summary>
        <returns>添加到页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>使用方法都要添加新的动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控制到页面，并重新打开以前已关闭的页的静态或动态控件。 若要添加新控件，调用方法，它实际创建一份中引用的控件`webPart`参数。 新的 ID 生成的控件，复制，因此开发人员应参考<xref:System.Web.UI.WebControls.WebParts.WebPart>从要获取新的 ID 值的方法返回控制。 若要重新打开以前关闭的控件，调用方法，它返回对所引用的控件的直接引用`webPart`参数。  
  
> [!IMPORTANT]
>  应始终使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，而不是<xref:System.Web.UI.ControlCollection.Add%2A>方法的引用的控件的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType>属性，以添加<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制到页上，因为使用<xref:System.Web.UI.ControlCollection.Add%2A>方法将引发异常。 若要添加的控件不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (即，将使用换行的服务器控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时)，首先应调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法创建控件，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将添加控件。 此方法的演示，请参阅示例部分。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将服务器控件以编程方式添加到一个页面。 页面标记包含一个空`<asp:webpartzone>`元素，和一个`<asp:webpartmanager>`元素。 第一次**添加日历**单击按钮时，代码在事件处理程序将创建<xref:System.Web.UI.WebControls.Calendar>控件，并将其添加到与区域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
或 
 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> 没有在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的区域集合中注册。  
  
- 或 - 
 <paramref name="webPart" /> 已存在于 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 的值小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当调用 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法以确定 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件是否能够添加到页中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>每当发生事件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页面。 有多种控件此处可添加到页面的常见方案。 有关这些的完整说明，请参阅备注部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。 添加一个控件，其必须进行检查以查看是否其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性未设置，如果是这样，无论该控件是否有权添加到页面。  
  
 开发人员可以创建事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，以提供筛选的控件。 如果控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值不符合事件处理程序代码中的条件，控件不会添加到页面。  
  
   
  
## Examples  
 下面的代码示例演示如何设置的自定义事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，会自动重写默认<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。  
  
 中的代码`mgr1_AuthorizeWebPart`方法检查页上的控件是否具有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性的值设置为`user`，如果是，则返回`true`，这意味着它们将被授权并添加到页面。 这假定的默认方法是允许用户在用户的个性化设置范围中查看与页面的控件。 但请注意，在示例中其中一个控件的具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值设置为`admin`。 开发人员可能会将此筛选器置于专供管理用户只能查看一个专用控件。 此控件期间的授权检查将失败<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，并将不会显示。 请注意还; 显示不具有设置的属性的控件它们被假定不是筛选方案的一部分，因为其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>未设置的属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合，这些对象可用于在服务器控件之间创建 Web 部件连接。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法来创建集合。 默认情况下，它可以从应用程序配置文件读取可用的转换器。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web 部件连接概述</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正为其建立连接的控件。</param>
        <summary>开始连接两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法的存在，因此可以在不同阶段，为开发人员提供更好地控制连接过程完成的构成控件之间的连接过程。 方法不会执行一组初始检查，确保`webPart`处于可以合法地连接的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并可以继续连接过程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
- 或 - 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <block subset="none" type="overrides"><para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能会想要重写此方法在派生类中的。 一种方法是调用基方法，然后添加一些附加的自定义处理;或者，可能想要完全自定义启动控件之间的连接的过程。 例如，你可能想要验证在创建连接之前，某些数据也可用。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要编辑的控件。</param>
        <summary>开始 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的编辑过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法的存在，因此可以在不同阶段，为开发人员提供更好地控制该过程完成编辑控件的过程。 方法不会执行一组初始检查，确保`webPart`处于可编辑的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并可以继续编辑过程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
- 或 - 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 部件控件的页的默认显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象的创建，并通过包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，您可以参考它直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 当用户只需浏览就像在普通网页上时，页面保留在浏览模式。 如果用户想要个性化页面的布局、 控件、 外观或行为，则必须为一个可通过专用的显示模式切换页面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>字段以编程方式。 此代码填充的受支持的显示模式，在这种情况下是浏览和设计的下拉列表。 请注意，在`Page_PreRender`方法中，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>。 如果是这样，`Label1`将是可见的如果不能，`Label1`将被隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 加载浏览器中的页面后，你就在默认情况下浏览模式中。 请注意，该值指示在浏览模式中的页上的标签。 使用下拉列表控件切换到设计模式下的页面。 请注意，上述代码`Page_PreRender`方法，该标签现在处于隐藏状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定它们是否能够被连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法用于确定两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以连接。 该方法通常用作之前调用的条件检查<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法检查的两个控件可以形成连接之前必须满足的条件数。 以下列表总结了用于建立连接的主要条件。 如果满足这些条件 （再加上一些额外的内部条件），该方法返回`true`，这意味着这些控件可以连接：  
  
-   提供程序和使用者控件不能`null`，并且它们必须由所引用的控件集合中包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
-   提供程序和使用者不能为同一个控件。 换而言之<xref:System.Web.UI.WebControls.WebParts.WebPart>控件无法连接到其自身。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>对象 （连接点） 提供程序和使用者不能为`null`。  
  
-   无法关闭提供程序和使用者 (两个控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>属性可以是`true`)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>连接点控件的属性必须与使用者和提供程序的控件的类型匹配。  
  
-   连接点必须同时启用 (其<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>方法必须返回`true`)。  
  
-   每个连接点必须尝试形成所指定在其自己的更多连接<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>属性。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>，则需要连接不兼容的控件对象 （转换器），它不能为`null`。 但是，如果控件已兼容，则转换器必须为`null`。  
  
-   转换器 （如果使用） 必须在中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>集合。  
  
-   转换器 （如果使用） 必须具有接口，以便它可以将两个控件之间的数据转换的提供程序和使用者与兼容的。 使用者和提供程序的辅助接口还必须兼容。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">使 <paramref name="provider" /> 能够参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <summary>当使用者和提供者控件有兼容接口且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象时，请检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控件，以确定它们是否能够被连接。</summary>
        <returns>一个布尔值，指示是否能连接 <paramref name="provider" /> 和 <paramref name="consumer" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于连接`provider`并`consumer`时这两个控件具有兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象，则不需要。 您可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。  
  
 此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法的重载，唯一的例外是，此重载不需要转换器。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件`<asp:webpartmanager>`元素，并创建一个连接使用一些事件处理代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 页的声明性标记包含`Register`为用户控件和自定义控件的指令。 没有`<asp:webpartmanager>`元素中，`<asp:webpartzone>`元素以包含自定义控件和一个`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法中，代码检查是否连接可为和，是否是这样，定义一个提供程序、 使用者，以及它们各自的连接点，然后将新的连接添加到组的静态连接引用由<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 它包含接口和两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 一个充当一个提供程序，另一个用作使用者。 因为它们具有兼容的连接点 (这两个文件识别`IZipCode`接口)，转换器不需要进行连接。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 出现后，请注意是否已创建一个连接中包含的代码通过`Page_Load`方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="provider" /> 可以参与连接。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它使不兼容的 <paramref name="provider" /> 和 <paramref name="consumer" /> 能够进行连接。</param>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定这些控件是否能够连接，并使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在不兼容的使用者和提供者之间创建连接。</summary>
        <returns>一个布尔值，它指示 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以形成连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于连接`provider`并`consumer`时这两个控件具有不兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象是必需的。 您可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。  
  
 此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法的重载，唯一的例外是此重载需要使用转换器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于从控件目录向网页添加服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象的创建，并通过包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，您可以参考它直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 当用户想要将控件添加到页中，如果服务器控件的目录可用时，则可以切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>（目录模式下），并显示目录用户界面 (UI)。 Web 部件目录的 UI 提供的<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>区域控件。 开发人员在设计时，将此区域添加到页，然后将服务器控件添加到区域，以便用户能够在运行时将这些控件添加到其页面。 开发人员已添加这些控件后，目录模式变得在页上的受支持的显示模式，因为所需的控件有启用目录模式。  
  
 当用户切换目录模式、 区域和已添加到变得可见，它的所有服务器控件的页面和用户可以选择目录将添加到页上，或从页中移除控件中的控件。 控件已添加到页面后，它们出现在正常浏览模式并更新页面。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览、 设计和目录的受支持的显示模式的下拉列表。 目录模式是由于可用`<asp:CatalogZone>`元素，并在 Web 页面及其子元素。 请注意，在`Page_PreRender`方法中，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>。 如果是这样，`Label1`将是可见的如果不能，`Label1`将被隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 加载浏览器中的页面后，你就在默认情况下浏览模式中。 请注意页面上的标签处于隐藏状态。 使用下拉列表控件以切换到目录模式的页面。 请注意，上述代码`Page_PreRender`方法中，标签现已显示。 可以在目录中选择的控件，并将其添加到页面上的两个区域之一。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查发出请求的浏览器的功能，并检查 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 属性的值，以确定是否呈现客户端脚本。</summary>
        <returns>一个布尔值，指示是否呈现客户端脚本。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个警告，用户关闭在连接中充当其他控件的提供者的控件时，会显示该警告。</summary>
        <value>一个包含警告消息的字符串。 默认值是一条由 .NET Framework 提供的、特定于区域性的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常情况下不显示任何消息。 这意味着若要关闭一个控件的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法。  
  
 但是，当控件连接到另一个控件，并充当其他控件的数据提供程序，用户尝试关闭该控件时，将显示默认警告消息。 该消息会通知用户，提供者控件即将关闭，这意味着，用于控制连接到此提供程序，如使用者将不再有任何要使用的数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性使开发人员能够自定义向用户显示的警告消息。  
  
 当用户关闭时，如果页面开发人员将为空或 null 字符串值分配给此属性，将显示任何警告消息框<xref:System.Web.UI.WebControls.WebParts.WebPart>是一个提供程序的控制。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性以向用户显示自定义警告。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   在浏览器中的示例工作原理的说明。  
  
 下面的代码包含示例的 Web 页部分。 您还需要自定义用户控件和上面提到的自定义控件的源代码。 从示例部分获取这两项<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 以下网页代码演示了如何将分配到自定义警告消息<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性中的声明性标记中`<asp:webpartmanager>`元素。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 出现后，单击**创建连接到使用者**链接。 单元格将显示具有下拉列表控件。 选择**天气控件**在下拉列表中，单击**Connect**来完成两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表，以将页返回到正常浏览模式。 最后，单击的谓词菜单**邮政编码**控件 （这是提供者控件在这种情况下），然后选择**关闭**。 自定义消息分配给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>显示属性。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中关闭的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件。</param>
        <summary>以不在网页上呈现，但可以重新打开的方式关闭 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法移除<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件，以使其不呈现在最初包含该网页上。 已关闭的控件添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，该维护对已关闭的控件的引用，并使控件还原到的页对象。 已关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件仍显示在所引用的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
 关闭一个控件是不同于删除它。 已关闭的控件仍可用于将还原到一个页面，但已删除的控件实例永久删除，而且永远不会还原。 无论是否<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件 （在页面的标记中声明） 的静态或动态 （添加到页面以编程方式或通过用户从 Web 部件目录），它可以关闭并重新打开上一个页面。  
  
 通常情况下，用户可以关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>通过单击其谓词菜单并选择关闭谓词的控件。 也可以通过直接调用关闭控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法并将其传递到引用`webPart`。  
  
 在页面上其中<xref:System.Web.UI.WebControls.WebParts.WebPart>控件都已关闭，如果开发人员声明`<asp:catalogzone>`元素，并在其中添加`<asp:pagecatalogpart>`元素，它提供了适合用户已关闭的控件还原到页上，在运行时的简单的用户界面 (UI)。 用户可以将页切换到目录显示模式，并已关闭的控件将显示在页目录中。 用户可以选择已关闭的控件并将它们添加回页面的任何位置力度，和所选的控件然后还原到页并按正常方式呈现。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法调用时，它会发出多个事件： <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> （如果有多个控件），和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>（如果有连接的控件）。 通常情况下开发人员可以取消这些事件，但在某些情况下它不能取消它们。 有关详细信息，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改页的显示模式。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此示例使用动态编译的方法;因此没有任何`Assembly`属性中`Register`指令针对此控件在网页的顶部。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 代码示例的第三部分是 Web 页。 该页面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域中，使用`<asp:pagecatalogpart>`其中声明的元素。 这是将包含哪些内容的已关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件并使用户能够将其添加回页面。 `Button1_Click`方法直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法关闭自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，但用户还可以关闭通过谓词菜单的控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 加载浏览器中的页面后，关闭自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>通过单击该控件的标头中的谓词菜单 （箭头符号），然后单击控件**关闭**。 现在将页面更改为目录模式下通过选择**目录**中**显示模式**下拉列表控件。 页目录中将显示与已关闭的控件。 选择已关闭的控件旁边的复选框，单击**外**以将其添加到页上，然后单击**关闭**返回页后，可以浏览模式。 控件还原到页。 现在关闭，这次通过单击**关闭 web 部件**按钮。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
- 或 - 
 <paramref name="webPart" /> 是共享控件，并已被另一个用户关闭。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于显示特殊用户界面 (UI) 以便用户管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象的创建，并通过包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，您可以参考它直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 当用户想要管理之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在网页上，如果<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>区域已声明的页上，则可以切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。 连接显示模式显示特殊用户界面管理连接，其中包括能够连接或断开连接的控件，并编辑现有连接的详细信息。  
  
 如果你想要向用户提供的功能使用由 Web 部件控件集提供的用户界面中管理连接，您必须声明`<asp:connectionszone>`中页的标记元素。 与其他类型的元素不同<xref:System.Web.UI.WebControls.WebParts.WebZone>区域，不需要添加此元素中的任何其他标记; 您只需将元素声明本身。  
  
   
  
## Examples  
 下面的代码示例演示的使用情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
 代码示例包含三个部分：  
  
-   包含接口和自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>可以形成连接的控件。  
  
-   一个网页，提供连接用户界面，并演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
-   如何运行该示例的说明。  
  
 代码示例的第一个部分是包含接口和两个自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>的设计使它们可以连接的控件。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此代码示例使用动态编译的方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 该示例的第二部分是托管的自定义控件的网页。 在服务器内`<script>`页上的标记是可在页面的显示模式下拉列表中填充的几种方法。 用户可以选择这些从下拉列表中，若要更改页面的显示模式。 可用的显示模式之一是连接显示模式，因为`<asp:connectionszone>`元素声明中页面的标记。 请注意，此元素不包含任何其他子元素;它存在只是为了启用用户的连接管理 UI。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式下将显示在此示例中的两个位置中。 首先，在`Page_Init`方法中，连接显示模式添加到下拉列表的显示模式，为该代码循环访问集合中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 第二个，`Page_PreRender`方法检查当前的显示模式下的页上，以及当前模式是否<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>，在显示一条消息<xref:System.Web.UI.WebControls.Label>控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 加载浏览器中的页面后，单击下拉列表并选择**Connect**页切换到连接显示模式。 请注意，将显示一条消息，告诉你在页处于连接显示模式。 现在，单击 （箭头符号） 的谓词菜单中的其中一个的标题栏<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击**Connect**的谓词菜单中。 连接后将显示用户界面中，单击链接以创建连接。 使用连接用户界面中显示的下拉列表，请选择另一个控件，将参与连接，然后单击**Connect**按钮。 建立连接。 单击**关闭**按钮，，然后使用在页面顶部的下拉列表以返回页后，可以浏览显示模式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有当前连接的集合的引用。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性提供了一种方法来访问当前的页上的连接集。 集合本身是只读的并且想要处理集合中的特定连接开发人员应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>等方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何声明和以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 下面的代码包含示例的 Web 页部分。 您还需要自定义用户控件和上面提到的自定义控件的源代码。 从示例部分获取这两项<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 以下网页代码演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性以编程方式在页面上获取当前连接数。 请注意，在`<script>`标记部分、 代码来处理两个事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性以获取该计数。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 中显示后，单击**创建连接到使用者**链接。 单元格将显示具有下拉列表控件。 选择**天气控件**在下拉列表中，单击**Connect**来完成两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表，以将页返回到正常浏览模式。 请注意，一个标签现在显示的连接数和数<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 如果现在返回连接模式和断开两个控件，则在返回到浏览模式下，应更新标签的内容，并且应该有任何连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在页上的所有当前 Web 部件连接不仅已经连接，而且已经开始在每个连接所涉及的使用者控件和提供者控件之间共享数据之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生命周期的连接，此事件发生后页面完成加载过程。 它也会发生后<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件，仅指示<xref:System.Web.UI.WebControls.WebParts.WebPart>或特定连接中所涉及的服务器控件已成功连接。 用例中有多个连接在页上，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>方法指示页上的所有有效 Web 部件连接现为活动状态，并且能够共享数据。 如果知道所有连接都处于活动状态，开发人员可以执行任意数量的任务，包括通知用户的所有连接的状态通知使用者控件处理并显示来自其提供程序，数据等等。  
  
 与此事件关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法，用于引发事件并允许开发人员创建自定义事件处理程序。  
  
 页面开发人员可以创建自定义事件的处理程序通过添加`OnConnectionsActivated`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在激活网页上所有已建立的 Web 部件连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生命周期的连接，会发生此事件页之前完成其加载过程，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。 不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，这涉及到之间的特定连接<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件发生时在页面上所有可能的连接已连接并且要激活。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>与事件关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，引发事件。 控件开发人员想要扩展可以添加到页的连接类型可以重写受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法并激活其他类型的连接。  
  
 页面开发人员可以创建自定义事件的处理程序通过添加`OnConnectionsActivating`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或其他能建立连接的服务器控件）之间创建一个连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法之间建立任何两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件。 调用此方法以创建连接之前，您可能还想要调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>条件检查，以确保控件满足的要求，构成一个连接中的方法。  
  
> [!NOTE]
>  还有可能不是两个服务器控件之间创建连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 一般情况下，必须在两个控件进行自定义服务器控件 (例如，从继承的控件<xref:System.Web.UI.WebControls.WebControl>或现有的 ASP.NET 服务器控件)，以便您可以添加所需的成员。 控件还必须满足以下要求。  
  
 任何类型的两个控件之间的连接方案必须满足以下要求，才能将无法连接：  
  
-   每个控件位于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域 （它不会不一定是相同的区域）。  
  
-   在 Web 部件控件集中实现时，在连接中的提供者控件实现一个接口作为公共方法用作回调到提供程序，并具有`ConnectionProvider`方法以将标识为提供程序连接上的元数据属性点。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法检索提供程序连接点是虚方法，派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件不一定必须使用相同的元数据属性。  
  
-   在 Web 部件控件集中实现时，在连接中的使用者控件还具有一个特殊的方法，使它能够获取对提供程序的回调方法中公开的接口的引用和使用者拥有`ConnectionConsumer`上的元数据属性该方法以将标识为使用者连接点。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法检索使用者连接点是虚方法，派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件不一定必须使用相同的元数据属性。  
  
-   回调方法必须是兼容的提供程序的回调方法 （即，使用者和提供程序可以直接共享数据），或者开发人员提供的接口，使用者可以使用的类型必须使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象传递给从提供程序将数据转换成使用者可以使用的窗体。  
  
    > [!IMPORTANT]
    >  如果不需要转换器，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载。 当需要转换器时，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责向另一个连接控件提供数据。</param>
        <param name="providerConnectionPoint">用作连接回调方法的方法。 与 Web 部件控件集中实现的一样，这是 <paramref name="provider" /> 中以 <see langword="ConnectionProvider" /> 元数据特性标记的一个公共方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责接收来自 <paramref name="provider" /> 的数据，然后处理或显示接收到的数据。</param>
        <param name="consumerConnectionPoint">与 <paramref name="providerConnectionPoint" /> 连接的方法，它接收连接的数据。 与 Web 部件控件集中实现的一样，这是 <paramref name="consumer" /> 中以 <see langword="ConnectionConsumer" /> 元数据特性标记的一个公共方法。</param>
        <summary>只使用对控件的引用和控件所指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象在两个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含连接所需的提供者和使用者的各种信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于连接控件，其连接点使其能够连接而不使用充分兼容时<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。 当调用此重载方法时，它只是将传递到其他重载版本的方法，调用并传递`null`的参数，它需要<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。  
  
 当您尝试以编程方式连接两个控件时，可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>条件检查，以确定是否可以直接连接控件中的方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法以编程方式创建的连接。 运行该示例所需的完整代码，请参阅示例部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 从该示例中，您需要允许您更改的页上，显示模式的用户控件的源代码和源代码的两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 承载这两个 Web 页的代码控制如下所示。 页面使用`Register`顶部的指令以声明的用户控件和自定义控件。 然后以声明方式在引用的自定义控件`<asp:webpartzone>`元素。 处理的代码`Button1_Click`方法创建使用控件之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中的页面后，单击**连接 web 部件控件**按钮以形成连接。 然后可以在文本框中输入一些数据，并单击**输入 5 位数字的邮政编码**按钮，以演示，控件已连接，并且第一个控件中输入的数据更新在第二个。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态集合的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件集合是只读的。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它的角色是为另一个连接的控件提供数据。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> 中的一个公共方法，它标有 <see langword="ConnectionProvider" /> 元数据特性，并用作连接的回调方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它担任从 <paramref name="provider" /> 或 <paramref name="transformer" /> 中接收数据然后对数据进行处理和显示的角色。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> 中的一个公共方法，它标有 <see langword="ConnectionConsumer" /> 元数据特性，并与 <paramref name="providerConnectionPoint" /> 连接以接收连接的数据。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它通过将数据从 <paramref name="provider" /> 转换为 <paramref name="consumer" /> 可以处理的格式来实现两个控件之间的连接。</param>
        <summary>使用对两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的引用、它们的指定 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 对象和一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在这两个控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，它包含有关提供者、使用者以及连接所需的转换器的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于连接控件时它们的连接点不兼容。 发生不兼容时`consumer`实现不同接口比`provider`作为连接点。 转换器将数据转换为类型可以理解的`consumer`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">连接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中激活。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在网页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中并由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件管理的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、服务器或用户控件的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.ControlCollection" />，包含由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的所有控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>属性不引用所引用的其他控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，如各种区域控件，<xref:System.Web.UI.WebControls.WebParts.EditorPart>或<xref:System.Web.UI.WebControls.WebParts.CatalogPart>控件和其他人。  
  
 此属性使用 Web 部件控件集，以及在大多数开发情况下不应在代码中调用。 出于此原因，尽管该属性是公共的但它是隐藏的智能感知。 开发人员想要访问的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>或由其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件应使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要复制的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>由 Web 部件控件集用来创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的副本，以向网页中添加该控件。</summary>
        <returns>要添加到页中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>在代码中直接的方法。 在内部调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件添加新的动态的过程的一部分<xref:System.Web.UI.WebControls.WebParts.WebPart>或到页服务器控件。 动态控件添加到页面以编程方式或通过 Web 部件用户界面 (UI)，例如通过将控件添加的控件，而不是直接在页的标记中声明了静态控件目录中的用户。  
  
> [!NOTE]
>  如果开发人员想要启用该方法以处理复制方案的更多控制，则可以在派生类中重写方法。 有关详细信息，请参阅对继承者部分的说明。  
  
 添加新的动态控件时，如果它是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法将返回该控件的新实例。 如果要添加的控件 （如用户控件、 自定义控件或 ASP.NET 控件） 的服务器控件的某些其他类型，已将具有与包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>由 Web 部件控件集的对象。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法遇到<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件，它将返回的新实例<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件包装在其中的子控件的新实例。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法创建要返回的控件的新副本，它也会重置所有属性的值为其默认值。 请注意，是否你想要保留可个性化属性的值，并将它们复制到新的控件实例，应调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>也方法。 由执行的最后一步<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法是调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>方法来获取该控件的新 ID。  
  
> [!NOTE]
>  因为此方法获取复制的控件的新 ID，您应该不依赖于引用其原始 id 添加到页面的动态控件 相反，应引用该方法返回的控件的新实例。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>该方法声明为<see langword="virtual" />，以便开发人员无法继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写方法，并提供有关其他方案，它可以在其中创建的控件的副本。 例如，该方法可能可以选择接收作为输入已序列化到 XML 文件的控件。 方法无法反序列化 XML （如果存在），然后调用基方法来处理现有用例，并返回的新实例<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一组在网站配置文件中指定的转换器，并将它们添加到 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 属性所引用的转换器的集合。</summary>
        <returns>网站的配置文件中指定的转换器的集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>可以重写此方法以添加其他应用程序可以使用的转换器。 例如，可以编写此方法从 Web 服务中检索一系列可用的转换器。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有控件的集合。 此类不能被继承。</summary>
        <returns>一个 <see cref="T:System.Web.UI.ControlCollection" />，由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有 Web 部件控件组成。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>此方法是受保护的和密封的因为它是继承的类可见<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，但它不能重写。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 Web 部件应用程序创建由所有可能的显示模式组成的显示模式集。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有受支持的显示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建所有可能的显示模式，而不仅仅是在特定页面上受支持的显示模式的列表。 有关受支持的显示模式的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
 默认情况下，Web 部件控件集创建下面的一组要在 Web 部件页上使用的显示模式：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 开发人员可以创建自定义显示模式，可以使用或不附带派生的自定义区域<xref:System.Web.UI.WebControls.WebParts.WebZone>或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类。 若要创建自定义显示模式，则必须从<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，并且将显示模式添加为受支持的模式页面上，您必须继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法。  
  
 当使用添加显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法，您应将其添加你希望它们在任何用户界面 (UI) 控件中显示的顺序 (如<xref:System.Web.UI.WebControls.ListBox>控件)，向用户提供可能的显示模式页面上。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 代码示例包含五个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   承载其他控件的网页。  
  
-   驻留在用户控制<xref:System.Web.UI.WebControls.WebParts.WebPartZone>Web 页面上的区域并使您能够输入和显示在标签中的文本。  
  
-   包含两个控件的源的代码文件。 一个是一个自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>，另一个控件，是一个自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>要添加到页面的默认显示模式对象。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是 Web 页。 它包含两个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控件，用户控件和自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 请注意`Register`在页面顶部的指令来引用用户控件和编译控件的命名空间。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 该示例的第三个部分是用于输入和显示文本的用户控件。 它使用<xref:System.Web.UI.WebControls.MultiView>控件创建 UI 的多个视图。 一个视图显示与`Button1`按钮，另一个却没有。 请注意，在重写`OnPreRender`方法中，代码检查以查看页面当前是否在自定义显示模式下，如果是这样，将显示该用户控件，其中包括按钮的第一个视图。 如果该页不在自定义显示模式中，例如，如果页是在浏览或设计模式下，按钮处于隐藏状态。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 该示例的第四个部分是两个自定义类的源文件。 请注意，自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类将重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法，并且它首先调用基方法，以添加所有默认显示模式，然后添加自定义显示模式。 自定义显示模式类`InLineEditDisplayMode`，只需继承<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>、 在构造函数中设置的显示模式的名称和重写的基属性来建立自定义显示的特征数。  
  
 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要运行的代码示例，请加载浏览器中的页。 请注意页面目前在浏览模式中，没有按钮可见。 使用**显示模式**下拉列表控件中，更改到的页**内联编辑显示**模式和，请注意现在`Button1`按钮是在较低的用户控件中可见。 添加一些文本，然后单击更新管理按钮。 请注意，页面显示返回到浏览模式，现在显示您输入的文本，按钮再次处于隐藏状态，因为页面已不再在自定义显示模式下。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个唯一值，用于充当动态连接的 ID。</summary>
        <returns>一个包含连接的唯一 ID 的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法生成的 GUID 值，并将其转换为字符串以用作连接的唯一 ID。 该方法被调用每次创建动态连接。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以重写此方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，以更改实现，用于生成唯一 id。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">为其生成 ID 的控件的 <see cref="T:System.Type" />。</param>
        <summary>为动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件生成唯一 ID。</summary>
        <returns>一个字符串，包含控件的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到 Web 页，它们可以是静态 （这意味着在页标记中声明的控件） 或动态 （这意味着它们将以编程方式添加）。 在任何情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建新的动态控件将添加到页上，它将调用此方法以生成唯一 id。  
  
 方法是虚方法，以便开发人员可以重写它如果他们想要提供自定义实现来生成此 id。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">作为失败控件 ID 的字符串。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该 ID 为其子服务器控件的 ID。</param>
        <param name="originalTypeName">字符串，失败控件的 <see cref="T:System.Type" /> 名称。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该类型名称是其子服务器控件的类型。</param>
        <param name="originalPath">包含用户控件路径的字符串（如果失败涉及包含子用户控件的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />）。</param>
        <param name="genericWebPartID">返回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> ID 的字符串（如果加载或创建控件的失败涉及该类型的控件）。</param>
        <param name="errorMessage">包含要在页中显示的错误消息的字符串。</param>
        <summary>当加载或创建动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的尝试因某种原因失败时，创建插入页中并向最终用户显示的特殊控件。</summary>
        <returns>插入页中以替代未能加载或创建的控件的 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>时的 Web 部件控件集尝试加载或创建的动态实例调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件使用，而且由于某种原因而失败。 该方法将创建<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>对象，将一条错误消息分配给它，并将其返回。 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件插入失败，在控件的位置，并且其错误消息显示在页上。  
  
 不能调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>在代码中直接的方法。 但是，继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和扩展方法。 有关详细信息，请参阅继承者部分的说明。  
  
 最终用户可以使用<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制在页面中很多类似的方式进行常规<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要删除的错误消息，用户可以关闭控件通过单击关闭谓词，此时该控件将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，像任何其他已关闭的控件一样。 如果最终用户删除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>也将从页面删除控件时，无法加载服务器控件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果你想要自定义中返回的信息<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件，可重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />方法，调用基方法、 不同的值分配传递到基方法的参数和返回生成<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件。 例如，如果不希望最终用户查看<paramref name="originalPath" />值 （该值将显示一个用户控件的虚拟目录路径），调用基方法时可以传递一个空字符串 ("") 为该参数。  
  
此外可以自定义的行为<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件本身，通过从其继承。 例如，您可能希望重写其<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />或<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />属性。</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个个性化设置对象，该对象包含当前网页的用户个性化设置数据。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含用户的个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>方法返回包含和管理当前页的用户的个性化设置的对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理此对象。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化设置概述</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的服务器控件。</param>
        <summary>用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象包装一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的服务器控件，以使该控件能具有 Web 部件的功能。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，包装 <paramref name="control" /> 并使其功能与真正的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件一样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法是启用的不是服务器控件的主要机制<xref:System.Web.UI.WebControls.WebParts.WebPart>控件以相同的功能对其执行<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，从而完全参与到 Web 部件应用程序。 通过使用此方法，开发人员都得到了显著扩展的 Web 部件应用程序，他们可以将服务器控件的数量，因为几乎任何类型的服务器控件-可以使用标准 ASP.NET 控件、 用户控件和自定义控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还使用此方法在两种情况下包装与服务器控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象。 当用户将服务器控件添加到页通过使用<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制，如果导入的控件不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>调用方法。 此外，当服务器控件声明中的持久性格式<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>网页上的区域<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法调用的任何控件，不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 时以编程方式向区域添加服务器控件，典型的方法是使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法以使用包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将控件添加到所有的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在页上，通过引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。 在`Button2_Click method`，则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>调用方法来包装<xref:System.Web.UI.WebControls.Calendar>控件，其<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>之前将其添加到该区域的对象。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>可以重写此方法，以便使用派生<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />类相反的基类提供与 Web 部件控件集。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个自定义警告消息，当最终用户删除一个控件时，将显示该消息。</summary>
        <value>包含警告消息文本的字符串。 默认值是经本地化的警告消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常显示默认警告消息。 它会警告用户删除控件的此实例时，删除是永久性。 页面开发人员可以向用户提供一种方法将控件的新实例添加到页面 (如通过目录的<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，或通过某些编程的方式)，但永久移除已删除的控件的当前实例。 如果需要，将显示警告对话框中包括用户以取消删除，一个按钮。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性使开发人员能够设置向用户显示的警告消息。  
  
 如果页面开发人员分配一个空字符串 ("") 将显示任何警告消息对话框中的此属性的值，当用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性未显示在静态的情况下<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和服务器控件。 服务器控件中声明静态控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在 Web 页的标记中的区域。 此类控件是静态的因为它们不能删除，因此永远不会在这种情况下显示删除警告消息。 静态控件可以关闭用户，但已关闭的控件添加到页目录中，从中可以由添加它返回到页用户，而永远无法恢复已删除的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性以声明方式和以编程方式。  
  
 有四个部分的代码示例：  
  
-   用户控件，可用于更改页的显示模式。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此示例使用动态编译的方法;因此没有任何`Assembly`属性中`Register`指令针对此控件在网页的顶部。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 代码示例的第三部分是 Web 页。 该页面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，使用的自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，以便用户可以将其添加到页在运行时在该区域中声明。 请注意，可以从页面删除仅动态控件 （以编程方式或从与此类似的目录添加到页的控件）。 静态控件 (中声明的控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域在页面的标记中) 可以关闭，但不会被删除。 `<asp:webpartmanager>`元素声明的自定义值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性使用`DeleteWarning`属性。 `Button1_Click`方法将分配到另一个自定义值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 加载浏览器中的页面后，需要将添加<xref:System.Web.UI.WebControls.WebParts.WebPart>到页面的控件。 使用**显示模式**下拉列表控件中，选择目录模式。 出现目录后，选择自定义控件旁边的复选框，单击**外**以将其添加到页上，然后单击**关闭**返回页后，可以浏览模式。 现在，控件可见，则可以将其删除。 使用**显示模式**再次控件，将页切换到设计模式 （页在浏览模式中时不能删除控件）。 单击的标头中的谓词菜单 （箭头符号）<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并选择**删除**。 对其设置的警告`DeleteWarning`属性将会显示。 单击“取消”。 现在，单击标记为按钮**更改删除警告**，这将以编程方式更改的属性值。 在控件上的谓词菜单中，选择**删除**同样，请注意，此时会出现其他警告消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要删除的服务器控件。</param>
        <summary>永久地从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的动态实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法永久移除所表示的控件`webPart`参数从一个页面。 与关闭的控件，它将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制和可重新添加到页上，可以永远不会将已删除的控件实例添加回页面。  
  
> [!NOTE]
>  由 Web 部件控件实现的设置，用户若要删除动态的能力<xref:System.Web.UI.WebControls.WebParts.WebPart>控件取决于用户和控件添加到页面中的个性化设置范围。 如果控件 （由具有权限的用户） 共享作用域中页面时添加，则该控件不能删除由各个用户页面时用户作用域中。  
  
 可以删除仅动态控件。 以编程方式或通过用户从目录中添加控件动态控件添加到一个页面。 静态控件添加到以声明方式中的标记或持久性格式的页。 由于声明性标记都永久存在的标记中，可以永远不会删除静态控件，但可以关闭并重新打开。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次**添加日历**单击按钮时，代码在事件处理程序将创建<xref:System.Web.UI.WebControls.Calendar>控件，并将其添加到与区域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象。 以编程方式添加了控件，因为它是一个动态控件，并因此被删除。 当用户单击**删除日历**按钮，该代码可确保控件存在，并且删除通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于更改包含 Web 部件控件的网页布局的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象的创建，并通过包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，您可以参考它直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 当用户想要通过将控件移到不同区域或在当前区域内更改页的布局时，则必须先切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>（设计模式下）。 在设计模式下显示各区域的用户界面 (UI)，并且用户可以拖动控件来更改布局。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览和设计的受支持的显示模式的下拉列表。 请注意，在`Page_PreRender`方法中，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>。 如果是这样，`Label1`将是可见的如果不能，`Label1`将被隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 加载浏览器中的页面后，你就在默认情况下浏览模式中。 请注意页面上的标签处于隐藏状态。 使用下拉列表控件切换到设计模式下的页面。 请注意，上述代码`Page_PreRender`方法中，标签现已显示。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要断开连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</param>
        <summary>移除要关闭或要从其所参与的连接中删除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法会在内部调用的 Web 部件控件集时在页上关闭或从页中删除控件。 在此类方案中，方法被调用来删除该控件从任何连接它涉及作为使用者或提供程序。 如果控件已从任何连接，此方法还会调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束的任何连接`webPart`曾参与过。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法调用时，它会发出<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。 通常情况下可以取消此事件，但不是能取消两种情况下。 页上，在请求期间发生一个用例时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。 如果在现有的连接之间冲突<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>将调用方法以关闭一个相互冲突的连接，并在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能被取消，因为必须解决该冲突。  
  
 另一种情况时<xref:System.Web.UI.WebControls.WebParts.WebPart>或关闭或删除当前连接的服务器控件。 在这种情况下，由于该控件正在从删除页上，也会终止，因此不能取消的设计及其连接需要<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件中断结束连接的过程。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 使用两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，Web 页使你可以通过单击一个按钮，而另一个按钮，可断开的控件的控件之间创建连接。 如果该页是在浏览模式中，并且控件已连接时，会关闭其中一个控件的重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法断开连接已关闭的控件、 结束连接，并显示一条消息。  
  
 代码示例包含四个部分：  
  
-   一个用于更改显示模式的用户控件。  
  
-   包含自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   若要承载控件网页。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是包含两个自定义的源代码的文件<xref:System.Web.UI.WebControls.WebParts.WebPart>将连接的控件和自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此示例使用动态编译，因此`Register`指令，它引用这些组件在 Web 页中的声明相应地在 Web 页的顶部。 有关演示编译选项的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 中的源代码，请注意，继承的控件`MyWebPartManager`重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法。 此方法检查页以查看被关闭的控件是否参与连接，如果是这样，调用中的每个连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束连接。 这等同于中的方法的基实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 重写的方法并自定义通过将消息写入到页的基实现。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 代码示例的第三部分是 Web 页。 请注意顶部附近，它包含`Register`指令来注册该用户控件，并具有动态编译的程序集<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 页都有两种主要方法。 `Button1_Click`方法创建控件之间的连接时`Button2_Click`方法则断开控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，单击**Connect**按钮，以连接控件。 然后单击其中一个控件 （该控件的标头中的向下箭头），谓词菜单并选择**关闭**谓词菜单中。 当您尝试关闭该控件时，重写的方法调用、 连接结束，和消息写入到页。 如果你想要重置页后，可以还原已关闭的控件并尝试使用其他选项，请单击**重置用户状态**链接中删除个性化设置数据和还原在页的原始状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">表示服务器控件之间的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>执行断开网页中连接的服务器控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法执行结束之间的连接的完整过程<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件时，将其传递`connection`参数。  
  
 此方法用于在将断开连接控件`<asp:connectionszone>`网页，以提供用于管理连接的用户界面 (UI) 中的元素。 当页面已在连接显示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)，且当前连接存在，则用户可以单击一个按钮来调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束连接。  
  
 您还可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法直接从代码中，如果你想要断开连接控件以编程方式，而无需添加`<asp:connectionszone>`到页面的元素。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 使用两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，Web 页使你可以通过单击一个按钮，而另一个按钮，可断开的控件的控件之间创建连接。  
  
 代码示例包含四个部分：  
  
-   一个用于更改显示模式的用户控件。  
  
-   包含自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   若要承载控件网页。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是一个包含两个自定义的源代码文件<xref:System.Web.UI.WebControls.WebParts.WebPart>将连接的控件。 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此示例使用动态编译，因此`Register`指令，它引用这些组件在 Web 页中的声明相应地在 Web 页的顶部。 有关演示编译选项的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 代码示例的第三部分是 Web 页。 请注意顶部附近，它包含`Register`指令来注册用户控件和动态编译的程序集与<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 页都有两种主要方法。 `Button1_Click`方法创建控件之间的连接和`Button2_Click`方法则断开控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，可以单击**Connect**按钮，以连接控件。 如果在文本框控件中，输入一些文本，然后单击**Enter**按钮，文本将显示在连接的控件 （它将不显示如果控件已断开连接）。 如果单击**断开连接**按钮时，控件将断开连接。 可以使用验证控件的连接状态**显示模式**要切换到页的下拉列表控件**Connect**模式。 之后，单击其中一个控件的标题栏中 （由一个箭头表示） 的谓词菜单，然后选择**Connect**项。 显示连接用户界面;它是可用的因为没有`<asp:connectionszone>`页面中声明的元素。 您还可以连接和断开此 UI 的控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 为只读。  
  
- 或 - 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 断开。  
  
- 或 - 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 为只读。  
  
- 或 - 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 断开。</exception>
        <block subset="none" type="overrides"><para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />方法，如果你想要更改正在断开连接的默认实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件。 如果你重写方法，并且只是想要将某些实现添加到现有的方法，可以调用基方法，然后执行你自己的代码。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含 Web 部件控件的网页的活动显示模式。</summary>
        <value>确定页显示模式的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含 Web 部件控件的页面始终是多个可能的显示模式之一。 有关显示模式的详细信息，请参阅[Web 部件页显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类创建网页的显示模式。 使用基<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建可以用在包含 Web 部件控件的页的多个标准显示模式对象。 这些标准的显示模式进行了介绍<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类概述。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还管理使用 Web 部件控件的页的显示模式。 使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页面上将保留对当前显示模式下的引用。 此外可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性页切换到不同的显示模式。 更改使用 Web 部件控件的页面上的显示模式的示例，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 为管理显示模式的一部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还提供事件和事件处理程序与相关显示模式，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。 这些方法提供了一种机制，用于自定义页面的行为，以及甚至将添加自定义显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性。 加载后在浏览器中的页，可以使用页面底部附近的按钮以切换显示模式。 页是在默认情况下浏览模式中加载时。 如果您切换到设计模式下，可以将服务器控件从一个区域拖到另一个，或安排在一个区域中的两个控件。 如果切换到编辑模式，则可以单击任何一个服务器控件，选择的标头中的谓词菜单**编辑**，和编辑使用提供的编辑用户界面 (UI) 控件。  
  
> [!NOTE]
>  在 Web 部件应用程序中的显示模式之间切换是很常见，并且可能想要提供包含 Web 部件控件的所有页面上执行此操作的一致、 可重复使用方法。 有关在很多页上，可以重用更改显示模式和用户控件的示例，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象不是受支持的显示模式。  
  
- 或 - 
赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象已禁用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 Web 部件页上的当前显示模式更改之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序的重要组成部分。 当用户切换到不同的显示模式在网页上时，页面通常会采用非常不同的外观，具体取决于新的显示模式的用途。 一种显示模式已更改后，您可能想要在用户界面 (UI) 中进行某些更改如隐藏或显示某些控件中，更改所选的 UI 元素的外观等。  
  
> [!NOTE]
>  显示模式的详细信息，请参阅[Web 部件页显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击网页上的谓词以启动不同显示模式之间的更改过程之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序的重要组成部分。 当用户切换到不同的显示模式在网页上时，页面通常会采用非常不同的外观，具体取决于新的显示模式的用途。 用户启动通过单击谓词更改为新的显示模式的过程后，你可能想要通过用户界面 (UI) 中进行某些更改<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>属性来确定新的显示模式将为，然后更改各种用户界面元素相应地。 执行此操作的有用方法是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法以自定义 UI。  
  
> [!NOTE]
>  显示模式的详细信息，请参阅[Web 部件页显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件关联的所有显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性引用关联的所有显示模式，相较于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性，引用是可用 （支持） 当前页上的显示模式。  
  
 提供的显示模式、 浏览和设计，其中两个始终支持在页面上。 其他三个显示模式、 编辑、 目录和连接支持仅当页具有特定显示模式工作所需的区域的相应类型。 例如，如果您的页面不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域中，编辑显示模式会显示在所引用的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性，但不是会显示在所引用的集合中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性。 代码使用此属性可在 Web 部件控件集中的所有显示模式列表中填充，甚至包括那些不支持在当前页上。 在这种情况下，该目录并连接的显示模式不支持，因为所需的相应区域不在页面上。  
  
 其他三个显示模式--浏览、 设计和编辑--支持在页面上。 编辑支持模式，因为该页面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域，而浏览和设计模式始终受支持。  
  
 加载浏览器中的页面后，可以使用下拉列表控件切换到设计模式下，浏览模式的页面，然后编辑模式。 在编辑模式下，您可以单击其中一个服务器控件的标头中的下拉谓词菜单并选择**编辑**编辑该控件。 请注意，如果您选择**目录**或**Connect**在下拉列表中，生成一个错误页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取网页上当前存在的所有动态连接的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含对页上所有动态连接的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态连接都是以编程方式，而不是以静态方式创建的连接。 在 Web 窗体页的标记中声明创建静态连接。 以编程方式，或使用连接用户界面 (UI) 创建连接用户形成动态连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合，但它是只读的不能更改其内容，将提供以编程方式访问每个动态连接对象。  
  
> [!NOTE]
>  若要执行常见操作，如连接或断开<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，开发人员应使用的公共方法，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而无需尝试直接修改连接中的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示最终用户可在其中编辑和修改服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象的创建，并通过包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，您可以参考它直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 当用户想要编辑或修改服务器控件时，则必须先切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>（编辑模式下）。 第二，他们必须选择特定的服务器控件进行编辑，通过单击该控件的标头中的谓词菜单上的编辑谓词。 该控件处于编辑模式后，编辑用户界面 (UI) 会显示用于编辑选定的控件。  
  
 若要启用页面上的编辑模式下，页必须包含至少一个<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域包含一个或多个所提供的编辑控件，如<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>控件或自定义编辑控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览、 设计和编辑的受支持的显示模式的下拉列表。 若要支持编辑，`<asp:EditorZone>`元素是在页中。 请注意，在`Page_PreRender`方法中，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>。 如果是这样，`Label1`将是可见的如果不能，`Label1`将被隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 加载浏览器中的页面后，你就在默认情况下浏览模式中。 请注意页面上的标签处于隐藏状态。 使用下拉列表控件切换到编辑模式的页。 请注意，上述代码`Page_PreRender`方法中，标签现已显示。 单击**编辑**上一个控件，以启用该特定控件的编辑的谓词菜单中的谓词。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定在包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的网页上是否启用了客户端脚本。</summary>
        <value>一个布尔值，指示页上是否可以运行客户端脚本。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性提供了一种方法为开发人员若要禁用客户端脚本。 您可能希望禁用客户端脚本出于安全目的，或以确保对页的所有用户将都具有类似的用户体验，即使它们使用不同的浏览器。  
  
 您可以禁用客户端脚本通过添加`EnableClientScript`属性为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在网页上，如下面的声明性代码行中所示：  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外，开发人员可以消除此属性，通过继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和设置默认值设为`false`。  
  
 Web 部件控件集使用的客户端脚本提供了一些客户端用户界面 (UI) 和个性化功能。 如果禁用客户端脚本、 Web 部件控件仍然起作用，但某些功能将被禁用。 若要将控件拖到不同区域的功能已禁用，以及呈现控件的标题栏 （谓词改为显示为控件的标题栏中的链接） 中的下拉谓词菜单中的谓词的功能。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示网页启用了主题。</summary>
        <value>一个布尔值，指示是否启用了主题。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.EnableTheming%2A>属性以确保它始终返回值为`true`。 这是因为 Web 部件控件集要求使用主题呈现 Web 部件控件的子控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制且形成 Web 页的用户界面 (UI)。 例如，使用主题呈现的各种区域，并位于区域，其中包括各种类型的控件部件控件 (从继承的控件<xref:System.Web.UI.WebControls.WebParts.Part>类)，用户控件、 ASP.NET 服务器控件和自定义服务器控件。  
  
 尽管重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>属性实现为读/写属性根据其基属性，无法设置属性，因为设计它必须始终返回值为`true`。 如果您尝试设置属性，<xref:System.NotSupportedException>引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件连接到另一个控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法完成连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件的控件。 它是到对应<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法可确保引用的个性化设置对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是不可修改，这是必要的因为建立连接本身是一种类型的个性化设置。 然后该方法确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能会想要重写此方法在派生类中的。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者你可能想要完全自定义完成控件之间的连接的整个过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成编辑 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法完成编辑过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 它是到对应<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法可确保引用的个性化设置对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是不可修改，这是必要的因为控件编辑这一过程需要的个性化设置更改。 然后该方法确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，以便当前所选<xref:System.Web.UI.WebControls.WebParts.WebPart>可以更改控制，并且最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能会想要重写此方法在派生类中的。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者你可能想要完全自定义完成编辑控件的整个过程。 例如，在重写方法中，无法首先，调用基方法，然后添加一些代码来确定进行了哪些编辑更改，并显示更改的列表返回给最终用户作为一条确认消息。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在用户尝试从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件导出敏感状态数据时显示的警告消息的文本。</summary>
        <value>一个包含警告消息的字符串。 默认消息是由 .NET Framework 提供的、特定于区域性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户尝试导出敏感状态数据从<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，如果任何要导出的数据来自已标记为敏感的源代码中的成员时，向在一个消息框，告知他们的用户显示一条警告消息正在导出敏感数据并提供一个机会，若要取消导出。 开发人员可以通过设置标记为敏感的特定成员的数据`isSensitive`的参数`[Personalizable]`属性为`true`成员上。 有关此属性和参数的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>类。  
  
> [!IMPORTANT]
>  当您使用 Web 部件的导出功能时，敏感数据可能潜在将导出到未经授权的用户。 有关如何保护用户免受此威胁的详细信息，请参阅[保护的 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每当用户尝试导出时，会显示默认消息。 但是，通过将分配到的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性，可以提供自定义的警告消息。  
  
   
  
## Examples  
 下面的代码示例演示如何将声明性的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。  
  
 以下 Web 页面的代码使用一种标准<xref:System.Web.UI.WebControls.BulletedList>控制并将其放在某个区域中。 将与包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时，使其能够充当真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要使控件可导出，`ExportMode`属性添加到`<asp:bulletedlist>`元素，元素和属性值设置为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>，可以导出这意味着该敏感和非敏感数据。 此外请注意，在`<asp:webpartmanager>`元素，`ExportSensitiveDataWarning`属性分配自定义值。  
  
 请注意，对于代码示例正常工作，必须在 Web.config 文件，以使导出 Web 部件说明文件中添加的设置。 确保您有 Web 页所在的目录中为此代码示例的 Web.config 文件。 内`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 加载浏览器中的页面后，单击 （向下箭头表示） 的谓词菜单中包含的链接控件的标题栏。 在谓词菜单中，选择**导出**，请注意，与该自定义警告出现一个消息框。 如果你想要继续导出，请单击**确定**，这将允许你保存的 XML 说明文件的本地副本的有关控件的所有数据。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">将从中导出数据的控件。</param>
        <param name="writer">一个 <see cref="T:System.Xml.XmlWriter" />，它将导出的数据从 <paramref name="webPart" /> 写入 XML 说明文件。</param>
        <summary>创建包含服务器控件的状态和属性数据的 XML 说明文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法将从各种状态和属性的数据组合`webPart`到一个 XML 文件。 数据包括有关控件本身，包括其程序集、 状态数据和属性数据的信息。 启动导出的用户可以将 XML 文件保存到磁盘中，在本地计算机或网络上。 其他用户可以描述文件导入到另一个页面或网站，并应用到其他实例的状态和属性数据`webPart`。 这提供了用户可以共享和重复使用的设置，服务器控件的快速而方便机制，它还为开发人员提供了一种控制外观和行为的导出和导入控件。  
  
 上的属性`webPart`默认情况下不导出。 若要启用的属性的导出，必须将其与标记`[Personalizable]`的源代码中的属性。 可以选择性地将标记为包含敏感数据，通过设置一个可导出属性`isSensitive`的参数`[Personalizable]`属性为`true`。 默认情况下`isSensitive`是`false`。 开发人员可以将参数设置为`true`以指示数据为敏感。  
  
 若要启用`webPart`要导出，开发人员设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性值设置为任一<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>（包括所有可个性化和敏感属性） 或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>，导出除敏感属性.  
  
> [!IMPORTANT]
>  允许用户从控件，导出数据并将数据导入其他控件，需要某些安全风险。 开发人员应使用以保护敏感数据，上文所述的方法，如果用户想要避免公开所有数据的风险，不应该在启用导出`webPart`根本。 有关 Web 部件的安全问题的详细信息，请参阅[保护的 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
或 
 <paramref name="writer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所引用的控件集合中。  
  
- 或 - 
<paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 属性设置为值 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />，该值表明对 <paramref name="webPart" /> 禁用导出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>被重写以防止将焦点设置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件上，因为该控件没有用户界面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>方法重写基<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>方法，并引发异常，如果调用方调用方法。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件没有用户界面，并且是永远不会对用户可见，但永远不会导致在本身上设置焦点。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">调用方尝试调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，该方法在没有用户界面的控件中不受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的使用者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 对象的集合，这些对象可以作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的使用者。</summary>
        <returns>包含使用者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接中始终涉及两个控件，其中一个作为数据，另一个充当数据的使用者提供者。 每个控件必须具有一个或多个被定义为连接点的方法。 对于使用者控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 检索使用者连接点是在建立 Web 部件连接中的必要步骤。  
  
 使用者必须始终具有至少一个连接点，以便能够建立的连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法检查使用者控件，并检索其所有连接点的集合。 如果<xref:System.Web.UI.WebControls.WebParts.WebPart>控件具有没有连接点，则方法返回一个空集合。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅本主题[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 页的声明性标记包含`Register`为用户控件和自定义控件的指令。 没有`<asp:webpartmanager>`元素中，`<asp:webpartzone>`元素以包含自定义控件和一个`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法中，代码会检查以查看是否连接已存在，如果没有，请定义一个提供程序、 使用者和其各自的连接点，然后将新的连接添加到所引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>通过使用检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法然后传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 此代码，以及用于编译该示例中所述的说明可以获取<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 出现后，请注意是否已创建一个连接中包含的代码通过`Page_Load`方法。 如果在更高版本浏览器会话中返回到此页，此静态连接已建立，并将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的实例的网页。</param>
        <summary>检索对页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的当前实例的引用。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，引用该控件在页上的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法可在上下文中你想要检索对当前的引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 出现这种常见情况是如果您正在编写自定义控件，在开发过程的 ID 不能知道<xref:System.Web.UI.WebControls.WebParts.WebPartManager>将在其页面上的控件。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法是静态的因此不需要的实例而直接调用它<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 Web 部件中的某些控件的控制设置，如<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，具有<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>属性可检索对当前的引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 因此，当处理此类控件，您应使用此属性来检索的引用。  
  
 如果您知道的 ID 的上下文中编写<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，如编写内联代码在网页中的，它是最简单且最有效的方法来直接引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件中的使用其 id。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 该示例由两部分组成： 一个自定义服务器控件和承载控件的网页。  
  
 自定义<xref:System.Web.UI.WebControls.Label>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法来检索其中的 ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件上的当前页上，然后显示该 id。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下面的代码示例提供程序中承载控件的 Web 页<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 加载浏览器中的页面后，请注意，当前的 ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件显示在自定义<xref:System.Web.UI.WebControls.Label>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">此方法返回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值的控件。</param>
        <summary>获取一个字符串，其中包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的值。</summary>
        <returns>一个字符串，包含 <paramref name="webPart" /> 的计算得出的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取计算的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>属性`webPart`。 当开发人员不将值赋给<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>属性的<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，此方法生成要显示为标题的值。 无标题控件的计算的值包含，该值指示在当前区域内的控件的序列号为一个字符串，追加一个编号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides"><para>可以重写此方法以更改如何计算默认显示标题。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在导出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>获取当用户尝试导出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件时包含在请求中的相对虚拟路径和查询字符串。</summary>
        <returns>一个字符串，其中包含共同形成导出控件请求的相对虚拟路径和查询字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法是包含该控件的页的服务器位置的相对虚拟路径加上追加的查询字符串值的窗体导出请求提交到服务器。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法将字符串编码之前允许该请求提交，以防止恶意脚本攻击。  
  
> [!NOTE]
>  有关保护 Web 部件应用程序的详细信息，请参阅[保护的 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个服务器控件，它存在于 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 中，并在运行时被包装为 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控件。</param>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的实例的引用，该实例包含一个服务器控件。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，将 <paramref name="control" /> 包装为子控件。 如果 <paramref name="control" /> 未包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情况下，有两种类别的控件的开发人员将放入<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域中参与 Web 部件应用程序：<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，它们继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>基本类和其他服务器控件，可以是标准ASP.NET 控件、 自定义控件或用户控件。 当其中的任何控件置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，所需的功能<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件本质上是，具有此功能，但其他类型的服务器控件不这样做。 若要启用其他服务器控件，使其作为<xref:System.Web.UI.WebControls.WebParts.WebPart>控制当中放置<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域中，ASP.NET 将它们封装与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。 因为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>直接从控件继承<xref:System.Web.UI.WebControls.WebParts.WebPart>类，它提供给它的子控件，则返回 true Web 部件功能。  
  
 通常在运行时，页面开发人员可能想要获取对引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含一个区域中的服务器控件的控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法使他们能够检索到的引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法。 代码示例包含<xref:System.Web.UI.WebControls.Calendar>控件中声明<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。 `Button1_Click`方法首先将该 ID 的输出<xref:System.Web.UI.WebControls.Calendar>为一个标签，然后使用控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法来检索到的引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装日历的控件。 ID<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件，且其子控件的 ID (即<xref:System.Web.UI.WebControls.Calendar>控件)，将打印到第二个标签。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的提供者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 对象的集合，这些对象可作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的提供者。</summary>
        <returns>包含提供者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接中始终涉及两个控件，其中一个作为数据，另一个充当数据的使用者提供者。 每个控件必须具有一个或多个被定义为连接点的方法。 对于提供程序控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。  
  
 一个提供程序必须始终具有至少一个连接点，以便能够建立的连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法检查提供程序控件，并检索其所有连接点的集合。 检索提供程序连接点是在建立 Web 部件连接中的必要步骤。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 该示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   在浏览器中的示例工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 Web 页的声明性标记包含`Register`为用户控件和自定义控件的指令。 没有`<asp:webpartmanager>`元素中，`<asp:webpartzone>`元素以包含自定义控件和一个`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法中，代码会检查以查看是否连接已存在，如果没有，请定义一个提供程序、 使用者和其各自的连接点，然后将新的连接添加到所引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>通过使用检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法然后传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法，以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 此代码，以及用于编译该示例中所述的说明可以获取<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 出现后，请注意是否已创建一个连接中包含的代码通过`Page_Load`方法。 如果在更高版本浏览器会话中返回到此页，此静态连接已建立，并将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">一个 <see cref="T:System.Xml.XmlReader" />，它从导入的 XML 说明文件中读取状态和属性数据。</param>
        <param name="errorMessage">在导入过程中遇到错误时将向用户显示的 <see cref="T:System.String" />。</param>
        <summary>导入包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的状态和属性数据的 XML 说明文件，并将这些数据应用于控件。</summary>
        <returns>在导入的 XML 说明文件中引用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或由 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包装并因此被视为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 的服务器控件）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法导入创建的 XML 说明文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>服务器控件的方法。 它不是导入，则实际的服务器控件，但仅包含有关控件的状态和属性数据的说明文件。 控件和说明文件中引用的程序集已在用户尝试导入说明文件服务器上可用。  
  
 若要启用导入一个控件，开发人员需要添加<xref:System.Web.UI.WebControls.WebParts.CatalogZone>启用导入页上的控件。 该区域内<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必须添加控件。 此控件提供了文件对话框中，用户可以浏览并找到要导入的说明文件。  
  
 用户找到说明文件，并开始导入后，通过阅读说明文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法。 如果没有任何错误，并且如果找到的程序集和控件，将服务器控件添加到目录中<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制和说明文件中指定的各种属性和状态数据应用于控件。 然后，用户可以选择的控件，并将其添加到页面。  
  
> [!IMPORTANT]
>  像<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法有一些潜在的安全风险。 因为它涉及到将数据导入网站，恶意用户可能尝试插入描述文件导入错误数据或者甚至脚本代码。 然后将错误数据可能会显示在页面上，或在数据库中，或插入的脚本无法运行。 与导入说明文件，以及避免这些风险的方法相关的潜在风险的概述，请参阅[保护的 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> 未能读取文件。  
  
- 或 - 
 需要 <paramref name="reader" /> 来显示导入错误消息，但在文件中未找到。  
  
- 或 - 
 <paramref name="reader" /> 已到达文件末尾，但未找到包含导出数据的 XML 元素。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 类的引用，该类用于合并和拆分实际在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中实现的，但通常对控件开发人员很有用的一组方法。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 通过它可引用已拆分为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各种方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性公开的 Api 调用为一系列<xref:System.Web.UI.WebControls.WebParts.WebPartManager>主要是在可扩展性的情况下使用的方法。  
  
 若要使用这些内部方法的设计的方法是访问是通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性。 由于属性受到保护，仅可以对其进行访问并调用实例中的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。  
  
> [!NOTE]
>  此属性隐藏的中的 IntelliSense [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]。 但是，在派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，你仍可以访问的属性和其各种成员。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定能否将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件添加到页中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件功能的一部分是灵活性的能够在运行时将服务器控件添加到网页。 有多种常见方案中的服务器控件 (可以是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 自定义服务器控件、 用户控件或 ASP.NET 控件) 可以添加。  
  
 在以下常见方案中，Web 部件控件集尝试将服务器控件添加到页上，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>调用方法对它们进行授权：  
  
-   通过声明的标记中的 Web 页面中添加的服务器控件时<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。  
  
-   当服务器控件是以编程方式添加到区域。  
  
-   当用户导入到 Web 部件控件目录中的服务器控件。  
  
-   如果现有服务器控件从个性化设置数据存储区中加载。  
  
-   当服务器控件添加到<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>控件以使其在服务器控件的目录中可用。  
  
 在其中添加控件，每个方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>调用方法以确保具有已满足所有授权条件以允许要添加的控件。 当控件已经过授权时，将其添加通常因为它将是否存在任何筛选方案。 当控件未获得授权时，可以在几个方面，具体取决于上下文响应 Web 部件控件集。 可以以无提示方式失败控件集 （如果不需要通知用户） 添加一个未经授权的部分，它可以显示错误消息，或者它可以添加的实例<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>类作为一个占位符。 此占位符对象是不可见的页上，但会显示在页的源代码以指示未经授权的控件已被排除。  
  
 是否获得授权控件的决定因素是授权筛选器。 授权筛选器是 Web 部件控件集，开发人员可从一个页面中排除任何不符合指定的条件的控件中的功能。  
  
 若要创建筛选方案，开发人员必须做两件事。 首先，他们必须将分配到一个字符串值 （值可以是任意）<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>他们计划在此方案中使用的控件。 它们还可以将值分配给此属性对于其他类型的服务器控件不<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，因为如果将它们放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，此类控件使用包装<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时，而该控件继承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。  
  
 创建筛选方案的第二个必要步骤是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，或创建的事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。 在这些方法，开发人员可以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性，并且如果该值指示不应授权控件，开发人员需确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法返回的值`false`。  
  
> [!NOTE]
>  有关代码示例和说明如何设置自定义的筛选方案中使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，请参阅该方法的重载的主题。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在接受授权检查的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <summary>执行确定控件是否被授权添加到页中的初始步骤。</summary>
        <returns>一个布尔值，指示能否将 <paramref name="webPart" /> 添加到页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法是调用的 Web 部件控件集用来检查授权的初始方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 它接受`webPart`作为参数，并开始最终确定控件是否将添加到页面的过程。 直接调用此方法从您的代码时需要确定是否授权给定的控件。  
  
 此方法将执行确定控件是否继承自的初始任务<xref:System.Web.UI.WebControls.WebParts.WebPart>类或者是否<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制，并包含如果是这样，哪种类型的子对其进行控制。 若要完成该任务的授权，它将调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>从您的代码以确定控件是否有权添加到页的方法。  
  
 代码示例包含三个部分：  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>重写控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。  
  
-   创建的筛选器的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   如何运行该代码示例的说明。  
  
 此代码示例使用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法，以提供自定义处理<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。 此控件的属性值的检查`admin`和的值存在时，如果对该控件的授权。 如果控件具有不同的值，未授权;控件的属性值不授予的权限，因为它们可能不为筛选方案的一部分。  
  
 若要运行此代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此代码示例使用动态编译方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 代码示例的第二部分创建筛选器可能排除控件。 以下网页包含三个 ASP.NET 服务器控件中的`<asp:webpartzone>`元素。 请注意，第一个和第二个控件都具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性设置为不同的值和第三个未分配给属性。 可以在运行时，检查此授权值和该控件可以添加到页上，如果在筛选器匹配由开发人员设置的条件。 此外请注意，在`Page_Load`方法，该代码调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>方法以确定是否每个控件已获得授权，以及如果是，则设置每个控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 请注意，若要运行代码示例，必须添加的设置在 Web.config 文件，以使导出 Web 部件说明文件中。 确保您有 Web 页所在的目录中为此代码示例的 Web.config 文件。 内`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 加载浏览器中的页面后，请注意，显示的第一个控件，因为它与重写方法中的条件相匹配。 第二个控件不添加到页上，因为筛选器排除。 此外添加了第三个控件，因为它不具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性集。 请注意，如果单击任一控件的标题栏中的谓词菜单图标，它们均可导出，因为它们各自<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>都分配了属性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>在代码中直接调用此方法。 如果你想要获得更好地授权过程以编程方式控制，则可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />重载方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">被检查授权情况的控件的 <see cref="T:System.Type" />。</param>
        <param name="path">被授权的控件的源文件的相对应用程序路径（如果该控件为用户控件）。</param>
        <param name="authorizationFilter">赋予 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的任意字符串值，用于授权是否可将控件添加至页中。</param>
        <param name="isShared">指示被检查授权情况的控件是否为共享控件，共享意味着它对应用程序的许多用户或所有用户可见，并且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 属性值设为 <see langword="true" />。</param>
        <summary>执行确定控件是否已经过授权可添加至页的最后步骤。</summary>
        <returns>一个布尔值，指示控件是否已经过授权可添加至页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法执行确定控件是否有权添加到页的最后一个步骤。 该方法可确保`type`是有效的类型，而`path`被检查的控件是用户控制时，才会包含一个值。 然后，它调用的关键<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，以确定控件是否有权添加到页。  
  
 第一步是创建筛选器可能排除控件。 以下网页包含三个 ASP.NET 服务器控件中的`<asp:webpartzone>`元素。 请注意，第一个和第二个控件都具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性设置为不同的值和第三个未分配给属性。 可以在运行时，检查此授权值和该控件可以添加到页上，如果在筛选器匹配由开发人员设置的条件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二步是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，并创建自定义授权筛选器处理。 请注意，代码首先检查属性是否具有一个值，以便任何控制，不会分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性将自动添加。 如果控件具有筛选器，代码将返回`true`仅当筛选器值等于`admin`。 此示例演示一个简单的机制可用于向某些用户，具体取决于其角色显示某些控件。 尽管本主题的范围超出了使用角色的完整示例，您可以使用相同的逻辑作为在此代码示例中，重写的方法，只不过无法检查当前用户是否属于与授权筛选器值匹配的角色然后添加仅针对该用户控件。 这样便可以创建其中某些用户将看到所有控件和其他用户将只能都看到所选的控件的页面。 这是如果你已用角色检查筛选器的逻辑可能显示方式：  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此代码示例使用动态编译方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 加载浏览器中的页面后，请注意，显示的第一个控件，因为它与重写方法中的条件相匹配。 第二个控件不添加到页上，因为排除其筛选器值。 添加第三个控件，因为它不具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性集。 如果更改上要匹配的第一个控件，然后重新运行页面的第二个控件的属性值，以及添加第二个控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 为用户控件，且 <paramref name="path" /> 为 <see langword="null" /> 或空字符串 ("")。  
  
- 或 - 
 <paramref name="type" /> 不是用户控件，且 <paramref name="path" /> 已赋值。</exception>
        <block subset="none" type="overrides"><para>可以重写此方法通过继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，如果你想要签入授权时提供附加的处理。 你可能想要重写方法，以检查的某些值<paramref name="authorizationFilter" />参数，并基于值，返回一个布尔值，确定是否会将控件添加到页面。  
  
页面开发人员还想要检查的授权筛选器，并提供自定义处理，对于没有执行此内联在.aspx 页中，或在代码隐藏文件中，而无需从任何类继承的选项。 您可以声明中的页的备用事件处理程序<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法的<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件。 有关更多详细信息和示例，请参阅<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已进行了个性化设置更改，这些更改影响 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所控制的页级别个性化设置详细信息。</summary>
        <value>一个布尔值，指示是否已进行了个性化设置更改。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性在内部以跟踪是否有任何它所管理的页级别个性化设置数据已更改。 当用户执行各种个性化设置操作，在页面级别，如添加或删除时将个性化设置数据更改<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 连接或断开连接控件，通过移动控件和其他操作更改页面的布局。  
  
> [!NOTE]
>  用户还可以执行在控制级别，这意味着它们到特定的控件进行个性化修改，个性化设置和所做的更改仅影响该控件。 示例将编辑控件，并更改其标题文本或它的背景色。 控制级别个性化设置不会影响所跟踪的页级别个性化设置数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，因此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性值不会更改为`true`控件级别个性化设置发生时。  
  
 虽然该方法受保护，并且不能由调用方，直接访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>直接由调用方，可以访问属性，则返回此属性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要加载的保留的状态数据。</param>
        <summary>加载从前一个页请求保存并需要在后续请求上还原的控件状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>方法可用于还原应在回发期间的页上，保留的属性数据，即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>存储由个性化对象传递给 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化数据，稍后会将其用于初始化过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法提供的形式保存的状态数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>对象。 若要加载到 Web 部件控件的个性化设置数据和执行其他初始化任务，最终使用此数据。  
  
> [!NOTE]
>  时，开始一系列方法调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法最初请求相关联<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>对象提供个性化设置数据到<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 您不能在代码中直接调用此方法。 但是，可以直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法，后者自身调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法并返回的个性化设置数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</summary>
        <value>仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>类型反序列化的导入过程中使用此属性返回的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</summary>
        <value>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>导入的所有内容只不过类型反序列化过程中使用此属性返回的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要移动的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <param name="zone"><paramref name="webPart" /> 要移动到的目标 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，指示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中相对于其他控件的索引。</param>
        <summary>将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件从一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域移动到另一个区域，或移动到相同区域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法来移动`webPart`到在同一区域中，或在不同区域中的新位置。 您可以直接从代码中，调用此方法，也会调用时用户将一个控件移动到 Web 部件用户界面 (UI) 中使用不同选项的新位置。  
  
 多个条件必须满足`webPart`可以移动，以及其中的大多数指示由本主题的异常部分中列出的项。 如果`webPart`未包含在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域开始时，不能移动的区域中。  
  
 在满足的条件后，以下操作序列发生移动`webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  `webPart` 已从其当前区域 （如有必要），并添加到其新的区域或其当前的区域中的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  `zoneIndex`的每个<xref:System.Web.UI.WebControls.WebParts.WebPart>源和目标区域中的控件重置以反映移动的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>直接从代码移动方法<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件从一个区域。  
  
 代码示例包含三个部分：  
  
-   一个用于更改显示模式的用户控件。  
  
-   若要承载控件网页。  
  
-   如何运行该代码示例的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的详细信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是包含两个区域，其中每个包含两个服务器控件的 Web 页面。 当用户单击**移动 web 部件**页中的代码上按钮`Button1_Click`方法将第一个区域中一个控件移动到第二个区域中的新位置。 请注意，代码必须先调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法来检索<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装的对象`list1`控件。 这是必需的因为的第一个参数<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法要求<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，而`list1`是 ASP.NET 服务器控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 在页面加载后，单击**移动 web 部件**按钮，并请注意，包含链接的控件将移到第二个区域中的中间位置。 通过调用以编程方式完成此移动控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法。 此外可以使用**显示模式**下拉列表控件以将页切换到设计模式，并在设计模式下，可以将控件拖到不同区域或其区域内的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>还会调用方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来处理此类用户启动移动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
- 或 - 
 <paramref name="zone" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
- 或 - 
<paramref name="webPart" /> 控件的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 属性所引用的区域为 <see langword="null" />，意味着 <paramref name="webPart" /> 当前未包含在任何区域中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 或 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件并调用该事件的处理程序（如果存在）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>调用方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件被检查授权添加到页。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法调用时，它会发出<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，并且如果没有为事件处理程序方法，它将调用处理程序。  
  
 授权的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是一项重要的 Web 部件功能。 每个<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件添加到由区域<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件就可以执行授权过程以确定是否可以添加控件。 默认情况下，Web 部件控件集不提供任何筛选条件，以防止控件添加到区域。 但控件集提供了开发人员能够创建他们自己的筛选条件所需的机制。 通过使用这些机制，可以创建自定义筛选方案。 例如，可以创建筛选器，以便如果用户是管理员角色中，将添加到区域的某些控件时呈现页面时，如果用户是在用户角色中，将不会添加这些控件。  
  
 这种机制用于在授权过程中筛选控件<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>上的属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，并<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>上的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 若要创建筛选方案，有实质上是两个任务。 首先，将字符串转换为的分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>你想要筛选的控件。 这些字符串值可以是任意的但它们应包含你想要筛选的条件。 例如，如果您希望某一给定的控件以管理员身份添加到区域仅当用户正在查看页上，则可以分配的字符串值`admin`到的属性。 然后可以使用 ASP.NET 角色功能，并将你的站点的所有用户都添加到如管理员、 管理员和用户的各种角色。 筛选代码时加载页面时，将检查用户的何种角色为，其与要检查的控件上的授权筛选器值进行比较，如果用户的管理员角色的是 （例如） 和你设置控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的值`admin`，无法添加控件。  
  
 创建筛选方案的第二步是编写代码以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值上<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并确定每个控件是否被授权添加到其区域之前。 有两个用于此筛选代码的放置位置选项。 第一个选项是页面开发人员的首的选项。 可以创建一个方法来处理<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>直接在网页上的服务器脚本代码，或在代码分离文件中的事件。 将你的方法与事件相关联通过添加`OnAuthorizeWebPart`属性的标记为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制在页中，如下面的示例标记代码中所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 自定义方法只需为每个复选<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是否满足筛选条件并根据结果，然后，将布尔值赋给<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>的属性<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>对象，以指示是否<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以是添加。 示例部分中的代码演示如何执行此操作。  
  
 有关在何处放置筛选代码的第二个选项是继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写一个方法以检查筛选器条件。 可以重写以执行此操作的两种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 尽管这两种方法会起作用，但在大多数情况下最好是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，因为它提供了更好地以编程方式控制整个授权过程中，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法执行只有一项特定任务这是引发的事件和检查处理程序。 有关自定义的代码示例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法的重载。  
  
   
  
## Examples  
 下面的代码示例演示如何设置的自定义事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，以便该处理程序可以提供用于自定义筛选代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 此示例是页面开发人员提供筛选方案和授权的典型方式<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页。  
  
 在网页上，注意`<asp:webpartmanager>`元素具有`OnAuthorizeWebPart`具有分配给它的事件处理程序名称属性。 该方法检查页上的控件是否具有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性的值设置为`admin`，如果是，则返回`true`，这意味着它们将被授权并添加到页面。  
  
> [!NOTE]
>  请注意，控件不具有分配给任何值<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性还将添加，因为它们被假定不是筛选方案的一部分。 这将是筛选方案中的常见方法： 将筛选一些控件，并且其他人不会因为它们都假定为可供所有用户。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 设置角色的用户不在本主题的范围内，因为此代码示例不会检查用户角色中的筛选操作。 但是，筛选控件根据用户角色的方案是，可能需要此筛选功能的最常见用途之一。 如果角色对你的站点，并且你想要检查此方法筛选器控件中的用户角色，该方法将类似于下面的代码块 （而不是更简单的方法，在前面的代码示例不使用角色）。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件以指示已加载页及其控件，并且已激活页上的连接，可以开始共享数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>页面完成加载过程之后的事件。 该方法提供了一种添加事件处理程序方法。  
  
 页面开发人员可以通过添加添加事件的自定义处理程序`OnConnectionsActivated`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件以指示已加载页及其控件，可以开始激活连接的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件，开发人员提供了一种机制，用于以编程方式自定义激活连接的过程。  
  
 页面开发人员可以通过添加添加事件的自定义处理程序`OnConnectionsActivating`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含与更改后的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上已完成从一种显示模式切换到另一种显示模式的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法的基窗体只是引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />方法。 例如，显示模式的更改后您可能想要更改某些内容中的用户界面 (UI)，具体取决于哪些显示模式包含在外观<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />属性。 或者，可能想要隐藏某些内容，或显示某个控件。  
  
时重写该方法，您应通常调用基方法重写方法的最后一个步骤，以便自定义代码在运行第一个，并最后，引发该事件指示模式更改已完成。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.EventArgs" />，包含与正在更改的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上正处于从一种显示模式切换到另一种显示模式的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法的基窗体只是引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />方法。 例如，当更改显示模式，您可能想要检查新的显示模式将是 (通过使用<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />属性) 和更改基于新的显示模式将是用户界面 (UI) 中的某些内容。 如果您有自定义显示模式下，可能想要使某些控件在自定义模式将新的显示模式的情况下可见。  
  
当重写此方法时，您应通常调用基方法重写方法的第一步，以便在引发事件以指示正在启动显示模式更改。 然后，自定义代码可以进行更改用户界面 (UI) 中实际显示新的显示模式之前。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件，该事件是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件生命周期中的第一个事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法调用基方法，将引发<xref:System.Web.UI.Control.Init>控件，然后执行几个预备步骤，如确保只有一个实例的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页上，并加载个性化设置数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">页上还有另一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，该事件恰好在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件被呈现在网页上之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>方法调用基方法，将引发<xref:System.Web.UI.Control.PreRender>控件，然后注册的事件包含 Web 部件页所需的多个客户端脚本控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，该事件在新选择了某个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件或清除对它的选择之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件，这通常是一名开发人员可能想要更改的用户界面 (UI) 的外观的时间点。 例如，当新<xref:System.Web.UI.WebControls.WebParts.WebPart>控件处于选中状态，Web 部件控件集更改新选择的控件的呈现。 清除控件的选择后，呈现正常返回。  
  
 在用户选择特定<xref:System.Web.UI.WebControls.WebParts.WebPart>控件进行编辑，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>调用方法。 当用户完成编辑控件，并关闭它，从而导致清除控件的选择，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>再次调用方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>有几个选项与相关<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />事件，以允许开发人员自定义更改所选的控件之后发生的呈现。 在声明性代码中，在<see langword="&lt;asp:webpartmanager&gt;" />元素，无法设置<see langword="OnSelectedWebPartChanged" />属性，并为其分配自定义方法的名称。 在自定义的方法中，您可以在事件发生时修改所选控件的呈现。 另一个选项是继承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写此方法。 第三个选项是自定义呈现在区域级别;例如，可以继承自<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />类，并重写其<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />方法，以自定义控件在选中和清除在编辑过程中的呈现。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，该事件在更改当前选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件，更改其中的过程中发生<xref:System.Web.UI.WebControls.WebParts.WebPart>当前选定控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用此方法，而且关联的事件，以提供取消进程在其中更改所选的控件的机会。 例如，在调用方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法，并且也在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法，以提供一种方法，将取消该过程。 如果用户单击要编辑的控件上的取消谓词，该控件不再处于选中状态和未保存编辑的任何更改，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法，可以取消的编辑更改。  
  
> [!NOTE]
>  同样的方法的开始和结束连接的过程期间调用该方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件到另一个控件，以便取消该过程。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>通过添加事件`OnSelectedWebPartChanging`属性为`<asp:webpartmanager>`元素中声明性页标记中，并为属性指定自定义方法的名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">与控件的移除相关联的事件数据。</param>
        <summary>引发基 <see cref="E:System.Web.UI.Control.Unload" /> 事件，并从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被添加到某个页之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>添加的过程中调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 到页面。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>通过添加事件`OnWebPartAdded`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，该事件将在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>事件以指示控件是要添加的过程中。 该方法还提供了选项将取消该添加过程。 如果已成功添加控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartAdding`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件以表明控件已从页中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件以指示<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （或其他服务器或用户控件） 已成功关闭上一个页面。  
  
 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页面以便不呈现，并且还将其放在一个特殊持有对象调用页目录。 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件中，会保留对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页面的控件。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件中的页面上声明<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录显示模式，并添加回页面之前关闭任何控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法使开发人员能够创建自定义处理程序有机会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。 页面开发人员可以通过添加添加事件的自定义处理程序`OnWebPartClosed`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。 一个有用的任务可能会执行开发人员，在这种方法是显示在已关闭的控件的位置的占位符，请使用工具提示会告知用户完成如何将控件添加到页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，该事件将在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件以指示控件正在被关闭或从页中移除。 该方法还提供了取消结束进程的选项。 如果从页中，已成功删除控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartClosing`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，该事件在从页中永久删除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>删除的过程中调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 从一个页面。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>通过添加事件`OnWebPartDeleted`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，该事件指示动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中包含的服务器控件或用户控件）正处于被删除的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅动态<xref:System.Web.UI.WebControls.WebParts.WebPart>可以删除控件，并删除一个控件时，控件实例从页中永久删除，无法还原。 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是那些以编程方式添加或从 Web 部件目录，而不是静态控件中声明的 Web 页的标记。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件以指示控件已被永久删除从其区域。 该方法还提供了取消删除进程的机会。 如果控件已成功从页中，删除<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartDeleting`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被移动到页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，这可确保之前的任何代码在事件处理程序将运行的移动控件的过程已完成。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>在其当前的区域内或另一个区域，在移动控件和是否移动以编程方式或通过用户拖动控件完成不重要时引发事件。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>通过添加事件`OnWebPartMoved`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />、服务器控件或用户控件正处于移动过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件，发生时<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件要移动其区域中或另一个区域。 该方法还提供了取消移动过程的机会。 如果移动已成功完成，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartMoving`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间建立了连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法将引发其相应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法，可确保事件处理程序中的任何代码运行之前完成连接两个控件所需的步骤。  
  
 该方法提供了以编程方式控制创建连接的过程和关联的事件是方便地在要更新用户界面 (UI) 或通知给用户的已建立的连接。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>通过添加事件`OnWebPartsConnected`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，该事件发生于在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域内包含的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件之间建立连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，当两个控件尝试建立连接时发生该事件。 该方法提供了取消连接尝试的机会。 如果连接成功，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartsConnecting`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法将引发其相应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，执行终止两个控件之间的连接的过程。  
  
 该方法提供了以编程方式控制结束连接的过程，以便开发人员可以通知用户，对用户界面 (UI) 进行更改或对应用程序进行其他更改。  
  
 页面开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>通过添加事件`OnWebPartsDisconnected`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件正处于结束连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，当两个控件将结束连接时发生该事件。 该方法提供了机会来取消断开连接过程。 如果已成功删除连接，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件遵循。  
  
 页面开发人员可以通过添加为关联的事件提供自定义处理程序`OnWebPartsDisconnecting`属性为`<asp:webpartmanager>`上一个网页，以及然后向该属性分配自定义方法名称的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对包含网页个性化设置数据的对象的引用。</summary>
        <value>包含个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性提供了一种访问方法<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>与通过页相关联的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 使用此属性，可以访问的个性化设置对象的各种成员。 例如，可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法才能切换页面的个性化设置范围从共享到用户作用域，反之亦然。 您还可以查找出当前个性化设置范围的页上，是否启用了个性化设置甚至在页上，哪个提供程序用于个性化设置数据等。  
  
 请注意，通过引用数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是仅由跟踪的页级别个性化设置数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 特定于控件的个性化设置数据，如可个性化设置的属性的值<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是属于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性。  
  
> [!NOTE]
>  Web 部件个性化设置的详细信息，请参阅[Web 部件个性化设置概述](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性以编程方式。  
  
 以下 Web 页面，用户可以进入编辑模式，若要编辑的某些方面<xref:System.Web.UI.WebControls.Calendar>控件。 **切换范围**按钮切换到用户或共享个性化设置范围的页面。 **编辑模式**并**浏览模式**按钮每个页切换到适当的显示模式。 请注意，在`<script>`标记文件，处理事件使用的方法的两个部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性来访问基础对象的有用成员。 具体而言，这些方法使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>上通过访问的对象属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要运行的代码示例，您还必须启用一个用户进行个性化设置共享范围内的页。 将条目添加到 Web.config 文件中，在`<system.web>`部分，如以下标记所示。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 加载浏览器中的页面后，单击**切换范围**按钮，然后注意页面现在显示共享作用域。 单击**编辑模式**若要更改显示模式下，单击在可见的控件中的谓词菜单，然后选择**编辑**菜单中。 请注意，显示这两个编辑控件的用户界面 (UI)。 现在，单击**浏览模式**返回到正常浏览。 如果页面显示在共享范围内，单击**切换范围**以确保该页是用户作用域中。 接下来，请按照相同的步骤来再次编辑控件，但请注意，现在在编辑 UI<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>控件不会出现。 这是因为此控件仅在页处于共享个性化设置范围。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化设置概述</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件能够发出用于各种个性化设置功能（例如，在网页中拖动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件）的客户端脚本。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个 <see cref="T:System.Web.UI.HtmlTextWriter" />，它接收控件的内容以写入页。</param>
        <summary>重写以防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件呈现任何内容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的状态数据，以便在将来请求包含该控件的网页时可以还原这些数据。</summary>
        <returns>一个 <see cref="T:System.Object" />，它包含控件的已保存的状态数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>方法保存的属性，应在页回发之间保留的状态数据，即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件维护的自定义个性化设置状态数据，以便重新加载该页时可以重新加载此数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>方法非常重要个性化设置的过程中，因为它使存储为将来的浏览器会话的个性化的用户设置和页访问。 该方法保存自定义个性化设置状态数据，其中包括以下各项： 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>或已添加到页或从一个页面; 被移动页面; 的控件和动态连接的已删除的服务器控件已创建或删除。  
  
 您不能在代码中直接调用此方法。 但是，可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法，后者自身调用此方法以保存个性化设置数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以重写此方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类自定义保存个性化设置数据的过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对当前选择的用于编辑或用于创建与另一个控件的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件的引用。</summary>
        <value>当前选择的用于编辑或建立连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性返回的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件的当前选定进行编辑或创建与另一个控件的连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件提供了几个有用的方法和事件用于处理选择一个控件的过程。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>但只需选择控件后，进行任何更改之前发生的事件。 若要选择它后执行控件上的某些操作，请重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 例如，你可能想要更改的控件处于选中状态但未更改，若要以可视方式强调所选控件的外观。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件发生后所选的控件已更改。 若要更改后对其执行某些控件上的操作，重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的选择已经发生更改并被移动到网页上的另一个控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法，以更改所选控件的用户界面 (UI)。 例如，如果用户切换到设计模式下的页 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)，然后选择<xref:System.Web.UI.WebControls.WebParts.WebPart>控件将其拖到新位置的意图，很常见，若要更改所选控件的呈现，例如通过更改的颜色其边框或背景处于选定状态时。  
  
> [!NOTE]
>  使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改网页上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件当前的选定状态的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 页面开发人员可以通过添加在其代码中创建一个事件处理程序`OnSelectedWebPartChanging`属性为`<asp:webpartmanager>`页上，并将该属性的值设置为自定义方法的名称中的元素将处理的事件。  
  
 在开始或结束以及时开始和结束的编辑控件的控件之间的连接的过程中引发此事件。 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。  
  
 通常情况下，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>作为更改所选的控件的用户的操作的直接结果引发事件，可以取消该事件。 但是，是不能在其中取消该事件的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控件中删除，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须全部关闭，否则它们将成为孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 不用户，它必须确定当前所选控件以及何时更改而无需中断，任何可能的选择，以便它可以完成的清理过程所有控件。 因此，根据设计<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>不能在此情况下取消方法。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>设置一个标志，该标志指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化设置数据已更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法设置最终在 Web 部件控件集用来保存已更新的个性化设置数据将导致个性化设置组件的标志。 有关详细信息可能会导致更改跟踪的个性化设置数据的方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法不能在代码中直接调用，并不能重写，因为它在内部由 Web 部件控件集作为 Web 部件个性化设置功能的一部分。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>可以调用该方法由派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。 这会非常有用，如果你想要自定义个性化设置组件的 Web 部件控件的设置，并因此需要控制设置个性化设置数据的标志的过程。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">已被选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>将 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性值设置为等于当前选定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法调用的开始或结束编辑指定的控件的过程`webPart`参数，和的开头或结尾的连接，包括那些`webPart`。  
  
 编辑并连接进程的开始处`webPart`是已被选择要编辑或输入连接的控件。  
  
 编辑和连接过程中，末尾`null`传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法，这会导致不能再选择当前所选控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个空字符串 ("")，使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件不能应用任何外观。</summary>
        <value>一个空字符串，该字符串防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件使用指定给它的外观。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>属性重写继承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>属性，以阻止<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，这是不可见的控件中，从使用外观。 实现属性可以防止通过始终返回空字符串从指定外观`get`访问器，并且始终引发异常，如果尝试设置一个值`set`访问器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有定义为静态连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的集合的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含页上的所有静态连接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来跟踪和管理页上的所有静态连接。 静态连接，而相比之下，动态连接，不必每次呈现页面时添加到一个页面。  
  
 此属性所引用的集合包含在页上，存在，无论它们是以编程方式创建，还是使用指定的所有静态连接`<asp:webpartconnection>`中页面的标记元素。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 代码示例包含四个部分：  
  
-   用户控件，可用于更改 Web 部件页上的显示模式。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义的接口。  
  
-   包含两个自定义的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个`<asp:webpartmanager>`元素。  
  
-   在浏览器中的示例工作原理的说明。  
  
 下面的代码包含示例的 Web 页部分。 您还需要获取示例中所述的例子-自定义用户控件和自定义控件和接口的源代码的前两个部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 该主题还介绍了用于编译选项<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 代码示例的第三部分是 Web 页。 页的声明性标记包含`Register`为用户控件和自定义控件的指令。 没有`<asp:webpartmanager>`元素中，`<asp:webpartzone>`元素以包含自定义控件和一个`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法中，代码会检查以查看是否连接已存在，如果没有，请定义一个提供程序、 使用者和其各自的连接点，然后将新的连接添加到所引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 已加载网页的浏览器中后，单击**显示模式**下拉列表控件，然后选择**Connect**切换页可连接模式。 连接模式使用`<asp:connectionszone>`元素以使您能够创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单，，然后单击**Connect**。 连接用户界面 (UI) 出现后，请注意是否已创建一个连接中包含的代码通过`Page_Load`方法。 如果在更高版本浏览器会话中返回到此页，此静态连接已建立，并将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取特定网页上所有可用显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定网页上的可用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性包含实际可用在页上，给定类型的页面上存在的区域控件的显示模式。  
  
> [!NOTE]
>  可以禁用显示模式，并禁用后一种显示模式，未添加到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>集合，即使该显示模式支持的区域的相应类型的页上存在。  
  
 浏览模式和设计模式始终是受支持。 而异的显示模式是编辑、 目录和连接模式。 每种显示模式是与特定类型的关联<xref:System.Web.UI.WebControls.WebParts.ToolZone>控件。 它是该特定类型的区域会导致某种显示模式要添加到所引用的集合的网页上是否存在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 例如，如果网页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>但不是区域<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，然后编辑显示模式是在该页面上，支持的模式之一，但不是支持目录显示模式。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性，引用的集合包含与当前可用的显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，甚至那些不支持特定页面上。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 代码使用此属性以填充该列表仅显示可用的模式中，当前网页。  
  
 有三种受支持的此页上显示模式： 浏览、 设计和编辑。 前两个始终可用，以及编辑模式是可用此代码示例中，因为该页面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>控件。 目录和连接模式不在显示时，显示，因为它们的相应区域不在此页上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 加载浏览器中的页面后，可以使用下拉列表控件切换到设计模式下，浏览模式的页面，然后编辑模式。 在编辑模式下，您可以单击其中一个服务器控件的标头中的下拉谓词菜单并选择**编辑**编辑该控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据是否已在网页上更改。</summary>
        <value>一个布尔值，指示个性化设置状态数据是否已更改。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性提供了一种方法的调用方以确定是否个性化设置状态数据由管理<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。 当用户进行个性化设置页面级别的详细信息，例如通过更改页面布局、 创建或删除连接，并通过添加或删除控件，管理个性化设置数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件发生更改。 这是保护项的值返回给调用方传递方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性，它不能由调用方直接访问。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性不指示是否可个性化属性值或会影响个人外观的各个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，已更改。 控制级别个性化设置单独跟踪每个控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性指示仅个性化设置数据的页级别由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。  
  
 以下列表描述了个性化设置会导致某些常见情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性返回的值`true`，以指示的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有某些更改的个性化设置数据：  
  
-   关闭静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （或服务器或用户控件） 页面上。  
  
-   还原已关闭的静态<xref:System.Web.UI.WebControls.WebParts.WebPart>页目录中返回到页的控件。  
  
-   将在其区域内或向另一个区域移动任何控件。  
  
-   从目录中添加控件<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件，或以编程方式添加控件。  
  
-   创建两个连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面 (UI)。  
  
-   正在删除连接两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面。  
  
 若要访问此属性的值，必须强制转换<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件实例与<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>接口; 你可以然后读取<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>属性值。  
  
   
  
## Examples  
 下面的代码示例演示的简单用法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性，以指示某些常见的页面个性化设置实例的原因<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的个性化设置数据更改。  
  
 代码示例包含四个部分：  
  
-   用户控件，您可以更改包含 Web 部件控件的页面上的显示模式。  
  
-   包含两个自定义代码的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件和一个接口。  
  
-   承载的所有控件的网页。  
  
-   代码示例的工作原理的说明。  
  
 代码示例的第一个部分是用于更改显示模式的用户控件。 可以从示例部分中获取用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式的用户控件的工作原理的信息，请参阅[演练：更改显示模式同时适用于 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是使用自定义控件和接口的源文件。 请注意，`IZipCode`接口公开一个方法，并在自定义实现此方法作为`ZipCodeWebPart`控件作为回调方法，以使`ZipCodeWebPart`充当连接方案中的提供程序。 另一个控件`WeatherWebPart`，在连接中充当使用者控件; 它可以使用提供的特定接口`ZipCodeWebPart`。 在实际的应用程序，`WeatherWebPart`无法使用个性化的邮政编码值从提供程序，并向用户提供图形天气信息。  
  
 若要运行的代码示例，必须编译此源代码。 可以显式对其进行编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在你网站的 App_Code 文件夹中，其中它将被动态编译在运行时。 此代码示例使用动态编译;因此，请注意，`Register`此组件在 Web 页面顶部的指令只包含`TagPrefix`并`Namespace`属性，而不`Assembly`属性。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 代码示例的第三部分是 Web 页。 请注意，它包含两个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，其中包含两个自定义第一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 此外，还有<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，其中包含一种标准<xref:System.Web.UI.WebControls.Calendar>用户可添加到页面的控件。 `<asp:connectionszone>`元素提供一个连接的用户控件之间创建连接的用户界面。 在中`Page_PreRender`方法，请注意，它会检查是否已更改的个性化设置数据，如果是这样，更新的文本`Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 加载浏览器中的页面后，尝试创建的一些方案将更改个性化设置数据本主题的备注部分中列出。 如果某个更改涉及的跟踪的个性化设置方案之一进行各种更改，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的文本`Label1`控件将显示指示个性化数据已更改。 例如，你可以：  
  
-   通过单击控件之间创建连接**连接 web 部件控件**按钮。  
  
-   使用**显示模式**下拉列表控件以将页切换到目录模式，并添加**我的日历**第二个控件<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
-   更改后翻页以浏览模式下，单击谓词菜单 （显示在标题栏中的箭头符号） 的**我的日历**控件，并选择**关闭**关闭它，并将其添加到页目录。  
  
-   将页返回到目录模式下，并添加**我的日历**回页面的控件。  
  
-   使用**显示模式**控件将页切换到设计模式，并重新排列控件的布局，通过将一个或多个其拖到另一个区域或相同区域中的其他位置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>返回先前保存的需要加载到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是实现<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 调用此方法时，它将存储由管理的自定义个性化的数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，并且以前保存稍后在初始化过程中使用的永久性的数据存储区中。  
  
> [!NOTE]
>  在大多数情况下，页面和控件开发人员代码不必调用此方法，因为它主要由 Web 部件控件集用作检索个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员会在其中使用此方法的一种情况是如果他们正在开发一个自定义个性化设置框架来代替一个提供由 Web 部件控件集。 在这种情况下，开发人员可以继承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法返回的自定义实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将调用的实现<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法在加载自定义个性化设置数据的适当时间。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含待保存的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法是实现<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 调用此方法时，它将由管理的所有个人的数据保存<xref:System.Web.UI.WebControls.WebParts.WebPartManager>为 Web 部件应用程序配置的永久性的数据存储到的控件。  
  
> [!NOTE]
>  在大多数情况下，页面和控件开发人员代码不必调用此方法，因为它主要由 Web 部件控件集用作用于保存个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员将在其中使用此方法的一种情况是如果他们正在开发一个自定义个性化设置框架来代替一个提供由 Web 部件控件集。 在这种情况下，开发人员可以继承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法返回的自定义实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将调用的实现<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />在适当的时间来保存自定义个性化设置数据的方法。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将个性化设置状态数据应用到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件，调用基方法以便能够跟踪对控件视图状态数据的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对视图状态数据的更改存储在<xref:System.Web.UI.StateBag>对象，并且可以访问通过控件的<xref:System.Web.UI.Control.ViewState%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值可使子控件可见。</summary>
        <value>一个布尔值，指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件及其子控件是否可见。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>属性始终返回值为`true`为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。 即使<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件本身不可见，请<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性应设置为`true`，以便所有子控件默认情况下可见。  
  
 如果您尝试设置的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性，它始终能生成一个错误，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件已重写基属性行为，并且可防止将任何值分配给该属性。  
  
 此属性不在可视化设计器，可绑定，而是在运行时可绑定。 有关更多信息，请参见<xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试向该属性指定一个值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已被添加到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域之后发生，以指示已成功添加了控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件将非常有用，该值指示是否动态控件 （而不是页面标记中声明，以编程方式添加控件） 已成功添加到区域。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法，该事件为开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功添加控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法后将控件添加到区域的过程已开始。 此事件提供将取消该过程完成之前的机会。 此事件添加过程是否成功后, 跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。  
  
 页面开发人员可以通过添加为事件提供自定义处理程序`OnWebPartAdding`属性为`<asp:webpartmanager>`页上，并为属性指定自定义方法名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件用于指示控件已成功关闭了，由用户或以编程方式。 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页面以便不呈现，并且还将其放在一个特殊持有对象调用页目录。 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件中，会保留对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页面的控件。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件中的页面上声明<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录显示模式，并将重新添加到一个页面之前关闭任何控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>与事件关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法，它同时引发事件，并为其提供一个处理程序。  
  
 页面开发人员可以通过添加添加事件的自定义处理程序`OnWebPartClosed`属性为`<asp:webpartmanager>`页上，然后将自定义方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的过程中关闭一个控件。 如果控件移除成功，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。  
  
 页面开发人员可以通过添加为事件提供自定义处理程序`OnWebPartClosed`属性为`<asp:webpartmanager>`页上，并为属性指定自定义方法名称中的元素。  
  
 通常情况下，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>作为用户结束的直接结果引发事件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，可以取消该事件。 但是，是不能在其中取消该事件的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控件中删除，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须全部关闭，否则它们将成为孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，不是用户。 以及何时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的过程中调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法关闭每个控件，并<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>引发事件，事件不能被取消 （按照设计），因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>需要完成的清理任务所有区域的控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域删除之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件将非常有用，该值指示从区域已成功删除动态控件 （而不是页面标记中声明，以编程方式添加控件）。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法，该事件为开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功删除控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中永久删除动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的实例的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法，在删除动态控件 （通过编程方式或通过 Web 部件用户界面的用户已添加的控件） 的过程。 事件提供将在完成之前取消该过程的机会。 如果已成功完成删除过程，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。  
  
 页面开发人员可以通过添加为事件提供自定义处理程序`OnWebPartDeleting`属性为`<asp:webpartmanager>`页上，并为属性指定自定义方法名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件已被移动到网页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件适用于 （Web 页面的标记中声明） 的静态和动态控件。 与之关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法。 由于移动完成后，引发该事件，开发人员可以包含事件处理程序来提供某些通知给用户、 一些验证或某些其他操作。 若要添加的事件处理程序，可以添加`OnWebPartMoved`属性为`<asp:webpartmanager>`页上，并分配到的属性的自定义方法的名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中包含的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>引发事件时<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件要移动其自己区域中或另一个区域。 当用户拖动控件，或以编程方式移动时，可以发生此情况。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法，并提供完成之前取消移动过程的机会。 如果移动已完成且控件放置在新的位置，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。  
  
 页面开发人员可以创建自定义事件的处理程序通过添加`OnWebPartMoving`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件所跟踪的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含对一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性可供<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来跟踪所有<xref:System.Web.UI.WebControls.WebParts.WebPart>中包含的控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>页上的区域。 尽管该集合是只读的您可以访问单个<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制通过对它们的集合并进行更改。  
  
> [!NOTE]
>  可以具有<xref:System.Web.UI.WebControls.WebParts.WebPart>之外的页面上放置控件<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，这会导致该控件不跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制或在引用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>集合。 但是，没有理由使用<xref:System.Web.UI.WebControls.WebParts.WebPart>控制区域之外，因为它然后失去其 Web 部件的功能，并且可作为正常的服务器控件。  
  
 任何类型的可放置在区域中，无论是自定义控件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 标准的 ASP.NET 控件、 一个用户控件或自定义服务器控件，可将其视为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在运行时。 当控件不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件放置在<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，在 ASP.NET 包装与控件的运行时<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，以便控件可以作真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 因此，通过使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制可以跟踪服务器控件，而不考虑是否它派生的任何类型<xref:System.Web.UI.WebControls.WebParts.WebPart>类。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性以编程方式来访问各<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 请注意，在网页上，在声明性标记内`<asp:webpartzone>`有元素是两个标准的 ASP.NET 服务器控件。 虽然这些不继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>类，因为它们是在它们将使用换行的区域中<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在运行时对象，并因此将包括在所引用的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。 您还可以添加自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 用户控件或自定义服务器控制在此区域中，并能够得到处理相同的方式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 请注意，若要运行代码示例，必须添加的设置在 Web.config 文件，以使导出 Web 部件说明文件中。 确保您有 Web 页所在的目录中为此代码示例的 Web.config 文件。 内`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 如果单击到浏览器中，加载页面后**WebPart 计数**按钮，该代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性集合中返回控件的计数。 如果单击**隐藏日历标题**按钮，代码更改日历，以便它使用仅边框和标题不呈现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或者服务器或用户控件）之间已建立特定连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>与事件关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法。 此事件非常有用，因为连接已完成后，可能想要通知的这一事实，用户或甚至更改页面的用户界面 (UI)。 例如，你可能想要显示某个建议两个控件之间的成功连接的图形图像或显示简要的消息，然后将更改页显示模式下重新浏览模式。  
  
 页面开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsConnected`属性为`<asp:webpartmanager>`页上，并为属性指定自定义方法名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或放置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中的服务器控件或用户控件）之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法，并且它表明连接过程已开始 （例如，用户已选择了某个控件并单击连接谓词），但尚未完成。 事件提供完成之前取消连接的机会。 如果连接成功完成，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。  
  
 页面开发人员可以通过添加添加事件的自定义处理程序`OnWebPartsConnecting`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>与事件关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法。 此事件非常有用，因为您知道连接终止后，你可能想要通知用户，在代码中，执行某些清除操作或在用户界面 (UI) 中进行其他更改。  
  
 页面开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsDisConnected`属性为`<asp:webpartmanager>`页上，并为属性指定自定义方法名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在结束以前连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法，并且它表明这一事实，用户已单击了断开连接的谓词，或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法已被调用。 事件提供的机会将取消该过程的完成之前结束连接。 如果连接成功结束，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。  
  
 页面开发人员可以通过添加添加事件的自定义处理程序`OnWebPartsDisconnecting`属性为`<asp:webpartmanager>`元素，并为属性指定自定义方法名称。  
  
 通常情况下，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>作为结束连接的用户的操作的直接结果引发事件，可以取消该事件。 但是，有几种方案不能在其中取消该事件。 第一个方案是，如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控件中删除，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须全部关闭，否则它们将成为孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 不用户，并已还必须能够终止任何连接的控件，而无需中断，任何可能的连接，以便它可以完成清理和关闭的过程所有控件。 因此，根据设计<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>不能在此情况下取消方法。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 第二个方案，其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能被取消时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法时 （这称为到页中，每个请求过程），并且没有某种类型的页面上的现有连接中的冲突。 例如，可能是用户在连接到控件 y，x 控件，但共享的用户连接控件 x 来控制 z，并尚未控件 x 不允许进行多个连接。 在这种情况下，连接的每个用户的设置优先，并<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件通过调用来解决冲突<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法和结束之间的连接 x 和 z 为特定的用户。 由于此断开连接是至关重要的设计解决冲突，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>不能在此情况下取消事件。  
  
 在其中的第三个方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法不能被取消时<xref:System.Web.UI.WebControls.WebParts.WebPart>或删除或关闭当前连接的服务器控件。 控件总是从页中删除，因为它是逻辑必须删除其连接。 因此，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，从而引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，根据设计不是可能，可取消事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域的集合的引用。</summary>
        <value>引用一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 区域的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性可供<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在网页上的区域。 请注意，该属性不引用所有类型的区域;它引用了派生的区域<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>类，其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
 尽管该属性引用的集合是只读的但可以使用它来访问集合中的单个对象和以编程方式使用它们。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性以编程方式来访问各<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域控件。 请注意，在 Web 页的声明性标记，有两个`<asp:webpartzone>`元素，每个包含服务器控件。 在中`<script>`部分中的页上，代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性来访问各个区域，列出所有区域的 Id，然后更改对第二个区域的背景色。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 请注意，若要运行代码示例，必须添加的设置在 Web.config 文件，以使导出 Web 部件说明文件中。 确保您有 Web 页所在的目录中为此代码示例的 Web.config 文件。 内`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 如果单击到浏览器中，加载页面后**列表区域 Id**按钮，该代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性可以列出集合中的所有区域的 Id。 如果单击**更改区域 BackColor**按钮，代码将更改第二个区域的背景色。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>