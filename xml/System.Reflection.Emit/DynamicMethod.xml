<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="13b1d9daf4a4d7aae5b5478565ec2459bbd08759" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69070986" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9329e-101">定义并表示一种可编译、执行和丢弃的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-101">Defines and represents a dynamic method that can be compiled, executed, and discarded.</span></span> <span data-ttu-id="9329e-102">丢弃的方法可用于垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="9329e-102">Discarded methods are available for garbage collection.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-103">您可以使用<xref:System.Reflection.Emit.DynamicMethod>类在运行时生成和执行方法, 而不必生成动态程序集和动态类型来包含方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-103">You can use the <xref:System.Reflection.Emit.DynamicMethod> class to generate and execute a method at run time, without having to generate a dynamic assembly and a dynamic type to contain the method.</span></span> <span data-ttu-id="9329e-104">回收<xref:System.Reflection.Emit.DynamicMethod>对象时, 由实时 (JIT) 编译器创建的可执行代码将被回收。</span><span class="sxs-lookup"><span data-stu-id="9329e-104">The executable code created by the just-in-time (JIT) compiler is reclaimed when the <xref:System.Reflection.Emit.DynamicMethod> object is reclaimed.</span></span> <span data-ttu-id="9329e-105">动态方法是生成和执行少量代码的最有效方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-105">Dynamic methods are the most efficient way to generate and execute small amounts of code.</span></span>  
  
 <span data-ttu-id="9329e-106">动态方法可以是匿名承载的, 也可以逻辑上与模块或类型相关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-106">A dynamic method can be anonymously hosted, or it can be logically associated with a module or with a type.</span></span>  
  
-   <span data-ttu-id="9329e-107">如果动态方法是匿名承载的, 则该方法位于系统提供的程序集中, 因此与其他代码隔离。</span><span class="sxs-lookup"><span data-stu-id="9329e-107">If the dynamic method is anonymously hosted, it is located in a system-provided assembly, and therefore is isolated from other code.</span></span> <span data-ttu-id="9329e-108">默认情况下, 它无权访问任何非公共数据。</span><span class="sxs-lookup"><span data-stu-id="9329e-108">By default, it does not have access to any non-public data.</span></span> <span data-ttu-id="9329e-109">匿名托管的动态方法可以具有跳过 JIT 编译器的可见性检查的受限能力, 前提是该方法<xref:System.Security.Permissions.ReflectionPermission>已被<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>授予标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-109">An anonymously hosted dynamic method can have restricted ability to skip the JIT compiler's visibility checks, if it has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-110">动态方法访问其非公共成员的程序集的信任级别必须等于发出动态方法的调用堆栈的信任级别 (或的子集)。</span><span class="sxs-lookup"><span data-stu-id="9329e-110">The trust level of the assembly whose non-public members are accessed by the dynamic method must be equal to, or a subset of, the trust level of the call stack that emitted the dynamic method.</span></span> <span data-ttu-id="9329e-111">有关匿名承载的动态方法的详细信息, [请参阅演练:在部分信任方案](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)中发出代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-111">For more information about anonymously hosted dynamic methods, see [Walkthrough: Emitting Code in Partial Trust Scenarios](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).</span></span>  
  
-   <span data-ttu-id="9329e-112">如果动态方法与指定的模块相关联, 动态方法将在该模块中有效地成为全局方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-112">If the dynamic method is associated with a module that you specify, the dynamic method is effectively global to that module.</span></span> <span data-ttu-id="9329e-113">它可以访问模块中的所有类型以及这些`internal`类型`Friend`的所有 (在 Visual Basic 中) 成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-113">It can access all types in the module and all `internal` (`Friend` in Visual Basic) members of the types.</span></span> <span data-ttu-id="9329e-114">无论是否已创建模块, 都可以将动态方法与任何模块相关联, 前提是包含代码的调用<xref:System.Security.Permissions.ReflectionPermission>堆栈可以<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>满足带标志的请求。</span><span class="sxs-lookup"><span data-stu-id="9329e-114">You can associate a dynamic method with any module, regardless of whether you created the module, provided that a demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag can be satisfied by the call stack that includes your code.</span></span> <span data-ttu-id="9329e-115">如果该<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志包含在 grant 中, 则动态方法可以跳过 JIT 编译器的可见性检查并访问在该模块中声明的所有类型的私有数据或任何程序集中的任何其他模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-115">If the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag is included in the grant, the dynamic method can skip the JIT compiler's visibility checks and access the private data of all types declared in the module or in any other module in any assembly.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9329e-116">指定与动态方法关联的模块时, 该模块不得位于系统提供的程序集中, 该程序集用于匿名托管。</span><span class="sxs-lookup"><span data-stu-id="9329e-116">When you specify the module with which a dynamic method is associated, that module must not be in the system-provided assembly that is used for anonymous hosting.</span></span>  
  
-   <span data-ttu-id="9329e-117">如果动态方法与指定的类型相关联, 则它有权访问该类型的所有成员, 而不考虑访问级别。</span><span class="sxs-lookup"><span data-stu-id="9329e-117">If the dynamic method is associated with a type that you specify, it has access to all members of the type, regardless of access level.</span></span> <span data-ttu-id="9329e-118">此外, 还可以跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-118">In addition, JIT visibility checks can be skipped.</span></span> <span data-ttu-id="9329e-119">这为动态方法提供对在同一模块中或在任何程序集中的任何其他模块中声明的其他类型的私有数据的访问。</span><span class="sxs-lookup"><span data-stu-id="9329e-119">This gives the dynamic method access to the private data of other types declared in the same module or in any other module in any assembly.</span></span> <span data-ttu-id="9329e-120">可以将动态方法与任何类型相关联, 但必须<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>同时向代码授予和<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-120">You can associate a dynamic method with any type, but your code must be granted <xref:System.Security.Permissions.ReflectionPermission> with both the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> and <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flags.</span></span>  
  
 <span data-ttu-id="9329e-121">下表显示了匿名托管的动态方法可访问的类型和成员 (带有和不带 JIT 可见性检查), 具体<xref:System.Security.Permissions.ReflectionPermission>取决于<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>是否授予了标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-121">The following table shows which types and members are accessible to an anonymously hosted dynamic method, with and without JIT visibility checks, depending on whether <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag is granted.</span></span>  
  
||<span data-ttu-id="9329e-122">没有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess></span><span class="sxs-lookup"><span data-stu-id="9329e-122">Without <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess></span></span>|<span data-ttu-id="9329e-123">通过 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess></span><span class="sxs-lookup"><span data-stu-id="9329e-123">With <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess></span></span>|  
|-|-|-|  
|<span data-ttu-id="9329e-124">不跳过 JIT 可见性检查</span><span class="sxs-lookup"><span data-stu-id="9329e-124">Without skipping JIT visibility checks</span></span>|<span data-ttu-id="9329e-125">任何程序集中公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-125">Public members of public types in any assembly.</span></span>|<span data-ttu-id="9329e-126">任何程序集中公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-126">Public members of public types in any assembly.</span></span>|  
|<span data-ttu-id="9329e-127">跳过 JIT 可见性检查, 但有限制</span><span class="sxs-lookup"><span data-stu-id="9329e-127">Skipping JIT visibility checks, with restrictions</span></span>|<span data-ttu-id="9329e-128">任何程序集中公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-128">Public members of public types in any assembly.</span></span>|<span data-ttu-id="9329e-129">所有类型的所有成员, 仅在其信任级别等于或小于发出动态方法的程序集的信任级别的程序集中。</span><span class="sxs-lookup"><span data-stu-id="9329e-129">All members of all types, only in assemblies whose trust levels are equal to or less than the trust level of the assembly that emitted the dynamic method.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="9329e-130">在[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前, 发出<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标记所需<xref:System.Security.Permissions.ReflectionPermission>的代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-130">Prior to the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-131">默认情况下, 此权限包含在 FullTrust 和 LocalIntranet 命名权限集中, 而不是在 Internet 权限集中。</span><span class="sxs-lookup"><span data-stu-id="9329e-131">This permission is included by default in the FullTrust and LocalIntranet named permission sets, but not in the Internet permission set.</span></span> <span data-ttu-id="9329e-132">因此, [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]在早期版本的库中, 只有当库<xref:System.Security.SecurityCriticalAttribute>具有<xref:System.Security.PermissionSet.Assert%2A>特性并为<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>执行时, 才能与 Internet 权限一起使用。</span><span class="sxs-lookup"><span data-stu-id="9329e-132">Therefore, in earlier versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] a library can be used with Internet permissions only if it has the <xref:System.Security.SecurityCriticalAttribute> attribute and also executes an <xref:System.Security.PermissionSet.Assert%2A> for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="9329e-133">这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="9329e-133">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="9329e-134">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-134">The [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="9329e-135">也就是说，生成的代码不会具有比发出它的程序集更多的权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-135">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="9329e-136">这使得发出代码的库是安全透明的，且不再需要断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，这简化了编写安全库任务。</span><span class="sxs-lookup"><span data-stu-id="9329e-136">This allows libraries that emit code to be security transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, which simplifies the task of writing a secure library.</span></span> <span data-ttu-id="9329e-137">若要使用此功能, 应用程序应面向[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-137">To use this feature, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="9329e-138">下表显示了与模块或模块中的类型相关联的动态方法可以访问的类型和成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-138">The following table shows which types and members are accessible to a dynamic method that is associated with a module or with a type in a module.</span></span>  
  
||<span data-ttu-id="9329e-139">与模块关联</span><span class="sxs-lookup"><span data-stu-id="9329e-139">Associated with module</span></span>|<span data-ttu-id="9329e-140">与类型关联</span><span class="sxs-lookup"><span data-stu-id="9329e-140">Associated with type</span></span>|  
|-|-|-|  
|<span data-ttu-id="9329e-141">不跳过 JIT 可见性检查</span><span class="sxs-lookup"><span data-stu-id="9329e-141">Without skipping JIT visibility checks</span></span>|<span data-ttu-id="9329e-142">模块中公共类型、内部类型和私有类型的公共和内部成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-142">Public and internal members of public, internal, and private types in the module.</span></span><br /><br /> <span data-ttu-id="9329e-143">任何程序集中公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-143">Public members of public types in any assembly.</span></span>|<span data-ttu-id="9329e-144">关联类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-144">All members of the associated type.</span></span> <span data-ttu-id="9329e-145">模块中所有其他类型的公共和内部成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-145">Public and internal members of all the other types in the module.</span></span><br /><br /> <span data-ttu-id="9329e-146">任何程序集中公共类型的公共成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-146">Public members of public types in any assembly.</span></span>|  
|<span data-ttu-id="9329e-147">跳过 JIT 可见性检查</span><span class="sxs-lookup"><span data-stu-id="9329e-147">Skipping JIT visibility checks</span></span>|<span data-ttu-id="9329e-148">所有程序集中的所有类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-148">All members of all types in any assembly.</span></span>|<span data-ttu-id="9329e-149">所有程序集中的所有类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-149">All members of all types in any assembly.</span></span>|  
  
 <span data-ttu-id="9329e-150">与模块关联的动态方法具有该模块的权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-150">A dynamic method that is associated with a module has the permissions of that module.</span></span> <span data-ttu-id="9329e-151">与某一类型关联的动态方法具有包含该类型的模块的权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-151">A dynamic method that is associated with a type has the permissions of the module containing that type.</span></span>  
  
 <span data-ttu-id="9329e-152">动态方法及其参数无需命名, 但你可以指定名称来帮助进行调试。</span><span class="sxs-lookup"><span data-stu-id="9329e-152">Dynamic methods and their parameters do not have to be named, but you can specify names to assist in debugging.</span></span> <span data-ttu-id="9329e-153">动态方法或其参数不支持自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-153">Custom attributes are not supported on dynamic methods or their parameters.</span></span>  
  
 <span data-ttu-id="9329e-154">尽管动态方法是`static`方法 (`Shared` Visual Basic 中的方法), 但中引入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]委托绑定的宽松规则允许将动态方法绑定到对象, 以便在使用该委托实例调用。</span><span class="sxs-lookup"><span data-stu-id="9329e-154">Although dynamic methods are `static` methods (`Shared` methods in Visual Basic), the relaxed rules for delegate binding introduced in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] allow a dynamic method to be bound to an object, so that it acts like an instance method when called using that delegate instance.</span></span> <span data-ttu-id="9329e-155">此示例演示了如何为<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载提供此方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-155">An example that demonstrates this is provided for the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-156">在中[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 动态方法不支持符号信息, 即局部变量名称和行号映射。</span><span class="sxs-lookup"><span data-stu-id="9329e-156">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], dynamic methods do not support symbol information, that is, local variable names and line-number mapping.</span></span> <span data-ttu-id="9329e-157">在将来的版本中可能会删除此限制。</span><span class="sxs-lookup"><span data-stu-id="9329e-157">This limitation might be removed in a future version.</span></span> <span data-ttu-id="9329e-158">你可以在<xref:System.Reflection.Emit.AssemblyBuilder>开发过程中使用来简化生成的 Microsoft 中间语言 (MSIL) 的调试, 然后在最终部署过程中切换到动态<xref:System.Reflection.Emit.ILGenerator>方法, 因为这两种情况下的调用都是相同的。</span><span class="sxs-lookup"><span data-stu-id="9329e-158">You can use <xref:System.Reflection.Emit.AssemblyBuilder> during development to simplify debugging the generated Microsoft intermediate language (MSIL), and then switch to dynamic methods during final deployment, because the <xref:System.Reflection.Emit.ILGenerator> calls are the same in both cases.</span></span>  
  
## <a name="verification"></a><span data-ttu-id="9329e-159">确认</span><span class="sxs-lookup"><span data-stu-id="9329e-159">Verification</span></span>  
 <span data-ttu-id="9329e-160">下面的列表汇总了动态方法可包含无法验证的代码的情况。</span><span class="sxs-lookup"><span data-stu-id="9329e-160">The following list summarizes the conditions under which dynamic methods can contain unverifiable code.</span></span> <span data-ttu-id="9329e-161">(例如, 如果动态方法的属性设置为, <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>则无法`false`对其进行验证。)</span><span class="sxs-lookup"><span data-stu-id="9329e-161">(For example, a dynamic method is unverifiable if its <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> property is set to `false`.)</span></span>  
  
-   <span data-ttu-id="9329e-162">与安全关键程序集关联的动态方法也是安全关键的, 可跳过验证。</span><span class="sxs-lookup"><span data-stu-id="9329e-162">A dynamic method that is associated with a security-critical assembly is also security-critical, and can skip verification.</span></span> <span data-ttu-id="9329e-163">例如, 如果程序集不具有作为桌面应用程序运行的安全属性, 则运行时将其视为安全关键。</span><span class="sxs-lookup"><span data-stu-id="9329e-163">For example, an assembly without security attributes that is run as a desktop application is treated as security-critical by the runtime.</span></span> <span data-ttu-id="9329e-164">如果将动态方法与程序集相关联, 则动态方法可能包含不可验证的代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-164">If you associate a dynamic method with the assembly, the dynamic method can contain unverifiable code.</span></span>  
  
-   <span data-ttu-id="9329e-165">如果包含不可验证代码的动态方法与具有级别1透明度的程序集相关联, 则实时 (JIT) 编译器将注入安全要求。</span><span class="sxs-lookup"><span data-stu-id="9329e-165">If a dynamic method that contains unverifiable code is associated with an assembly that has level 1 transparency, the just-in-time (JIT) compiler injects a security demand.</span></span> <span data-ttu-id="9329e-166">仅当动态方法由完全受信任的代码执行时, 请求才会成功。</span><span class="sxs-lookup"><span data-stu-id="9329e-166">The demand succeeds only if the dynamic method is executed by fully trusted code.</span></span> <span data-ttu-id="9329e-167">请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-167">See [Security-Transparent Code, Level 1](~/docs/framework/misc/security-transparent-code-level-1.md).</span></span>  
  
-   <span data-ttu-id="9329e-168">如果包含不可验证代码的动态方法与具有2级透明度 (如 mscorlib.dll) 的程序集相关联, 则它会引发异常 (由 JIT 编译器注入), 而不是发出安全要求。</span><span class="sxs-lookup"><span data-stu-id="9329e-168">If a dynamic method that contains unverifiable code is associated with an assembly that has level 2 transparency (such as mscorlib.dll), it throws an exception (injected by the JIT compiler) instead of making a security demand.</span></span> <span data-ttu-id="9329e-169">请参阅[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-169">See [Security-Transparent Code, Level 2](~/docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
-   <span data-ttu-id="9329e-170">包含不可验证的代码的匿名托管动态方法始终引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-170">An anonymously hosted dynamic method that contains unverifiable code always throws an exception.</span></span> <span data-ttu-id="9329e-171">即使它是由完全受信任的代码创建和执行的, 它也永远不会跳过验证。</span><span class="sxs-lookup"><span data-stu-id="9329e-171">It can never skip verification, even if it is created and executed by fully trusted code.</span></span>  
  
 <span data-ttu-id="9329e-172">对于不可验证的代码引发的异常会根据动态方法的调用方式而有所不同。</span><span class="sxs-lookup"><span data-stu-id="9329e-172">The exception that is thrown for unverifiable code varies depending on the way the dynamic method is invoked.</span></span> <span data-ttu-id="9329e-173">如果使用从<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法返回的委托调用动态方法<xref:System.Security.VerificationException> , 则将引发。</span><span class="sxs-lookup"><span data-stu-id="9329e-173">If you invoke a dynamic method by using a delegate returned from the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> method, a <xref:System.Security.VerificationException> is thrown.</span></span> <span data-ttu-id="9329e-174">如果通过使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法<xref:System.Reflection.TargetInvocationException> , 则将引发与内部<xref:System.Security.VerificationException>的。</span><span class="sxs-lookup"><span data-stu-id="9329e-174">If you invoke the dynamic method by using the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method, a <xref:System.Reflection.TargetInvocationException> is thrown with an inner <xref:System.Security.VerificationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-175">下面的代码示例创建一个带有两个参数的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-175">The following code example creates a dynamic method that takes two parameters.</span></span> <span data-ttu-id="9329e-176">该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-176">The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</span></span> <span data-ttu-id="9329e-177">该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-177">The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-178">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-178">How to: Define and Execute Dynamic Methods</span></span></related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-179">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-179">Security Issues in Reflection Emit</span></span></related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md"><span data-ttu-id="9329e-180">演练：在部分信任应用场景中发出代码</span><span class="sxs-lookup"><span data-stu-id="9329e-180">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9329e-181">创建动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-181">Creates a dynamic method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-182">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-182">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-183">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-183">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-184">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-184">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-185">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-185">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <summary><span data-ttu-id="9329e-186">初始化匿名承载的动态方法，指定方法名称、返回类型和参数类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-186">Initializes an anonymously hosted dynamic method, specifying the method name, return type, and parameter types.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-187">此构造函数创建的动态方法与匿名程序集相关联, 而不是与现有类型或模块关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-187">The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</span></span> <span data-ttu-id="9329e-188">匿名程序集的存在只是为了为动态方法提供沙盒环境, 即, 将它们与其他代码隔离开来。</span><span class="sxs-lookup"><span data-stu-id="9329e-188">The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</span></span> <span data-ttu-id="9329e-189">此环境使动态方法可由部分受信任的代码发出并执行。</span><span class="sxs-lookup"><span data-stu-id="9329e-189">This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</span></span>  
  
 <span data-ttu-id="9329e-190">此构造函数指定将对动态方法的 Microsoft 中间语言 (MSIL) 强制执行实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-190">This constructor specifies that just-in-time (JIT) visibility checks will be enforced for the Microsoft intermediate language (MSIL) of the dynamic method.</span></span> <span data-ttu-id="9329e-191">也就是说, 动态方法中的代码可以访问公共类的公共方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-191">That is, the code in the dynamic method has access to public methods of public classes.</span></span> <span data-ttu-id="9329e-192">如果方法尝试访问的类型或`private`成员为、或`internal` (`Friend`在 Visual Basic 中`protected`), 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-192">Exceptions are thrown if the method tries to access types or members that are `private`, `protected`, or `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="9329e-193">若要创建具有跳过 JIT 可见性检查的受限能力的动态方法, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>请使用构造函数。</span><span class="sxs-lookup"><span data-stu-id="9329e-193">To create a dynamic method that has restricted ability to skip JIT visibility checks, use the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor.</span></span>  
  
 <span data-ttu-id="9329e-194">构造匿名托管的动态方法时, 将包含发出程序集的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="9329e-194">When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</span></span> <span data-ttu-id="9329e-195">调用方法时, 将使用发出程序集的权限, 而不是实际调用方的权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-195">When the method is invoked, the permissions of the emitting assembly are used instead of the permissions of the actual caller.</span></span> <span data-ttu-id="9329e-196">因此, 动态方法无法以比发出它的程序集更高的特权级别执行, 即使该方法传递到并且由具有较高信任级别的程序集执行。</span><span class="sxs-lookup"><span data-stu-id="9329e-196">Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</span></span>  
  
 <span data-ttu-id="9329e-197">此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9329e-197">This constructor specifies the method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, and the calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-198">此构造函数是在或[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]更高版本中引入的。</span><span class="sxs-lookup"><span data-stu-id="9329e-198">This constructor was introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-199"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-199">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-200"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-200"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-201"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-201"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-202">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-202">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-203">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-203">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md"><span data-ttu-id="9329e-204">演练：在部分信任应用场景中发出代码</span><span class="sxs-lookup"><span data-stu-id="9329e-204">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-205">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-205">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-206">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-206">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-207">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-207">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-208">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-208">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="restrictedSkipVisibility"><span data-ttu-id="9329e-209">如果为 <see langword="true" />，则跳过针对动态方法的 MSIL 访问的类型和成员进行的 JIT 可见性检查，含此限制：包含这些类型和成员的程序集的信任级别必须等于或小于发出动态方法的调用堆栈的信任级别；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-209"><see langword="true" /> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method, with this restriction: the trust level of the assemblies that contain those types and members must be equal to or less than the trust level of the call stack that emits the dynamic method; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9329e-210">初始化匿名托管的动态方法，同时指定方法名称、返回类型、参数类型并指定是否应针对动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-210">Initializes an anonymously hosted dynamic method, specifying the method name, return type, parameter types, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-211">此构造函数创建的动态方法与匿名程序集相关联, 而不是与现有类型或模块关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-211">The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</span></span> <span data-ttu-id="9329e-212">匿名程序集的存在只是为了为动态方法提供沙盒环境, 即, 将它们与其他代码隔离开来。</span><span class="sxs-lookup"><span data-stu-id="9329e-212">The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</span></span> <span data-ttu-id="9329e-213">此环境使动态方法可由部分受信任的代码发出并执行。</span><span class="sxs-lookup"><span data-stu-id="9329e-213">This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</span></span>  
  
 <span data-ttu-id="9329e-214">匿名`private`托管的`protected`动态方法`Friend`不能自动访问任何类型或成员(在VisualBasic中)。`internal`</span><span class="sxs-lookup"><span data-stu-id="9329e-214">Anonymously hosted dynamic methods do not have automatic access to any types or members that are `private`, `protected`, or `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="9329e-215">这不同于与现有类型或模块关联的动态方法, 这些方法可以访问其关联范围内的隐藏成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-215">This is different from dynamic methods that are associated with an existing type or module, which have access to hidden members in their associated scope.</span></span>  
  
 <span data-ttu-id="9329e-216">`true` `private`如果动态`protected`方法必须访问、或`internal`类型的类型或成员, 请指定。 `restrictedSkipVisibility`</span><span class="sxs-lookup"><span data-stu-id="9329e-216">Specify `true` for `restrictedSkipVisibility` if your dynamic method has to access types or members that are `private`, `protected`, or `internal`.</span></span> <span data-ttu-id="9329e-217">这为动态方法授予了对这些成员的有限访问权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-217">This gives the dynamic method restricted access to these members.</span></span> <span data-ttu-id="9329e-218">也就是说, 仅当满足以下条件时, 才能访问成员:</span><span class="sxs-lookup"><span data-stu-id="9329e-218">That is, the members can be accessed only if the following conditions are met:</span></span>  
  
-   <span data-ttu-id="9329e-219">目标成员属于具有等于或小于发出动态方法的调用堆栈的信任级别的程序集。</span><span class="sxs-lookup"><span data-stu-id="9329e-219">The target members belong to an assembly that has a level of trust equal to or lower than the call stack that emits the dynamic method.</span></span>  
  
-   <span data-ttu-id="9329e-220">向发出动态方法的调用堆栈授予<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-220">The call stack that emits the dynamic method is granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-221">在完全信任的情况下执行代码时, 这始终为 true。</span><span class="sxs-lookup"><span data-stu-id="9329e-221">This is always true when the code is executed with full trust.</span></span> <span data-ttu-id="9329e-222">对于部分受信任的代码, 仅当主机显式授予权限时才为 true。</span><span class="sxs-lookup"><span data-stu-id="9329e-222">For partially trusted code, it is true only if the host explicitly grants the permission.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="9329e-223">如果尚未授予该权限, 则在<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用或调用动态方法时, 而不是在调用此构造函数时, 将引发安全异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-223">If the permission has not been granted, a security exception is thrown when <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> is called or when the dynamic method is invoked, not when this constructor is called.</span></span> <span data-ttu-id="9329e-224">发出动态方法不需要任何特殊权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-224">No special permissions are required to emit the dynamic method.</span></span>  
  
 <span data-ttu-id="9329e-225">例如, 如果已向调用堆栈授予受限成员`restrictedSkipVisibility`访问权限`true` , 则使用设置为的创建的动态方法可以访问调用堆栈上任何程序集的私有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-225">For example, a dynamic method that is created with `restrictedSkipVisibility` set to `true` can access a private member of any assembly on the call stack if the call stack has been granted restricted member access.</span></span> <span data-ttu-id="9329e-226">如果动态方法是使用调用堆栈上部分受信任的代码创建的, 则它无法访问[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]程序集中类型的私有成员, 因为此类程序集是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="9329e-226">If the dynamic method is created with partially trusted code on the call stack, it cannot access a private member of a type in a [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] assembly, because such assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="9329e-227">如果`restrictedSkipVisibility` 为`false`, 则强制执行 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-227">If `restrictedSkipVisibility` is `false`, JIT visibility checks are enforced.</span></span> <span data-ttu-id="9329e-228">动态方法中的代码有权访问公共类的公共方法, 如果尝试访问的类型或成员`private`为、 `protected`或`internal`, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-228">The code in the dynamic method has access to public methods of public classes, and exceptions are thrown if it tries to access types or members that are `private`, `protected`, or `internal`.</span></span>  
  
 <span data-ttu-id="9329e-229">构造匿名托管的动态方法时, 将包含发出程序集的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="9329e-229">When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</span></span> <span data-ttu-id="9329e-230">调用方法时, 将使用发出调用堆栈的权限, 而不是实际调用方的权限。</span><span class="sxs-lookup"><span data-stu-id="9329e-230">When the method is invoked, the permissions of the emitting call stack are used instead of the permissions of the actual caller.</span></span> <span data-ttu-id="9329e-231">因此, 动态方法无法以比发出它的程序集更高的特权级别执行, 即使该方法传递到并且由具有较高信任级别的程序集执行。</span><span class="sxs-lookup"><span data-stu-id="9329e-231">Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</span></span>  
  
 <span data-ttu-id="9329e-232">此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9329e-232">This constructor specifies the method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, and the calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-233">此构造函数是在或[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]更高版本中引入的。</span><span class="sxs-lookup"><span data-stu-id="9329e-233">This constructor was introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-234"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-234">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-235"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-235"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-236"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-236"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-237">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-237">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-238">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-238">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md"><span data-ttu-id="9329e-239">演练：在部分信任应用场景中发出代码</span><span class="sxs-lookup"><span data-stu-id="9329e-239">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-240">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-240">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-241">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-241">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-242">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-242">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-243">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-243">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="m"><span data-ttu-id="9329e-244">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-244">A <see cref="T:System.Reflection.Module" /> representing the module with which the dynamic method is to be logically associated.</span></span></param>
        <summary><span data-ttu-id="9329e-245">创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-245">Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, and module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-246">此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 而不会跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-246">This constructor specifies method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, and does not skip just-in-time (JIT) visibility checks.</span></span>  
  
 <span data-ttu-id="9329e-247">使用此构造函数创建的动态方法可以访问模块`internal` `m`中包含`Friend`的所有类型的公共和 (在 Visual Basic) 成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-247">The dynamic method created with this constructor has access to public and `internal` (`Friend` in Visual Basic) members of all the types contained in module `m`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-248">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-248">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `m` is a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-249">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-249">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-250">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-250">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-251">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-251">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-252">下面的代码示例创建一个带有两个参数的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-252">The following code example creates a dynamic method that takes two parameters.</span></span> <span data-ttu-id="9329e-253">该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-253">The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</span></span> <span data-ttu-id="9329e-254">该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法调用动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-254">The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-255"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-255">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-256">或</span><span class="sxs-lookup"><span data-stu-id="9329e-256">-or-</span></span> 
 <span data-ttu-id="9329e-257"><paramref name="m" /> 是为动态方法提供匿名承载的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-257"><paramref name="m" /> is a module that provides anonymous hosting for dynamic methods.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-258"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-258"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-259">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-259">-or-</span></span> 
 <span data-ttu-id="9329e-260"><paramref name="m" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-260"><paramref name="m" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-261"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-261"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-262">将动态方法与调用模块以外的模块关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-262">to associate the dynamic method with a module other than the calling module.</span></span> <span data-ttu-id="9329e-263">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-263">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-264">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-264">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-265">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-265">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-266">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-266">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-267">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-267">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-268">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-268">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-269">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9329e-269">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="owner"><span data-ttu-id="9329e-270">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-270">A <see cref="T:System.Type" /> with which the dynamic method is logically associated.</span></span> <span data-ttu-id="9329e-271">动态方法可以访问类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-271">The dynamic method has access to all members of the type.</span></span></param>
        <summary><span data-ttu-id="9329e-272">创建一个动态方法，指定方法名称、返回类型、参数类型和动态方法逻辑关联的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-272">Creates a dynamic method, specifying the method name, return type, parameter types, and the type with which the dynamic method is logically associated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-273">使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含`owner`的模块中所有其他类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。</span><span class="sxs-lookup"><span data-stu-id="9329e-273">The dynamic method created with this constructor has access to all members of the type `owner`, and to public and `internal` (`Friend` in Visual Basic) members of all the other types in the module that contains `owner`.</span></span>  
  
 <span data-ttu-id="9329e-274">此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 而不会跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-274">This constructor specifies method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, and does not skip just-in-time (JIT) visibility checks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-275">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-275">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `owner` is in a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-276">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-276">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-277">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-277">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-278">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-278">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-279">下面的代码示例创建一个<xref:System.Reflection.Emit.DynamicMethod>与类型逻辑上关联的。</span><span class="sxs-lookup"><span data-stu-id="9329e-279">The following code example creates a <xref:System.Reflection.Emit.DynamicMethod> that is logically associated with a type.</span></span> <span data-ttu-id="9329e-280">此关联使其能够访问该类型的私有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-280">This association gives it access to the private members of that type.</span></span>  
  
 <span data-ttu-id="9329e-281">此代码示例定义了一个名`Example`为的类, 该类具有私有字段`DerivedFromExample` , 该类是从第一个类派生的名为`UseLikeStatic`的类, 它是一个名`Example`为的委托类型, 它返回<xref:System.Int32>并具有类型为和<xref:System.Int32>和一个名为`UseLikeInstance`的委托类型, 它返回<xref:System.Int32>并具有一个类型<xref:System.Int32>为的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-281">The code example defines a class named `Example` with a private field, a class named `DerivedFromExample` that derives from the first class, a delegate type named `UseLikeStatic` that returns <xref:System.Int32> and has parameters of type `Example` and <xref:System.Int32>, and a delegate type named `UseLikeInstance` that returns <xref:System.Int32> and has one parameter of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="9329e-282">然后, 该代码示例创建<xref:System.Reflection.Emit.DynamicMethod>一个, 它将更改`Example`实例的私有字段并返回以前的值。</span><span class="sxs-lookup"><span data-stu-id="9329e-282">The example code then creates a <xref:System.Reflection.Emit.DynamicMethod> that changes the private field of an instance of `Example` and returns the previous value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-283">通常, 更改类的内部字段并不是面向对象的适当编码做法。</span><span class="sxs-lookup"><span data-stu-id="9329e-283">In general, changing the internal fields of classes is not good object-oriented coding practice.</span></span>  
  
 <span data-ttu-id="9329e-284">示例代码创建的`Example`实例, 然后创建两个委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-284">The example code creates an instance of `Example` and then creates two delegates.</span></span> <span data-ttu-id="9329e-285">第一个类型`UseLikeStatic`为, 它具有与动态方法相同的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-285">The first is of type `UseLikeStatic`, which has the same parameters as the dynamic method.</span></span> <span data-ttu-id="9329e-286">第二种类型`UseLikeInstance`为, 它缺少第一个参数 (类型`Example`为)。</span><span class="sxs-lookup"><span data-stu-id="9329e-286">The second is of type `UseLikeInstance`, which lacks the first parameter (of type `Example`).</span></span> <span data-ttu-id="9329e-287">此委托是使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载创建的; 此方法重载的第二个参数是的`Example`实例, 在本例中为刚创建的实例, 该实例绑定到新创建的委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-287">This delegate is created using the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> method overload; the second parameter of that method overload is an instance of `Example`, in this case the instance just created, which is bound to the newly created delegate.</span></span> <span data-ttu-id="9329e-288">无论何时调用该委托, 动态方法都将对的绑定实例`Example`起作用。</span><span class="sxs-lookup"><span data-stu-id="9329e-288">Whenever that delegate is invoked, the dynamic method acts on the bound instance of `Example`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-289">这是中引入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]委托绑定的宽松规则的示例, 以及<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法的新重载。</span><span class="sxs-lookup"><span data-stu-id="9329e-289">This is an example of the relaxed rules for delegate binding introduced in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], along with new overloads of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9329e-290">有关更多信息，请参见 <xref:System.Delegate> 类。</span><span class="sxs-lookup"><span data-stu-id="9329e-290">For more information, see the <xref:System.Delegate> class.</span></span>  
  
 <span data-ttu-id="9329e-291">调用委托, 并传入绑定到`UseLikeInstance`委托的的`Example`实例。 `UseLikeStatic`</span><span class="sxs-lookup"><span data-stu-id="9329e-291">The `UseLikeStatic` delegate is invoked, passing in the instance of `Example` that is bound to the `UseLikeInstance` delegate.</span></span> <span data-ttu-id="9329e-292">然后调用`Example`委托, 使这两个委托对相同的实例执行操作。 `UseLikeInstance`</span><span class="sxs-lookup"><span data-stu-id="9329e-292">Then the `UseLikeInstance` delegate is invoked, so that both delegates act on the same instance of `Example`.</span></span> <span data-ttu-id="9329e-293">在每次调用后, 将显示内部字段的值中的更改。</span><span class="sxs-lookup"><span data-stu-id="9329e-293">The changes in the values of the internal field are displayed after each call.</span></span> <span data-ttu-id="9329e-294">最后, `UseLikeInstance`委托绑定到的`DerivedFromExample`实例, 并且委托调用重复。</span><span class="sxs-lookup"><span data-stu-id="9329e-294">Finally, a `UseLikeInstance` delegate is bound to an instance of `DerivedFromExample`, and the delegate calls are repeated.</span></span>  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-295"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-295">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-296">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-296">-or-</span></span> 
 <span data-ttu-id="9329e-297"><paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-297"><paramref name="owner" /> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-298"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-298"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-299">或</span><span class="sxs-lookup"><span data-stu-id="9329e-299">-or-</span></span> 
 <span data-ttu-id="9329e-300"><paramref name="owner" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-300"><paramref name="owner" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-301"><paramref name="returnType" /> 为 <see langword="null" />，或者为 <see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-301"><paramref name="returnType" /> is <see langword="null" />, or is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-302">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。</span><span class="sxs-lookup"><span data-stu-id="9329e-302">to associate the dynamic method with a type in a module other than the calling module.</span></span> <span data-ttu-id="9329e-303">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-303">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-304">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-304">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-305">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-305">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-306">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-306">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-307">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-307">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-308">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-308">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-309">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-309">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="m"><span data-ttu-id="9329e-310">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-310">A <see cref="T:System.Reflection.Module" /> representing the module with which the dynamic method is to be logically associated.</span></span></param>
        <param name="skipVisibility"><span data-ttu-id="9329e-311">要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-311"><see langword="true" /> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method.</span></span></param>
        <summary><span data-ttu-id="9329e-312">创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-312">Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-313">此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>特性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9329e-313">This constructor specifies method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, and calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9329e-314">使用此构造函数创建的动态方法有权访问包含`internal`模块`Friend` `m`中所有类型的公共和 (在 Visual Basic) 成员中。</span><span class="sxs-lookup"><span data-stu-id="9329e-314">The dynamic method created with this constructor has access to public and `internal` (`Friend` in Visual Basic) members of all the types in contained module `m`.</span></span> <span data-ttu-id="9329e-315">通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-315">Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</span></span> <span data-ttu-id="9329e-316">例如, 在编写代码以序列化对象时, 这很有用。</span><span class="sxs-lookup"><span data-stu-id="9329e-316">This is useful, for example, when writing code to serialize objects.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-317">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-317">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `m` is a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-318">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-318">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-319">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-319">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-320">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-320">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-321"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-321">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-322">或</span><span class="sxs-lookup"><span data-stu-id="9329e-322">-or-</span></span> 
 <span data-ttu-id="9329e-323"><paramref name="m" /> 是为动态方法提供匿名承载的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-323"><paramref name="m" /> is a module that provides anonymous hosting for dynamic methods.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-324"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-324"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-325">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-325">-or-</span></span> 
 <span data-ttu-id="9329e-326"><paramref name="m" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-326"><paramref name="m" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-327"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-327"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-328">将动态方法与调用模块以外的模块关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-328">to associate the dynamic method with a module other than the calling module.</span></span> <span data-ttu-id="9329e-329">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-329">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-330">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-330">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-331">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-331">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-332">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-332">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-333">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-333">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-334">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-334">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-335">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9329e-335">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="owner"><span data-ttu-id="9329e-336">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-336">A <see cref="T:System.Type" /> with which the dynamic method is logically associated.</span></span> <span data-ttu-id="9329e-337">动态方法可以访问类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-337">The dynamic method has access to all members of the type.</span></span></param>
        <param name="skipVisibility"><span data-ttu-id="9329e-338">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-338"><see langword="true" /> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9329e-339">创建一个动态方法，指定方法名称、返回类型、参数类型、动态方法逻辑关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-339">Creates a dynamic method, specifying the method name, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-340">使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含`owner`的模块中所有其他类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。</span><span class="sxs-lookup"><span data-stu-id="9329e-340">The dynamic method created with this constructor has access to all members of the type `owner`, and to public and `internal` (`Friend` in Visual Basic) members of all the other types in the module that contains `owner`.</span></span> <span data-ttu-id="9329e-341">通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-341">Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</span></span> <span data-ttu-id="9329e-342">例如, 在编写代码以序列化对象时, 这很有用。</span><span class="sxs-lookup"><span data-stu-id="9329e-342">This is useful, for example, when writing code to serialize objects.</span></span>  
  
 <span data-ttu-id="9329e-343">此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>特性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9329e-343">This constructor specifies method attributes <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> and <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, and calling convention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-344">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-344">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `owner` is in a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-345">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-345">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-346">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-346">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-347">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-347">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-348"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-348">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-349">或</span><span class="sxs-lookup"><span data-stu-id="9329e-349">-or-</span></span> 
 <span data-ttu-id="9329e-350"><paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-350"><paramref name="owner" /> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-351"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-351"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-352">或</span><span class="sxs-lookup"><span data-stu-id="9329e-352">-or-</span></span> 
 <span data-ttu-id="9329e-353"><paramref name="owner" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-353"><paramref name="owner" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-354"><paramref name="returnType" /> 为 <see langword="null" />，或者为 <see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-354"><paramref name="returnType" /> is <see langword="null" />, or is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-355">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。</span><span class="sxs-lookup"><span data-stu-id="9329e-355">to associate the dynamic method with a type in a module other than the calling module.</span></span> <span data-ttu-id="9329e-356">关联的枚举<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />:。</span><span class="sxs-lookup"><span data-stu-id="9329e-356">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-357">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-357">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-358">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-358">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-359">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-359">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-360">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-360">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="attributes"><span data-ttu-id="9329e-361"><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，指定动态方法的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-361">A bitwise combination of <see cref="T:System.Reflection.MethodAttributes" /> values that specifies the attributes of the dynamic method.</span></span> <span data-ttu-id="9329e-362">允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-362">The only combination allowed is <see cref="F:System.Reflection.MethodAttributes.Public" /> and <see cref="F:System.Reflection.MethodAttributes.Static" />.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="9329e-363">动态方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-363">The calling convention for the dynamic method.</span></span> <span data-ttu-id="9329e-364">必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-364">Must be <see cref="F:System.Reflection.CallingConventions.Standard" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-365">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9329e-365">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-366">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-366">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="m"><span data-ttu-id="9329e-367">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-367">A <see cref="T:System.Reflection.Module" /> representing the module with which the dynamic method is to be logically associated.</span></span></param>
        <param name="skipVisibility"><span data-ttu-id="9329e-368">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-368"><see langword="true" /> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9329e-369">创建一个对模块全局有效的动态方法，指定方法名称、属性、调用约定、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-369">Creates a dynamic method that is global to a module, specifying the method name, attributes, calling convention, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-370">使用此构造函数创建的动态方法可以访问模块`internal` `m`中包含`Friend`的所有公共和内部类型的公共和 (在 Visual Basic) 成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-370">The dynamic method created with this constructor has access to public and `internal` (`Friend` in Visual Basic) members of all the public and internal types contained in module `m`.</span></span>  
  
 <span data-ttu-id="9329e-371">通过跳过 JIT 编译器的可见性检查, 动态方法可以访问模块和所有其他程序集中的所有其他类型的私有和受保护成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-371">Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types in the module and in all other assemblies as well.</span></span> <span data-ttu-id="9329e-372">例如, 在编写代码以序列化对象时, 这很有用。</span><span class="sxs-lookup"><span data-stu-id="9329e-372">This is useful, for example, when writing code to serialize objects.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-373">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-373">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `m` is a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-374">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-374">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-375">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-375">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-376">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-376">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-377"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-377">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-378">或</span><span class="sxs-lookup"><span data-stu-id="9329e-378">-or-</span></span> 
 <span data-ttu-id="9329e-379"><paramref name="m" /> 是为动态方法提供匿名承载的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-379"><paramref name="m" /> is a module that provides anonymous hosting for dynamic methods.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-380"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-380"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-381">或</span><span class="sxs-lookup"><span data-stu-id="9329e-381">-or-</span></span> 
 <span data-ttu-id="9329e-382"><paramref name="m" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-382"><paramref name="m" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-383"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="9329e-383"><paramref name="attributes" /> is a combination of flags other than <see cref="F:System.Reflection.MethodAttributes.Public" /> and <see cref="F:System.Reflection.MethodAttributes.Static" />.</span></span>  
  
<span data-ttu-id="9329e-384">或</span><span class="sxs-lookup"><span data-stu-id="9329e-384">-or-</span></span> 
 <span data-ttu-id="9329e-385"><paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-385"><paramref name="callingConvention" /> is not <see cref="F:System.Reflection.CallingConventions.Standard" />.</span></span>  
  
<span data-ttu-id="9329e-386">或</span><span class="sxs-lookup"><span data-stu-id="9329e-386">-or-</span></span> 
 <span data-ttu-id="9329e-387"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-387"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-388">将动态方法与调用模块以外的模块关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-388">to associate the dynamic method with a module other than the calling module.</span></span> <span data-ttu-id="9329e-389">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-389">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-390">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-390">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-391">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-391">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9329e-392">动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-392">The name of the dynamic method.</span></span> <span data-ttu-id="9329e-393">它可以是长度为零的字符串，但不能为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-393">This can be a zero-length string, but it cannot be <see langword="null" />.</span></span></param>
        <param name="attributes"><span data-ttu-id="9329e-394"><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，指定动态方法的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-394">A bitwise combination of <see cref="T:System.Reflection.MethodAttributes" /> values that specifies the attributes of the dynamic method.</span></span> <span data-ttu-id="9329e-395">允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-395">The only combination allowed is <see cref="F:System.Reflection.MethodAttributes.Public" /> and <see cref="F:System.Reflection.MethodAttributes.Static" />.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="9329e-396">动态方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-396">The calling convention for the dynamic method.</span></span> <span data-ttu-id="9329e-397">必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-397">Must be <see cref="F:System.Reflection.CallingConventions.Standard" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9329e-398">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9329e-398">A <see cref="T:System.Type" /> object that specifies the return type of the dynamic method, or <see langword="null" /> if the method has no return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="9329e-399">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="9329e-399">An array of <see cref="T:System.Type" /> objects specifying the types of the parameters of the dynamic method, or <see langword="null" /> if the method has no parameters.</span></span></param>
        <param name="owner"><span data-ttu-id="9329e-400">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。</span><span class="sxs-lookup"><span data-stu-id="9329e-400">A <see cref="T:System.Type" /> with which the dynamic method is logically associated.</span></span> <span data-ttu-id="9329e-401">动态方法可以访问类型的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-401">The dynamic method has access to all members of the type.</span></span></param>
        <param name="skipVisibility"><span data-ttu-id="9329e-402">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-402"><see langword="true" /> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9329e-403">创建一个动态方法，指定方法名称、特性、调用约定、返回类型、参数类型、动态方法逻辑关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="9329e-403">Creates a dynamic method, specifying the method name, attributes, calling convention, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-404">动态方法对于包含该类型`owner`的模块是全局性的。</span><span class="sxs-lookup"><span data-stu-id="9329e-404">The dynamic method is global to the module that contains the type `owner`.</span></span> <span data-ttu-id="9329e-405">它有权访问该类型`owner`的所有成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-405">It has access to all members of the type `owner`.</span></span>  
  
 <span data-ttu-id="9329e-406">使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含在包含在包含`owner`的模块中的所有类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。</span><span class="sxs-lookup"><span data-stu-id="9329e-406">The dynamic method created with this constructor has access to all members of the type `owner`, and to public and `internal` (`Friend` in Visual Basic) members of all the types contained in the module that contains `owner`.</span></span> <span data-ttu-id="9329e-407">通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-407">Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</span></span> <span data-ttu-id="9329e-408">例如, 在编写代码以序列化对象时, 这很有用。</span><span class="sxs-lookup"><span data-stu-id="9329e-408">This is useful, for example, when writing code to serialize objects.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-409">为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。</span><span class="sxs-lookup"><span data-stu-id="9329e-409">For backward compatibility, this constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag if the following conditions are both true: `owner` is in a module other than the calling module, and the demand for <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag has failed.</span></span> <span data-ttu-id="9329e-410">如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-410">If the demand for <xref:System.Security.Permissions.SecurityPermission> succeeds, the operation is allowed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-411">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="9329e-411">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="9329e-412">(请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="9329e-412">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-413"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-413">An element of <paramref name="parameterTypes" /> is <see langword="null" /> or <see cref="T:System.Void" />.</span></span>  
  
<span data-ttu-id="9329e-414">或</span><span class="sxs-lookup"><span data-stu-id="9329e-414">-or-</span></span> 
 <span data-ttu-id="9329e-415"><paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-415"><paramref name="owner" /> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-416"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-416"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9329e-417">或</span><span class="sxs-lookup"><span data-stu-id="9329e-417">-or-</span></span> 
 <span data-ttu-id="9329e-418"><paramref name="owner" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-418"><paramref name="owner" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-419"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="9329e-419"><paramref name="attributes" /> is a combination of flags other than <see cref="F:System.Reflection.MethodAttributes.Public" /> and <see cref="F:System.Reflection.MethodAttributes.Static" />.</span></span>  
  
<span data-ttu-id="9329e-420">或</span><span class="sxs-lookup"><span data-stu-id="9329e-420">-or-</span></span> 
 <span data-ttu-id="9329e-421"><paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-421"><paramref name="callingConvention" /> is not <see cref="F:System.Reflection.CallingConventions.Standard" />.</span></span>  
  
<span data-ttu-id="9329e-422">或</span><span class="sxs-lookup"><span data-stu-id="9329e-422">-or-</span></span> 
 <span data-ttu-id="9329e-423"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-423"><paramref name="returnType" /> is a type for which <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9329e-424">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。</span><span class="sxs-lookup"><span data-stu-id="9329e-424">to associate the dynamic method with a type in a module other than the calling module.</span></span> <span data-ttu-id="9329e-425">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-425">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</span></span></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-426">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-426">How to: Define and Execute Dynamic Methods</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-427">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-427">Security Issues in Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-428">获取创建动态方法时指定的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-428">Gets the attributes specified when the dynamic method was created.</span></span></summary>
        <value><span data-ttu-id="9329e-429"><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，表示方法的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-429">A bitwise combination of the <see cref="T:System.Reflection.MethodAttributes" /> values representing the attributes for the method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-430">目前, 动态方法的方法特性始终<xref:System.Reflection.MethodAttributes.Public>为和。 <xref:System.Reflection.MethodAttributes.Static></span><span class="sxs-lookup"><span data-stu-id="9329e-430">Currently, the method attributes for a dynamic method are always <xref:System.Reflection.MethodAttributes.Public> and <xref:System.Reflection.MethodAttributes.Static>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-431">下面的代码示例显示动态方法的方法特性。</span><span class="sxs-lookup"><span data-stu-id="9329e-431">The following code example displays the method attributes of a dynamic method.</span></span> <span data-ttu-id="9329e-432">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-432">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-433">获取创建动态方法时指定的调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-433">Gets the calling convention specified when the dynamic method was created.</span></span></summary>
        <value><span data-ttu-id="9329e-434">一个 <see cref="T:System.Reflection.CallingConventions" /> 值，它指示方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-434">One of the <see cref="T:System.Reflection.CallingConventions" /> values that indicates the calling convention of the method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-435">目前, 动态方法的调用约定始终<xref:System.Reflection.CallingConventions.Standard>为。</span><span class="sxs-lookup"><span data-stu-id="9329e-435">Currently, the calling convention for a dynamic method is always <xref:System.Reflection.CallingConventions.Standard>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-436">下面的代码示例显示动态方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-436">The following code example displays the calling convention of a dynamic method.</span></span> <span data-ttu-id="9329e-437">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-437">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9329e-438">完成动态方法并创建一个可执行此方法的委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-438">Completes the dynamic method and creates a delegate that can be used to execute it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="9329e-439">一个签名与动态方法的签名匹配的委托类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-439">A delegate type whose signature matches that of the dynamic method.</span></span></param>
        <summary><span data-ttu-id="9329e-440">完成动态方法并创建一个可执行此方法的委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-440">Completes the dynamic method and creates a delegate that can be used to execute it.</span></span></summary>
        <returns><span data-ttu-id="9329e-441">一个指定类型的委托，可用于执行动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-441">A delegate of the specified type, which can be used to execute the dynamic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-442"><xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>或方法完成动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-442">Calling the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> method or the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method completes the dynamic method.</span></span> <span data-ttu-id="9329e-443">将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-443">Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</span></span>  
  
 <span data-ttu-id="9329e-444">若要在有自己的 MSIL 生成器时为动态方法创建方法体, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法以<xref:System.Reflection.Emit.DynamicILInfo>获取对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-444">To create a method body for a dynamic method when you have your own MSIL generator, call the <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> method to obtain a <xref:System.Reflection.Emit.DynamicILInfo> object.</span></span> <span data-ttu-id="9329e-445">如果没有自己的 MSIL 生成器, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来<xref:System.Reflection.Emit.ILGenerator>获取可用于生成方法体的对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-445">If you do not have your own MSIL generator, call the <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> method to obtain an <xref:System.Reflection.Emit.ILGenerator> object that can be used to generate the method body.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-446">下面的代码示例创建一个带有两个参数的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-446">The following code example creates a dynamic method that takes two parameters.</span></span> <span data-ttu-id="9329e-447">该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-447">The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</span></span> <span data-ttu-id="9329e-448">该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-448">The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-449">动态方法没有方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-449">The dynamic method has no method body.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-450"><paramref name="delegateType" /> 的参数数量不正确，或者参数类型不正确。</span><span class="sxs-lookup"><span data-stu-id="9329e-450"><paramref name="delegateType" /> has the wrong number of parameters or the wrong parameter types.</span></span></exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-451">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-451">How to: Define and Execute Dynamic Methods</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="9329e-452">一个签名与动态方法的签名匹配的委托类型，不包括第一个参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-452">A delegate type whose signature matches that of the dynamic method, minus the first parameter.</span></span></param>
        <param name="target"><span data-ttu-id="9329e-453">委托绑定到的对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-453">An object the delegate is bound to.</span></span> <span data-ttu-id="9329e-454">其类型必须与动态方法的第一个参数的类型相同。</span><span class="sxs-lookup"><span data-stu-id="9329e-454">Must be of the same type as the first parameter of the dynamic method.</span></span></param>
        <summary><span data-ttu-id="9329e-455">完成动态方法并创建一个可用于执行该方法的委托，指定委托类型和委托绑定到的对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-455">Completes the dynamic method and creates a delegate that can be used to execute it, specifying the delegate type and an object the delegate is bound to.</span></span></summary>
        <returns><span data-ttu-id="9329e-456">一个指定类型的委托，可用于对指定的目标对象执行动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-456">A delegate of the specified type, which can be used to execute the dynamic method with the specified target object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-457">此方法重载创建绑定到特定对象的委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-457">This method overload creates a delegate bound to a particular object.</span></span> <span data-ttu-id="9329e-458">此类委托被称为通过其第一个参数关闭。</span><span class="sxs-lookup"><span data-stu-id="9329e-458">Such a delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="9329e-459">尽管该方法是静态的, 但它的作用就像是实例方法;实例为`target`。</span><span class="sxs-lookup"><span data-stu-id="9329e-459">Although the method is static, it acts as if it were an instance method; the instance is `target`.</span></span>  
  
 <span data-ttu-id="9329e-460">此方法重载需要`target`与动态方法的第一个参数具有相同的类型, 或可分配给该类型 (例如, 派生类)。</span><span class="sxs-lookup"><span data-stu-id="9329e-460">This method overload requires `target` to be of the same type as the first parameter of the dynamic method, or to be assignable to that type (for example, a derived class).</span></span>  <span data-ttu-id="9329e-461">的`delegateType`签名包含除第一个以外的动态方法的所有参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-461">The signature of `delegateType` has all the parameters of the dynamic method except the first.</span></span> <span data-ttu-id="9329e-462">例如, 如果动态方法具有参数<xref:System.String>、 <xref:System.Int32>和<xref:System.Byte>, 则`delegateType`具有参数<xref:System.Int32>和<xref:System.Byte>;`target`的类型<xref:System.String>为。</span><span class="sxs-lookup"><span data-stu-id="9329e-462">For example, if the dynamic method has the parameters <xref:System.String>, <xref:System.Int32>, and <xref:System.Byte>, then `delegateType` has the parameters <xref:System.Int32> and <xref:System.Byte>; `target` is of type <xref:System.String>.</span></span>  
  
 <span data-ttu-id="9329e-463"><xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>或方法完成动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-463">Calling the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> method or the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method completes the dynamic method.</span></span> <span data-ttu-id="9329e-464">将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-464">Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</span></span>  
  
 <span data-ttu-id="9329e-465">若要在有自己的 MSIL 生成器时为动态方法创建方法体, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法以<xref:System.Reflection.Emit.DynamicILInfo>获取对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-465">To create a method body for a dynamic method when you have your own MSIL generator, call the <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> method to obtain a <xref:System.Reflection.Emit.DynamicILInfo> object.</span></span> <span data-ttu-id="9329e-466">如果没有自己的 MSIL 生成器, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来<xref:System.Reflection.Emit.ILGenerator>获取可用于生成方法体的对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-466">If you do not have your own MSIL generator, call the <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> method to obtain an <xref:System.Reflection.Emit.ILGenerator> object that can be used to generate the method body.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-467">下面的代码示例创建委托, 该委托<xref:System.Reflection.Emit.DynamicMethod>将绑定到类型的实例, 以便在每次调用该方法时, 该方法都在同一实例上操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-467">The following code example creates delegate that binds a <xref:System.Reflection.Emit.DynamicMethod> to an instance of a type, so that the method acts on the same instance each time it is invoked.</span></span>  
  
 <span data-ttu-id="9329e-468">此代码示例定义了一个名`Example`为的类, 该类具有私有字段`DerivedFromExample` , 该类是从第一个类派生的名为`UseLikeStatic`的类, 它是一个名`Example`为的委托类型, 它返回<xref:System.Int32>并具有类型为和<xref:System.Int32>和一个名为`UseLikeInstance`的委托类型, 它返回<xref:System.Int32>并具有一个类型<xref:System.Int32>为的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-468">The code example defines a class named `Example` with a private field, a class named `DerivedFromExample` that derives from the first class, a delegate type named `UseLikeStatic` that returns <xref:System.Int32> and has parameters of type `Example` and <xref:System.Int32>, and a delegate type named `UseLikeInstance` that returns <xref:System.Int32> and has one parameter of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="9329e-469">然后, 该代码示例创建<xref:System.Reflection.Emit.DynamicMethod>一个, 它将更改`Example`实例的私有字段并返回以前的值。</span><span class="sxs-lookup"><span data-stu-id="9329e-469">The example code then creates a <xref:System.Reflection.Emit.DynamicMethod> that changes the private field of an instance of `Example` and returns the previous value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-470">通常, 更改类的内部字段并不是面向对象的适当编码做法。</span><span class="sxs-lookup"><span data-stu-id="9329e-470">In general, changing the internal fields of classes is not good object-oriented coding practice.</span></span>  
  
 <span data-ttu-id="9329e-471">示例代码创建的`Example`实例, 然后创建两个委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-471">The example code creates an instance of `Example` and then creates two delegates.</span></span> <span data-ttu-id="9329e-472">第一个类型`UseLikeStatic`为, 它具有与动态方法相同的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-472">The first is of type `UseLikeStatic`, which has the same parameters as the dynamic method.</span></span> <span data-ttu-id="9329e-473">第二种类型`UseLikeInstance`为, 它缺少第一个参数 (类型`Example`为)。</span><span class="sxs-lookup"><span data-stu-id="9329e-473">The second is of type `UseLikeInstance`, which lacks the first parameter (of type `Example`).</span></span> <span data-ttu-id="9329e-474">此委托是使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载创建的; 此方法重载的第二个参数是的`Example`实例, 在本例中为刚创建的实例, 该实例绑定到新创建的委托。</span><span class="sxs-lookup"><span data-stu-id="9329e-474">This delegate is created using the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> method overload; the second parameter of that method overload is an instance of `Example`, in this case the instance just created, which is bound to the newly created delegate.</span></span> <span data-ttu-id="9329e-475">无论何时调用该委托, 动态方法都将对的绑定实例`Example`起作用。</span><span class="sxs-lookup"><span data-stu-id="9329e-475">Whenever that delegate is invoked, the dynamic method acts on the bound instance of `Example`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-476">这是中引入的[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]委托绑定的宽松规则的示例, 以及<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法的新重载。</span><span class="sxs-lookup"><span data-stu-id="9329e-476">This is an example of the relaxed rules for delegate binding introduced in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], along with new overloads of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9329e-477">有关更多信息，请参见 <xref:System.Delegate> 类。</span><span class="sxs-lookup"><span data-stu-id="9329e-477">For more information, see the <xref:System.Delegate> class.</span></span>  
  
 <span data-ttu-id="9329e-478">调用委托, 并传入绑定到`UseLikeInstance`委托的的`Example`实例。 `UseLikeStatic`</span><span class="sxs-lookup"><span data-stu-id="9329e-478">The `UseLikeStatic` delegate is invoked, passing in the instance of `Example` that is bound to the `UseLikeInstance` delegate.</span></span> <span data-ttu-id="9329e-479">然后调用`Example`委托, 使这两个委托对相同的实例执行操作。 `UseLikeInstance`</span><span class="sxs-lookup"><span data-stu-id="9329e-479">Then the `UseLikeInstance` delegate is invoked, so that both delegates act on the same instance of `Example`.</span></span> <span data-ttu-id="9329e-480">在每次调用后, 将显示内部字段的值中的更改。</span><span class="sxs-lookup"><span data-stu-id="9329e-480">The changes in the values of the internal field are displayed after each call.</span></span> <span data-ttu-id="9329e-481">最后, `UseLikeInstance`委托绑定到的`DerivedFromExample`实例, 并且委托调用重复。</span><span class="sxs-lookup"><span data-stu-id="9329e-481">Finally, a `UseLikeInstance` delegate is bound to an instance of `DerivedFromExample`, and the delegate calls are repeated.</span></span>  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-482">动态方法没有方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-482">The dynamic method has no method body.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-483"><paramref name="target" /> 的类型与动态方法的第一个参数的类型不同，不能赋值给该类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-483"><paramref name="target" /> is not the same type as the first parameter of the dynamic method, and is not assignable to that type.</span></span>  
  
<span data-ttu-id="9329e-484">或</span><span class="sxs-lookup"><span data-stu-id="9329e-484">-or-</span></span> 
 <span data-ttu-id="9329e-485"><paramref name="delegateType" /> 的参数数量不正确，或者参数类型不正确。</span><span class="sxs-lookup"><span data-stu-id="9329e-485"><paramref name="delegateType" /> has the wrong number of parameters or the wrong parameter types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-486">获取声明方法的类型，对于动态方法，类型始终为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-486">Gets the type that declares the method, which is always <see langword="null" /> for dynamic methods.</span></span></summary>
        <value><span data-ttu-id="9329e-487">总是为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-487">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-488">此属性始终为`null`动态方法返回。</span><span class="sxs-lookup"><span data-stu-id="9329e-488">This property always returns `null` for dynamic methods.</span></span> <span data-ttu-id="9329e-489">即使动态方法与类型在逻辑上相关联, 它也不是由类型声明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-489">Even when a dynamic method is logically associated with a type, it is not declared by the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-490">下面的代码示例显示动态方法的声明类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-490">The following code example displays the declaring type of a dynamic method.</span></span> <span data-ttu-id="9329e-491">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-491">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position"><span data-ttu-id="9329e-492">参数在参数列表中的位置。</span><span class="sxs-lookup"><span data-stu-id="9329e-492">The position of the parameter in the parameter list.</span></span> <span data-ttu-id="9329e-493">为参数编索引，第一个参数从数字 1 开始。</span><span class="sxs-lookup"><span data-stu-id="9329e-493">Parameters are indexed beginning with the number 1 for the first parameter.</span></span></param>
        <param name="attributes"><span data-ttu-id="9329e-494"><see cref="T:System.Reflection.ParameterAttributes" /> 值的按位组合，用于指定参数的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-494">A bitwise combination of <see cref="T:System.Reflection.ParameterAttributes" /> values that specifies the attributes of the parameter.</span></span></param>
        <param name="parameterName"><span data-ttu-id="9329e-495">参数的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-495">The name of the parameter.</span></span> <span data-ttu-id="9329e-496">名称可以为零长度字符串。</span><span class="sxs-lookup"><span data-stu-id="9329e-496">The name can be a zero-length string.</span></span></param>
        <summary><span data-ttu-id="9329e-497">定义动态方法的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-497">Defines a parameter of the dynamic method.</span></span></summary>
        <returns><span data-ttu-id="9329e-498">始终返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-498">Always returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-499">如果`position`为 0, 则<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>该方法引用返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-499">If `position` is 0, the <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> method refers to the return value.</span></span> <span data-ttu-id="9329e-500">设置参数信息不会影响返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-500">Setting parameter information has no effect on the return value.</span></span>  
  
 <span data-ttu-id="9329e-501">如果已通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法, 则该<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法不起作用。</span><span class="sxs-lookup"><span data-stu-id="9329e-501">If the dynamic method has already been completed, by calling the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> or <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method, the <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> method has no effect.</span></span> <span data-ttu-id="9329e-502">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-502">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-503">下面的代码示例演示如何定义动态方法的参数信息。</span><span class="sxs-lookup"><span data-stu-id="9329e-503">The following code example shows how to define parameter information for a dynamic method.</span></span> <span data-ttu-id="9329e-504">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-504">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9329e-505">此方法没有参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-505">The method has no parameters.</span></span>  
  
<span data-ttu-id="9329e-506">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-506">-or-</span></span> 
 <span data-ttu-id="9329e-507"><paramref name="position" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="9329e-507"><paramref name="position" /> is less than 0.</span></span>  
  
<span data-ttu-id="9329e-508">或</span><span class="sxs-lookup"><span data-stu-id="9329e-508">-or-</span></span> 
 <span data-ttu-id="9329e-509"><paramref name="position" /> 大于此方法的参数数目。</span><span class="sxs-lookup"><span data-stu-id="9329e-509"><paramref name="position" /> is greater than the number of the method's parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-510">返回方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9329e-510">Returns the base implementation for the method.</span></span></summary>
        <returns><span data-ttu-id="9329e-511">方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9329e-511">The base implementation of the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-512">此方法始终返回当前`DynamicMethod`对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-512">This method always returns the current `DynamicMethod` object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9329e-513">返回应用于此方法的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-513">Returns the custom attributes applied to the method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="9329e-514">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-514"><see langword="true" /> to search the method's inheritance chain to find the custom attributes; <see langword="false" /> to check only the current method.</span></span></param>
        <summary><span data-ttu-id="9329e-515">返回为此方法定义的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-515">Returns all the custom attributes defined for the method.</span></span></summary>
        <returns><span data-ttu-id="9329e-516">表示此方法的所有自定义属性的对象数组。</span><span class="sxs-lookup"><span data-stu-id="9329e-516">An array of objects representing all the custom attributes of the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-517">对于动态方法, 为`true` `inherit`指定不起作用, 因为方法未在类型中声明。</span><span class="sxs-lookup"><span data-stu-id="9329e-517">For dynamic methods, specifying `true` for `inherit` has no effect, because the method is not declared in a type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-518">动态方法当前不支持自定义特性。</span><span class="sxs-lookup"><span data-stu-id="9329e-518">Custom attributes are not currently supported on dynamic methods.</span></span> <span data-ttu-id="9329e-519">返回的唯一属性为<xref:System.Runtime.CompilerServices.MethodImplAttribute>; <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>使用方法可以更轻松地获取方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-519">The only attribute returned is <xref:System.Runtime.CompilerServices.MethodImplAttribute>; you can get the method implementation flags more easily using the <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="9329e-520">一个 <see cref="T:System.Type" />，表示要返回的自定义特性类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-520">A <see cref="T:System.Type" /> representing the type of custom attribute to return.</span></span></param>
        <param name="inherit"><span data-ttu-id="9329e-521">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-521"><see langword="true" /> to search the method's inheritance chain to find the custom attributes; <see langword="false" /> to check only the current method.</span></span></param>
        <summary><span data-ttu-id="9329e-522">返回应用于此方法的指定类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-522">Returns the custom attributes of the specified type that have been applied to the method.</span></span></summary>
        <returns><span data-ttu-id="9329e-523">一个对象数组，表示此方法的属性为 <paramref name="attributeType" /> 类型或派生自 <paramref name="attributeType" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-523">An array of objects representing the attributes of the method that are of type <paramref name="attributeType" /> or derive from type <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-524">对于动态方法, 为`true` `inherit`指定不起作用, 因为方法未在类型中声明。</span><span class="sxs-lookup"><span data-stu-id="9329e-524">For dynamic methods, specifying `true` for `inherit` has no effect, because the method is not declared in a type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-525">动态方法当前不支持自定义特性。</span><span class="sxs-lookup"><span data-stu-id="9329e-525">Custom attributes are not currently supported on dynamic methods.</span></span> <span data-ttu-id="9329e-526">返回的唯一属性为<xref:System.Runtime.CompilerServices.MethodImplAttribute>; <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>使用方法可以更轻松地获取方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-526">The only attribute returned is <xref:System.Runtime.CompilerServices.MethodImplAttribute>; you can get the method implementation flags more easily using the <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9329e-527"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-527"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-528">返回一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，该对象可用于从元数据标记、范围和 Microsoft 中间语言 (MSIL) 流生成方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-528">Returns a <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object that can be used to generate a method body from metadata tokens, scopes, and Microsoft intermediate language (MSIL) streams.</span></span></summary>
        <returns><span data-ttu-id="9329e-529">一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，可用于从元数据标记、范围和 MSIL 流生成方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-529">A <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object that can be used to generate a method body from metadata tokens, scopes, and MSIL streams.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-530">提供<xref:System.Reflection.Emit.DynamicILInfo>类以支持非托管代码生成。</span><span class="sxs-lookup"><span data-stu-id="9329e-530">The <xref:System.Reflection.Emit.DynamicILInfo> class is provided to support unmanaged code generation.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9329e-531">执行非托管代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-531">to execute unmanaged code.</span></span> <span data-ttu-id="9329e-532">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-532">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9329e-533">返回一个 MSIL 生成器，该生成器可用于发出动态方法的方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-533">Returns an MSIL generator that can be used to emit a body for the dynamic method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-534">为该方法返回一个具有默认 MSIL 流大小（64 字节）的 Microsoft 中间语言 (MSIL) 生成器。</span><span class="sxs-lookup"><span data-stu-id="9329e-534">Returns a Microsoft intermediate language (MSIL) generator for the method with a default MSIL stream size of 64 bytes.</span></span></summary>
        <returns><span data-ttu-id="9329e-535">该方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="9329e-535">An <see cref="T:System.Reflection.Emit.ILGenerator" /> object for the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-536">在通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法后, 将忽略添加 MSIL 的任何进一步尝试。</span><span class="sxs-lookup"><span data-stu-id="9329e-536">After a dynamic method has been completed, by calling the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> or <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method, any further attempt to add MSIL is ignored.</span></span> <span data-ttu-id="9329e-537">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-537">No exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-538">对于动态方法中的不可验证代码, 即使在某些完全信任的情况下也存在限制。</span><span class="sxs-lookup"><span data-stu-id="9329e-538">There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</span></span> <span data-ttu-id="9329e-539">请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-539">See the "Verification" section in Remarks for <xref:System.Reflection.Emit.DynamicMethod>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-540">下面的代码示例创建一个带有两个参数的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-540">The following code example creates a dynamic method that takes two parameters.</span></span> <span data-ttu-id="9329e-541">该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-541">The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</span></span> <span data-ttu-id="9329e-542">该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-542">The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-543">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-543">How to: Define and Execute Dynamic Methods</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize"><span data-ttu-id="9329e-544">MSIL 流的大小，以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="9329e-544">The size of the MSIL stream, in bytes.</span></span></param>
        <summary><span data-ttu-id="9329e-545">为方法返回一个具有指定 MSIL 流大小的 Microsoft 中间语言 (MSIL) 生成器。</span><span class="sxs-lookup"><span data-stu-id="9329e-545">Returns a Microsoft intermediate language (MSIL) generator for the method with the specified MSIL stream size.</span></span></summary>
        <returns><span data-ttu-id="9329e-546">方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象，具有指定的 MSIL 流大小。</span><span class="sxs-lookup"><span data-stu-id="9329e-546">An <see cref="T:System.Reflection.Emit.ILGenerator" /> object for the method, with the specified MSIL stream size.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-547">在通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法后, 将忽略添加 MSIL 的任何进一步尝试。</span><span class="sxs-lookup"><span data-stu-id="9329e-547">After a dynamic method has been completed, by calling the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> or <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method, any further attempt to add MSIL is ignored.</span></span> <span data-ttu-id="9329e-548">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-548">No exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-549">对于动态方法中的不可验证代码, 即使在某些完全信任的情况下也存在限制。</span><span class="sxs-lookup"><span data-stu-id="9329e-549">There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</span></span> <span data-ttu-id="9329e-550">请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-550">See the "Verification" section in Remarks for <xref:System.Reflection.Emit.DynamicMethod>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-551">下面的代码示例演示了此方法重载。</span><span class="sxs-lookup"><span data-stu-id="9329e-551">The following code example demonstrates this method overload.</span></span> <span data-ttu-id="9329e-552">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-552">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md"><span data-ttu-id="9329e-553">如何：定义和执行动态方法</span><span class="sxs-lookup"><span data-stu-id="9329e-553">How to: Define and Execute Dynamic Methods</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-554">返回此方法的实现标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-554">Returns the implementation flags for the method.</span></span></summary>
        <returns><span data-ttu-id="9329e-555"><see cref="T:System.Reflection.MethodImplAttributes" /> 值的按位组合，表示此方法的实现标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-555">A bitwise combination of <see cref="T:System.Reflection.MethodImplAttributes" /> values representing the implementation flags for the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-556">目前, 动态方法的方法实现属性始终<xref:System.Reflection.MethodImplAttributes.IL>为和。 <xref:System.Reflection.MethodImplAttributes.NoInlining></span><span class="sxs-lookup"><span data-stu-id="9329e-556">Currently, method implementation attributes for dynamic methods are always <xref:System.Reflection.MethodImplAttributes.IL> and <xref:System.Reflection.MethodImplAttributes.NoInlining>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-557">返回动态方法的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-557">Returns the parameters of the dynamic method.</span></span></summary>
        <returns><span data-ttu-id="9329e-558">一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象数组，表示动态方法的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-558">An array of <see cref="T:System.Reflection.ParameterInfo" /> objects that represent the parameters of the dynamic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-559">此方法返回的对象仅用于信息。<xref:System.Reflection.ParameterInfo></span><span class="sxs-lookup"><span data-stu-id="9329e-559">The <xref:System.Reflection.ParameterInfo> objects returned by this method are for information only.</span></span> <span data-ttu-id="9329e-560"><xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>使用方法可设置或更改参数的特征。</span><span class="sxs-lookup"><span data-stu-id="9329e-560">Use the <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> method to set or change the characteristics of the parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-561">下面的代码示例显示动态方法的参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-561">The following code example displays the parameters of a dynamic method.</span></span> <span data-ttu-id="9329e-562">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-562">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-563">获取或设置一个值，该值指示方法中的局部变量是否初始化为零。</span><span class="sxs-lookup"><span data-stu-id="9329e-563">Gets or sets a value indicating whether the local variables in the method are zero-initialized.</span></span></summary>
        <value><span data-ttu-id="9329e-564">如果方法中的局部变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-564"><see langword="true" /> if the local variables in the method are zero-initialized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9329e-565">默认值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-565">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-566">如果将此属性设置为`true`, 则发出的 Microsoft 中间语言 (MSIL) 包括初始化局部变量。</span><span class="sxs-lookup"><span data-stu-id="9329e-566">If this property is set to `true`, the emitted Microsoft intermediate language (MSIL) includes initialization of local variables.</span></span> <span data-ttu-id="9329e-567">如果将其设置为`false`, 则不初始化局部变量, 并且无法验证所生成的代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-567">If it is set to `false`, local variables are not initialized and the generated code is unverifiable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-568">下面的代码示例显示动态<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>方法的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-568">The following code example displays the <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> property of a dynamic method.</span></span> <span data-ttu-id="9329e-569">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-569">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="9329e-570">因为动态方法是静态的，所以对于动态方法，忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-570">This parameter is ignored for dynamic methods, because they are static.</span></span> <span data-ttu-id="9329e-571">指定 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-571">Specify <see langword="null" />.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="9329e-572"><see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="9329e-572">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</span></span></param>
        <param name="binder"><span data-ttu-id="9329e-573">一个 <see cref="T:System.Reflection.Binder" /> 对象，该对象通过反射来启用绑定、参数类型强制、成员调用以及对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="9329e-573">A <see cref="T:System.Reflection.Binder" /> object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="9329e-574">如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="9329e-574">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="9329e-575">有关更多详细信息，请参阅 <see cref="T:System.Reflection.Binder" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-575">For more details, see <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="parameters"><span data-ttu-id="9329e-576">自变量列表。</span><span class="sxs-lookup"><span data-stu-id="9329e-576">An argument list.</span></span> <span data-ttu-id="9329e-577">这是一个参数数组，这些参数与要调用的方法的参数具有相同的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-577">This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</span></span> <span data-ttu-id="9329e-578">如果没有任何参数，则此参数应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-578">If there are no parameters this parameter should be <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="9329e-579">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="9329e-579">An instance of <see cref="T:System.Globalization.CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="9329e-580">如果这是 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-580">If this is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="9329e-581">例如，将表示 1000 的 <see cref="T:System.String" /> 正确转换为 <see cref="T:System.Double" /> 值时需要此信息，因为不同的区域性使用不同的形式表示 1000。</span><span class="sxs-lookup"><span data-stu-id="9329e-581">For example, this information is needed to correctly convert a <see cref="T:System.String" /> that represents 1000 to a <see cref="T:System.Double" /> value, because 1000 is represented differently by different cultures.</span></span></param>
        <summary><span data-ttu-id="9329e-582">使用指定的参数，在指定的联编程序的约束下，使用指定的区域性信息调用动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-582">Invokes the dynamic method using the specified parameters, under the constraints of the specified binder, with the specified culture information.</span></span></summary>
        <returns><span data-ttu-id="9329e-583">一个 <see cref="T:System.Object" />，包含调用的方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="9329e-583">A <see cref="T:System.Object" /> containing the return value of the invoked method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-584">除了列出的异常, 调用代码还应准备好捕获动态方法引发的任何异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-584">In addition to the listed exceptions, the calling code should be prepared to catch any exceptions thrown by the dynamic method.</span></span>  
  
 <span data-ttu-id="9329e-585">使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法创建的委托执行动态方法比<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>使用方法执行动态方法更有效。</span><span class="sxs-lookup"><span data-stu-id="9329e-585">Executing a dynamic method with a delegate created by the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> method is more efficient than executing it with the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method.</span></span>  
  
 <span data-ttu-id="9329e-586"><xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或方法完成动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-586">Calling the <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> method or the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> method completes the dynamic method.</span></span> <span data-ttu-id="9329e-587">将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。</span><span class="sxs-lookup"><span data-stu-id="9329e-587">Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</span></span>  
  
 <span data-ttu-id="9329e-588">所有动态方法都是静态的`obj` , 因此始终忽略参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-588">All dynamic methods are static, so the `obj` parameter is always ignored.</span></span> <span data-ttu-id="9329e-589">若要将动态方法视为实例方法, 请使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>采用对象实例的重载。</span><span class="sxs-lookup"><span data-stu-id="9329e-589">To treat a dynamic method as if it were an instance method, use the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> overload that takes an object instance.</span></span>  
  
 <span data-ttu-id="9329e-590">如果动态方法没有参数, 则的`parameters`值应为。 `null`</span><span class="sxs-lookup"><span data-stu-id="9329e-590">If the dynamic method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="9329e-591">否则, 参数数组中元素的数量、类型和顺序应与动态方法的参数的数量、类型和顺序相同。</span><span class="sxs-lookup"><span data-stu-id="9329e-591">Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters of the dynamic method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-592">此方法重载由<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> <xref:System.Reflection.MethodBase>从类继承的方法重载调用, 因此上述备注适用于这两个重载。</span><span class="sxs-lookup"><span data-stu-id="9329e-592">This method overload is called by the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> method overload inherited from the <xref:System.Reflection.MethodBase> class, so the preceding remarks apply to both overloads.</span></span>  
  
 <span data-ttu-id="9329e-593">此方法不直接要求权限, 但调用动态方法可能会导致安全要求, 具体取决于方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-593">This method does not demand permissions directly, but invoking the dynamic method can result in security demands, depending on the method.</span></span> <span data-ttu-id="9329e-594">例如, 对于在`restrictedSkipVisibility`参数设置为`false`的情况下创建的匿名托管动态方法, 不会产生任何要求。</span><span class="sxs-lookup"><span data-stu-id="9329e-594">For example, no demands are made for anonymously hosted dynamic methods that are created with the `restrictedSkipVisibility` parameter set to `false`.</span></span> <span data-ttu-id="9329e-595">另一方面, 如果你`restrictedSkipVisibility`创建了一个设置为`true`的方法, 以便它可以访问目标程序集的隐藏成员, 则该方法将导致要求<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>目标程序集的权限加上<xref:System.Security.Permissions.ReflectionPermission>标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-595">On the other hand, if you create a method with `restrictedSkipVisibility` set to `true` so it can access a hidden member of a target assembly, the method will cause a demand for the permissions of the target assembly plus <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-596">在[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前, 此方法需要<xref:System.Security.Permissions.ReflectionPermission>带有<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。</span><span class="sxs-lookup"><span data-stu-id="9329e-596">Prior to the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-597">下面的代码示例使用美国英语区域性调用具有完全绑定的动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-597">The following code example invokes a dynamic method with exact binding, using the US-English culture.</span></span> <span data-ttu-id="9329e-598">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-598">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9329e-599">不支持 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 调用约定。</span><span class="sxs-lookup"><span data-stu-id="9329e-599">The <see cref="F:System.Reflection.CallingConventions.VarArgs" /> calling convention is not supported.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="9329e-600"><paramref name="parameters" /> 中的元素数量与动态方法中的参数数量不匹配。</span><span class="sxs-lookup"><span data-stu-id="9329e-600">The number of elements in <paramref name="parameters" /> does not match the number of parameters in the dynamic method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9329e-601"><paramref name="parameters" /> 的一个或多个元素的类型与动态方法的相应参数的类型不匹配。</span><span class="sxs-lookup"><span data-stu-id="9329e-601">The type of one or more elements of <paramref name="parameters" /> does not match the type of the corresponding parameter of the dynamic method.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9329e-602">该动态方法与模块关联，并且不是匿名承载的，而是在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造的，但是该动态方法可以访问不是 <see langword="public" /> 或 <see langword="internal" />（在 Visual Basic 中为 <see langword="Friend" />）的成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-602">The dynamic method is associated with a module, is not anonymously hosted, and was constructed with <paramref name="skipVisibility" /> set to <see langword="false" />, but the dynamic method accesses members that are not <see langword="public" /> or <see langword="internal" /> (<see langword="Friend" /> in Visual Basic).</span></span>  
  
<span data-ttu-id="9329e-603">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-603">-or-</span></span> 
<span data-ttu-id="9329e-604">该动态方法是匿名承载的，并且是在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造的，但是它可以访问不是 <see langword="public" /> 的成员。</span><span class="sxs-lookup"><span data-stu-id="9329e-604">The dynamic method is anonymously hosted and was constructed with <paramref name="skipVisibility" /> set to <see langword="false" />, but it accesses members that are not <see langword="public" />.</span></span>  
  
<span data-ttu-id="9329e-605">- 或 -</span><span class="sxs-lookup"><span data-stu-id="9329e-605">-or-</span></span> 
<span data-ttu-id="9329e-606">动态方法包含不可验证的代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-606">The dynamic method contains unverifiable code.</span></span> <span data-ttu-id="9329e-607">请参阅“验证”部分中的 <see cref="T:System.Reflection.Emit.DynamicMethod" /> 注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-607">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="9329e-608">一个 <see cref="T:System.Type" />，表示要搜索的自定义特性类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-608">A <see cref="T:System.Type" /> representing the type of custom attribute to search for.</span></span></param>
        <param name="inherit"><span data-ttu-id="9329e-609">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-609"><see langword="true" /> to search the method's inheritance chain to find the custom attributes; <see langword="false" /> to check only the current method.</span></span></param>
        <summary><span data-ttu-id="9329e-610">指示是否定义了指定的自定义特性类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-610">Indicates whether the specified custom attribute type is defined.</span></span></summary>
        <returns><span data-ttu-id="9329e-611">如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-611"><see langword="true" /> if the specified custom attribute type is defined; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-612">对于动态方法, 将`true`指定`inherit`为不起作用。</span><span class="sxs-lookup"><span data-stu-id="9329e-612">For dynamic methods, specifying `true` for `inherit` has no effect.</span></span> <span data-ttu-id="9329e-613">动态方法没有继承链。</span><span class="sxs-lookup"><span data-stu-id="9329e-613">Dynamic methods have no inheritance chain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9329e-614">动态方法当前不支持自定义特性。</span><span class="sxs-lookup"><span data-stu-id="9329e-614">Custom attributes are not currently supported on dynamic methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-615">获取一个值，该值指示当前动态方法是安全关键的还是安全可靠关键的，因此可以执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-615">Gets a value that indicates whether the current dynamic method is security-critical or security-safe-critical, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="9329e-616">如果当前动态方法是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-616"><see langword="true" /> if the current dynamic method is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-617"><xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="9329e-617">The <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9329e-618">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="9329e-618">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="9329e-619">安全级别</span><span class="sxs-lookup"><span data-stu-id="9329e-619">Security level</span></span>|<span data-ttu-id="9329e-620">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-620">IsSecurityCritical</span></span>|<span data-ttu-id="9329e-621">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-621">IsSecuritySafeCritical</span></span>|<span data-ttu-id="9329e-622">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="9329e-622">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="9329e-623">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-623">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="9329e-624">安全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-624">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="9329e-625">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-625">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="9329e-626">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="9329e-626">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="9329e-627">动态方法的透明度取决于它所关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-627">The transparency of a dynamic method depends on the module it is associated with.</span></span> <span data-ttu-id="9329e-628">如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-628">If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</span></span> <span data-ttu-id="9329e-629">动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-629">Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</span></span>  
  
-   <span data-ttu-id="9329e-630">匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-630">Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</span></span>  
  
-   <span data-ttu-id="9329e-631">下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-631">The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</span></span>  
  
    |<span data-ttu-id="9329e-632">程序集批注</span><span class="sxs-lookup"><span data-stu-id="9329e-632">Assembly annotation</span></span>|<span data-ttu-id="9329e-633">1级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-633">Level 1 transparency</span></span>|<span data-ttu-id="9329e-634">2级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-634">Level 2 transparency</span></span>|  
    |-------------------------|--------------------------|--------------------------|  
    |<span data-ttu-id="9329e-635">完全透明</span><span class="sxs-lookup"><span data-stu-id="9329e-635">Fully transparent</span></span>|<span data-ttu-id="9329e-636">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-636">Transparent</span></span>|<span data-ttu-id="9329e-637">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-637">Transparent</span></span>|  
    |<span data-ttu-id="9329e-638">完全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-638">Fully critical</span></span>|<span data-ttu-id="9329e-639">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-639">Critical</span></span>|<span data-ttu-id="9329e-640">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-640">Critical</span></span>|  
    |<span data-ttu-id="9329e-641">混合透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-641">Mixed transparency</span></span>|<span data-ttu-id="9329e-642">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-642">Transparent</span></span>|<span data-ttu-id="9329e-643">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-643">Transparent</span></span>|  
    |<span data-ttu-id="9329e-644">不可知安全</span><span class="sxs-lookup"><span data-stu-id="9329e-644">Security-agnostic</span></span>|<span data-ttu-id="9329e-645">安全-关键</span><span class="sxs-lookup"><span data-stu-id="9329e-645">Safe-critical</span></span>|<span data-ttu-id="9329e-646">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-646">Critical</span></span>|  
  
     <span data-ttu-id="9329e-647">例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-647">For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</span></span> <span data-ttu-id="9329e-648">有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-648">For information about transparency levels, see [Security-Transparent Code, Level 1](~/docs/framework/misc/security-transparent-code-level-1.md) and [Security-Transparent Code, Level 2](~/docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9329e-649">将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。</span><span class="sxs-lookup"><span data-stu-id="9329e-649">Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</span></span> <span data-ttu-id="9329e-650">如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="9329e-650">If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <xref:System.Security.SecurityException> is thrown when the dynamic method is called.</span></span>  
  
-   <span data-ttu-id="9329e-651">与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。</span><span class="sxs-lookup"><span data-stu-id="9329e-651">The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</span></span> <span data-ttu-id="9329e-652">如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-652">If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9329e-653">程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-653">The assembly and all its types and members, including dynamic methods, are treated as transparent.</span></span> <span data-ttu-id="9329e-654">只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-654">The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9329e-655">在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-655">In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</span></span>  
  
 <span data-ttu-id="9329e-656">有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-656">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="9329e-657">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-657">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-658">动态方法没有方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-658">The dynamic method doesn't have a method body.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-659">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-659">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9329e-660">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="9329e-660">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9329e-661">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="9329e-661">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="9329e-662">安全透明代码, 级别1</span><span class="sxs-lookup"><span data-stu-id="9329e-662">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="9329e-663">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="9329e-663">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-664">获取一个值，该值指示当前动态方法在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</span><span class="sxs-lookup"><span data-stu-id="9329e-664">Gets a value that indicates whether the current dynamic method is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="9329e-665">如果动态方法在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-665"><see langword="true" /> if the dynamic method is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-666"><xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="9329e-666">The <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9329e-667">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="9329e-667">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="9329e-668">安全级别</span><span class="sxs-lookup"><span data-stu-id="9329e-668">Security level</span></span>|<span data-ttu-id="9329e-669">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-669">IsSecurityCritical</span></span>|<span data-ttu-id="9329e-670">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-670">IsSecuritySafeCritical</span></span>|<span data-ttu-id="9329e-671">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="9329e-671">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="9329e-672">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-672">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="9329e-673">安全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-673">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="9329e-674">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-674">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="9329e-675">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="9329e-675">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="9329e-676">动态方法的透明度取决于它所关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-676">The transparency of a dynamic method depends on the module it is associated with.</span></span> <span data-ttu-id="9329e-677">如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-677">If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</span></span> <span data-ttu-id="9329e-678">动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-678">Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</span></span>  
  
-   <span data-ttu-id="9329e-679">匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-679">Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</span></span>  
  
-   <span data-ttu-id="9329e-680">下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-680">The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</span></span>  
  
    |<span data-ttu-id="9329e-681">程序集批注</span><span class="sxs-lookup"><span data-stu-id="9329e-681">Assembly annotation</span></span>|<span data-ttu-id="9329e-682">1级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-682">Level 1 transparency</span></span>|<span data-ttu-id="9329e-683">2级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-683">Level 2 transparency</span></span>|  
    |-------------------------|--------------------------|--------------------------|  
    |<span data-ttu-id="9329e-684">完全透明</span><span class="sxs-lookup"><span data-stu-id="9329e-684">Fully transparent</span></span>|<span data-ttu-id="9329e-685">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-685">Transparent</span></span>|<span data-ttu-id="9329e-686">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-686">Transparent</span></span>|  
    |<span data-ttu-id="9329e-687">完全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-687">Fully critical</span></span>|<span data-ttu-id="9329e-688">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-688">Critical</span></span>|<span data-ttu-id="9329e-689">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-689">Critical</span></span>|  
    |<span data-ttu-id="9329e-690">混合透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-690">Mixed transparency</span></span>|<span data-ttu-id="9329e-691">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-691">Transparent</span></span>|<span data-ttu-id="9329e-692">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-692">Transparent</span></span>|  
    |<span data-ttu-id="9329e-693">不可知安全</span><span class="sxs-lookup"><span data-stu-id="9329e-693">Security-agnostic</span></span>|<span data-ttu-id="9329e-694">安全-关键</span><span class="sxs-lookup"><span data-stu-id="9329e-694">Safe-critical</span></span>|<span data-ttu-id="9329e-695">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-695">Critical</span></span>|  
  
     <span data-ttu-id="9329e-696">例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-696">For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</span></span> <span data-ttu-id="9329e-697">有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-697">For information about transparency levels, see [Security-Transparent Code, Level 1](~/docs/framework/misc/security-transparent-code-level-1.md) and [Security-Transparent Code, Level 2](~/docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9329e-698">将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。</span><span class="sxs-lookup"><span data-stu-id="9329e-698">Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</span></span> <span data-ttu-id="9329e-699">如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="9329e-699">If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <xref:System.Security.SecurityException> is thrown when the dynamic method is called.</span></span>  
  
-   <span data-ttu-id="9329e-700">与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。</span><span class="sxs-lookup"><span data-stu-id="9329e-700">The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</span></span> <span data-ttu-id="9329e-701">如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-701">If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9329e-702">程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-702">The assembly and all its types and members, including dynamic methods, are treated as transparent.</span></span> <span data-ttu-id="9329e-703">只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-703">The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9329e-704">在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-704">In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</span></span>  
  
 <span data-ttu-id="9329e-705">有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-705">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="9329e-706">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-706">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-707">动态方法没有方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-707">The dynamic method doesn't have a method body.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-708">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-708">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9329e-709">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="9329e-709">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9329e-710">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="9329e-710">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="9329e-711">安全透明代码, 级别1</span><span class="sxs-lookup"><span data-stu-id="9329e-711">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="9329e-712">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="9329e-712">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-713">获取一个值，该值指示动态方法在当前信任级别上是透明的，因此无法执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="9329e-713">Gets a value that indicates whether the current dynamic method is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="9329e-714">如果动态方法在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-714"><see langword="true" /> if the dynamic method is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-715"><xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="9329e-715">The <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9329e-716">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="9329e-716">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="9329e-717">安全级别</span><span class="sxs-lookup"><span data-stu-id="9329e-717">Security level</span></span>|<span data-ttu-id="9329e-718">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-718">IsSecurityCritical</span></span>|<span data-ttu-id="9329e-719">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9329e-719">IsSecuritySafeCritical</span></span>|<span data-ttu-id="9329e-720">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="9329e-720">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="9329e-721">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-721">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="9329e-722">安全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-722">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="9329e-723">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-723">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="9329e-724">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="9329e-724">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="9329e-725">动态方法的透明度取决于它所关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-725">The transparency of a dynamic method depends on the module it is associated with.</span></span> <span data-ttu-id="9329e-726">如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-726">If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</span></span> <span data-ttu-id="9329e-727">动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-727">Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</span></span>  
  
-   <span data-ttu-id="9329e-728">匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-728">Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</span></span>  
  
-   <span data-ttu-id="9329e-729">下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-729">The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</span></span>  
  
    |<span data-ttu-id="9329e-730">程序集批注</span><span class="sxs-lookup"><span data-stu-id="9329e-730">Assembly annotation</span></span>|<span data-ttu-id="9329e-731">1级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-731">Level 1 transparency</span></span>|<span data-ttu-id="9329e-732">2级透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-732">Level 2 transparency</span></span>|  
    |-------------------------|--------------------------|--------------------------|  
    |<span data-ttu-id="9329e-733">完全透明</span><span class="sxs-lookup"><span data-stu-id="9329e-733">Fully transparent</span></span>|<span data-ttu-id="9329e-734">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-734">Transparent</span></span>|<span data-ttu-id="9329e-735">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-735">Transparent</span></span>|  
    |<span data-ttu-id="9329e-736">完全关键</span><span class="sxs-lookup"><span data-stu-id="9329e-736">Fully critical</span></span>|<span data-ttu-id="9329e-737">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-737">Critical</span></span>|<span data-ttu-id="9329e-738">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-738">Critical</span></span>|  
    |<span data-ttu-id="9329e-739">混合透明度</span><span class="sxs-lookup"><span data-stu-id="9329e-739">Mixed transparency</span></span>|<span data-ttu-id="9329e-740">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-740">Transparent</span></span>|<span data-ttu-id="9329e-741">透明</span><span class="sxs-lookup"><span data-stu-id="9329e-741">Transparent</span></span>|  
    |<span data-ttu-id="9329e-742">不可知安全</span><span class="sxs-lookup"><span data-stu-id="9329e-742">Security-agnostic</span></span>|<span data-ttu-id="9329e-743">安全-关键</span><span class="sxs-lookup"><span data-stu-id="9329e-743">Safe-critical</span></span>|<span data-ttu-id="9329e-744">严重</span><span class="sxs-lookup"><span data-stu-id="9329e-744">Critical</span></span>|  
  
     <span data-ttu-id="9329e-745">例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。</span><span class="sxs-lookup"><span data-stu-id="9329e-745">For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</span></span> <span data-ttu-id="9329e-746">有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-746">For information about transparency levels, see [Security-Transparent Code, Level 1](~/docs/framework/misc/security-transparent-code-level-1.md) and [Security-Transparent Code, Level 2](~/docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9329e-747">将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。</span><span class="sxs-lookup"><span data-stu-id="9329e-747">Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</span></span> <span data-ttu-id="9329e-748">如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="9329e-748">If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <xref:System.Security.SecurityException> is thrown when the dynamic method is called.</span></span>  
  
-   <span data-ttu-id="9329e-749">与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。</span><span class="sxs-lookup"><span data-stu-id="9329e-749">The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</span></span> <span data-ttu-id="9329e-750">如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-750">If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9329e-751">程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。</span><span class="sxs-lookup"><span data-stu-id="9329e-751">The assembly and all its types and members, including dynamic methods, are treated as transparent.</span></span> <span data-ttu-id="9329e-752">只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。</span><span class="sxs-lookup"><span data-stu-id="9329e-752">The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9329e-753">在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。</span><span class="sxs-lookup"><span data-stu-id="9329e-753">In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</span></span>  
  
 <span data-ttu-id="9329e-754">有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-754">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="9329e-755">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="9329e-755">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-756">动态方法没有方法体。</span><span class="sxs-lookup"><span data-stu-id="9329e-756">The dynamic method doesn't have a method body.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="9329e-757">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="9329e-757">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9329e-758">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="9329e-758">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9329e-759">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="9329e-759">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="9329e-760">安全透明代码, 级别1</span><span class="sxs-lookup"><span data-stu-id="9329e-760">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="9329e-761">安全透明的代码，级别 2</span><span class="sxs-lookup"><span data-stu-id="9329e-761">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-762">动态方法不支持。</span><span class="sxs-lookup"><span data-stu-id="9329e-762">Not supported for dynamic methods.</span></span></summary>
        <value><span data-ttu-id="9329e-763">动态方法不支持。</span><span class="sxs-lookup"><span data-stu-id="9329e-763">Not supported for dynamic methods.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9329e-764">动态方法不允许。</span><span class="sxs-lookup"><span data-stu-id="9329e-764">Not allowed for dynamic methods.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-765">获取动态方法逻辑关联的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-765">Gets the module with which the dynamic method is logically associated.</span></span></summary>
        <value><span data-ttu-id="9329e-766">动态方法当前关联的 <see cref="T:System.Reflection.Module" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-766">The <see cref="T:System.Reflection.Module" /> with which the current dynamic method is associated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-767">如果在创建动态方法时指定了模块, 则此属性将返回该模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-767">If a module was specified when the dynamic method was created, this property returns that module.</span></span> <span data-ttu-id="9329e-768">如果在创建动态方法时指定了类型作为所有者, 则此属性将返回包含该类型的模块。</span><span class="sxs-lookup"><span data-stu-id="9329e-768">If a type was specified as the owner when the dynamic method was created, this property returns the module which contains that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-769">下面的代码示例显示动态<xref:System.Reflection.Emit.DynamicMethod.Module%2A>方法的属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-769">The following code example displays the <xref:System.Reflection.Emit.DynamicMethod.Module%2A> property of a dynamic method.</span></span> <span data-ttu-id="9329e-770">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-770">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-771">获取动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-771">Gets the name of the dynamic method.</span></span></summary>
        <value><span data-ttu-id="9329e-772">方法的简称。</span><span class="sxs-lookup"><span data-stu-id="9329e-772">The simple name of the method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="9329e-773">不需要命名动态方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-773">It is not necessary to name dynamic methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-774">下面的代码示例显示动态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-774">The following code example displays the name of a dynamic method.</span></span> <span data-ttu-id="9329e-775">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-775">This code example is part of a larger example provided for  the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-776">获取在反射中用于获取方法的类。</span><span class="sxs-lookup"><span data-stu-id="9329e-776">Gets the class that was used in reflection to obtain the method.</span></span></summary>
        <value><span data-ttu-id="9329e-777">总是为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-777">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-778">此属性始终为`null`动态方法返回。</span><span class="sxs-lookup"><span data-stu-id="9329e-778">This property always returns `null` for dynamic methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-779">下面的代码示例显示动态方法的反射类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-779">The following code example displays the reflected type of a dynamic method.</span></span> <span data-ttu-id="9329e-780">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-780">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-781">获取动态方法的返回参数。</span><span class="sxs-lookup"><span data-stu-id="9329e-781">Gets the return parameter of the dynamic method.</span></span></summary>
        <value><span data-ttu-id="9329e-782">总是为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-782">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-783">此属性始终为`null`动态方法返回。</span><span class="sxs-lookup"><span data-stu-id="9329e-783">This property always returns `null` for dynamic methods.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-784">获取动态方法的返回值的类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-784">Gets the type of return value for the dynamic method.</span></span></summary>
        <value><span data-ttu-id="9329e-785">一个 <see cref="T:System.Type" />，表示当前方法的返回值的类型；如果该方法没有返回类型，则为 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="9329e-785">A <see cref="T:System.Type" /> representing the type of the return value of the current method; <see cref="T:System.Void" /> if the method has no return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-786">如果`null`在创建动态方法时为返回类型指定, 则此属性返回<xref:System.Void?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9329e-786">If `null` was specified for the return type when the dynamic method was created, this property returns <xref:System.Void?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-787">下面的代码示例显示动态方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="9329e-787">The following code example displays the return type of a dynamic method.</span></span> <span data-ttu-id="9329e-788">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-788">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9329e-789">获取动态方法的返回类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-789">Gets the custom attributes of the return type for the dynamic method.</span></span></summary>
        <value><span data-ttu-id="9329e-790">一个 <see cref="T:System.Reflection.ICustomAttributeProvider" />，表示动态方法的返回类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="9329e-790">An <see cref="T:System.Reflection.ICustomAttributeProvider" /> representing the custom attributes of the return type for the dynamic method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-791">动态方法的返回类型不支持自定义特性, 因此该<xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>方法返回的自定义特性的数组始终为空。</span><span class="sxs-lookup"><span data-stu-id="9329e-791">Custom attributes are not supported on the return type of a dynamic method, so the array of custom attributes returned by the <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> method is always empty.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-792">下面的代码示例演示如何显示动态方法的返回类型的自定义特性。</span><span class="sxs-lookup"><span data-stu-id="9329e-792">The following code example shows how to display the custom attributes of the return type of a dynamic method.</span></span> <span data-ttu-id="9329e-793">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-793">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9329e-794">返回方法的签名，以字符串表示。</span><span class="sxs-lookup"><span data-stu-id="9329e-794">Returns the signature of the method, represented as a string.</span></span></summary>
        <returns><span data-ttu-id="9329e-795">表示方法签名的字符串。</span><span class="sxs-lookup"><span data-stu-id="9329e-795">A string representing the method signature.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9329e-796">签名仅包括类型和方法名称 (如果有)。</span><span class="sxs-lookup"><span data-stu-id="9329e-796">The signature includes only types and the method name, if any.</span></span> <span data-ttu-id="9329e-797">不包含参数名称。</span><span class="sxs-lookup"><span data-stu-id="9329e-797">Parameter names are not included.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9329e-798">下面的代码示例显示<xref:System.Reflection.Emit.DynamicMethod.ToString%2A>动态方法的方法。</span><span class="sxs-lookup"><span data-stu-id="9329e-798">The following code example displays the <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> method of a dynamic method.</span></span> <span data-ttu-id="9329e-799">此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="9329e-799">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
