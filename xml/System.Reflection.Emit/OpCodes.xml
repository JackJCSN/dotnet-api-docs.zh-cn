<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="feb111e137a41d186aef01d83f04819d820520eb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/21/2019" /><Meta Name="ms.locfileid" Value="67308030" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过 <see cref="T:System.Reflection.Emit.ILGenerator" /> 类成员（例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />）为发出提供 Microsoft 中间语言 (MSIL) 指令的字段表示形式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员操作码的详细说明，请参阅公共语言基础结构 (CLI) 文档，尤其是"第三部分：CIL 指令集"和"分区 II:元数据定义和语义"。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下面的示例演示动态方法使用的构造<xref:System.Reflection.Emit.ILGenerator>发出`OpCodes`到<xref:System.Reflection.Emit.MethodBuilder>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相加并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|58|添加|将两个数值相加，返回新的数字值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`。  
  
4.  将结果推送到堆栈上。  
  
 对于整数运算不检测溢出 (正确的溢出处理，请参阅<xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整数添加包装，而不是尽量充满。 例如，假定 8 位整数，其中`value1`都设置为 255 和`value2`设置为 1，已包装的结果是 0，而不是 256。  
  
 返回浮点溢出`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有任何条目进行特定类型的组合 (例如，`int32`和`float`;`int32`和`int64`)，它是无效的 Microsoft 中间语言 (MSIL) 并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`add`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D6|add.ovf|将添加两个有符号的整数值的溢出检查。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果结果中的结果类型不会显示将引发。  
  
 您可以执行此操作对有符号整数。 为浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有任何条目进行特定类型的组合 (例如，`int32`和`float`;`int32`和`int64`)，它是一个无效的 Microsoft 中间语言 (MSIL) 指令，将生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`add.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|将添加两个无符号的整数值的溢出检查。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果结果中的结果类型不会显示将引发。  
  
 您可以执行此操作对有符号整数。 为浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有任何条目进行特定类型的组合 (例如，`int32`和`float`;`int32`和`int64`)，它是一个无效的 Microsoft 中间语言 (MSIL) 指令，将生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`add.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算两个值的按位"与"并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|指令|说明|  
|------------|-----------------|-----------------|  
|5F|和|确定两个整数值的按位 AND。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value1` 和`value2`从堆栈中弹出计算两个值的按位 AND。  
  
4.  将结果推送到堆栈上。  
  
 `and`指令计算堆栈上的前两个值的按位 AND，并将结果留在堆栈上。  
  
 `And` 是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`and`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回指向当前方法的参数列表的非托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|返回当前方法的参数列表句柄。|  
  
 没有计算堆栈的行为被执行此操作。  
  
 `arglist`指令将返回一个不透明的句柄 (类型的非托管的指针`native int`)，表示当前方法的参数列表。 此句柄仅在当前方法的生存期是有效。 但是，可以将该句柄传递给其他方法，前提是控件的线程上的当前方法。 您只能执行`arglist`采用数目可变的参数的方法中的指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`arglist`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|分支到目标指令处于偏移量`target`如果两个值是否相等。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`等同于`value2`，执行分支操作。  
  
 `beq`指令将控制转移到指定的目标指令如果`value1`等同于`value2`。 效果等同于执行`ceq`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 下面概括了可接受的操作数类型：  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。  
  
 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块 (此类传输受到严格限制，必须使用<xref:System.Reflection.Emit.OpCodes.Leave>指令相反)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`beq`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|分支到目标指令处于偏移量`target`相等，如果短格式|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`等同于`value2`，执行分支操作。  
  
 `beq.s`指令将控制转移到指定的目标指令如果`value1`等同于`value2`。 效果等同于执行`ceq`指令后跟`brtrue`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 下面概括了可接受的操作数类型：  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。  
  
 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块 (此类传输受到严格限制，必须使用<xref:System.Reflection.Emit.OpCodes.Leave>指令相反)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`beq.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|分支到目标指令的第一个值是否大于或等于第二个值指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`。 效果等同于执行`clt.un`指令后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bge`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|分支到目标指令的第一个值是否大于或等于第二个值，缩写形式指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.s`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`。 效果等同于执行`clt.un`指令后跟`brfalse`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bge.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|进行 `target`|分支到目标指令的第一个值是否大于或等于第二个值 （无符号值） 指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.un`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`clt`指令后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bge.un`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|进行 `target`|分支到目标指令的第一个值是否大于或等于第二个值 （无符号值），缩写形式指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.un.s`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`clt`指令后跟`brfalse`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bge.un.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3D < `int32` >|标题 `target`|分支到目标指令的第一个值是否大于第二个值指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt`指令将控制转移到指定的目标指令如果`value1`大于`value2`。 效果等同于执行`cgt`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bgt`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|分支到目标指令的第一个值是否大于第二个值，缩写形式指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.s`指令将控制转移到指定的目标指令如果`value1`大于`value2`。 效果等同于执行`cgt`指令后跟`brtrue`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bgt.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|进行 `target`|分支到目标指令的第一个值是否大于第二个值 （无符号值） 指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.un`指令将控制转移到指定的目标指令如果`value1`大于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`cgt.un`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bgt.un`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|进行 `target`|分支到目标指令的第一个值是否大于第二个值 （无符号值），缩写形式指定的偏移量处。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.un.s`指令将控制转移到指定的目标指令如果`value1`大于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`cgt.un`指令后跟`brtrue`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bgt.un.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|分支到目标指令，如果第一个值小于或等于第二个值的指定偏移量。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果等同于执行`cgt`指令 (`cgt.un`对于浮点型值) 后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ble`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|分支到目标指令，如果第一个值小于或等于第二个值，缩写形式的指定偏移量。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.s`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果等同于执行`cgt`指令 (`cgt.un`为浮点数) 指令后跟`brfalse`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ble.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|时 `target`|分支到目标指令，如果第一个值小于或等于第二个值 （无符号值），则指定的偏移量。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.un`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`cgt.un`指令 (`cgt`对于浮点型值) 后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ble.un`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|时 `target`|分支到目标指令，如果第一个值小于或等于第二个值 （无符号值），缩写形式的指定偏移量。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.un.s`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`cgt.un`指令 (`cgt`对于浮点型值) 后跟`brfalse`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ble.un.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|分支到目标指令以指定的偏移量的第一个值是否小于第二个值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果等同于执行`clt`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`blt`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|分支到目标指令以指定的偏移量的第一个值是否小于第二个值，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.s`指令将控制转移到指定的目标指令如果`value1`是小于`value2`。 效果等同于执行`clt`指令后跟`brtrue`分支到特定目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`blt.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|时 `target`|分支到以指定的偏移量的第一个值是否小于第二个值 （无符号值） 目标指令。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.un`指令将控制转移到指定的目标指令如果`value1`是小于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`clt.un`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`blt.un`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|分支到目标指令以指定的偏移量的第一个值是否小于第二个值 （无符号值），缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.un`指令将控制转移到指定的目标指令如果`value1`是小于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`clt.un`指令后跟`brtrue`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`blt.un.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|分支到目标指令，如果两个无符号整数值指定的偏移量是不等于 （无符号的值）。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`不等于`value2`，执行分支操作。  
  
 `bne.un`指令将控制转移到指定的目标指令如果`value1`不等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`ceq`指令后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bne.un`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|分支到目标指令，如果两个无符号整数值指定的偏移量是不等于 （无符号的值）、 缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`从堆栈弹出，则`value1`不等于`value2`，执行分支操作。  
  
 `bne.un`指令将控制转移到指定的目标指令如果`value1`不等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果等同于执行`ceq`指令后跟`brfalse`分支到特定目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`bne.un.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类转换为对象引用（<see langword="O" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8C < `T` >|box `valTypeToken`|将值类型转换 (在指定的类型的`valTypeToken`) 为真正的对象引用。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值类型推送到堆栈上。  
  
2.  从堆栈中弹出值类型`box`执行操作。  
  
3.  对生成的"装箱"的值类型的对象引用推送到堆栈上。  
  
 值类型具有两个单独的表示形式中公共语言基础结构 (CLI):  
  
-   使用值类型嵌入在另一个对象中或在堆栈上时的原始格式。  
  
-   装箱形式，其中的值类型中的数据被包装 （装箱） 到一个对象以便它可以作为一个独立的实体存在。  
  
 `box`指令将转换的对象引用为原始 （未装箱） 的值类型 (类型`O`)。 这是通过创建一个新的对象并将数据复制到新分配的对象的值类型实现的。 `valTypeToken` 元数据标记指示在堆栈上的值类型的类型。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`box`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|到目标指令指定的偏移量处的分支。|  
  
 没有计算堆栈的行为被执行此操作。  
  
 `br`指令无条件将控制转移到目标指令。 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`br`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|分支到目标指令指定的偏移量，缩写形式。|  
  
 没有计算堆栈的行为被执行此操作。  
  
 `br.s`指令无条件将控制转移到目标指令。 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`br.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|01|break|通知调试器已达到断点。|  
  
 没有计算堆栈的行为被执行此操作。  
  
 `break`指令是用于支持调试。 它发出信号以通知调试器已撞上了一个中断 CLI。 它不起其他解释器状态。  
  
 `break`条指令的最小可能使代码指令大小与中断点修补和生成到周围的代码影响最小。  
  
 `break`指令可以捕获调试器、 不执行任何操作，或引发安全异常。 确切的行为是实现定义的。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`break`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用（Visual Basic 中的 <see langword="Nothing" />）或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|分支到目标指令在指定的偏移量 if `false`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`false`，分支到`target`。  
  
 `brfalse`指令 (和其别名`brnull`并`brzero`) 将控制转移到指定的目标指令，如果`value`(类型的`int32`， `int64`，对象引用`O`、 托管指针`&`，瞬态指针`*`， `native int`) 为零 (`false`)。 如果`value`不为零 (`true`) 在下一条指令处继续执行。  
  
 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`brfalse`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|分支到目标指令在指定的偏移量 if `false`，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`false`，分支到`target`。  
  
 `brfalse.s`指令 (和其别名`brnull`并`brzero`) 将控制转移到指定的目标指令，如果`value`(类型的`int32`， `int64`，对象引用`O`、 托管指针`&`，瞬态指针`*`， `native int`) 为零 (`false`)。 如果`value`不为零 (`true`) 在下一条指令处继续执行。  
  
 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`brfalse.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|如果非零值到目标指令指定的偏移量处分支 (`true`)。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`true`，分支到`target`。  
  
 `brtrue`指令将控制转移到指定的目标指令如果`value`(类型`native int`) 为非零值 (`true`)。 如果`value`为零 (`false`) 在下一条指令处继续执行。  
  
 如果`value`是一个对象引用 (类型`O`) 然后`brinst`(别名`brtrue`) 将控制转移如果它表示对象的实例 (例如，如果它不是空对象引用中; 请参阅<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 该目标指令被表示为 4 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`brtrue`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|如果非零值到目标指令指定的偏移量处分支 (`true`)，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`true`，分支到`target`。  
  
 `brtrue.s`指令将控制转移到指定的目标指令如果`value`(类型`native int`) 为非零值 (`true`)。 如果`value`为零 (`false`) 在下一条指令处继续执行。  
  
 如果`value`是一个对象引用 (类型`O`) 然后`brinst`(别名`brtrue`) 将控制转移如果它表示对象的实例 (例如，如果它不是空对象引用中; 请参阅<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 目标指令被表示为 1 字节有符号偏移量从当前指令之后的指令的开头。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`brtrue.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>调用由传递的方法说明符指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|28 < `T` >|调用 `methodDesc`|调用方法所描述`methodDesc`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  方法参数`arg1`通过`argN`推送到堆栈上。  
  
2.  方法参数`arg1`通过`argN`弹出，从堆栈; 方法调用执行用这些自变量和控制传输到引用的方法描述符的方法。 完成后，返回值是由被调用方方法生成并发送给调用方。  
  
3.  返回值推送到堆栈上。  
  
 `call`指令调用由随指令一起传递的方法说明符指示的方法。 方法描述符是一个元数据标记，指示方法调用和数量、 类型和已放置在要传递给该方法，以及要使用的调用约定的堆栈的参数的顺序。 `call`指令可以立即前面`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀指令，以指定应将控制转移之前释放当前的方法状态。 如果在调用将控制转移到更高的信任比原始方法的方法，将不会释放堆栈帧。 相反，在执行无提示方式继续像`tail`尚未提供。 元数据令牌携带足够的信息来确定是否该调用是对静态方法、 实例方法，一个虚拟方法或全局函数。 在所有这些情况下完全从方法描述符确定目标地址 (与此对比<xref:System.Reflection.Emit.OpCodes.Callvirt>指令用于调用虚方法，其中的目标地址还取决于该实例的运行时类型引用推送之前<xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 参数中从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算，并放置在堆栈中，则第二个参数，则第三，直到所有必需的自变量都位于降序排序堆栈上。 有三种重要特殊情况：  
  
 1. 调用方法实例 （或虚拟） 必须推送之前的所有用户可见的参数的该实例引用。 实例引用不能为 null 引用。 元数据中的签名不包含的参数列表中的条目`this`指针; 相反，它使用位指示方法是否需要传递`this`指针。  
  
 2. 它是可以调用虚方法使用`call`(而非`callvirt`); 这指示该方法是使用指定的方法，而不是所调用的对象从动态指定的类会得到解决。  
  
 3. 请注意，一个委托`Invoke`可以通过调用方法`call`或`callvirt`指令。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问，可能会引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，可能会进行安全检查。  
  
> [!NOTE]
>  如果在值类型上调用的 System.Object 方法，请考虑使用`constrained`带有前缀`callvirt`指令而不是发出`call`指令。 这无需发出不同 IL 具体取决于值类型重写方法，从而避免潜在的版本控制问题。 请考虑使用`constrained`可以使用更改时对调用接口方法的值类型，因为实现的接口方法的值类型方法的前缀`MethodImpl`。 中更详细地描述了这些问题<xref:System.Reflection.Emit.OpCodes.Constrained>操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`call`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法为提供`varargs`调用。 使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法进行正常调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|调用的调用约定描述的参数指向的方法。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  方法参数`arg1`通过`argN`推送到堆栈上。  
  
2.  方法入口指针推送到堆栈上。  
  
3.  方法参数`arg1`通过`argN`和从堆栈中弹出方法入口指针; 执行调用的方法。 完成后，返回值是由被调用方方法生成并发送给调用方。  
  
4.  返回值推送到堆栈上。  
  
 `calli`指令调用带有参数的方法入口指针`arg1`通过`argN`。 由特定的调用约定描述这些参数的类型 (`callSiteDesc`)。 `calli`指令可能会立即前面`tail`前缀 (<xref:System.Reflection.Emit.OpCodes.Tailcall>)，以指定应将控制转移之前释放当前的方法状态。 如果在调用时将传输到更高的信任度比原始方法的堆栈帧的方法控制将不释放;相反，会以无提示方式继续执行像`tail`尚未提供。  
  
 方法入口指针被假定为指向 （的目标计算机） 可以使用参数所描述的调用约定 （独立签名的元数据标记） 以合法方式调用的本机代码的特定指针。 可以使用创建此类指针<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>的说明，或从本机代码中传递。  
  
 调用约定不会动态检查，因此代码，则使用`calli`如果目标实际上没有使用指定的调用约定，说明无法正常工作。  
  
 参数中从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算，并放置在堆栈中，则第二个参数，则第三，直到所有必需的自变量都位于降序排序堆栈上。 实例或虚方法的参数生成代码序列必须将该实例引用 （即不能为空引用） 推送之前的所有用户可见的参数。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问，可能会引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，可以进行安全检查。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可用于执行`calli`在堆栈上的指令。 请注意，`calli`应通过调用以下方法，而不是使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>类直接在堆栈上放置该指令。  
  
-   ILGenerator.EmitCalli (操作码、 CallingConventions、 类型、 Type []，Type[]) 使用托管调用约定的调用。  
  
-   ILGenerator.EmitCalli （操作码，CallingConvention，类型，Type[]) 使用非托管调用约定的调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|调用与相关联的特定方法`obj`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`obj`推送到堆栈上。  
  
2.  方法参数`arg1`通过`argN`推送到堆栈上。  
  
3.  方法参数`arg1`通过`argN`和对象引用`obj`从堆栈中弹出用这些自变量执行方法调用和控制转移到其中的方法中`obj`方法引用元数据标记。 完成后，返回值是由被调用方方法生成并发送给调用方。  
  
4.  返回值推送到堆栈上。  
  
 `callvirt`指令对对象调用后期绑定方法。 也就是说，该方法根据选择的运行时类型`obj`而不是在方法指针中可见的编译时类。 `Callvirt` 可用来调用虚拟和实例方法。 `callvirt`指令可能会立即前面`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀，以指定应将控制转移之前释放当前堆栈帧。 如果在调用时将传输将不发布到比原始方法的堆栈帧的信任级别更高的方法的控件。  
  
 方法的元数据令牌提供的名称、 类和要调用的方法的签名。 与关联的类`obj`是它的实例的类。 如果类定义相匹配的指示的方法名称和签名的非静态方法，调用此方法。 否则按顺序检查此类的基类链中的所有类。 如果未不找到任何方法，它是错误。  
  
 `Callvirt` 调用方法之前弹出对象以及从计算堆栈的关联的参数。 如果该方法具有返回值，它会在方法完成后在堆栈上推送。 被调用方侧`obj`参数将作为参数 0，访问`arg1`作为自变量 1，依此类推。  
  
 参数中从左到右的顺序放置在堆栈上。 也就是说，第一个参数是计算，并放置在堆栈中，则第二个参数，则第三，直到所有必需的自变量都位于降序排序堆栈上。 实例引用`obj`(始终需要的`callvirt`) 必须推送之前的所有用户可见的参数。 （带有元数据令牌中） 的签名不需要此包含参数列表中的条目指针。  
  
 请注意，还可以使用调用虚拟方法<xref:System.Reflection.Emit.OpCodes.Call>指令。  
  
 <xref:System.MissingMethodException> 如果与关联的类中找不到具有指定的名称和签名的非静态方法，将引发`obj`或任何其基类。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 <xref:System.NullReferenceException> obj 为 null 时引发。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问权限会引发。 在 CIL 被转换为本机代码，而不是在运行时，可能会进行安全检查。  
  
> [!NOTE]
>  如果在值类型上调用的 System.Object 方法，请考虑使用`constrained`带有前缀`callvirt`指令。 这无需发出不同 IL 具体取决于值类型重写方法，从而避免潜在的版本控制问题。 请考虑使用`constrained`可以使用更改时对调用接口方法的值类型，因为实现的接口方法的值类型方法的前缀`MethodImpl`。 中更详细地描述了这些问题<xref:System.Reflection.Emit.OpCodes.Constrained>操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`callvirt`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尝试将引用传递的对象转换为指定的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|将对象转换为类型的新对象`class`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  从堆栈中弹出对象引用被引用的对象被强制转换为指定`class`。  
  
3.  如果成功，新的对象引用推送到堆栈上。  
  
 `castclass`指令会尝试将对象引用强制转换 (类型`O`) 位于指定类到堆栈上。 由元数据标记，该值指示所需的类指定新类。 如果位于堆栈顶部的对象的类未实现 （假定新类一个接口） 的新类并不是派生的类的新类则<xref:System.InvalidCastException>引发。 如果对象引用为空引用，则`castclass`成功并返回新的对象为 null 引用。  
  
 <xref:System.InvalidCastException> 如果 obj 不能强制转换为类将引发。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令将转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`castclass`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果这两个值相等，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；否则，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|如果推送 1`value1`等于`value2`; 否则将推送 0。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`进行比较的`value2`。  
  
4.  如果`value1`等同于`value2`，1 推送到堆栈上; 否则为 0 推入堆栈。  
  
 `ceq`指令进行比较`value1`和`value2`。 如果`value1`等同于`value2`，然后 1 (类型的`int32`) 推送到堆栈上。 否则为 0 (类型的`int32`) 推送到堆栈上。  
  
 为浮点数，`ceq`将返回 0，如果数字是无序 （或者两种方法是 NaN）。 无限期的值相等其自身。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ceq`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|如果推送 1`value1`大于`value2`; 否则将推送 0。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`cgt`测试`value1`大于`value2`。  
  
4.  如果`value1`大于`value2`，1 推送到堆栈上; 否则为 0 推入堆栈。  
  
 `cgt`指令进行比较`value1`和`value2`。 如果`value1`完全大于`value2`，则`int32`值为 1 推送到堆栈上。 否则为`int32`0 的值推送到堆栈上。  
  
-   对于浮点数，`cgt`如果数字是无序 （即，如果一个或两个参数为 NaN），则返回 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`cgt`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个无符号的或不可排序的值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|如果推送 1`value1`大于`value2`; 否则将推送 0 （无符号值）。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`cgt.un`测试`value1`大于`value2`。  
  
4.  如果`value1`大于`value2`，1 推送到堆栈上; 否则为 0 推入堆栈。  
  
 `int32`值为 1 推送到堆栈上，如果以下任一`true`:  
  
 对于浮点数`value1`未排序与`value2`。  
  
 对于整数值，`value1`严格大于`value2`时视为无符号数字。  
  
 否则为`int32`0 的值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`cgt.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果值不是有限数，则引发 <see cref="T:System.ArithmeticException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|引发<xref:System.ArithmeticException>如果值不是有限的。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。 
  
2.  `value` 从堆栈中弹出和`ckfinite`对其执行指令。  
  
3.  `value` 是如果推送回到堆栈上不会引发异常。  
  
 `ckfinite instruction`将引发<xref:System.ArithmeticException>如果`value`（浮点数） 是"不是数字"值 (NaN) 或`+-`无穷大值。 `Ckfinite` 如果不引发任何异常在堆栈上留出的值。 如果执行是未指定`value`不是浮点数。  
  
 <xref:System.ArithmeticException> 如果引发`value`不是正常数。  
  
 请注意，一个特殊的异常或派生的类的<xref:System.ArithmeticException>可能更为合适，将不正确的值传递到异常处理程序。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ckfinite`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值小于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 04|clt|如果推送 1`value1`是小于`value2`; 否则将推送 0。|  
  
 堆栈转换行为按先后顺序是： 

1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`clt`测试`value1`是小于`value2`。  
  
4.  如果`value1`是小于`value2`，1 推送到堆栈上; 否则为 0 推入堆栈。  
  
 `clt`指令进行比较`value1`和`value2`。 如果`value1`是严格小于`value2`，则`int32`值为 1 推送到堆栈上。 否则为`int32`0 的值推送到堆栈上。  
  
-   对于浮点数，`clt`如果数字是无序 （即，如果一个或两个参数为 NaN），则返回 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`clt`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较无符号的或不可排序的值 <paramref name="value1" /> 和 <paramref name="value2" />。 如果 <paramref name="value1" /> 小于 <paramref name="value2" />，则将整数值 1 <see langword="(int32" /> ) 推送到计算堆栈上；反之，将 0 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|如果推送 1`value1`是小于`value2`; 否则将推送 0 （无符号值）。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`clt.un`测试`value1`是小于`value2`。  
  
4.  如果`value1`是小于`value2`，1 推送到堆栈上; 否则为 0 推入堆栈。  
  
 `clt.un`指令进行比较`value1`和`value2`。 `int32`值为 1 推送到堆栈上，如果任意下列条件成立：  
  
-   `value1` 是严格小于`value2`(对于`clt`)。  
  
-   对于浮点数`value1`未排序与`value2`。  
  
-   对于整数值，`value1`是严格小于`value2`时视为无符号数字。  
  
 否则为`int32`0 的值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`clt.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>约束要对其进行虚方法调用的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|受限制。 `thisType`|调用类型上的虚拟方法约束类型`T`。|  
  
 `constrained`上只允许前缀`callvirt`指令。  
  
 此时 MSIL 堆栈的状态必须按如下所示：  
  
1.  托管的指针， `ptr`，推送到堆栈上。 类型`ptr`必须是托管的指针 (`&`) 到`thisType`。 请注意，这不同于与无前缀的用例`callvirt`指令，需要引用的`thisType`。  
  
2.  方法参数`arg1`通过`argN`推送到堆栈，就像使用没有前缀`callvirt`指令。  
  
 `constrained`前缀被设计为允许`callvirt`说明进行操作，使其以统一方式独立于是否`thisType`是值类型还是引用类型。  
  
 当`callvirt``method`指令加`constrained` `thisType`，执行的指令，如下所示：  
  
-   如果`thisType`是引用类型 （而不是值类型），然后`ptr`是取消引用，并指向 this 指针作为传递`callvirt`的`method`。  
  
-   如果`thisType`是值类型和`thisType`实现`method`然后`ptr`传递给 this 指针作为未修改`call``method`指令实现的`method`通过`thisType`.  
  
-   如果`thisType`是值类型和`thisType`不实现`method`然后`ptr`被取消引用、 装箱，并指向 this 指针作为传递`callvirt``method`指令。  
  
 此最后一种情况可能发生时，才`method`上定义<xref:System.Object>， <xref:System.ValueType>，或<xref:System.Enum>不被重写`thisType`。 在这种情况下，装箱会导致要进行的原始对象的副本。 但是，因为的方法都不能<xref:System.Object>， <xref:System.ValueType>，和<xref:System.Enum>修改状态的对象，不能检测到这一事实。  
  
 `constrained`前缀支持创建泛型代码的 IL 生成器。 通常情况下`callvirt`指令不是值类型上有效。 因此，需要 IL 编译器有效地执行上述在编译时，具体取决于的类型的 this 变换`ptr`和被调用的方法。 但是，当`ptr`是在编译时是未知的泛型类型不是可以进行此转换在编译时。  
  
 `constrained`操作码允许 IL 编译器能够对虚拟函数的调用以统一方式独立于是否`ptr`是值类型还是引用类型。 虽然适用于这种情况，但其中`thisType`是泛型类型变量，`constrained`前缀还适用于非泛型类型，可以降低在隐藏值类型之间的区别的语言中生成虚拟调用的复杂性和引用类型。  
  
 使用`constrained`前缀还避免了值类型的潜在版本问题。 如果`constrained`不使用前缀，具体取决于是否是值类型重写 System.Object 的方法，必须发出不同的 IL。 例如，如果值类型`V`object.tostring （） 方法中，将覆盖`call``V.ToString()`发出指令; 如果不是，请`box`指令和一个`callvirt``Object.ToString()`发出指令。 版本控制问题可能出现在前一种情况下如果稍后删除重写，并在后一种情况下，如果以后添加重写。  
  
 `constrained`前缀还可调用接口方法上的值类型，因为可以使用更改实现接口方法的值类型方法`MethodImpl`。 如果`constrained`不使用前缀，会强制编译器选择的值将在编译时绑定到的类型的方法。 使用`constrained`前缀字符允许将绑定到在运行时，而不是在编译时实现的接口方法的方法的 MSIL。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`constrained`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D3|conv.i|将转换为`native int`、 推送`native int`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int8" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|67|conv.i1|将转换为`int8`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i1`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int16" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|68|conv.i2|将转换为`int16`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i2`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|69|conv.i4|将转换为`int32`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6A|conv.i8|将转换为`int64`、 推送`int64`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|将转换为`native int`(在堆栈上为`native int`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|无符号的值转换为`native int`(在堆栈上为`native int`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号的 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|将转换为`int8`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i1`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|无符号的值转换为`int8`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i1.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i1.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|将转换为`int16`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i2`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|无符号的值转换为`int16`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i2.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i2.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|将转换为`int32`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i4`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|无符号的值转换为`int32`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i4.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i4.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|将转换为`int64`(在堆栈上为`int64`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i8`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|无符号的值转换为`int64`(在堆栈上为`int64`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i8.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.i8.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|将转换为`unsigned native int`(在堆栈上为`native int`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|将无符号值到`unsigned native int`(在堆栈上为`native int`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.uvf.u.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|将转换为`unsigned int8`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u1`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|无符号的值转换为`unsigned int8`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u1.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u1.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|将转换为`unsigned int16`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u2`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|无符号的值转换为`unsigned int16`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u2.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u2.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|将转换为`unsigned int32`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u4`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|无符号的值转换为`unsigned int32`(在堆栈上为`int32`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u4.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u4.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|将转换为`unsigned int64`(在堆栈上为`int64`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u8`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|无符号的值转换为`unsigned int64`(在堆栈上为`int64`)，并在溢出时引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u8.un`操作码将转换`value`操作码，并将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小，无法表示的目标类型，将引发异常。  
  
 从浮点数转换为整数值将向截断数字零。 请注意小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.ovf.i`或`conv.ovf.u`习惯，在这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.ovf.u8.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号整数值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|76|conv.r.un|转换无符号的整数到浮点型推送`F`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r.un`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果将浮点类型转换为一个整数，会发生溢出`result`返回未指定。 `conv.r.un`操作采用堆栈中弹出一个整数，将其解释为无符号整数，并替换表示整数的浮点数： 任一`float32`，如果这是足够宽，以表示整数而不会丢失精度，或其他`float64`。  
  
 使用此字段时不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.r.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|将转换为`float32`、 推送`F`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|将转换为`float64`、 推送`F`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned native int" />，然后将其扩展为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|E0|conv.u|将转换为`unsigned native int`、 推送`native int`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.u`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int8" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D2|conv.u1|将转换为`int8`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u1`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int16" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D1|conv.u2|将转换为`int16`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u2`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int32" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6D|conv.u4|将转换为`unsigned int32`、 推送`int32`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int64" />，然后将其扩展为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6E|conv.u8|将转换为`int64`、 推送`int64`堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和转换尝试执行操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`时加载到计算堆栈上 (除非`conv.i`或`conv.u`使用，则结果是这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正值) 或负无穷大 (如果`value`为负) 返回。 如果转换到另一个的一个整数类型发生溢出时，高顺序位将被截断。 如果结果为小于`int32`，值将进行符号扩展，以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数返回的值是未指定。  
  
 使用此字段时不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>为等效的结果类型不正确表示的结果值时将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`conv.u8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定数目的字节从源地址复制到目标地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|将数据从一个内存块复制到另一个。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  目标地址推送到堆栈上。  
  
2.  源地址推送到堆栈上。  
  
3.  要复制的字节数推送到堆栈上。  
  
4.  从堆栈弹出，字节数、 源地址和目标地址数指定的字节数都复制到目标地址的源地址。  
  
 `cpblk`指令将复制一个数字 (类型`unsigned int32`) 的字节从源地址 (类型的`*`， `native int`，或`&`) 为目标地址 (类型的`*`， `native int`，或`&`)。 行为`cpblk`是未指定，如果源和目标区域重叠。  
  
 `cpblk` 假定的源和目标解决的计算机的自然大小对齐。 `cpblk`指令可以立即前面`unaligned.<prefix>`指令指示的源或目标是未对齐。  
  
 操作`cpblk`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`cpblk`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）地址的值类型复制到目标对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|将值类型的源对象从到的目标对象。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  目标对象引用推送到堆栈上。  
  
2.  源对象引用推送到堆栈上。  
  
3.  从堆栈弹出，两个对象引用在地址处的源对象的值类型复制到目标对象的地址。  
  
 行为`cpobj`未指定源和目标对象的引用都不是指向类标记表示类的实例`classTok`(`typeref`或`typedef`)，或者如果`classTok`不表示值类型。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`cpobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将结果作为浮点（<see langword="F" /> 类型）或商（<see langword="int32" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5B|div|将两个值以返回商或浮点结果。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`除以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` div value2 满足以下条件：  
  
 &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  
  
 登录 (`result`) = +，如果签名 (`value1`) = 登录 (`value2`)，或-，如果符号 (`value1`) ~ = 登录 (`value2`)  
  
 `div`指令计算结果并将其推送到堆栈上。  
  
 整数除法向零截断。  
  
 为零的有限数量的部门生成正确的有符号无穷大值。  
  
 NaN （非一个数字） 值除以零被零或无穷大除以无穷大生成。 任何数字除以无穷大将生成零个值。  
  
 整数运算引发<xref:System.ArithmeticException>如果结果不能表示结果类型中。 如果发生这种情况`value1`是最大的负值，和`value2`为-1。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 请注意，在基于 Intel 的平台上<xref:System.OverflowException>计算 (minint div-1) 时引发。 浮点运算永远不会引发的异常 （它们生成 Nan 或无穷大相反）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`div`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>两个无符号整数值相除并将结果 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5C|div.un|将两个值，未签名，返回商。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`除以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `div.un`指令计算`value1`除以`value2`，同时作为无符号的整数和推送`result`在堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`div.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|25|dup|重复项位于堆栈顶部的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 从重复堆栈中弹出。  
  
3.  `value` 被推送回到堆栈上。  
  
4.  重复的值推送到堆栈上。  
  
 `dup`指令重复项在堆栈的顶级元素，并将留在它的两个完全相同的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`dup`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常的 <see langword="filter" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|SEH 异常处理的最终筛选器子句。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 从堆栈中弹出`endfilter`执行并将控制权转交给异常处理程序。  
  
 `Value` (它必须是类型的`int32`，是一组特定的值之一) 返回从筛选器子句。 它应该是之一：  
  
-   `exception_continue_search` (`value` = 0) 表示不继续搜索异常处理程序  
  
-   `exception_execute_handler` (`value` = 1) 开始第二个位置运行 finally 块之前与此筛选器子句的处理程序关联的异常处理的阶段是所在。 在发现后，执行处理程序。  
  
 其他整数值将产生未指定的结果。  
  
 该方法的异常表中所示的筛选器的入口点必须是筛选器的代码块中的第一个指令。 `endfilter`指令必须为筛选器的代码块中的最后一个指令 (因此只能有一个`endfilter`任何单个筛选器块)。 执行后`endfilter`指令，控制逻辑流回 CLI 异常处理机制。  
  
 不能转移到一个筛选器块除外通过异常机制的控件。 无法从一个筛选器块以外使用传输控制`throw`指令或通过执行最终`endfilter`指令。 不能嵌入`try`块内`filter`块。 如果在引发异常`filter`块中，将截获它和值为 0 (`exception_continue_search`) 返回。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`endfilter`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常块的 <see langword="fault" /> 或 <see langword="finally" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> 同样|结束`finally`或`fault`异常块的子句。|  
  
 没有堆栈此指令的转换行为。  
  
 `Endfinally` 并`endfault`结束的信号`finally`或`fault`子句，以便该堆栈展开可以继续，直到调用异常处理程序。 `endfinally`或`endfault`指令将控制转移到 CLI 异常机制。 然后，此机制在接下来搜索`finally`链如果受保护的块已退出，并保留说明中的子句。 如果出现异常退出的受保护的块，CLI 将搜索在接下来`finally`或`fault`，或输入在异常处理的第一次传递过程中选择的异常处理程序。  
  
 `endfinally`指令可能仅显示在词法上`finally`块。 与不同`endfilter`指令，没有任何要求的块的末尾`endfinally`指令，并在该处可以有任意多个`endfinally`所需的块中的说明。 这些相同的限制适用于`endfault`指令和`fault`块。  
  
 不能将控制转移到`finally`(或`fault`) 阻止除通过异常机制。 不能将控制转移共`finally`(或`fault`) 使用阻止除`throw`指令或执行`endfinally`(或`endfault`) 指令。 具体而言，您不能"倒出"的`finally`(或`fault`) 块或执行<xref:System.Reflection.Emit.OpCodes.Ret>或<xref:System.Reflection.Emit.OpCodes.Leave>中的指令`finally`(或`fault`) 块。  
  
 请注意，`endfault`和`endfinally`说明别名-它们对应于相同的操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>可以使用方法重载`endfinally`(`endfault`) 操作码，并将`ILGenerator`方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定地址的内存的指定块初始化为给定大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 18|紧接|在为给定值的内存块中设置每个位置。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  起始地址推送到堆栈上。  
  
2.  一个初始化值推送到堆栈上。  
  
3.  要初始化的字节数推送到堆栈上。  
  
4.  从堆栈弹出，字节数、 初始化值和起始地址的数量并根据它们的值执行初始化。  
  
 `initblk`指令设置数 (`unsigned int32`) 的指定地址开始的字节数 (类型的`native int`， `&`，或`*`) 的初始化值 (类型的`unsigned int8`)。 `initblk` 假定的起始地址计算机的自然大小对齐。  
  
 操作`initblk`说明可以更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`initblk`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|初始化值类型。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  要初始化的值类型的地址推送到堆栈上。  
  
2.  从堆栈中弹出地址指定地址处的值类型初始化为类型`typeTok`。  
  
 `initobj`指令初始化推送的地址由指定的值类型的每个字段 (类型的`native int`， `&`，或`*`) 为空引用或适当的基元类型 0。 调用此方法后，该实例可为要在调用构造函数方法。 如果`typeTok`是引用类型，此指令具有相同的效果`ldnull`跟`stind.ref`。  
  
 与不同<xref:System.Reflection.Emit.OpCodes.Newobj>，`initobj`不会调用构造函数方法。 `Initobj` 是用于初始化值类型，而`newobj`用于分配和初始化对象。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`initobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>测试对象引用（<see langword="O" /> 类型）是否为特定类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|测试的实例的对象引用是否`class`、 返回空引用或该类的实例或接口。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  从堆栈中弹出记录并将对象引用进行测试以查看它是否传递中的类的实例`class`。  
  
3.  （对象引用或空引用） 将结果推送到堆栈上。  
  
 `Class` 元数据标记指示所需的类。 如果位于堆栈顶部的对象的类实现`class`(如果`class`是一个接口) 或作为派生的类的`class`(如果`class`是一个常规类) 然后它强制转换为类型`class`并将结果推送到堆栈上，完全像<xref:System.Reflection.Emit.OpCodes.Castclass>已调用一样。 否则，在堆栈上推送空引用。 如果对象引用本身为空引用，则`isinst`同样将返回空引用。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`isinst`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出当前方法并跳至指定方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|退出当前方法并跳转到指定的方法。|  
  
 没有堆栈此指令的转换行为。  
  
 `jmp` （跳转） 指令将控制转移到指定的方法`method`，这是用于方法引用的元数据标记。 当前参数会传输到目标方法。  
  
 执行此指令时，计算堆栈必须为空。 调用约定、 数量和类型的目标地址上的自变量必须与匹配的当前方法。  
  
 `jmp`指令不能用于将控制转移出`try`， `filter`， `catch`，或`finally`块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`jmp`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数（由指定索引值引用）加载到堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|处的参数加载`index`到堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  处的参数值`index`推送到堆栈上。  
  
 `ldarg`指令将推送索引处的参数`index`、 参数进行索引从 0 开始，到计算堆栈上。 `ldarg`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 对于采用变长参数列表中，过程`ldarg`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令 (请参阅<xref:System.Reflection.Emit.OpCodes.Arglist>指令的更多详细信息)。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg`操作码：  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 0 的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|02|ldarg.0|将参数 0 到堆栈上加载|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 0 处的参数值推送到堆栈上。  
  
 `ldarg.0`指令是用于加载位于索引 0 处的参数值的有效编码。  
  
 `ldarg.0`指令将推送索引为 0 到计算堆栈上的参数。 `ldarg.0`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|03|ldarg.1|加载到堆栈上的参数 1。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 1 处的参数值推送到堆栈上。  
  
 `ldarg.1`指令是用于加载位于索引 1 处的参数值的有效编码。  
  
 `ldarg.1`指令将推送索引为 1 到计算堆栈上的参数。 `ldarg.1`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|04|ldarg.2|加载到堆栈上的参数 2。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 2 处的参数值推送到堆栈上。  
  
 `ldarg.2`指令是用于加载索引 2 处的参数值的有效编码。  
  
 `ldarg.2`指令将推送索引为 2 到计算堆栈上的参数。 `ldarg.2`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|05|ldarg.3|将参数 3 到堆栈上的加载。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 3 处的参数值推送到堆栈上。  
  
 `ldarg.3`指令是用于加载到索引 3 处的参数值的有效编码。  
  
 `ldarg.3`指令将推送索引为 3 到计算堆栈上的参数。 `ldarg.3`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数（由指定的短格式索引引用）加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|处的参数加载`index`到堆栈，短格式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  处的参数值`index`推送到堆栈上。  
  
 `ldarg.s`指令是有效的编码为加载参数索引为从 4 到 255 之间。  
  
 `ldarg.s`指令将推送索引处的参数`index`、 参数进行索引从 0 开始，到计算堆栈上。 `ldarg.s`指令可用于加载通过复制从传入的参数的值类型或基元值到堆栈上的。 参数值的类型是参数的由当前方法的签名指定的类型相同。  
  
 对于采用变长参数列表中，过程`ldarg.s`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令 (请参阅<xref:System.Reflection.Emit.OpCodes.Arglist>指令的更多详细信息)。  
  
 保存的整数值小于 4 个字节长的参数将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarg.s`操作码：  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|提取由索引参数的地址`index`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  地址`addr`的索引的参数的`index`推送到堆栈上。  
  
 `ldarga`指令获取地址 (类型的`*`) 的索引的参数的`index`且参数从 0 开始编制索引的位置。 地址`addr`总是与目标计算机上的自然边界对齐。  
  
 对于采用变长参数列表中，过程`ldarga`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令。  
  
 `ldarga` 可通过 ref 参数传递。 其他情况下，对于<xref:System.Reflection.Emit.OpCodes.Ldarg>和<xref:System.Reflection.Emit.OpCodes.Starg>应使用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarga`操作码：  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以短格式将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|变 `index`|提取由索引参数的地址`index`，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  地址`addr`的索引的参数的`index`推送到堆栈上。  
  
 `ldarga.s` (的缩写形式`ldarga`) 应使用参数的数字 0 到 255 之间，并且是更有效的编码。  
  
 `ldarga.s`指令获取地址 (类型的`*`) 的索引的参数的`index`且参数从 0 开始编制索引的位置。 地址`addr`总是与目标计算机上的自然边界对齐。  
  
 对于采用变长参数列表中，过程`ldarga.s`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令。  
  
 `ldarga.s` 可通过 ref 参数传递。 其他情况下，对于<xref:System.Reflection.Emit.OpCodes.Ldarg_S>和<xref:System.Reflection.Emit.OpCodes.Starg_S>应使用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldarga.s`操作码：  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|将值推送`num`到堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值`num`推送到堆栈上。  
  
 请注意，有用于整数-128 到 127，和尤其是短编码为-1 到 8 通过特殊短 （并因此更有效） 的编码。 所有短编码将 4 字节整数推送到堆栈上。 较长的编码用于 8 字节整数和 4 到 8 字节浮点数，以及无法容纳在简短的窗体中的 4 字节值。 有三种方法将推送到堆栈上的 8 字节整数常量  
  
 1. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I8>指令必须以多个 32 位为单位表示的常量。  
  
 2. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I4>指令后跟<xref:System.Reflection.Emit.OpCodes.Conv_I8>需要 9 到 32 位的常量。  
  
 3. 使用短格式指令后跟<xref:System.Reflection.Emit.OpCodes.Conv_I8>可以用 8 或更少的位表示的常量。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4`操作码：  
  
-   ILGenerator.Emit （操作码，int）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 0 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|将推送到堆栈上的 0。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 0 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|将推送到堆栈上的 1。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 1 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 1 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 2 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|将推送到堆栈上的 2。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 2 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 2 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 3 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|将推送到堆栈上的 3。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 3 推入堆栈。  
  
 这是一个特殊短编码的整数值 3 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 4 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|将推送到堆栈上的 4。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 4 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 4 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 5 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|将推送到堆栈上的 5。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 5 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 5 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.5`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 6 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|将推送到堆栈上的 6。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  6 的值推送到堆栈上。  
  
 这是一个特殊短编码的整数值 6 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.6`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 7 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|将推送到堆栈上的 7。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 7 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 7 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.7`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 8 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|将推送到堆栈上的 8。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值 8 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 8 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 -1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|将推送到堆栈上的-1。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值-1 推送到堆栈上。  
  
 这是一个特殊短编码的整数值-1 推送。 所有特殊短编码将 4 字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.m1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的 <see langword="int8" /> 值作为 <see langword="int32" /> 推送到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|将推送`num`到作为堆栈上`int32`，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值`num`推送到堆栈上。  
  
 `ldc.i4.s` 是用于将从-128 到 127 之间的整数推送到计算堆栈上更有效的编码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i4.s`操作码：  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|将推送`num`到作为堆栈上`int64`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值`num`推送到堆栈上。  
  
 此编码将推送`int64`到堆栈上的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.i8`操作码：  
  
-   ILGenerator.Emit （操作码，long）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|将推送`num`到作为堆栈上`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值`num`推送到堆栈上。  
  
 此编码将推送`float32`到堆栈上的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.r4`操作码：  
  
-   ILGenerator.Emit （操作码，单个）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|将推送`num`到作为堆栈上`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值`num`推送到堆栈上。  
  
 此编码将推送`float64`到堆栈上的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldc.r8`操作码：  
  
-   ILGenerator.Emit （操作码，double）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|元素加载`index`到类型为堆栈的顶部`typeTok`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，并因此由类型的值`O`。  
  
 标记指定的返回值类型`typeTok`指令中。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于上限`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="native int" /> 类型的元素作为 <see langword="native int" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|97|ldelem.i|中的元素加载具有类型`native int`处`index`到作为堆栈的顶部`native int`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.i`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i`是`native int`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|中的元素加载具有类型`int8`处`index`到作为堆栈的顶部`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.i1`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i1`是`int8`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|中的元素加载具有类型`int16`处`index`到作为堆栈的顶部`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.i2`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i2`是`int16`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|中的元素加载具有类型`int32`处`index`到作为堆栈的顶部`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.i4`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i4`是`int32`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int64" /> 类型的元素作为 <see langword="int64" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|中的元素加载具有类型`int64`处`index`到作为堆栈的顶部`int64`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.i8`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i8`是`int64`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float32" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|中的元素加载具有类型`float32`处`index`到作为一种类型的堆栈的顶部`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.r4`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.r4`是`float32`。  
  
 浮点值转换为类型`F`时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float64" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|中的元素加载具有类型`float64`处`index`到类型为堆栈的顶部`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.r8`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.r8`是`float64`。  
  
 浮点值转换为类型`F`时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的包含对象引用的元素作为 <see langword="O" /> 类型（对象引用）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|通过在对象引用中的元素加载`index`到类型为堆栈的顶部`O`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.ref`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.ref`是类型`O`（对象引用）。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|中的元素加载具有类型`unsigned int8`处`index`到作为堆栈的顶部`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.u1`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u1`是`int8`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|中的元素加载具有类型`unsigned int16`作为堆栈顶部的索引处`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.u2`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u2`是`int16`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|中的元素加载具有类型`unsigned int32`作为堆栈顶部的索引处`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈上。  
  
 `ldelem.u4`指令将加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u4`是`int32`。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果数组不包含所需的类型的元素将引发。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelem.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引的数组元素的地址作为 <see langword="&amp;" /> 类型（托管指针）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|处的数组元素的地址加载`index`到类型为计算堆栈的顶部`&`（托管的指针）。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 并`array`从堆栈中弹出位置处存储的地址`index`中`array`查找。  
  
4.  地址推送到堆栈上。  
  
 `ldelema`用于检索对象的数组中的特定索引处的对象的地址 (类型的`class`)。 `ldelema`指令将索引处的值的地址加载`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放置在堆栈顶部。 数组是对象，因此由类型的值`O`。 值必须属于类型`class`随指令一起传递。  
  
 返回值`ldelema`是托管的指针 (类型`&`)。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldelema`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|推送到堆栈上指定的对象中的字段的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  对象引用 （或指针） 推送到堆栈上。  
  
2.  从堆栈中弹出对象引用 （或指针）找到的对象中的指定字段的值。  
  
3.  在字段中存储的值推送到堆栈上。  
  
 `ldfld`指令将推送到堆栈上的对象中的字段的值。 该对象必须是在堆栈上的对象引用为 (类型`O`)，托管的指针 (类型`&`)，非托管的指针 (类型`native int`)，瞬态指针 (类型`*`)，或值类型的实例。 可验证代码中不允许使用的非托管指针。 必须引用字段成员的元数据标记的指定对象的字段。 返回类型是与字段关联的一个相同。 该字段可能是实例字段 （在这种情况下的对象必须不是空引用） 或静态字段。  
  
 `ldfld`指令可以跟一个或两个<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.NullReferenceException> 如果对象为空且该字段不是静态。  
  
 <xref:System.MissingFieldException> 如果在元数据中找不到指定的字段将引发。 选中此项是通常在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，不是在运行时。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|将的地址推送`field`到堆栈上指定的对象中。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  对象引用 （或指针） 推送到堆栈上。  
  
2.  从堆栈中弹出对象引用 （或指针）找到的对象中的指定字段的地址。  
  
3.  指定字段的地址推送到堆栈上。  
  
 `ldflda`指令将推送到堆栈上的对象中字段的地址。 该对象必须是在堆栈上的对象引用为 (类型`O`)，托管的指针 (类型`&`)，非托管的指针 (类型`native int`)，瞬态指针 (类型`*`)，或值类型的实例。 可验证代码中不允许使用的非托管指针。 必须引用字段成员的元数据标记的指定对象的字段。  
  
 返回的值`ldflda`是托管的指针 (类型`&`) 对象推送到堆栈上为非托管指针上，除非在这种情况下返回地址也是的非托管的指针 (类型`native int`)。  
  
 `ldflda`指令可以跟一个或两个<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.InvalidOperationException> 如果该对象不是在应用程序域正在从中访问它会引发。 无法加载不访问的应用程序域中的字段的地址。  
  
 <xref:System.NullReferenceException> 如果对象为空且该字段不是静态。  
  
 <xref:System.MissingFieldException> 如果在元数据中找不到指定的字段将引发。 选中此项是通常在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，不是在运行时。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldflda`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现特定方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|将引用的方法的指针`method`在堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  指向特定方法的非托管的指针推送到堆栈上。  
  
 特定方法 (`method`) 可以使用名为<xref:System.Reflection.Emit.OpCodes.Calli>指令，如果它所引用的托管的方法 （或从非托管代码到托管代码转换的存根）。  
  
 为使用 CLR 调用约定的本机代码点返回的值。 作为回调例程之前，不应将此方法指针传递到非托管本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldftn`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="native int" /> 类型的值作为 <see langword="native int" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4D|ldind.i|加载`native int`地址处值`addr`到作为堆栈上`native int`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.i`间接加载指令`native int`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`native int`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|46|ldind.i1|加载`int8`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。 
  
 `ldind.i1`间接加载指令`int8`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|48|ldind.i2|加载`int16`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.i2`间接加载指令`int16`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|加载`int32`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.i4`间接加载指令`int32`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|加载`int64`地址处值`addr`到作为堆栈上`int64`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.i8`间接加载指令`int64`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int64`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|加载`float32`地址处值`addr`到一种类型作为堆栈上`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.r4`间接加载指令`float32`从指定的地址值 (类型的`native int`， `&`，或 *) 到一种类型作为堆栈上`F`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|加载`float64`地址处值`addr`到一种类型作为堆栈上`F`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.r8`间接加载指令`float64`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`float64`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对象引用作为 <see langword="O" />（对象引用）类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|加载地址处的对象引用`addr`到一种类型作为堆栈上 `O`|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的对象引用。  
  
3.  提取的引用推送到堆栈上。  
  
 `ldind.ref`指令间接加载对象引用指定的地址 (类型的`native int`， `&`，或 *) 到类型为堆栈上`O`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|47|ldind.u1|加载`unsigned int8`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.u1`间接加载指令`unsigned int8`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|49|ldind.u2|加载`unsigned int16`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.u2`间接加载指令`unsigned int16`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|加载`unsigned int32`地址处值`addr`到作为堆栈上`int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  提取的值推送到堆栈上。  
  
 `ldind.u4`间接加载指令`unsigned int32`从指定的地址值 (类型的`native int`， `&`，或 *) 到作为堆栈上`int32`。  
  
 所有`ldind`的快捷方式的说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意小于 4 个字节的整数值扩展到`int32`(不`native int`) 时加载到计算堆栈上。 浮点值转换为`F`键入时加载到计算堆栈上。  
  
 正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`指针的类型一致的方式使用说明。  
  
 必须在计算机上的对象的自然大小对齐最初推送到堆栈上的地址或<xref:System.NullReferenceException>可能发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀用于预防措施的说明)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 字节的数据类型，字节顺序是依赖于 CPU 的目标。 取决于字节顺序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址可引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldind.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将从零开始的、一维数组的元素的数目推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8E|ldlen|将推送长度 (类型的`natural unsigned int`) 在堆栈上的数组。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  对数组的对象引用推送到堆栈上。  
  
2.  从堆栈中弹出数组引用和计算长度。  
  
3.  长度推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 作为返回长度`natural unsigned int`。  
  
 <xref:System.NullReferenceException> 如果数组引用为空引用会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldlen`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定索引处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|将索引处的局部变量加载`index`到堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  指定索引处的局部变量值推送到堆栈上。  
  
 `ldloc`指令将本地可变数量的内容推送到计算堆栈上传递的索引处的本地变量的编号为 0 及以上版本。 仅当该方法中的初始化标志为 true，则进入方法之前将局部变量初始化为 0。 有 65,535 (2 ^16-1） 本地变量可能 (0-65534)。 索引 65,535 无效，因为实现很可能会使用一个 2 字节整数来跟踪这两个局部变量的索引，以及给定方法的局部变量的总数。 如果已使 65535 的索引有效，它将要求的更广泛的整数，用于跟踪此类方法中的局部变量。  
  
 `ldloc.0`， `ldloc.1`， `ldloc.2`，和`ldloc.3`说明介绍了用于访问前四个本地变量的有效编码。  
  
 方法头中指定的局部变量的类型相同的值的类型。 请参阅小于 4 个字节长被扩展为类型的分区 I.本地变量`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 0 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|06|ldloc.0|将索引 0 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  位于索引 0 处的局部变量值推送到堆栈上。  
  
 `ldloc.0` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，位于索引 0 处允许访问本地变量。  
  
 方法头中指定的局部变量的类型相同的值的类型。 小于 4 个字节长的本地变量将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|07|ldloc.1|将索引 1 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  位于索引 1 处的局部变量值推送到堆栈上。  
  
 `ldloc.1` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，位于索引 1 处允许访问本地变量。  
  
 方法头中指定的局部变量的类型相同的值的类型。 小于 4 个字节长的本地变量将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|08|ldloc.2|将索引 2 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 2 处的局部变量值推送到堆栈上。  
  
 `ldloc.2` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，允许索引 2 处访问该本地变量。  
  
 方法头中指定的局部变量的类型相同的值的类型。 小于 4 个字节长的本地变量将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|09|ldloc.3|将索引 3 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  索引 3 处的局部变量值推送到堆栈上。  
  
 `ldloc.3` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，允许索引 3 处访问该本地变量。  
  
 方法头中指定的局部变量的类型相同的值的类型。 小于 4 个字节长的本地变量将进行扩展以键入`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将特定索引处的局部变量加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|将索引处的局部变量加载`index`到堆栈，短格式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  指定索引处的局部变量值推送到堆栈上。  
  
 `ldloc.s`指令将本地可变数量的内容推送到计算堆栈上传递的索引处的本地变量的编号为 0 及以上版本。 如果在方法上的初始化标志为 true，则输入方法之前将局部变量初始化为 0。 有 256 (2 ^8) 中的局部变量可能 (0-255) 的缩写形式，这是更有效的编码比`ldloc`。  
  
 方法头中指定的局部变量的类型相同的值的类型。 请参阅小于 4 个字节长被扩展为类型的分区 I.本地变量`int32`时加载到堆栈上。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloc.s`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|处的局部变量的地址加载`index`到计算堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  存储在指定索引处的局部变量的地址推送到堆栈上。  
  
 `ldloca`指令将本地可变数量的地址推送到堆栈上传递的索引处的本地变量进行编号为 0 及以上版本。 推送到堆栈上的值已经正确对齐，用于说明等<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 结果是暂时性的指针 (类型`*`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloca`操作码：  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|处的局部变量的地址加载`index`到计算堆栈上缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  存储在指定索引处的局部变量的地址推送到堆栈上。  
  
 `ldloca.s`指令将本地可变数量的地址推送到堆栈上传递的索引处的本地变量进行编号为 0 及以上版本。 推送到堆栈上的值已经正确对齐，用于说明等<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 结果是暂时性的指针 (类型`*`)。  
  
 `ldloca.s`指令提供有效的编码为用于本地变量 0 到 255 之间。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldloca.s`操作码：  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将空引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|14|ldnull|推送到堆栈上的为空引用|  
  
 堆栈转换行为按先后顺序是：  
  
1.  空对象引用推送到堆栈上。  
  
 `ldnull` 将推送空引用 (类型`O`) 在堆栈上。 这用于初始化位置之前它们填充了数据，或被拒绝时。  
  
 `ldnull` 提供与大小无关的 null 引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldnull`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将地址指向的值类型对象复制到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|值类型的复制实例`class`到堆栈。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值类型对象的地址推送到堆栈上。  
  
2.  从堆栈中弹出该地址并查找在该特定地址的实例。  
  
3.  在该位置存储的对象的值推送到堆栈上。  
  
 `ldobj`指令用于作为参数传递值类型。  
  
 `ldobj`指令将指向的值复制`addrOfValObj`(类型的`&`， `*`，或`native int`) 到堆栈的顶部。 复制的字节数取决于类的大小 (所指定的`class`参数)。 `class`参数是表示值类型的元数据标记。  
  
 操作`ldobj`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令将转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|将的值推入`field`在堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  特定字段的值推送到堆栈上。  
  
 `ldsfld`指令将静态 （在类的所有实例间共享） 的值推到堆栈上的字段。 与传递的元数据令牌相关联的返回类型是`field`。  
  
 `ldsfld`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldsfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的地址推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|推送的地址`field`在堆栈上|  
  
 堆栈转换行为按先后顺序是：  
  
1.  特定字段的地址推送到堆栈上。  
  
 `ldsflda`指令将静态 （在类的所有实例间共享） 的地址推送到堆栈上的字段。 该地址可表示为瞬态指针 (类型`*`) 如果元数据标记`field`引用的类型来管理其内存。 否则，它对应于非托管指针 (类型`native int`)。 请注意，`field`可以是静态分配有相对虚拟地址 （此时其包含的 PE 文件加载到内存中的基址中的字段的偏移量） 全局内存是非托管。  
  
 `ldsflda`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.MissingFieldException> 如果在元数据中找不到字段会引发。 选中此项是通常在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而非运行时。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldsflda`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送对元数据中存储的字符串的新对象引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|推送的元数据字符串标记的字符串对象`mdToken`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  对字符串的对象引用推送到堆栈上。  
  
 `ldstr`指令将推送的对象引用 (类型`O`) 到表示存储在元数据中的特定字符串文本的新字符串对象。 `ldstr`指令分配必需的内存量并执行将字符串文字转换为在运行时所需的字符串格式的文件中使用窗体中所需的任何格式转换。  
  
 公共语言基础结构 (CLI) 可保证两个结果`ldstr`说明两个具有相同的字符序列的元数据标记引用返回相同的字符串对象 （称为"字符串暂留"的过程）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldstr`操作码：  
  
-   ILGenerator.Emit （操作码，字符串）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|将元数据标记转换为其运行时表示形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  传入的令牌转换为`RuntimeHandle`并将其推送到堆栈上。  
  
 `ldtoken`指令推送`RuntimeHandle`指定的元数据令牌。 一个`RuntimeHandle`可以是`fieldref/fielddef`即`methodref/methoddef`，或`typeref/typedef`。  
  
 推送到堆栈上的值可用于调用`Reflection`系统类库中的方法。  
  
 对运行时句柄的信息，请参阅以下类： <xref:System.RuntimeFieldHandle>， <xref:System.RuntimeTypeHandle>，和<xref:System.RuntimeMethodHandle>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldtoken`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|将对象的虚方法的指针`method`在堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  对象引用对方法从堆栈和入口点的地址中弹出 (所指定的元数据标记`method`) 查找。  
  
3.  将指针与`method`推送到堆栈上。  
  
 生成的非托管的指针推送到堆栈中，按`ldvirtftn`可以使用调用指令<xref:System.Reflection.Emit.OpCodes.Calli>指令，如果它所引用的托管的方法 （或从非托管代码到托管代码转换的存根）。  
  
 非托管的指针指向本机代码中使用 CLR 调用约定。 作为回调例程之前，不应将此方法指针传递到非托管本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ldvirtftn`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到特定目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DD < `int32` >|将保留 `target`|退出受保护的代码区域。|  
  
 不没有为此指令指定任何堆栈转换行为。  
  
 `leave`指令无条件将控制转移到特定目标指令，表示为 4 字节有符号偏移量，从当前指令之后的指令的开头。  
  
 `leave`指令是类似于`br`指令，但它可用于退出`try`， `filter`，或`catch`块，而普通分支指令可以仅用于此类块中传输中的控件它。 `leave`指令会清空计算堆栈，并确保周围的适当`finally`块被执行。  
  
 不能使用`leave`指令，以退出`finally`块。 为了简化在 catch 块以使用有效的方法是异常处理程序的代码生成`leave`指令将控制转移到中关联的任何指令`try`块。  
  
 如果一条指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`leave`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|退出代码中，缩写形式的受保护的区域。|  
  
 不没有为此指令指定任何堆栈转换行为。  
  
 `leave.s`指令无条件将控制转移到传递的目标指令，表示为 1 字节有符号偏移量，从当前指令之后的指令的开头。  
  
 `leave.s`指令是类似于`br`指令，但它可用于退出`try`， `filter`，或`catch`块，而普通分支指令可以仅用于此类块中传输中的控件它。 `leave.s`指令会清空计算堆栈，并确保周围的适当`finally`块被执行。  
  
 不能使用`leave.s`指令，以退出`finally`块。 为了简化在 catch 块以使用有效的方法是异常处理程序的代码生成`leave.s`指令将控制转移到中关联的任何指令`try`块。  
  
 如果一条指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`leave.s`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，<see langword="*" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|从本地堆中分配空间。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  要分配的字节数推送到堆栈上。  
  
2.  从堆栈中弹出的字节数本地堆分配的大小对应的内存量。  
  
3.  指向已分配的内存的第一个字节的指针推送到堆栈上。  
  
 `localloc`指令分配`size`(类型`natural unsigned int`) 个字节从本地动态内存池，并返回的地址 (瞬态指针，类型`*`) 的第一个分配的字节。 内存块返回初始化为 0，仅当该方法中的初始化标志为`true`。 当执行当前方法<xref:System.Reflection.Emit.OpCodes.Ret>，本地内存池可供重复使用。  
  
 生成的地址，以使任何基元数据类型可以存储那里使用对齐`stind`的说明 (如<xref:System.Reflection.Emit.OpCodes.Stind_I4>) 和使用加载`ldind`说明 (如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`指令不能出现在`filter`， `catch`， `finally`，或`fault`块。  
  
 <xref:System.StackOverflowException> 如果没有足够的内存来为请求提供服务将引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`localloc`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对特定类型实例的类型化引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|将类型的类型化的引用推送`class`到堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个指向数据片段推送到堆栈上。  
  
2.  弹出指针并将其转换为的类型化引用`class`。  
  
3.  类型化的引用推送到堆栈上。  
  
 `mkrefany`指令支持动态类型化的引用传递。 类型必须为指针`&`， `*`，或`native int`，并且保留一段数据的有效地址。 `Class` 类令牌描述类型的指针所引用的数据。 `Mkrefany` 将类型化的引用推送到堆栈上，提供的不透明指针和类型描述符`class`。  
  
 允许对类型化引用的唯一有效操作是将其传递给需要作为参数的类型化的引用的方法。 然后可以使用被调用方<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>分别检索类型 （类） 和地址的说明。  
  
 <xref:System.TypeLoadException> 如果引发`class`找不到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`mkrefany`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相乘并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5A|mul|将在堆栈上的两个值相乘。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `mul`指令将乘以`value1`通过`value2`并将结果推送到堆栈上。 整数运算以无提示方式截断在溢出较高的位。  
  
 请参阅<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整数特定的乘法运算，而不进行溢出处理。  
  
 对浮点类型，0 * 无穷大 = NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`mul`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|将具有溢出检查的堆栈上的两个整数值相乘。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`，并进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf`指令将整数相乘`value1`由整数`value2`并将结果推送到堆栈上。 如果结果将不符合要求的结果类型，将引发异常。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`mul.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|并进行溢出检查堆栈上的两个无符号的值相乘。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`，并进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf.un`指令将无符号的整数相乘`value1`由无符号整数`value2`并将结果推送到堆栈上。 如果结果将不符合要求的结果类型，将引发异常。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`mul.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对一个值执行求反并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|65|neg|当前位于堆栈顶部值求反。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  值是从堆栈中弹出，取反。  
  
3.  将结果推送到堆栈上。  
  
 `neg`指令求反值，并将结果位于堆栈顶部推送。 返回类型是操作数类型相同。  
  
 求反运算的整数值是标准 2 的补数求反运算。 具体而言，而取消最小数量 （这不具有正对应） 得到的最小数量。 若要检测此溢出，请改用<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>指令相反 （即，从 0 减）。  
  
 无法溢出而取消浮点数，并从而抵消 NaN 返回 NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`neg`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|创建一个新数组的元素的类型`etype`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  数组中元素的数目推送到堆栈上。  
  
2.  从堆栈中弹出的元素数和创建数组。  
  
3.  对新数组的对象引用推送到堆栈上。  
  
 `newarr`指令将推送的对象引用 (类型`O`) 到新的从零开始的、 一维数组，将其元素是类型的`etype`（描述类型的元数据标记）。 新数组中的元素的数量应指定为`native int`。 有效的数组索引范围是从 0 到减一的元素的最大数目。  
  
 数组的元素可以是任何类型，包括值类型。  
  
 使用引用相应的值类型的元数据标记创建的数字的对象的从零开始的一维数组 (<xref:System.Int32>，依此类推)。 数组的元素将初始化为 0 的适当的类型。  
  
 使用创建非从零开始的一维数组和多维数组<xref:System.Reflection.Emit.OpCodes.Newobj>而非`newarr`。 更常见的是，使用的方法创建它们<xref:System.Array>.NET Framework 中的类。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.OverflowException> 如果引发`numElems`小于 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`newarr`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建一个值类型的新对象或新实例，并将对象引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|分配未初始化的对象或值类型和调用构造函数方法`ctor`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  自变量`arg1`通过`argn`序列中推送到堆栈上。  
  
2.  自变量`argn`通过`arg1`从堆栈中弹出和传递给`ctor`创建对象。  
  
3.  对新对象的引用推送到堆栈上。  
  
 `newobj`指令会创建一个新的对象或值类型的新实例。 `Ctor` 为元数据标记 (`methodref`或`methoddef`必须标记为作为构造函数)，它指示名称、 类和要调用的构造函数的签名。  
  
 `newobj`指令会分配与关联的类的新实例`ctor`并初始化为 0 （或适当的类型） 或空引用作为相应的新实例中的所有字段。 然后，它调用构造函数`ctor`与给定的参数以及新创建的实例。 调用的构造函数后，将新初始化的对象引用 (类型`O`) 推送到堆栈上。  
  
 从构造函数的角度来看，未初始化的对象是参数 0 并且传递给 newobj 的其他参数遵循顺序。  
  
 使用创建所有从零开始的一维数组<xref:System.Reflection.Emit.OpCodes.Newarr>，而不`newobj`。 但是，所有其他 （更多维度，或一维但不是从零开始） 创建了数组使用`newobj`。  
  
 值类型通常不创建使用`newobj`。 它们通常分配作为参数或局部变量，使用`newarr`（适用于从零开始的一维数组），或作为对象的字段。 分配后，它们将初始化使用<xref:System.Reflection.Emit.OpCodes.Initobj>。 但是，`newobj`指令可用于创建在堆栈中，然后可以作为自变量，存储在本地，并因此在传递值类型的新实例。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.MissingMethodException> 如果构造函数方法，将引发`ctor`使用指定的名称，类和签名未找到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`newobj`操作码：  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果修补操作码，则填充空间。 尽管可能消耗处理周期，但未执行任何有意义的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|00|nop|执行的操作而无需行为。|  
  
 为此指令定义没有堆栈转换行为。  
  
 `nop`操作不起作用。 它用于填充空间中，如果修补操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`nop`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|66|not|计算一个值的按位求补。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈和其按位求补计算。  
  
3.  将结果推送到堆栈上。  
  
 `not`指令计算整数值的按位求补并将推送到堆栈上的结果。 返回类型是操作数类型相同。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`not`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|60|or|计算按位或两个整数值，返回一个整数。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`弹出，从堆栈和其位或计算。  
  
4.  将结果推送到堆栈上。  
  
 `or`指令计算推送到堆栈上的结果位于堆栈上的两个值的按位 OR。  
  
 `Or` 是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`or`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>移除当前位于计算堆栈顶部的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|26|pop|弹出从堆栈顶部的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  位于顶部的值是从堆栈中弹出。  
  
 `pop`指令从堆栈中移除的顶级元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`pop`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1E|readonly。|指定后面的数组地址操作执行运行时，任何类型检查和它返回可变性受限的托管的指针。|  
  
 此前缀只能出现前面紧邻`ldelema`指令，并对这两个特殊的调用`Address`阵列上的方法。 后续操作的影响是双重的：  
  
1.  在运行时，会不执行任何类型检查操作。 请注意，通常为隐式类型检查`ldelema`和`stelem`说明在引用中使用时键入数组。 从来没有运行时类型检查的值类，因此`readonly`这种情况下是执行任何操作。  
  
2.  验证工具可变性受限的托管指针作为处理地址的操作的结果。  
  
 指针称为定义类型控制值的并且是否可转变，因此具有受限的可变性。 对于公开的任何公共字段或更新的位置中的值的方法的值类，该指针是只读的 (因此前缀的名称)。 具体而言，表示基元类型 (例如，System.Int32) 的类不公开赋值函数，因此是只读的。  
  
 仅以下方式使用受限制的这种方式中的托管的指针：  
  
-   作为`object`参数`ldfld`， `ldflda`， `stfld`， `call`，或`constrained callvirt`说明。  
  
-   作为`pointer`参数`ldobj`指令或其中的某个`ldind`说明。  
  
-   作为`source`参数`cpobj`指令。  
  
 所有其他操作不允许使用，包括`stobj`， `initobj`，或`mkrefany`操作，或任何`stind`说明。  
  
 用途`readonly`前缀是从泛型代码中的数组中提取元素时避免执行类型检查。 例如，表达式`arr[i].m()`，其中的元素类型数组`arr`是被约束为有一个接口，使用方法的泛型类型`m`，可能会编译成如下 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 无需`readonly`前缀，`ldelema`指令将在这种情况中执行类型检查其中 ！ 0 是引用类型。 不只是这种类型检查低效的但在语义上不正确。 类型检查`ldelema`是完全匹配，这是太强。 如果数组包含类型的子类 ！ 0，上面的代码将失败类型检查。  
  
 数组元素的地址提取，而不是元素本身，以便具有的句柄`arr[i]`适用于这两值类型和引用类型，并因此可以传递给`constrained callvirt`指令。  
  
 一般情况下是不安全，以跳过运行时检查，如果数组保留的引用类型的元素。 为了安全起见，它是需要确保对数组做任何修改都通过此指针。 验证程序规则确保这一点。 受限制的托管的指针可以作为实例方法调用的对象传递，因此它不是严格地说只读的值类型，但是没有任何类型的安全性问题对于值类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`readonly`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的类型标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|将推送存储在类型化引用的类型标记。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值类型引用推送到堆栈上。  
  
2.  从堆栈中弹出的类型化的引用，并检索其相应的类型标记。  
  
3.  类型标记推送到堆栈上。  
  
 类型化的引用包含类型标记和对象实例的地址。  
  
 `refanytype`指令检索嵌入在类型化引用内的类型标记。 请参阅<xref:System.Reflection.Emit.OpCodes.Mkrefany>指令创建信息的类型化的引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`refanytype`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的地址（<see langword="&amp;" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|将推送存储在类型化引用内的地址。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  值类型引用推送到堆栈上。  
  
2.  从堆栈中弹出的类型化的引用和检索相应的地址。  
  
3.  地址推送到堆栈上。  
  
 类型化的引用包含类型标记和对象实例的地址。  
  
 `refanyval`指令检索嵌入在的地址类型化的引用。 嵌入在堆栈上提供的类型化引用的类型必须匹配指定的类型`type`(元数据令牌`typedef`或`typeref`)。 请参阅<xref:System.Reflection.Emit.OpCodes.Mkrefany>相关内容的说明。  
  
 <xref:System.InvalidCastException> 如果将引发`type`不等同于存储中的类型引用的类型 (在这种情况下，`type`类提供给<xref:System.Reflection.Emit.OpCodes.Mkrefany>构造的指令所说的类型化的引用)。  
  
 <xref:System.TypeLoadException> 如果引发`type`找不到。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`refanyval`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5D|rem|推送后所得的余数`value1`通过`value2`到堆栈上。|  
  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个`value1`推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`弹出，从堆栈的其余部分`value1` `div` `value2`计算。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)，和：  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;，登录 (`result`) = 登录 (`value1`)，其中`div`是向零截断除法指令。  
  
 如果`value2`为零或`value1`为的无穷大，结果为 NaN。 如果`value2`为无穷大，结果是`value1`(求反的`-infinity`)。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 请注意，在基于 Intel 的平台<xref:System.OverflowException>计算时引发 (minint `rem` -1)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`rem`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5E|rem.un|推送后所得的余数无符号`value1`的无符号`value2`到堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 并`value1`弹出，从堆栈的其余部分`value1` `div` `value2`计算。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem.un` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)，和：  
  
 0 = `result`  <  `value2`，其中`div.un`是无符号的除法指令。  
  
 `rem.un`指令计算`result`并将其推送到堆栈上。 `Rem.un` 将其参数视为无符号整数，而<xref:System.Reflection.Emit.OpCodes.Rem>会将它们视为为有符号的整数。  
  
 `Rem.un` 未指定为浮点数。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`rem.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2A|ret|从方法返回，可能返回一个值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从被调用方计算堆栈中弹出的返回值。  
  
2.  在步骤 1 中的返回值推送到调用方计算堆栈上。  
  
 如果返回值不存在被调用方计算堆栈上，则返回任何值是 （对于被调用方或调用方方法没有堆栈转换行为）。  
  
 类型的返回值，如果有，当前方法确定要从堆栈顶部并被复制到调用当前方法的方法的堆栈中提取值的类型。 计算堆栈的当前方法必须是空 （要返回的值除外）。  
  
 `ret`指令不能用于将控制转移出`try`， `filter`， `catch`，或`finally`块。 从内部`try`或`catch`，使用<xref:System.Reflection.Emit.OpCodes.Leave>指令的目标`ret`是所有封闭异常块的外部的指令。 因为`filter`和`finally`块逻辑上属于异常处理和不在其中嵌入其代码的方法，正确生成的 Microsoft 中间语言 (MSIL) 指令不执行方法中返回从`filter`或`finally`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`ret`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>再次引发当前异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1A|重新引发|重新引发当前异常|  
  
 为此指令不定义了任何堆栈转换行为。  
  
 `rethrow`指令仅允许主体内`catch`处理程序。 它将引发此处理程序捕获相同的异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`rethrow`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|62|shl|将左移 （用零移位） 整数。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  要移动的比特数目推送到堆栈上。  
  
3.  从堆栈中弹出的要移动的位数和值指定数目的位向左移动值。  
  
4.  将结果推送到堆栈上。  
  
 `shl`指令右移值 (类型`int32`，`int64`或`native int`) 指定数目的位向左。 比特数是类型的值`int32`或`native int`。 如果要移动的位数是大于或等于提供的值的宽度 （以位为单位），返回值为未指定。  
  
 `Shl` 在每个班次上最低的位置中插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`shl`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|63|shr|将一个整数 （保留符号移位） 左移。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  要移动的比特数目推送到堆栈上。  
  
3.  从堆栈中弹出的要移动的位数和值值按指定位数向右位移。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un`指令右移值 (类型`int32`，`int64`或`native int`) 权限的指定数目的位。 比特数是类型的值`int32`或`native int`。 如果要移动的位数是大于或等于提供的值的宽度 （以位为单位），返回值为未指定。  
  
 `Shr` 复制在每个班次，保留原始值中的符号的高序位`result`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`shr`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|64|shr.un|将一个整数 （用零填充移位） 左移。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  要移动的比特数目推送到堆栈上。  
  
3.  从堆栈中弹出的要移动的位数和值值按指定位数向右位移。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un`指令右移值 (类型`int32`，`int64`或`native int`) 权限的指定数目的位。 比特数是类型的值`int32`，`int64`或`native int`。 如果要移动的位数是大于或等于提供的值的宽度 （以位为单位），返回值为未指定。  
  
 `Shr.un` 在每个班次的最高位置插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`shr.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|推送大小，以字节为单位的值类型作为`unsigned int32`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  提供的值类型的大小 （以字节为单位） (`valType`) 推送到堆栈上。  
  
 `valType` 必须是元数据标记 (`typeref`或`typedef`)，它指定值类型、 引用类型或泛型类型参数。  
  
 对于引用类型，返回的大小是相应的参考值的大小类型 （32 位系统上为 4 字节），不是引用的引用值对象中存储的数据的大小。 可以仅在类型或其定义的方法的主体中使用泛型类型参数。 该类型或方法实例化时，泛型类型参数将替换为值类型或引用类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`sizeof`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储到位于指定索引的参数槽中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|弹出从堆栈顶部的值并将其存储在自变量槽中`num`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  弹出当前位于堆栈顶部的值并将其放置在自变量槽`num`。  
  
 `starg`指令从堆栈弹出一个值，并将其放在自变量槽中`num`。 值的类型必须匹配的参数，在当前方法的签名中指定的类型。  
  
 对于采用变量参数列表中，过程`starg`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令。  
  
 执行一个存储到保存的整数值小于 4 个字节长的参数截断值，如从堆栈移动到参数。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`starg`操作码：  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储在参数槽中的指定索引处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|弹出从堆栈顶部的值并将其存储在自变量槽中`num`，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  弹出当前位于堆栈顶部的值并将其放置在自变量槽`num`。  
  
 `starg.s`指令从堆栈弹出一个值，并将其放在自变量槽中`num`。 值的类型必须匹配的参数，在当前方法的签名中指定的类型。  
  
 `starg.s`指令提供了用于与前 256 个自变量一起使用的有效编码。  
  
 对于采用变量参数列表中，过程`starg.s`仅用于初始固定参数，不是那些签名的可变部分中，可以使用指令。  
  
 执行一个存储到保存的整数值小于 4 个字节长的参数截断值，如从堆栈移动到参数。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`starg.s`操作码：  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|所提供的索引处的数组元素替换为值类型的`typeTok`在堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  索引值时， `index`，到中的元素`array`推送到堆栈上。  
  
3.  指令中指定的类型的值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem`指令替换的一维数组中提供的从零开始索引处的元素值`array`的值。 值具有指定标记的类型`typeTok`指令中。  
  
 数组是对象，并因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="native int" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9B|stelem.i|替换与提供的索引处的数组元素`native int`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i`指令将替换元素的值`index`中的一维数组`array`与`native int`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int8" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|替换与提供的索引处的数组元素`int8`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i1`指令将替换元素的值`index`中的一维数组`array`与`int8`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int16" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|替换与提供的索引处的数组元素`int16`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i2`指令将替换元素的值`index`中的一维数组`array`与`int16`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|替换与提供的索引处的数组元素`int32`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i4`指令将替换元素的值`index`中的一维数组`array`与`int32`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|替换与提供的索引处的数组元素`int64`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i8`指令将替换元素的值`index`中的一维数组`array`与`int64`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|替换与提供的索引处的数组元素`float32`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.r4`指令将替换元素的值`index`中的一维数组`array`与`float32`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|替换与提供的索引处的数组元素`float64`堆栈上的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.r8`指令将替换元素的值`index`中的一维数组`array`与`float64`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的对象 ref 值（<see langword="O" /> 类型）替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|替换与提供的索引处的数组元素`ref`值 (类型`O`) 在堆栈上。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.ref`指令将替换所提供的一维数组中的索引处的元素的值`array`与`ref`(类型`O`) 值将被推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 请注意，`stelem.ref`隐式转换到的元素类型提供的值`array`之前将值分配到的数组元素。 此强制转换可能会失败，即使已验证的代码。 从而`stelem.ref`指令可能会引发<xref:System.InvalidCastException>。 对于不是从零开始的一维数组和多维数组<xref:System.Array>类提供了<xref:System.Array.SetValue%2A>方法。  
  
 <xref:System.NullReferenceException> 如果引发`array`为 null 引用。  
  
 <xref:System.IndexOutOfRangeException> 如果将引发`index`为负或大于的绑定`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stelem.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用新值替换在对象引用或指针的字段中存储的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld 从 `field`|替换的值`field`的具有新值的对象。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  对象引用或指针推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和对象引用/指针值`field`对象中替换为所提供的值。  
  
 `stfld`指令替换的对象的字段值 (类型`O`) 或通过指针 (类型`native int`， `&`，或`*`) 使用给定值。 `Field` 是指字段成员引用的元数据标记。 `stfld`指令可以具有一个或两个前缀<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.NullReferenceException> 如果对象引用或指针为 null 引用，并且该字段是静态。  
  
 <xref:System.MissingFieldException> 如果引发`field`元数据中找不到。 通常时 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而非运行时检查。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="native int" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DF|用|存储`native int`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.i`指令存储`native int`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i`指令用于指针的类型与一致的方式。 操作`stind.i`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int8" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|52|stind.i1|存储`int8`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.i1`指令存储`int8`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i1`指令用于指针的类型与一致的方式。 操作`stind.i1`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int16" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|53|stind.i2|存储`int16`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.i2`指令存储`int16`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.2i`指令用于指针的类型与一致的方式。 操作`stind.i2`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|54|stind.i4|存储`int32`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.i4`指令存储`int32`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i4`指令用于指针的类型与一致的方式。 操作`stind.i4`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|55|stind.i8|存储`int64`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.i8`指令存储`int64`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i8`指令用于指针的类型与一致的方式。 操作`stind.i`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|56|stind.r4|存储`float32`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.r4`指令存储`float32`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.r4`指令用于指针的类型与一致的方式。 操作`stind.r4`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|57|stind.r8|存储`float64`在给定的地址值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.r8`指令存储`float64`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.r8`指令用于指针的类型与一致的方式。 操作`stind.r8`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存储所提供地址处的对象引用值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|51|stind.ref|将存储的对象引用 (类型`O`) 值在给定的地址。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址值存储在该地址。  
  
 `stind.ref`指令将存储在提供的地址的对象引用值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.ref`指令用于指针的类型与一致的方式。 操作`stind.ref`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐权限隐含的指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stind.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|从堆栈弹出一个值，并将其存储在局部变量中`index`。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出一个值，并将其置于本地变量`index`。  
  
 `stloc`指令弹出从计算堆栈顶部的值，并将其移到本地变量数目`index`，其中本地变量是及更高版本编号为 0。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 正确的 Microsoft 中间语言 (MSIL) 指令需要`index`是有效的本地索引。 有关`stloc`指令，`index`必须介于范围 0 到 65534 （含） （具体而言，65535 无效）。 不包括 65535 的原因是实际： 实现很可能将使用一个 2 字节整数跟踪局部变量的索引以及给定方法的局部变量的总数。 如果已使 65535 的索引有效，它将要求的更广泛的整数，用于跟踪此类方法中的局部变量。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit （操作码，short）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0A|stloc.0|将值从堆栈弹出到本地变量 0。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出值并将其放在局部变量索引为 0。  
  
 `stloc.0`指令弹出从计算堆栈顶部的值，并将其移至索引为 0 的局部变量。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 `stloc.0` 是用于将值存储在本地变量 0 的非常有效的编码。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0B|stloc.1|将值从堆栈弹出到本地变量 1。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出值并将其放在局部变量索引为 1。  
  
 `stloc.1`指令弹出从计算堆栈顶部的值，并将其移至索引为 1 的局部变量。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 `stloc.1` 是用于将值存储在本地变量 1 的非常有效的编码。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0C|stloc.2|将值从堆栈弹出到本地变量 2|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出值并将其放在索引为 2 的局部变量中。  
  
 `stloc.2`指令弹出从计算堆栈顶部的值，并将其移至索引为 2 的局部变量。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 `stloc.2` 是用于将值存储在本地变量 2 的非常有效的编码。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0D|stloc.3|将值从堆栈弹出到本地变量 3|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出值并将其放在局部变量索引为 3。  
  
 `stloc.3`指令弹出从计算堆栈顶部的值，并将其移至索引为 3 的局部变量。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 `stloc.3` 是用于将值存储在本地变量 3 的非常有效的编码。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 <paramref name="index" /> 处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|从堆栈弹出一个值，并将其存储在局部变量中`index`，缩写形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  从堆栈弹出一个值，并将其置于本地变量`index`。  
  
 `stloc.s`指令弹出从计算堆栈顶部的值，并将其移到本地变量数目`index`，其中本地变量是及更高版本编号为 0。 值的类型必须匹配在当前方法的本地签名中指定的本地变量的类型。  
  
 `stloc.s`指令提供了用于局部变量 0 到 255 之间的有效编码。  
  
 存储到局部变量中保存的整数值小于 4 个字节长截断值，从堆栈移动。 从其本机大小舍入浮点值 (类型`F`) 到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stloc.s`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定类型的值从计算堆栈复制到所提供的内存地址中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|存储类型的值`class`到内存中堆栈中。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
2.  类型的值类型对象`class`推送到堆栈上。  
  
3.  从堆栈中弹出对象和地址值类型对象存储在该地址。  
  
 `stobj`指令将值类型对象复制到指定的地址的地址 (类型的指针`native int`， `*`，或`&`)。 复制的字节数表示的类的大小取决于`class`，表示值类型的元数据标记。  
  
 操作`stobj`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用来自计算堆栈的值替换静态字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|替换中的值`field`与提供的值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  从堆栈中弹出一个值，并将其存储在`field`。  
  
 `stsfld`指令在堆栈中的值替换静态字段的值。 `field` 是必须引用静态字段成员的元数据标记。  
  
 `stsfld`指令可能加<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.MissingFieldException> 如果在元数据中找不到字段会引发。 选中此项是通常在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，不是在运行时。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`stsfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从其他值中减去一个值并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|59|sub|中减去一个值，从另一个，则返回一个新的数字值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`。  
  
4.  将结果推送到堆栈上。  
  
 对于整数运算不检测溢出 (正确的溢出处理，请参阅<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整数减法包装，而不是尽量充满。 例如： 假定 8 位整数，其中`value1`设置为 0 和`value2`设置为 1，"包装"的结果将是 255。  
  
 返回浮点溢出`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`sub`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|减去从另一个具有溢出检查的一个整数值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 有符号整数; 上执行此操作为浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`sub.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|中减去一个无符号的整数值，从另一个具有溢出检查。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 有符号整数; 上执行此操作为浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`sub.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现跳转表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|切换 (`N`， `t1`， `t2`...`tN`)|跳转到其中一个`N`值。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个值推送到堆栈上。  
  
2.  堆栈中弹出值并将执行转移到指令编制索引的值的偏移量，其中的值是小于`N`。  
  
 `switch`指令实现跳转表。 指令的格式`unsigned int32`表示的目标数目`N`后, 跟`N`指定的 int32 值跳转目标。 这些目标被表示为 （正或负） 的偏移量，从一开始后的指令`switch`指令。  
  
 `switch`指令弹出堆栈中弹出一个值，并将其，比较为无符号整数到`N`。 如果值为小于`N`，执行将传递到目标索引的值，其中目标从 0 开始编号 （例如，值为 0 将第一个目标，值为 1 将第二个目标，等等）。 如果值为大于或等于`N`，在下一条指令 （贯穿） 处继续执行。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个上述前缀之一。  
  
 控制输入和输出传输`try`， `catch`， `filter`，和`finally`此指令不能执行块。 （此类传输受到严格限制，必须改为使用保留指令）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`switch`操作码。 `Label[]`参数为标签表示 32 位偏移量的数组。  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 下面的代码示例演示如何使用`Switch`操作码生成使用的数组的跳转表<xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 14|结尾。|后续调用将终止当前方法|  
  
 不没有为此指令定义任何堆栈转换行为。  
  
 `tail`前缀指令必须紧跟<xref:System.Reflection.Emit.OpCodes.Call>， <xref:System.Reflection.Emit.OpCodes.Calli>，或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令。 它指示在执行调用指令前，应删除当前方法的堆栈帧。 这也暗示着从以下调用返回的值也是当前方法返回的值和调用因此可转换为跨方法跳转。  
  
 堆栈必须为空传输的以下调用的参数除外。 调用指令之后的指令必须是 ret。因此，唯一有效的代码序列是`tail. call`(或`calli`或`callvirt`)。 正确的 Microsoft 中间语言 (MSIL) 指令必须不到分支`call`指令，但它们可能分支到后续<xref:System.Reflection.Emit.OpCodes.Ret>。  
  
 不能丢弃当前帧，控制传输到的时间不受信任的代码从受信任的代码，因为这会危害代码标识安全性。 .NET Framework 安全检查，从而可能导致`tail`被忽略，离开标准<xref:System.Reflection.Emit.OpCodes.Call>指令。 同样，为了允许同步区域发生在调用返回后退出，则`tail`时用于退出标记为已同步的方法，将忽略前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`tail`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">操作码对象的实例。</param>
        <summary>如果提供的操作码采用单字节参数则返回真或假。</summary>
        <returns><see langword="true" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于查找哪些 MSIL 操作码在优化代码中包括"缩写"，供使用。  
  
 `TakesSingleByteArgument` 返回`true`如果<xref:System.Reflection.Emit.OpCode>实例在以下情况下采用单字节自变量：  
  
-   操作码执行分支指令对字节大小的地址 (例如，<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   操作码将推送到堆栈上的字节值 (例如， <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   操作码引用变量或通过字节大小的"短格式"的自变量 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 否则，它将返回 `false`。  
  
 下面的示例演示如何使用`TakesSingleByteArgument`通过到反映`OpCodes`类和测试以查看是否每个`OpCode`字段采用单字节自变量。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引发当前位于计算堆栈上的异常对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7A|throw|引发异常。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  （对异常） 的对象引用推送到堆栈上。  
  
2.  从堆栈和引发的异常中弹出的对象引用。  
  
 `throw`指令将引发的异常对象 (类型`O`) 当前在堆栈上。  
  
 <xref:System.NullReferenceException> 如果对象引用为空引用会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`throw`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前位于计算堆栈上的地址可能没有与紧接的 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的自然大小对齐。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|未对齐。 `alignment`|表明后面的指针指令可能未对齐。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
 `Unaligned` 指定的地址 (的非托管的指针`native int`) 在堆栈上可能没有与紧接的自然大小`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`，`initblk`，或`cpblk`指令。 也就是说，对于<xref:System.Reflection.Emit.OpCodes.Ldind_I4>指令的地址的对齐方式可能不是 4 字节边界。 有关`initblk`和`cpblk`默认对齐方式是体系结构依赖 （在 32 位 Cpu，在 64 位 Cpu 上的 8 字节 4 字节）。 必须使用不将其输出限制为 32 位字大小的代码生成器`unaligned`对齐方式是如果未知，则在编译时为 8 字节。  
  
 对齐的值必须是 1、 2 或 4 和生成的代码应采用的地址是字节、 双字节，或四字节对齐，分别表示。 请注意该暂时性指针 (类型`*`) 始终对齐。  
  
 尽管的对齐方式`cpblk`指令以逻辑方式将需要两个数字 （一个用于源） 和一个用于目标，不产生明显影响性能时如果只指定了较小的数字。  
  
 `unaligned`和`volatile`前缀可以按任意顺序组合。 它们必须紧跟`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 仅<xref:System.Reflection.Emit.OpCodes.Volatile>允许使用前缀<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`unaligned`操作码：  
  
-   ILGenerator.Emit （操作码，标签）  
  
-   ILGenerator.Emit(Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类型的已装箱的表示形式转换为其未装箱的形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|79 < `T` >|取消装箱 `valType`|中的值类型数据中提取`obj`，将其装箱表示形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  对象引用是从堆栈中弹出和取消装箱值类型指针。  
  
3.  值类型指针推送到堆栈上。  
  
 值类型具有两个单独的表示形式中公共语言基础结构 (CLI):  
  
-   使用值类型嵌入在另一个对象时的原始格式。  
  
-   装箱形式，其中的值类型中的数据被包装 （装箱） 到一个对象以便它可以作为一个独立的实体存在。  
  
 `unbox`指令将转换的对象引用 (类型`O`)，则为指针值类型装箱值类型的表示形式 (托管的指针，类型`&`)，将其未装箱的形式。 提供的值类型 (`valType`) 是，它指示值类型装箱的对象中包含的类型的元数据标记。  
  
 与不同<xref:System.Reflection.Emit.OpCodes.Box>，需要在对象中，请使用值类型的副本`unbox`不需要从对象复制的值类型。 通常只需计算的值类型的已装箱对象内部存在的地址。  
  
 <xref:System.InvalidCastException> 如果该对象未被装箱为引发`valType`。  
  
 <xref:System.NullReferenceException> 如果对象引用为空引用会引发。  
  
 <xref:System.TypeLoadException> 如果类型值，将引发`valType`找不到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`unbox`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指令中指定类型的已装箱的表示形式转换成未装箱形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|从数据中提取`obj`，将其装箱表示形式。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个对象引用`obj`推送到堆栈上。  
  
2.  对象引用是从堆栈中弹出和取消装箱到指令中指定的类型。  
  
3.  生成的对象引用或值类型推送到堆栈上。  
  
 当应用于值类型的装箱形式`unbox.any`指令提取内包含的值`obj`(类型的`O`)，，因此等效于`unbox`跟`ldobj`。  
  
 当应用于引用类型，`unbox.any`指令具有相同的效果`castclass` `typeTok`。  
  
 如果操作数`typeTok`为泛型类型参数，则运行时行为由为该泛型类型参数指定的类型。  
  
 <xref:System.InvalidCastException> 如果引发`obj`不是装箱的类型。  
  
 <xref:System.NullReferenceException> 如果引发`obj`为 null 引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`unbox.any`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 13|易失性。|表示可变的后续指针引用。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  一个地址推送到堆栈上。  
  
 `volatile`。 指定的地址是易失性的地址 （即，它可以在外部引用到当前的执行线程） 和读取位置不能被缓存，或者多个存储到该位置不能被取消的结果。 将标记作为访问`volatile`只影响该单一访问; 因此，必须分别标记为其他访问到相同的位置。 不需要以原子方式执行对易失性的位置的访问。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>和`volatile`前缀可以按任意顺序组合。 它们必须紧跟`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 仅`volatile`允许使用前缀<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`volatile`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|61|xor|计算两个整数值的按位异或，并返回一个整数。|  
  
 堆栈转换行为按先后顺序是：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`弹出，从堆栈和按位异或计算。  
  
4.  按位 XOR`value2`和`value1`推送到堆栈上。  
  
 `xor`指令计算前两个的按位 XOR 值在堆栈上，并将结果留在堆栈上。  
  
 `Xor` 是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可使用`xor`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
