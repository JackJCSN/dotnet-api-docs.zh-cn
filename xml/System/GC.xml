<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b44a711ee888d1ea3c30d724e1959d5c05b1be32" /><Meta Name="ms.sourcegitcommit" Value="93667418e6e77da6ba7109a407c61b8969cec4ec" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/05/2019" /><Meta Name="ms.locfileid" Value="67571243" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a5881-101">控制系统垃圾回收器（一种自动回收未使用内存的服务）。</span><span class="sxs-lookup"><span data-stu-id="a5881-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-102">垃圾回收器是公共语言运行时组件，用于控制分配和释放的托管内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="a5881-103">对某个对象并释放由对象分配的资源执行垃圾回收时，会影响此类中的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="a5881-104">此类中的属性系统和年龄类别或生成，分配给对象的内存中提供信息的总可用内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="a5881-105">垃圾回收器跟踪并回收托管内存中分配的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="a5881-106">我们会定期垃圾回收器执行垃圾回收来回收内存分配给对象没有有效的引用。</span><span class="sxs-lookup"><span data-stu-id="a5881-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="a5881-107">不能满足内存要求，使用可用的可用内存时自动发生垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="a5881-108">或者，应用程序可以强制垃圾收集使用<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="a5881-109">垃圾回收包括以下步骤：</span><span class="sxs-lookup"><span data-stu-id="a5881-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="a5881-110">垃圾回收器将搜索在托管代码中引用的托管对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="a5881-111">垃圾回收器尝试完成未引用的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="a5881-112">垃圾回收器释放未引用的对象并回收其内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="a5881-113">本主题包括以下部分：</span><span class="sxs-lookup"><span data-stu-id="a5881-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="a5881-114">[垃圾回收器和非托管的资源](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="a5881-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="a5881-115">[对象老化和生成](#generations) </span><span class="sxs-lookup"><span data-stu-id="a5881-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="a5881-116">不允许垃圾回收</span><span class="sxs-lookup"><span data-stu-id="a5881-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="a5881-117">垃圾回收器和非托管的资源</span><span class="sxs-lookup"><span data-stu-id="a5881-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="a5881-118">在回收中，垃圾回收器将不会释放对象如果在托管代码中找到该对象的一个或多个引用。</span><span class="sxs-lookup"><span data-stu-id="a5881-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="a5881-119">但是，垃圾回收器不能识别从非托管代码引用的对象，并且可能会释放正在使用非托管代码中以独占方式除非明确禁止执行此操作的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="a5881-120"><xref:System.GC.KeepAlive%2A>方法提供了一种机制，可防止垃圾回收器收集非托管代码中仍在使用的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="a5881-121">除了托管的内存分配，垃圾回收器的实现不维护有关资源持有的对象，如文件句柄或数据库连接的信息。</span><span class="sxs-lookup"><span data-stu-id="a5881-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="a5881-122">当类型使用该类型的实例将被回收之前，必须释放的非托管的资源时，该类型可以实现终结器。</span><span class="sxs-lookup"><span data-stu-id="a5881-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="a5881-123">在大多数情况下，终结器实现通过重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法; 但是，在编写的类型C#或C++实现析构函数，哪些编译器将转换为的重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5881-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a5881-124">在大多数情况下，如果对象具有一个终结器，垃圾回收器会调用它之前释放对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="a5881-125">但是，垃圾回收器不需要在所有情况下; 调用终结器例如，<xref:System.GC.SuppressFinalize%2A>方法显式会被调用对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="a5881-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="a5881-126">此外，垃圾回收器不需要使用特定的线程来完成对象，或保证的相互引用，但适用于垃圾回收的对象调用终结器的顺序。</span><span class="sxs-lookup"><span data-stu-id="a5881-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="a5881-127">在其中必须在特定时间释放资源的情况下，类可以实现<xref:System.IDisposable>接口，其中包含<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>执行资源管理和清理任务的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="a5881-128">类实现<xref:System.IDisposable.Dispose%2A>必须指定，作为它们的类协定中，如果类使用者调用方法来清理对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="a5881-129">垃圾回收器不会默认情况下，调用<xref:System.IDisposable.Dispose%2A>方法; 但是，实现<xref:System.IDisposable.Dispose%2A>方法调用中方法<xref:System.GC>类自定义的垃圾回收器终止行为。</span><span class="sxs-lookup"><span data-stu-id="a5881-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="a5881-130">有关准备对象终止和 dispose 模式的详细信息，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="a5881-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="a5881-131">对象老化和生成</span><span class="sxs-lookup"><span data-stu-id="a5881-131">Object aging and generations</span></span>  
 <span data-ttu-id="a5881-132">公共语言运行时中的垃圾收集器支持使用代对象老化。</span><span class="sxs-lookup"><span data-stu-id="a5881-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="a5881-133">生成是内存中对象的相对存在时间度量单位。</span><span class="sxs-lookup"><span data-stu-id="a5881-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="a5881-134">生成编号和年龄，对象的表示对象所属的代。</span><span class="sxs-lookup"><span data-stu-id="a5881-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="a5881-135">创建多个对象最近是的较新的生成，并具有较低的生成数字不是对象前面部分创建应用程序生命周期。</span><span class="sxs-lookup"><span data-stu-id="a5881-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="a5881-136">第 0 代中是最新代中的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="a5881-137">垃圾回收器的此实现支持三代的对象、 0、 1 和 2 代。</span><span class="sxs-lookup"><span data-stu-id="a5881-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="a5881-138">可以检索的值<xref:System.GC.MaxGeneration%2A>属性来确定系统支持的最大代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="a5881-139">对象老化允许在一组特定的生成，而无需计算所有代垃圾回收器回收应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5881-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="a5881-140">重载<xref:System.GC.Collect%2A>方法，包括`generation`参数可用于指定最后一代进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="a5881-141">不允许垃圾回收</span><span class="sxs-lookup"><span data-stu-id="a5881-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="a5881-142">从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，垃圾回收器支持无 GC 区域延迟模式，可以在垃圾收集会影响应用程序的性能的关键路径执行期间使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="a5881-143">无 GC 区域延迟模式要求您指定的可以不受干扰地从垃圾回收器分配的内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="a5881-144">如果在运行时可以分配内存，运行时代码中的关键路径执行时将执行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="a5881-145">通过调用的重载之一定义的无 GC 区域的关键路径开头<xref:System.GC.TryStartNoGCRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="a5881-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="a5881-146">通过调用指定其关键路径的末尾<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="a5881-147">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-148">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-149">以下示例使用多个 GC 方法以获取生成和内存块未使用的对象有关的信息并将其打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="a5881-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="a5881-150">然后收集未使用的对象，并显示结果的内存总量。</span><span class="sxs-lookup"><span data-stu-id="a5881-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="a5881-151">垃圾回收</span><span class="sxs-lookup"><span data-stu-id="a5881-151">Garbage Collection</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="a5881-152">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="a5881-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="a5881-153">已分配的非托管内存的增量。</span><span class="sxs-lookup"><span data-stu-id="a5881-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="a5881-154">通知运行时在安排垃圾回收时应考虑分配大量的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-155">在确定何时安排垃圾回收时，运行时将考虑分配托管的内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="a5881-156">一个小的托管的对象分配大量的非托管内存，如果运行时将考虑仅托管的内存，并从而低估安排垃圾回收的紧急性。</span><span class="sxs-lookup"><span data-stu-id="a5881-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="a5881-157"><xref:System.GC.AddMemoryPressure%2A>方法将通知此附加系统内存不足的运行时。</span><span class="sxs-lookup"><span data-stu-id="a5881-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="a5881-158">在最简单的使用情况模式中，托管的对象的构造函数中的非托管的内存分配和中释放它`Dispose`或`Finalize`方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="a5881-159">调用<xref:System.GC.AddMemoryPressure%2A>方法之后分配非托管的内存，并调用<xref:System.GC.RemoveMemoryPressure%2A>方法之后释放它。</span><span class="sxs-lookup"><span data-stu-id="a5881-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="a5881-160">在更复杂的方案，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>方法进行通信，运行时对这些增量更改。</span><span class="sxs-lookup"><span data-stu-id="a5881-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a5881-161">您必须确保删除完全您添加的压力量。</span><span class="sxs-lookup"><span data-stu-id="a5881-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="a5881-162">如果不这样做可以会在长时间运行的应用程序中的系统性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="a5881-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-163"><paramref name="bytesAllocated" /> 小于或等于 0。</span><span class="sxs-lookup"><span data-stu-id="a5881-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="a5881-164">或</span><span class="sxs-lookup"><span data-stu-id="a5881-164">-or-</span></span> 
<span data-ttu-id="a5881-165">在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a5881-166">表示操作垃圾回收优先级时调用非托管的代码的能力。</span><span class="sxs-lookup"><span data-stu-id="a5881-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="a5881-167">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="a5881-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-168">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-169">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-170">取消注册垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="a5881-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-171">此方法取消使用注册垃圾回收通知<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="a5881-172">不需要调整阈值参数值在后续调用之前调用此方法<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-173">以下示例取消垃圾回收注册。</span><span class="sxs-lookup"><span data-stu-id="a5881-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="a5881-174">此示例摘自一个更大的示例为提供[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5881-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-175">此成员在启用并发垃圾回收时不可用。</span><span class="sxs-lookup"><span data-stu-id="a5881-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="a5881-176">若要了解如何禁用并发垃圾回收，请参阅 [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 运行时设置。</span><span class="sxs-lookup"><span data-stu-id="a5881-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-177">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-178">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-179">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-180">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-181">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a5881-182">强制进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-183">强制对所有代进行即时垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-184">使用此方法尝试回收无法访问的所有内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="a5881-185">它执行所有生成阻碍性垃圾的回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="a5881-186">所有对象，而不考虑时间已在内存中，被都视为集合;但是，不会收集在托管代码中引用的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="a5881-187">使用此方法强制系统尝试回收的最大可用内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="a5881-188">从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，您可以通过设置压缩大型对象堆 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前，调用<xref:System.GC.Collect%2A>方法，如下面的示例说明了。</span><span class="sxs-lookup"><span data-stu-id="a5881-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="a5881-189">下面的示例演示如何使用<xref:System.GC.Collect%2A>方法在每一代的内存上执行回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="a5881-190">代码生成的多个未使用的对象，然后调用<xref:System.GC.Collect%2A>方法以其从内存中清除。</span><span class="sxs-lookup"><span data-stu-id="a5881-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="a5881-191">被动回收</span><span class="sxs-lookup"><span data-stu-id="a5881-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="a5881-192">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="a5881-193">强制对 0 代到指定代进行即时垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-194">使用此方法尝试回收无法访问的内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="a5881-195">但是，使用此方法不保证回收指定的代中的所有无法访问内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="a5881-196">如果实现对象老化，垃圾回收器不会收集对象使用生成号大于指定的代。</span><span class="sxs-lookup"><span data-stu-id="a5881-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="a5881-197">如果未实现对象老化，垃圾回收器会在垃圾回收期间考虑的所有对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="a5881-198">使用<xref:System.GC.MaxGeneration%2A>属性来确定有效的最大值`generation`参数。</span><span class="sxs-lookup"><span data-stu-id="a5881-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="a5881-199">若要让垃圾回收器考虑而不考虑其生成的所有对象，使用此方法不带参数的版本。</span><span class="sxs-lookup"><span data-stu-id="a5881-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="a5881-200">具有垃圾回收器回收对象基于<xref:System.GCCollectionMode>设置，请使用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="a5881-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-201">下面的示例演示如何使用<xref:System.GC.Collect%2A>方法执行回收内存的各个层级上。</span><span class="sxs-lookup"><span data-stu-id="a5881-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="a5881-202">代码生成的多个未使用的对象，然后调用<xref:System.GC.Collect%2A>方法以其从内存中清除。</span><span class="sxs-lookup"><span data-stu-id="a5881-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-203"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="a5881-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="a5881-204">被动回收</span><span class="sxs-lookup"><span data-stu-id="a5881-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="a5881-205">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="a5881-206">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="a5881-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="a5881-207">强制在 <see cref="T:System.GCCollectionMode" /> 值所指定的时间对 0 代到指定代进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-208">使用`mode`参数来指定是否应该进行垃圾回收立即或仅时间是否将回收对象的最佳选择。</span><span class="sxs-lookup"><span data-stu-id="a5881-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="a5881-209">使用此方法不保证回收指定的代中的所有无法访问内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="a5881-210">若要调整的应用程序中的重要期间垃圾回收侵入性，请设置<xref:System.Runtime.GCSettings.LatencyMode%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a5881-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="a5881-211">垃圾回收器不会收集与生成号大于指定的对象`generation`参数。</span><span class="sxs-lookup"><span data-stu-id="a5881-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="a5881-212">使用<xref:System.GC.MaxGeneration%2A>属性来确定有效的最大值`generation`。</span><span class="sxs-lookup"><span data-stu-id="a5881-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="a5881-213">若要让垃圾回收器考虑而不考虑其生成的所有对象，使用此方法不带参数的版本。</span><span class="sxs-lookup"><span data-stu-id="a5881-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="a5881-214">若要有垃圾回收器回收对象最多指定的代的对象，请使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="a5881-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="a5881-215">当指定的最大生成时，收集的所有对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-216">下面的示例强制的第 2 代对象进行垃圾回收<xref:System.GCCollectionMode.Optimized>设置。</span><span class="sxs-lookup"><span data-stu-id="a5881-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-217"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="a5881-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="a5881-218">或</span><span class="sxs-lookup"><span data-stu-id="a5881-218">-or-</span></span> 
 <span data-ttu-id="a5881-219"><paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="a5881-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="a5881-220">被动回收</span><span class="sxs-lookup"><span data-stu-id="a5881-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="a5881-221">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="a5881-222">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="a5881-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="a5881-223"><see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="a5881-224">在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收是否应该为阻碍性。</span><span class="sxs-lookup"><span data-stu-id="a5881-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-225">下表总结了的交互`mode`和`blocking`参数：</span><span class="sxs-lookup"><span data-stu-id="a5881-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="a5881-226">`blocking` 为 `true`</span><span class="sxs-lookup"><span data-stu-id="a5881-226">`blocking` is `true`</span></span>|<span data-ttu-id="a5881-227">`blocking` 为 `false`</span><span class="sxs-lookup"><span data-stu-id="a5881-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="a5881-228"><xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="a5881-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="a5881-229">尽快执行阻塞回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="a5881-230">如果后台回收正在进行中以及`generation`为 0 或 1，<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法立即触发阻塞回收，并返回集合完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="a5881-231">如果后台回收正在进行中和`generation`为 2，方法会等到后台回收完成，触发阻塞第 2 代回收，，然后返回。</span><span class="sxs-lookup"><span data-stu-id="a5881-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="a5881-232">尽快执行回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="a5881-233"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</span><span class="sxs-lookup"><span data-stu-id="a5881-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="a5881-234">如果后台回收正在进行，该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="a5881-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="a5881-235">可能会执行阻止式回收，具体视垃圾回收器的状态和 `generation` 参数而定。</span><span class="sxs-lookup"><span data-stu-id="a5881-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="a5881-236">垃圾回收器会尽量提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="a5881-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="a5881-237">根据垃圾回收器的状态，有时可执行回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="a5881-238"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</span><span class="sxs-lookup"><span data-stu-id="a5881-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="a5881-239">垃圾回收器会尽量提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="a5881-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="a5881-240">如果后台回收正在进行，该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="a5881-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="a5881-241">如果调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法执行完整的阻碍性垃圾回收时，您还可以通过设置压缩大型对象堆<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前，调用<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-242"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="a5881-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="a5881-243">或</span><span class="sxs-lookup"><span data-stu-id="a5881-243">-or-</span></span> 
 <span data-ttu-id="a5881-244"><paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="a5881-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="a5881-245">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="a5881-246">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="a5881-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="a5881-247"><see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="a5881-248"><see langword="true" /> 表示压缩小对象堆；<see langword="false" /> 表示仅进行清理。</span><span class="sxs-lookup"><span data-stu-id="a5881-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="a5881-249">在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收应该为阻碍性还是压缩性。</span><span class="sxs-lookup"><span data-stu-id="a5881-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-250">如果`blocking`是`false`，GC 决定是否要执行后台任务或阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="a5881-251">如果`compacting`是`true`，它执行阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="a5881-252">如果`compacting`是`true`，运行时将压缩小对象堆 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="a5881-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="a5881-253">不会压缩大型对象堆 (LOH)，除非<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5881-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a5881-254">请注意，这包括所有阻止垃圾回收，不只是完全阻止垃圾收集。</span><span class="sxs-lookup"><span data-stu-id="a5881-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="a5881-255">您可以调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法来减少托管的堆大小可能的最小，如下面的代码段所示。</span><span class="sxs-lookup"><span data-stu-id="a5881-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="a5881-256">指定`true`为`compacting`参数可保证压缩、 完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="a5881-257">设置<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>可确保将压缩 LOH 和 SOH。</span><span class="sxs-lookup"><span data-stu-id="a5881-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="a5881-258">对象的代，将针对此代确定垃圾回收计数。</span><span class="sxs-lookup"><span data-stu-id="a5881-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="a5881-259">返回已经对对象的指定代进行的垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="a5881-260">自启动进程以来已经对指定代进行的垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="a5881-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-261">如果您实现您自己的资源管理，可能需要通过调用定期强制进行垃圾回收<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="a5881-262">由于这是代价高昂的操作，可以通过最近发生垃圾回收时跳过调用来提高性能。</span><span class="sxs-lookup"><span data-stu-id="a5881-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="a5881-263">保存返回的值<xref:System.GC.CollectionCount%2A>后立即调用<xref:System.GC.Collect%2A>。</span><span class="sxs-lookup"><span data-stu-id="a5881-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="a5881-264">您需要调用下一次<xref:System.GC.Collect%2A>，返回的当前值进行比较<xref:System.GC.CollectionCount%2A>到保存的值。</span><span class="sxs-lookup"><span data-stu-id="a5881-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="a5881-265">如果两个值相等，没有任何集合出现在此期间，它是合乎调用<xref:System.GC.Collect%2A>试。</span><span class="sxs-lookup"><span data-stu-id="a5881-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-266"><paramref name="generation" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="a5881-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-267">结束无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-268"><xref:System.GC.EndNoGCRegion%2A>方法会抛出<xref:System.InvalidOperationException>如果垃圾回收器不处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="a5881-269">任何以下情况下发生这种情况：</span><span class="sxs-lookup"><span data-stu-id="a5881-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="a5881-270"><xref:System.GC.TryStartNoGCRegion%2A>以前未调用方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="a5881-271">在调用<xref:System.GC.TryStartNoGCRegion%2A>方法返回`false`。</span><span class="sxs-lookup"><span data-stu-id="a5881-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="a5881-272">对调用<xref:System.GC.TryStartNoGCRegion%2A>方法引发了异常。</span><span class="sxs-lookup"><span data-stu-id="a5881-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="a5881-273">通过使用类似以下的代码，可以为以下任一原因防止异常：</span><span class="sxs-lookup"><span data-stu-id="a5881-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-274">垃圾回收器不处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="a5881-275">或</span><span class="sxs-lookup"><span data-stu-id="a5881-275">-or-</span></span> 
<span data-ttu-id="a5881-276">无 GC 区域延迟模式已结束，可能是因为已引发垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="a5881-277">或</span><span class="sxs-lookup"><span data-stu-id="a5881-277">-or-</span></span> 
<span data-ttu-id="a5881-278">内存分配超过了 <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> 方法调用中指定的量。</span><span class="sxs-lookup"><span data-stu-id="a5881-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="a5881-279">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="a5881-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-280">获取自当前线程的生存期开始以来分配给它的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="a5881-281">自当前线程的生存期开始以来分配给它的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="a5881-282">`GetAllocatedBytesForCurrentThread`方法返回的线程，不的垃圾回收中幸存下来的字节总数的生存期内托管堆上分配的字节总数。</span><span class="sxs-lookup"><span data-stu-id="a5881-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="a5881-283">返回的值也不包括任何本机分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="a5881-284">此方法是在监视的度量之间的时间间隔或事件内存分配的不同方案中最有用。</span><span class="sxs-lookup"><span data-stu-id="a5881-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a5881-285">返回对象的当前代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-285">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a5881-286">检索其代信息的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-286">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="a5881-287">返回指定对象的当前代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-287">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="a5881-288"><paramref name="obj" /> 的当前代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-288">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-289">使用此方法来确定对象的年龄，然后使用该信息与<xref:System.GC.Collect%2A>在同一个生成对象的方法，以强制垃圾回收器收集。</span><span class="sxs-lookup"><span data-stu-id="a5881-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="a5881-290">例如，使用此方法时有一组对象作为一个组创建的并在同一时间变为不可访问。</span><span class="sxs-lookup"><span data-stu-id="a5881-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-291">下面的示例演示如何使用<xref:System.GC.GetGeneration%2A>方法来确定对象的年龄。</span><span class="sxs-lookup"><span data-stu-id="a5881-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="a5881-292">此示例将执行垃圾回收来清理内存并进行比较 pre 和 post 集合在控制台中的内存总量。</span><span class="sxs-lookup"><span data-stu-id="a5881-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="a5881-293">引用要确定其代数的目标对象的 <see cref="T:System.WeakReference" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="a5881-294">返回指定弱引用的目标的当前代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-294">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="a5881-295"><paramref name="wo" /> 的目标的当前代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-295">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a5881-296">下面的示例演示如何将<xref:System.GC.GetGeneration%2A>方法，以确定弱引用对象的年龄。</span><span class="sxs-lookup"><span data-stu-id="a5881-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a5881-297">已经对 <paramref name="wo" /> 执行了垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-297">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="precise">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="a5881-298">如果此方法可以在返回之前等待垃圾回收发生，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-298"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a5881-299">检索当前认为要分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-299">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="a5881-300">一个参数，指示此方法是否可以等待较短间隔再返回，以便系统回收垃圾和终结对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-300">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="a5881-301">一个数字，它是托管内存中当前所分配字节数的可用的最佳近似值。</span><span class="sxs-lookup"><span data-stu-id="a5881-301">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-302">如果`forceFullCollection`参数是`true`，此方法在时系统回收垃圾和完成对象返回前等待短的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="a5881-302">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="a5881-303">间隔的持续时间为内部指定的限制由已完成的垃圾回收周期的数量和恢复周期之间的内存量的更改。</span><span class="sxs-lookup"><span data-stu-id="a5881-303">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="a5881-304">垃圾回收器不保证收集所有不可访问的内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-304">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-305">下面的示例演示如何使用<xref:System.GC.GetTotalMemory%2A>方法以获取并显示当前分配的托管内存的字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-305">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a5881-306">要引用的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-306">The object to reference.</span></span></param>
        <summary><span data-ttu-id="a5881-307">引用指定对象，使其从当前例程开始到调用此方法的那一刻为止均不符合进行垃圾回收的条件。</span><span class="sxs-lookup"><span data-stu-id="a5881-307">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-308">用途<xref:System.GC.KeepAlive%2A>方法是确保对面临风险的过早地被垃圾回收器回收对象的引用是否存在。</span><span class="sxs-lookup"><span data-stu-id="a5881-308">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="a5881-309">常见的方案可能会发生这种情况是在中的托管的代码或数据，存在对该对象不引用，但仍在使用该对象处于非托管代码如 Windows Api，非托管 Dll，或使用 COM 的方法</span><span class="sxs-lookup"><span data-stu-id="a5881-309">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Windows APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="a5881-310">此方法引用`obj`参数，从而使该对象进行垃圾回收不符合条件从例程开始到点，按执行顺序，调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-310">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="a5881-311">在结束时，不，范围的起始处的说明此方法的代码位置`obj`必须可用。</span><span class="sxs-lookup"><span data-stu-id="a5881-311">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="a5881-312"><xref:System.GC.KeepAlive%2A>方法会执行任何操作，并生成扩展中作为参数传递的对象的生存期以外没有副作用。</span><span class="sxs-lookup"><span data-stu-id="a5881-312">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-313">下面的代码示例的开始处创建一个对象及其`Main`方法并不是指对象结束时，直到再次时<xref:System.GC.KeepAlive%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-313">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="a5881-314">该对象仍然存在 30 秒持续时间内`Main`方法，即使调用<xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-314">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a5881-315">获取系统当前支持的最大代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-315">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="a5881-316">从零到所支持的最大代数间的一个值。</span><span class="sxs-lookup"><span data-stu-id="a5881-316">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-317">生成编号或年龄，对象的对象的生命周期的实现定义的相对度量。</span><span class="sxs-lookup"><span data-stu-id="a5881-317">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="a5881-318">最近创建的对象是在第 0 代和最旧的对象是否小于或等于生成返回的生成中<xref:System.GC.MaxGeneration%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a5881-318">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="a5881-319">垃圾回收器假定较新的内存更有可能有资格获得比旧内存垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-319">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="a5881-320">因此，垃圾回收器通过调整回收内存，每次生成数字来提高其性能和<xref:System.GC.MaxGeneration%2A>属性值可以随时间增长而增加。</span><span class="sxs-lookup"><span data-stu-id="a5881-320">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="a5881-321">如果实现对象老化，<xref:System.GC.MaxGeneration%2A>属性返回由系统使用的最大代数; 否则，此属性返回零。</span><span class="sxs-lookup"><span data-stu-id="a5881-321">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-322">下面的示例演示如何使用 MaxGeneration 属性中使用当前显示的最大代数。</span><span class="sxs-lookup"><span data-stu-id="a5881-322">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="a5881-323">有关此实现中，返回的值<see cref="P:System.GC.MaxGeneration" />保证属性执行的应用程序的生存期内保持不变。</span><span class="sxs-lookup"><span data-stu-id="a5881-323">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
<span data-ttu-id="a5881-324">使用<see cref="P:System.GC.MaxGeneration" />属性来确定最大值时调用，可以指定<see cref="M:System.GC.Collect(System.Int32)" />采用 generation 参数的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-324">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span></span></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="a5881-325">一个介于 1 和 99 之间的数字，指定根据在第 2 代中分配的对象，应何时引发通知。</span><span class="sxs-lookup"><span data-stu-id="a5881-325">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="a5881-326">一个介于 1 和 99 之间的数字，指定根据大对象堆中分配的对象，应何时引发通知。</span><span class="sxs-lookup"><span data-stu-id="a5881-326">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="a5881-327">指定当条件支持完整垃圾回收以及回收完成时，应引发垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="a5881-327">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-328">为每一代垃圾回收器设置分配到该代的阈值。</span><span class="sxs-lookup"><span data-stu-id="a5881-328">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="a5881-329">当分配的大小超过此阈值时，在该代触发垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-329">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="a5881-330">有关示例中，如果第 2 的代的阈值为 20 MB （这意味着 20 MB 可以幸存，但第 1 代集合和提升到第 2 代），超过 20 MB 了保留第 1 代和第 2 代入系统会提示，将尝试下一个垃圾回收作为第 2 代集合。</span><span class="sxs-lookup"><span data-stu-id="a5881-330">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="a5881-331">同样，如果大型对象堆 (LOH) 的阈值为 20 MB 和您的应用程序已经分配了超过 20 MB 的大型对象下, 一次垃圾回收将还尝试为第 2 代集合 （由于仅在第 2 代垃圾回收中收集 LOH）。</span><span class="sxs-lookup"><span data-stu-id="a5881-331">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="a5881-332">`maxGenerationThreshold`和`largeObjectHeapThreshold`阈值控制完全垃圾回收发生前收到通知多少提前。</span><span class="sxs-lookup"><span data-stu-id="a5881-332">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="a5881-333">阈值越大，通知下一次完整的垃圾回收之间可能发生的多个分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-333">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="a5881-334">如果公共语言运行时完全垃圾回收会对应用程序的性能产生负面影响的情况下，你可以要求在运行时即将执行完全垃圾回收和绕过该集合时得到通知自行引发集合 (使用<xref:System.GC.Collect%2A>方法) 仍有利条件时。</span><span class="sxs-lookup"><span data-stu-id="a5881-334">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="a5881-335">除了更改自己的垃圾收集计划，完整 GC 通知适合以下方案中：</span><span class="sxs-lookup"><span data-stu-id="a5881-335">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="a5881-336">有关完整的垃圾回收的方法监视和时，将收到通知，即将，减少实时数据大小 （例如，通过释放某些缓存条目）。</span><span class="sxs-lookup"><span data-stu-id="a5881-336">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="a5881-337">因此，当垃圾回收发生时，它便可以回收更多的内存。</span><span class="sxs-lookup"><span data-stu-id="a5881-337">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="a5881-338">监视完整的垃圾回收完成，这样可以收集一些统计信息。</span><span class="sxs-lookup"><span data-stu-id="a5881-338">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="a5881-339">例如，你可能想要度量在 GC 完成时堆的大小，以便您知道实时数据的大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-339">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="a5881-340">（完整 GC 堆后在其最小大小。）</span><span class="sxs-lookup"><span data-stu-id="a5881-340">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="a5881-341">表示完整的垃圾回收的内容的详细信息，请参阅[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)。</span><span class="sxs-lookup"><span data-stu-id="a5881-341">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="a5881-342">当你注册垃圾回收通知时，可以时完全垃圾回收的开始时间和完成后通知您。</span><span class="sxs-lookup"><span data-stu-id="a5881-342">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="a5881-343">此模式类似于操作系统如何监视内存不足通知。</span><span class="sxs-lookup"><span data-stu-id="a5881-343">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="a5881-344">使用以下准则来指定`maxGenerationThreshold`和`largeObjectHeapThreshold`参数：</span><span class="sxs-lookup"><span data-stu-id="a5881-344">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="a5881-345">阈值值越大，更多的分配将通知与完全垃圾回收之间发生。</span><span class="sxs-lookup"><span data-stu-id="a5881-345">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="a5881-346">更大的阈值值提供了更多的运行时检查临近的回收机会。</span><span class="sxs-lookup"><span data-stu-id="a5881-346">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="a5881-347">这会增加，将会通知的可能性。</span><span class="sxs-lookup"><span data-stu-id="a5881-347">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="a5881-348">但是，因为之前运行时引入下一次回收产生更多分配，不应设置过高的阈值。</span><span class="sxs-lookup"><span data-stu-id="a5881-348">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="a5881-349">当您自行诱导回收使用高阈值的通知时，不是运行时的下一次回收将回收将被回收更少的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-349">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="a5881-350">阈值越小，较少的分配通知与完全垃圾回收之间。</span><span class="sxs-lookup"><span data-stu-id="a5881-350">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-351">下面的示例演示如何注册垃圾回收通知并启动一个线程来监视垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-351">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="a5881-352">此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5881-352">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-353"><paramref name="maxGenerationThreshold" /> 或 <paramref name="largeObjectHeapThreshold" /> 不在 1 和 99 之间。</span><span class="sxs-lookup"><span data-stu-id="a5881-353"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-354">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-354">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-355">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-355">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-356">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-356">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-357">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-357">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-358">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-358">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-359">此成员在启用并发垃圾回收时不可用。</span><span class="sxs-lookup"><span data-stu-id="a5881-359">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="a5881-360">若要了解如何禁用并发垃圾回收，请参阅 &lt;gcConcurrent&gt; 运行时设置。</span><span class="sxs-lookup"><span data-stu-id="a5881-360">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="a5881-361">已释放的非托管内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-361">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="a5881-362">通知运行时已释放非托管内存，在安排垃圾回收时不需要再考虑它。</span><span class="sxs-lookup"><span data-stu-id="a5881-362">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-363">在确定何时安排垃圾回收时，运行时将考虑分配托管的内存量。</span><span class="sxs-lookup"><span data-stu-id="a5881-363">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="a5881-364">一个小的托管的对象分配大量的非托管内存，如果运行时将考虑仅托管的内存，并从而低估安排垃圾回收的紧急性。</span><span class="sxs-lookup"><span data-stu-id="a5881-364">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="a5881-365"><xref:System.GC.AddMemoryPressure%2A>方法将通知此附加系统内存不足的运行时和<xref:System.GC.RemoveMemoryPressure%2A>方法将通知运行时已释放额外的压力。</span><span class="sxs-lookup"><span data-stu-id="a5881-365">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="a5881-366">在最简单的使用情况模式中，托管的对象的构造函数中的非托管的内存分配和中释放它`Dispose`或`Finalize`方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-366">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="a5881-367">调用<xref:System.GC.AddMemoryPressure%2A>方法之后分配非托管的内存，并调用<xref:System.GC.RemoveMemoryPressure%2A>方法之后释放它。</span><span class="sxs-lookup"><span data-stu-id="a5881-367">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="a5881-368">在更复杂的方案，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>方法进行通信，运行时对这些增量更改。</span><span class="sxs-lookup"><span data-stu-id="a5881-368">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a5881-369">您必须确保删除完全您添加的压力量。</span><span class="sxs-lookup"><span data-stu-id="a5881-369">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="a5881-370">如果不这样做可以会在长时间运行的应用程序中的系统性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="a5881-370">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-371"><paramref name="bytesAllocated" /> 小于或等于 0。</span><span class="sxs-lookup"><span data-stu-id="a5881-371"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="a5881-372">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a5881-372">-or-</span></span> 
<span data-ttu-id="a5881-373">在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-373">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a5881-374">表示操作垃圾回收优先级时调用非托管的代码的能力。</span><span class="sxs-lookup"><span data-stu-id="a5881-374">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="a5881-375">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="a5881-375">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-376">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-376">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-377">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-377">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a5881-378">必须为其调用终结器的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-378">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="a5881-379">请求系统调用指定对象的终结器，此前已为该对象调用 <see cref="M:System.GC.SuppressFinalize(System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-379">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-380"><xref:System.GC.ReRegisterForFinalize%2A>方法将添加`obj`参数的垃圾回收器释放对象前会请求终止的对象的列表。</span><span class="sxs-lookup"><span data-stu-id="a5881-380">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="a5881-381">`obj`参数必须是此方法的调用方。</span><span class="sxs-lookup"><span data-stu-id="a5881-381">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="a5881-382">调用<xref:System.GC.ReRegisterForFinalize%2A>方法不保证垃圾回收器将调用对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="a5881-382">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="a5881-383">默认情况下，实现终结器的所有对象都添加到需要终止; 的对象的列表但是，对象可能已被终结，或可能已禁用通过调用的定案<xref:System.GC.SuppressFinalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-383">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="a5881-384">终结器可以使用此方法来继续研究下去自己或它所引用的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-384">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-385">下面的示例演示如何使用 ReRegisterForFinalize 方法来完成第二个对象垃圾回收后的时间。</span><span class="sxs-lookup"><span data-stu-id="a5881-385">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a5881-386"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-386"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a5881-387">不得执行其终结器的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-387">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="a5881-388">请求公共语言运行时不要调用指定对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="a5881-388">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-389">此方法的对象标头中设置有点`obj`，在调用终结器时将运行时检查。</span><span class="sxs-lookup"><span data-stu-id="a5881-389">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="a5881-390">终结器，由表示<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，用于对象进行垃圾回收之前释放非托管的资源。</span><span class="sxs-lookup"><span data-stu-id="a5881-390">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="a5881-391">如果`obj`不具有终结器中，调用<xref:System.GC.SuppressFinalize%2A>方法不起作用。</span><span class="sxs-lookup"><span data-stu-id="a5881-391">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="a5881-392">对象实现<xref:System.IDisposable>接口可以从该对象的调用此方法<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现，以防止垃圾回收器调用<xref:System.Object.Finalize%2A?displayProperty=nameWithType>上不需要的对象。</span><span class="sxs-lookup"><span data-stu-id="a5881-392">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="a5881-393">通常情况下，这样做是为了防止终结器释放非托管的资源，已释放由<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现。</span><span class="sxs-lookup"><span data-stu-id="a5881-393">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-394">下面的示例演示如何使用<xref:System.GC.SuppressFinalize%2A>中的资源类，以防止冗余垃圾回收被调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-394">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="a5881-395">该示例使用[释放模式](~/docs/standard/garbage-collection/implementing-dispose.md)若要同时释放托管资源 (即对象实现<xref:System.IDisposable>) 和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="a5881-395">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a5881-396"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-396"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb"><span data-ttu-id="a5881-397">释放模式</span><span class="sxs-lookup"><span data-stu-id="a5881-397">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a5881-398">在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-398">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="a5881-399">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-399">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-400">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-400">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="a5881-401">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a5881-401">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="a5881-402">它必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-402">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="a5881-403">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="a5881-403">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="a5881-404">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-404">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="a5881-405">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-405"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-406"><xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-406">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="a5881-407">如果运行时无法最初分配所需的内存，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-407">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="a5881-408">垃圾回收器进入无 GC 区域延迟模式，如果能够分配所需的数量的内存，在这种情况下为实际 2 \*`totalSize`字节 (它会尝试分配`totalSize`针对小型对象堆字节数和`totalSize`的字节数大型对象堆）。</span><span class="sxs-lookup"><span data-stu-id="a5881-408">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="a5881-409">`totalSize` 必须足够大，能够处理在关键路径中出现的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-409">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="a5881-410">这包括分配的应用程序，以及应用的代表，运行时做出的分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-410">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a5881-411">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-411">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-412">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-412">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="a5881-413">通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-413">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-414"><paramref name="totalSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-414"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-415">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-415">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="a5881-416">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="a5881-416">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="a5881-417">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="a5881-417">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="a5881-418">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a5881-418">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="a5881-419">它必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-419">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="a5881-420">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="a5881-420">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="a5881-421"><see langword="true" /> 表示如果垃圾回收器初始无法分配 <paramref name="totalSize" /> 字节，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-421"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a5881-422">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-422">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="a5881-423">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-423"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-424"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-424">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="a5881-425">如果运行时无法最初分配请求的内存量和`disallowFullBlockingGC`自变量是`false`，垃圾回收器执行完整的阻碍性垃圾回收中尝试释放更多内存; 否则为分配失败，并且该方法返回`false`。</span><span class="sxs-lookup"><span data-stu-id="a5881-425">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="a5881-426">垃圾回收器进入无 GC 区域延迟模式，如果能够分配所需的数量的内存，在这种情况下为实际 2 \* `totalSize` (它会尝试分配`totalSize`针对小型对象堆和`totalSize`大型对象堆）。</span><span class="sxs-lookup"><span data-stu-id="a5881-426">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="a5881-427">`totalSize` 必须足够大，能够处理在关键路径中出现的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-427">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="a5881-428">这包括分配的应用程序，以及应用的代表，运行时做出的分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-428">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="a5881-429">设置`disallowFullBlockingGC`到`true`以免完整的阻碍性垃圾回收集合最初可没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法并报告本身为准备好接受请求，如果它返回`true`，并且具有负载均衡器将请求重定向到其他系统，如果它返回`false`。</span><span class="sxs-lookup"><span data-stu-id="a5881-429">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="a5881-430">它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-430">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a5881-431">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-431">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-432">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-432">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="a5881-433">通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-433">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-434"><paramref name="totalSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-434"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-435">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-435">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="a5881-436">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="a5881-436">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="a5881-437">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="a5881-437">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="a5881-438">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a5881-438">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="a5881-439"><paramref name="totalSize" /> -<paramref name="lohSize" /> 必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-439"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="a5881-440">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="a5881-440">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="a5881-441"><paramref name="totalSize" /> 中用于大对象堆 (LOH) 分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-441">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="a5881-442">如果指定数量的内存可用于大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-442">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="a5881-443">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-443"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-444"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-444">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="a5881-445">如果运行时无法最初分配所需的内存，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-445">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="a5881-446">垃圾回收器进入无 GC 区域延迟模式，如果能够分配`lohSize`回收 loh 和`totalSize`  -  `lohSize`针对小型对象堆 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="a5881-446">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="a5881-447">`lohSize` 必须足够大，以处理对于 LOH，在关键路径中发生的所有内存分配和`totalSize`  -  `lohSize`必须足够大，能够都处理的 SOH 在关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-447">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="a5881-448">这包括分配的应用程序，以及应用的代表，运行时做出的分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-448">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a5881-449">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-449">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-450">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-450">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="a5881-451">通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-451">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-452"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-453">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-453">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="a5881-454">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="a5881-454">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="a5881-455">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="a5881-455">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="a5881-456">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a5881-456">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="a5881-457"><paramref name="totalSize" /> -<paramref name="lohSize" /> 必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-457"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="a5881-458">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="a5881-458">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="a5881-459"><paramref name="totalSize" /> 中用于大对象堆 (LOH) 分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="a5881-459">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="a5881-460"><see langword="true" /> 表示如果垃圾回收器初始无法分配小对象堆 (SOH) 和 LOH 上的指定内存，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-460"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a5881-461">如果指定数量的内存可用大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-461">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="a5881-462">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a5881-462"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-463"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-463">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="a5881-464">如果运行时无法最初分配请求的内存量和`disallowFullBlockingGC`自变量是`false`，垃圾回收器执行完整的阻碍性垃圾回收中尝试释放更多内存; 否则为分配失败，并且该方法返回`false`。</span><span class="sxs-lookup"><span data-stu-id="a5881-464">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="a5881-465">垃圾回收器进入无 GC 区域延迟模式，如果能够分配`lohSize`回收 loh 和`totalSize`  -  `lohSize`针对小型对象堆 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="a5881-465">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="a5881-466">`lohSize` 必须足够大，以处理对于 LOH，在关键路径中发生的所有内存分配和`totalSize`  -  `lohSize`必须足够大，能够都处理的 SOH 在关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-466">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="a5881-467">这包括分配的应用程序，以及应用的代表，运行时做出的分配。</span><span class="sxs-lookup"><span data-stu-id="a5881-467">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="a5881-468">设置`disallowFullBlockingGC`到`true`以免完整的阻碍性垃圾回收集合最初可没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法并报告本身为准备好接受请求，如果它返回`true`，并且具有负载均衡器将请求重定向到其他系统，如果它返回`false`。</span><span class="sxs-lookup"><span data-stu-id="a5881-468">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="a5881-469">它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-469">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a5881-470">不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-470">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="a5881-471">换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="a5881-471">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="a5881-472">通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-472">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="a5881-473"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-474">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="a5881-474">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="a5881-475">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="a5881-475">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="a5881-476">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="a5881-476">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a5881-477">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-477">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-478">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-478">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="a5881-479">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-479">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-480">使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-480">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="a5881-481">此外可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以确定完整的垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-481">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="a5881-482">当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如阻止其他对象分配和使用自行引发回收<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-482">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="a5881-483">请注意通知不保证完整的垃圾回收将实现的只能保证条件已达到阈值，支持完整垃圾回收发生。</span><span class="sxs-lookup"><span data-stu-id="a5881-483">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="a5881-484">无限期地等待垃圾回收通知，以获取此方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-484">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="a5881-485">如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="a5881-485">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="a5881-486">如果不指定超时情况下调用此方法，则可以调用<xref:System.GC.CancelFullGCNotification%2A>在等待时间长于首选的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-486">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="a5881-487">应遵循此方法通过调用<xref:System.GC.WaitForFullGCComplete%2A>方法以确保您已经完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-487">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="a5881-488">调用此方法只会导致结果不确定。</span><span class="sxs-lookup"><span data-stu-id="a5881-488">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-489">下面的示例演示如何使用此方法来确定是否正在接近完整、 阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-489">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="a5881-490">通知的状态是每当<xref:System.GCNotificationStatus.Succeeded>，将用户方法`OnFullGCApproachNotify`调用以执行操作以响应临近的集合。</span><span class="sxs-lookup"><span data-stu-id="a5881-490">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="a5881-491">此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5881-491">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-492">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-492">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-493">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-493">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-494">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-494">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-495">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-495">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-496">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-496">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="a5881-497">在获取通知状态前等待的时间长度。</span><span class="sxs-lookup"><span data-stu-id="a5881-497">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="a5881-498">指定 -1 表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="a5881-498">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a5881-499">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-499">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="a5881-500">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-500">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-501">使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-501">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="a5881-502">此外可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以确定完整的垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-502">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="a5881-503">请注意，此方法返回时获取垃圾回收通知状态，而不考虑指定的值立即`millisecondsTimeout`。</span><span class="sxs-lookup"><span data-stu-id="a5881-503">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="a5881-504">如果垃圾回收通知状态前未获取`millisecondsTimeout`时间，此方法返回<xref:System.GCNotificationStatus.NotApplicable>。</span><span class="sxs-lookup"><span data-stu-id="a5881-504">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="a5881-505">当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如阻止其他对象分配和使用自行引发回收<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-505">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="a5881-506">请注意通知不保证完整的垃圾回收将实现的只能保证条件已达到阈值，支持完整垃圾回收发生。</span><span class="sxs-lookup"><span data-stu-id="a5881-506">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="a5881-507">您可以调用<xref:System.GC.CancelFullGCNotification%2A>方法时不能等待超时周期结束。</span><span class="sxs-lookup"><span data-stu-id="a5881-507">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="a5881-508">应遵循此方法通过调用<xref:System.GC.WaitForFullGCComplete%2A>方法以确保您已经完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-508">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="a5881-509">调用此方法只会导致结果不确定。</span><span class="sxs-lookup"><span data-stu-id="a5881-509">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a5881-510"><paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span><span class="sxs-lookup"><span data-stu-id="a5881-510"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-511">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-511">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-512">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-512">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-513">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-513">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-514">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-514">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-515">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-515">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a5881-516">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-516">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-517">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-517">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="a5881-518">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-518">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-519">使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-519">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="a5881-520">此外可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以确定是否即将引发完整垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-520">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="a5881-521">当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如继续工作并获取集合计数与<xref:System.GC.CollectionCount%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a5881-521">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="a5881-522">无限期地等待垃圾回收通知，以获取此方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-522">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="a5881-523">如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="a5881-523">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="a5881-524">如果不指定超时情况下调用此方法，则可以调用<xref:System.GC.CancelFullGCNotification%2A>在等待时间长于首选的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-524">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="a5881-525">此方法调用的前面应带有通过调用<xref:System.GC.WaitForFullGCApproach%2A>方法以确保您已经完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-525">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="a5881-526">单独调用此方法可能产生不确定结果。</span><span class="sxs-lookup"><span data-stu-id="a5881-526">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-527">下面的示例演示如何使用此方法来确定是否已完成完整的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-527">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="a5881-528">通知的状态是每当<xref:System.GCNotificationStatus.Succeeded>，将用户方法`OnFullGCCompletedNotify`调用以执行操作以响应已完成的集合。</span><span class="sxs-lookup"><span data-stu-id="a5881-528">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="a5881-529">此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。</span><span class="sxs-lookup"><span data-stu-id="a5881-529">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-530">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-530">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-531">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-531">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-532">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-532">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-533">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-533">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-534">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-534">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="a5881-535">在获取通知状态前等待的时间长度。</span><span class="sxs-lookup"><span data-stu-id="a5881-535">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="a5881-536">指定 -1 表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="a5881-536">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a5881-537">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-537">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="a5881-538">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-538">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-539">使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-539">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="a5881-540">此外可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以确定是否即将引发完整垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-540">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="a5881-541">请注意，此方法返回时获取垃圾回收通知状态，而不考虑指定的值立即`millisecondsTimeout`。</span><span class="sxs-lookup"><span data-stu-id="a5881-541">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="a5881-542">如果垃圾回收通知状态前未获取`millisecondsTimeout`时间，此方法返回<xref:System.GCNotificationStatus.NotApplicable>。</span><span class="sxs-lookup"><span data-stu-id="a5881-542">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="a5881-543">当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如继续工作并获取集合计数与<xref:System.GC.CollectionCount%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a5881-543">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="a5881-544">您可以调用<xref:System.GC.CancelFullGCNotification%2A>方法时不能等待超时周期结束。</span><span class="sxs-lookup"><span data-stu-id="a5881-544">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="a5881-545">此方法调用的前面应带有通过调用<xref:System.GC.WaitForFullGCApproach%2A>方法以确保您已经完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="a5881-545">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="a5881-546">单独调用此方法可能产生不确定结果。</span><span class="sxs-lookup"><span data-stu-id="a5881-546">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a5881-547"><paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span><span class="sxs-lookup"><span data-stu-id="a5881-547"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="a5881-548">对于直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-548">for full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-549">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="a5881-549">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a5881-550">直接调用方需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="a5881-550">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a5881-551">不能由部分受信任的或透明的代码使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a5881-551">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="a5881-552">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="a5881-552">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a5881-553">挂起当前线程，直到处理终结器队列的线程清空该队列为止。</span><span class="sxs-lookup"><span data-stu-id="a5881-553">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a5881-554">当垃圾收集器发现可以回收的对象时，它会检查每个对象，以确定对象的终止要求。</span><span class="sxs-lookup"><span data-stu-id="a5881-554">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="a5881-555">如果对象实现终结器，并且未禁用通过调用终止<xref:System.GC.SuppressFinalize%2A>，该对象放在标记为准备好进行终结的对象的列表。</span><span class="sxs-lookup"><span data-stu-id="a5881-555">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="a5881-556">垃圾回收器调用<xref:System.Object.Finalize%2A>此列表中移除这些项从列表中的对象的方法。</span><span class="sxs-lookup"><span data-stu-id="a5881-556">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="a5881-557">此方法进行阻止，直到所有终结器运行到完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-557">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="a5881-558">在其运行终结器线程是未指定的因此将终止此方法不能保证。</span><span class="sxs-lookup"><span data-stu-id="a5881-558">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="a5881-559">但是，此线程时的另一个线程会中断<xref:System.GC.WaitForPendingFinalizers%2A>正在进行中。</span><span class="sxs-lookup"><span data-stu-id="a5881-559">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="a5881-560">例如，可以启动另一个线程的等待一段时间内，则中断此线程，如果此线程仍处于挂起状态。</span><span class="sxs-lookup"><span data-stu-id="a5881-560">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a5881-561">下面的示例演示如何使用<xref:System.GC.WaitForPendingFinalizers%2A>方法挂起当前线程，直到最终完成安装所收集的所有对象已完成。</span><span class="sxs-lookup"><span data-stu-id="a5881-561">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
