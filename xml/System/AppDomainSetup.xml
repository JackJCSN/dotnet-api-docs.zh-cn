<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="759804e6d0c35397ab8bdd9a5ad4486f3c6c39c4" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372552" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可以添加到 <see cref="T:System.AppDomain" /> 的实例的程序集绑定信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更改<xref:System.AppDomainSetup>实例的属性不会影响任何现有<xref:System.AppDomain>的。 当使用<xref:System.AppDomain> <xref:System.AppDomainSetup>实例作为参数调用方法时，它只会影响新创建的。<xref:System.AppDomain.CreateDomain%2A>  
  
 此类实现 <xref:System.IAppDomainSetup> 接口。  
  
> [!CAUTION]
>  <xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性的默认值为 false。 对于服务，此设置是不安全的。 若要帮助防止服务下载部分受信任的代码，请将此属性设置为 true  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">如何：配置应用程序域</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">要用于应用程序域的激活上下文。</param>
        <summary>使用指定的激活上下文（用于基于清单的应用程序域激活）初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为<xref:System.ActivationContext>指定的`activationContext`对象用于生成一个<xref:System.Runtime.Hosting.ActivationArguments>对象，该对象包含激活新应用程序域所需的信息。 可以<xref:System.Runtime.Hosting.ActivationArguments> 通过<xref:System.AppDomainSetup.ActivationArguments%2A>使用属性访问此对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">一个对象，指定以基于清单的方式激活新的应用程序域所需的信息。</param>
        <summary>使用基于清单的应用程序域激活所需的指定激活参数初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的`activationArguments`对象可以<xref:System.AppDomainSetup.ActivationArguments%2A>使用属性访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与应用程序域的激活有关的数据。</summary>
        <value>一个对象，其中包含与应用程序域的激活有关的数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为`null`，则不会引发异常。  
  
 <xref:System.Runtime.Hosting.ActivationArguments>对象提供的信息支持基于清单的激活。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">属性设置为 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性返回的 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象的应用程序标识。 如果 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性为 <see langword="null" />，则不会引发异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.AppDomainInitializer" /> 委托，该委托表示在初始化应用程序域时调用的回调方法。</summary>
        <value>一个委托，表示在初始化应用程序域时调用的回调方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要将信息传递给回调方法，请将字符串数组分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。 每次<xref:System.AppDomain>初始化时，都会将数组传递给回调方法。  
  
 回调方法在新创建的应用程序域的上下文中执行。  
  
   
  
## Examples  
 下面的示例<xref:System.AppDomainSetup>使用对象和默认应用程序`ChildDomain`域中的证据创建名为的子应用程序域。 属性设置为回调方法，该方法`AppDomainInit`是在初始化子域时调用的。 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 回调方法的参数放置在分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性的字符串数组中。 创建子域时，回调方法只是打印字符串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置传给 <see cref="T:System.AppDomainInitializer" /> 委托所表示的回调方法的参数。 在初始化应用程序域时将调用该回调方法。</summary>
        <value>一个字符串数组，当在 <see cref="T:System.AppDomainInitializer" /> 初始化过程中调用 <see cref="T:System.AppDomain" /> 委托所表示的回调方法时，该字符串数组将被传给该回调方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用属性指定在初始化过程中<xref:System.AppDomain>调用的回调方法。 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 如果未<xref:System.AppDomainSetup.AppDomainInitializer%2A>设置该属性，则不使用分配给此属性的数组。  
  
 回调方法在新创建的应用程序域的上下文中执行。  
  
   
  
## Examples  
 下面的代码示例`ChildDomain` <xref:System.AppDomainSetup>使用对象和默认应用程序域中的证据创建名为的子应用程序域。 属性设置为回调方法，该方法`AppDomainInit`是在初始化子域时调用的。 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 回调方法的参数放置在分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性的字符串数组中。 创建子域时，回调方法只是打印字符串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置程序集的显示名称，该程序集为使用 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器的类型。</summary>
        <value>程序集的显示名称，该程序集提供应用程序域管理器的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定应用程序域管理器的类型，请同时设置此属性<xref:System.AppDomainSetup.AppDomainManagerType%2A>和属性。 如果未设置这些属性中的任何一个，则将忽略另一个属性。  
  
 如果未提供任何类型，则将从与父应用程序域相同的类型（即，从中调用该<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法的应用程序域）创建应用程序域管理器。  
  
 当加载应用程序域时， <xref:System.TypeLoadException>如果程序集不存在，或者如果程序集不包含<xref:System.AppDomainSetup.AppDomainManagerType%2A>由属性指定的类型，则会引发。 <xref:System.IO.FileLoadException>如果找到程序集，但版本信息不匹配，则会引发。  
  
 若要设置默认应用程序域的应用程序域管理器，请使用 " [ \<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) " 部分中的[ \<b l y >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<y p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)元素在应用程序配置文件中，或使用中<xref:System.AppDomainManager>所述的环境变量。  
  
 此功能要求应用程序具有完全信任。 （例如，在桌面上运行的应用程序具有完全信任。）如果应用程序不具有完全信任， <xref:System.TypeLoadException>则会引发。  
  
 程序集显示名称的格式由<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性提供。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置类型的全名，该类型可为使用此 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器。</summary>
        <value>类型的全名，其中包括命名空间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定应用程序域管理器的类型，请同时设置此属性<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>和属性。 如果未设置这些属性中的任何一个，则将忽略另一个属性。  
  
 如果未提供任何类型，则将从与父应用程序域相同的类型（即，从中调用该<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法的应用程序域）创建应用程序域管理器。  
  
 当加载应用程序域时， <xref:System.TypeLoadException>如果<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>属性指定的程序集不包含此属性指定的类型，则会引发。  
  
 若要设置默认应用程序域的应用程序域管理器，请使用 " [ \<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) " 部分中的[ \<b l y >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<y p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)元素在应用程序配置文件中，或使用中<xref:System.AppDomainManager>所述的环境变量。  
  
 此功能要求应用程序具有完全信任。 （例如，在桌面上运行的应用程序具有完全信任。）如果应用程序不具有完全信任， <xref:System.TypeLoadException>则会引发。  
  
 类型的完整名称的格式由<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性提供。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationBase As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含该应用程序的目录的名称。</summary>
        <value>应用程序基目录的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序基目录是程序集管理器开始探测程序集的位置。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>属性可以影响向应用程序域授予的权限。 例如，来自本地计算机的应用程序域通常基于其源位置获得完全信任。 但是，如果<xref:System.AppDomainSetup.ApplicationBase%2A>将的<xref:System.AppDomain>属性设置为 intranet 目录的完整名称，则该<xref:System.AppDomainSetup.ApplicationBase%2A>设置会将授予应用程序域的权限限制为 LocalIntranet grant，即使应用程序域实际上来自本地计算机。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomainSetup.ApplicationBase%2A>属性设置程序集加载程序开始探测程序集以加载到新应用程序域中的位置。  
  
> [!NOTE]
>  必须确保指定的文件夹存在。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序的名称。</summary>
        <value>应用程序的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何在创建新<xref:System.AppDomainSetup.ApplicationName%2A>的应用程序域时设置属性。  
  
 该示例创建一个新的应用程序域，然后调用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>方法将示例程序集加载到新应用程序域中，并创建`Worker`类的实例。 该类继承<xref:System.MarshalByRefObject>，因此该示例可以<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>使用`TestLoad`返回的代理来调用方法。 `Worker`  
  
 `TestLoad`方法加载指定的程序集。 您必须指定有效的完全限定的程序集名称或注释掉该<xref:System.Reflection.Assembly.Load%28System.String%29>方法。 `TestLoad`方法列出加载到新应用程序域中的程序集，并显示指定的程序集和示例程序集已加载。  
  
 该示例使用<xref:System.LoaderOptimizationAttribute>特性告诉程序集加载程序，应用程序将如何跨应用程序域共享代码。  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个包含安全性和信任信息的对象。</summary>
        <value>包含安全和信任信息的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当创建时`null` ，此属性为。<xref:System.AppDomainSetup> 更改后，不能将其重置为空引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">属性设置为 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性返回的 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象的应用程序标识。 如果 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性为 <see langword="null" />，则不会引发异常。</exception>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置特定于应用程序且从中对文件进行卷影复制的区域的名称。</summary>
        <value>从中对文件进行卷影复制的目录路径和文件名的完全限定名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了使此属性生效， <xref:System.AppDomainSetup.ApplicationName%2A>还必须设置属性。 如果未<xref:System.AppDomainSetup.ApplicationName%2A>设置该属性<xref:System.AppDomainSetup.CachePath%2A> ，则将忽略属性，并将卷影副本缓存位置默认为下载缓存。  
  
 有关卷影复制的详细信息，请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">卷影复制程序集</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序域的配置文件的名称。</summary>
        <value>配置文件的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配置文件描述应用程序域的搜索规则和配置数据。 创建应用程序域的主机负责提供此数据，因为有意义的值因情况而异。  
  
 例如，为每个应用程序、站点和计算机存储 ASP.NET 应用程序的配置数据，而针对每个应用程序、用户和计算机存储可执行文件的配置数据。 只有主机知道特定情况下的配置数据细节。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">运行时设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定在搜索要加载的程序集时是否探测应用程序基路径和专用二进制路径。</summary>
        <value>如果不允许探测，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果属性为`true`，则忽略属性的值。<xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 也就是说，不会在<xref:System.AppDomainSetup.ApplicationBase%2A>属性所指定的目录中探测程序集。 此外，将忽略<xref:System.AppDomainSetup.PrivateBinPath%2A>属性<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>和属性的值。 不会在<xref:System.AppDomainSetup.PrivateBinPath%2A>属性所指定的目录中探测到的程序集。  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>属性提供了对加载过程的附加控制层。 在常规程序集加载序列中，在引发<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件之前会探测应用程序基。 但是，某些应用程序可能需要从文档内的 OLE 复合文件，或从非全局程序集缓存中或<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性指定的目录中的唯一已知位置加载程序集。 此类应用程序可<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>使用属性来避免正常探测导致的延迟，并避免加载可能位于正常探测路径中的必要程序集的副本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序域是否允许程序集绑定重定向。</summary>
        <value>如果不允许程序集的重定向，则为 <see langword="true" />；如果允许，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A>属性设计为由服务和服务器应用程序使用，其中程序集绑定重定向不是应用程序方案的一部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序域是否允许通过 HTTP 下载程序集。</summary>
        <value>如果不允许通过 HTTP 下载程序集，则为<see langword="true" /> ；如果允许则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性旨在供服务和服务器应用程序使用，在这些应用程序中从 intranet 或 Internet 下载代码不是应用程序方案的一部分。  
  
> [!CAUTION]
>  <xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性的默认值为`false`。 对于服务，此设置是不安全的。 若要帮助防止服务下载部分受信任的代码，请将`true`此属性设置为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将配置文件的 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 部分应用于应用程序域。</summary>
        <value>如果应用程序域忽略配置文件的 <see langword="true" /> 节，则为 <see langword="&lt;publisherPolicy&gt;" />；如果接受所声明的发行者策略，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>属性专门适用于在本地加载的 Web 应用程序。 使用此属性可帮助防止恶意尝试在安全模式下执行不安全的 Web 应用程序。  
  
 有关跳过发行者策略的详细信息，请参阅[重定向程序集版本](~/docs/framework/configure-apps/redirect-assembly-versions.md)主题。 有关安全模式的详细信息，请参阅[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)主题的 "检查配置文件" 部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置动态生成的文件所在的目录的基目录。</summary>
        <value><see cref="P:System.AppDomain.DynamicDirectory" /> 所在的目录。  

 <block subset="none" type="note"><para>  
 该属性的返回值不同于分配的值。
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 使用此属性可设置新应用程序域的动态目录所在的基目录。 当新应用程序域中的代码加载程序集时，程序集解析将首先在正常探测路径中查找。 如果它找不到程序集，则会在动态目录中查找<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性返回的动态目录。 新应用程序域将加载并执行的动态程序集可以放置在该处。  
  
 为<xref:System.AppDomainSetup.DynamicBase%2A>属性分配路径时，会添加一个附加的子目录; 此子目录的名称是分配<xref:System.AppDomainSetup.ApplicationName%2A>给属性的值的哈希代码。 因此，随后由此属性返回的基目录始终不同于分配的值。  
  
> [!IMPORTANT]
>  为此属性赋值不会创建任何目录。 目录必须由使用它们的代码创建或验证。  
  
 动态目录是的<xref:System.AppDomainSetup.DynamicBase%2A>子目录。 <xref:System.AppDomainSetup.ApplicationName%2A>它的简单名称是由属性返回的值，因此其格式为*原始路径*\\*哈希代码*\\*应用程序名称*。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomainSetup.DynamicBase%2A>属性来设置加载动态程序集时应用程序域探测的路径。  
  
 该示例创建一个<xref:System.AppDomainSetup>对象，并将<xref:System.AppDomainSetup.ApplicationName%2A>其属性设置为 "example" <xref:System.AppDomainSetup.DynamicBase%2A> ，并将其属性设置为 "C:\DynamicAssemblyDir"。 然后，该示例显示<xref:System.AppDomainSetup.DynamicBase%2A>属性，显示已将应用程序名称的哈希代码附加为最初分配的路径的子目录。  
  
> [!NOTE]
>  本示例中的基目录应位于示例应用程序的探测路径之外。 请确保在其他位置编译该示例。 每次运行该示例时，删除基目录及其所有子目录。  
  
 该示例使用<xref:System.AppDomainSetup>对象创建一个新的应用程序域。 然后，该示例创建动态目录（如果它尚不存在）。 尽管该示例使用应用程序域的<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性来获取动态目录的名称，但它可以通过连接原始路径、应用程序名称的哈希代码和应用程序名称。  
  
 该示例包含一个`GenerateDynamicAssembly`方法，该方法发出名`DynamicHelloWorld.dll`为的程序集，并将其存储在新应用程序域的动态目录中。 动态程序集包含一个类型， `HelloWorld`该类型具有一个名为`HelloFromAD`的`Shared`静态方法（Visual Basic 中的方法）。 调用此方法将显示应用程序域的名称。  
  
 类派生自<xref:System.MarshalByRefObject>，因此该示例可以在新的应用程序域中创建类的实例并调用其`Test`方法。 `Example` 方法按其显示名称加载动态程序集，并调用静态`HelloFromAD`方法。 `Test`  
  
 可以通过编写名为`DynamicHelloWorld.dll`的程序集的代码，并在与此示例相同的目录中进行编译，来显示在正常探测路径之后搜索动态目录。 程序集必须具有名为`HelloWorld`的静态`HelloFromAD`方法的类。 此方法不必与示例中的相同。它可以直接在控制台上显示字符串。 该程序集还必须有<xref:System.Reflection.AssemblyVersionAttribute>一个将其版本设置为1.0.0.0 的特性。 运行此示例时，将在搜索动态目录之前找到当前目录中编译的程序集。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">无法设置此属性，因为应用程序域上的应用程序名为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息，这些信息优先于应用程序的 XML 配置信息。</summary>
        <returns>一个数组，其中包含由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息；如果未调用 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了一种方法来重写创建新应用程序域的应用程序的配置信息。 中`value`的配置文件信息覆盖应用程序的配置文件信息。 例如，当 Example 应用程序创建新的应用程序域时，它可以重写最初从 web.config 文件中获取的配置信息。  
  
> [!IMPORTANT]
>  配置文件信息的某些使用者不使用<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法所存储的信息。 运行时不强制执行此功能。 若要确保在新的应用程序域中覆盖所有配置文件信息，请<xref:System.AppDomainSetup.ConfigurationFile%2A>使用属性来指定配置文件。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。  
  
 中`value`的 xml 与普通配置文件中的 xml 相同，不同之处在于它以<xref:System.Byte>数组形式存储。  
  
 若要访问应用程序域的配置字节，请使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>属性<xref:System.AppDomainSetup>获取应用程序<xref:System.AppDomainSetup.GetConfigurationBytes%2A>域的对象，然后使用方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此域关联的许可证文件的位置。</summary>
        <value>许可证文件的位置和名称。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定用于加载可执行文件的优化策略。</summary>
        <value>与 <see cref="T:System.LoaderOptimizationAttribute" /> 配合使用的枚举常数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个动态程序集，并将其保存到磁盘，然后<xref:System.AppDomainSetup.LoaderOptimization%2A>使用属性设置用于将程序集加载到应用程序域的优化策略。  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置标以 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 标志的程序集的列表，这些程序集对沙箱应用程序域中的部分信任代码可见。</summary>
        <value>部分程序集名称的数组，其中每个部分名称都由简单程序集名称和公钥组成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从开始<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> <xref:System.Security.AllowPartiallyTrustedCallersAttribute> ，可以通过将（APTCA）属性的属性设置为来使其成为条件特性。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 标记为的 APTCA 程序集<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>不能由部分受信任的代码使用，除非宿主应用程序允许它。  
  
 沙盒应用程序域的宿主允许应用程序域中的代码通过以下方式使用程序集：具有条件 APTCA 特性的程序集：创建一个包含每个程序集的简单名称和公钥的数组，并将该数组分配给此属性。 例如，数组元素可能如下所示："MyAssembly，PublicKey =0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  如果你使用的是的子类<xref:System.AppDomainManager>，并且定义它的程序集依赖于标记有条件 APTCA 特性的程序集，则你必须将这些程序集包含在你传递<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>给的<xref:System.AppDomainSetup>属性的列表中。使用创建应用程序域。 否则，将禁用用条件 APTCA 特性标记的程序集。  
  
> [!NOTE]
>  调试在沙盒应用程序域中运行的应用程序时，某些<xref:System.Security.SecurityException>消息可能会产生误导。 例如，消息可能表明，其中一个完全受信任的程序集只有有限的权限，而问题的真正原因在于，超过沙盒应用程序域的授予集的安全要求已传播到沙盒应用程序域失败。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序基目录下的目录列表，这些目录被探测以寻找其中的私有程序集。</summary>
        <value>目录名称的列表，以用分号分隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私有程序集部署在与应用程序相同的目录结构中。 如果为指定的<xref:System.AppDomainSetup.PrivateBinPath%2A>目录不在下<xref:System.AppDomainSetup.ApplicationBase%2A>，则它们将被忽略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个字符串值，用于在应用程序的搜索路径中包含 <see cref="P:System.AppDomainSetup.ApplicationBase" />，或者从搜索路径中排除该基路径而只在 <see cref="P:System.AppDomainSetup.PrivateBinPath" /> 中进行搜索。</summary>
        <value>空引用（ Visual Basic 中的 <see langword="Nothing" />），包括搜索程序集时的应用程序基路径；要排除该路径的任何非空字符串值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为任何非 null 字符串值（包括<xref:System.String.Empty?displayProperty=nameWithType> （""）），以排除应用程序目录路径<xref:System.AppDomainSetup.ApplicationBase%2A> （即从应用程序的搜索路径获取），并仅搜索中<xref:System.AppDomainSetup.PrivateBinPath%2A>的程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在应用程序域中为互操作调用禁用接口缓存，从而对每个调用执行 <c>QueryInterface</c>。</summary>
        <value>如果为使用当前 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域中的互操作调用禁用接口缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 禁用接口缓存会对互操作调用的性能产生显著影响。  
  
 此成员是在中引入[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">指定兼容性开关的字符串值的可枚举集或要擦除现有兼容性开关的 <see langword="null" />。</param>
        <summary>设置指定的开关，从而使应用程序域针对指定问题与早期版本的 .NET Framework 兼容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 的主要版本有时会引入以前版本的重大更改。 例如， [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]从中引入了少量的重大更改。 <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>使用方法可指定应为应用程序域回滚其中一个或多个重大更改，以使该行为与 .NET Framework 的以前版本兼容。  
  
 每次调用此方法时，它将替换现有的开关设置。 若要清除设置，请`null` `switches`为参数指定。  
  
 为提供的`switches`字符串值集可以是一个简单的字符串数组，因为数组实现了<xref:System.Collections.IEnumerable>接口。  
  
 下表提供了可设置为还原 .NET Framework 早期版本的行为的兼容性开关的示例。  
  
|开关|含义|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|在此应用程序域中启用了[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]的代码访问安全性（CAS）。 请[ &lt;参阅y&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|在此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的字符串排序默认值。 成功还原旧的排序行为还要求 sort00001000.dll 动态链接库在本地系统上可用。 请[ &lt;参阅CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|在此应用程序域[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]中启用和 Unicode 5.0 的字符串排序默认值。 成功还原旧的排序行为还要求 sort00060101 动态链接库在本地系统上可用。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的格式设置行为。 请[ &lt;参阅&gt; ](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) <xref:System.TimeSpan>主题中的 TimeSpan_LegacyFormatMode 元素和 "还原旧的 TimeSpan 格式" 部分。|  
|"UseRandomizedStringHashAlgorithm"|运行时基于每个应用程序域计算字符串的哈希代码，而不是使用单个哈希算法跨应用程序域生成一致的哈希代码。 请[ &lt;参阅UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;Y&gt;元素</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt;元素</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt;元素</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt;元素</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">一个数组，其中包含要用于应用程序域的 XML 配置信息。</param>
        <summary>提供应用程序域的 XML 配置信息，并替换应用程序的 XML 配置信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了一种方法来替换创建新应用程序域的应用程序的配置信息。 中`value`的配置文件信息将替换应用程序的配置文件信息。 例如，当 Example 应用程序创建新的应用程序域时，它可以替换最初从 web.config 文件中获取的配置信息。  
  
> [!IMPORTANT]
>  配置文件信息的某些使用者不使用<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法所存储的信息。 运行时不强制执行此功能。 若要确保在新的应用程序域中替换所有配置文件信息，请<xref:System.AppDomainSetup.ConfigurationFile%2A>使用属性来指定配置文件。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。  
  
 中`value`的 xml 与普通配置文件中的 xml 相同，不同之处在于它以<xref:System.Byte>数组形式存储。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">运行时设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">要重载的字符串比较函数的名称。</param>
        <param name="functionVersion">函数版本。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]，必须为 1 或者 更大的数值。</param>
        <param name="functionPointer">重写 <paramref name="functionName" /> 函数的指针。</param>
        <summary>向通用语言运行时提供备用字符串比较功能实施。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下字符串比较和排序方法可由<xref:System.AppDomainSetup.SetNativeFunction%2A>方法重写：  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 有关这些函数的信息，请参阅[国家语言支持功能](https://go.microsoft.com/fwlink/?LinkId=228134)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> 不是 1 或者更大的值。  
  
或 
 <paramref name="functionPointer" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置目录的名称，这些目录包含要影像复制的程序集。</summary>
        <value>目录名称的列表，以用分号分隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启用卷影复制时，默认情况下是通过探测找到的所有程序集的卷影副本。也就是说，在<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>属性指定的目录中。 属性将卷影副本限制为<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>指定目录中的程序集。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>  
  
 如果没有为<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>属性分配字符串，或者如果将此属性设置为`null`，则<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性指定的目录中的所有程序集都将进行卷影复制。  
  
> [!IMPORTANT]
>  目录路径不能包含分号，因为分号是分隔符。 分号没有转义符。  
  
 如果卷影复制生效，则在加载程序集之前，程序集文件将复制到另一个位置。 原始程序集文件未锁定，因此可进行更新。 有关卷影复制的详细信息，请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径信息。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">卷影复制程序集</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示影像复制是打开还是关闭的字符串。</summary>
        <value>字符串值“true”指示打开了卷影复制；“false”则指示关闭了卷影复制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关卷影复制的详细信息，请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">卷影复制程序集</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; }" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetFrameworkName As String" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); };" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置为应用程序域指定目标版本和 .NET Framework 配置文件的字符串，以可由 <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 构造函数分析的格式。</summary>
        <value>.NET Framework 的目标版本与配置文件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性，告知当前正在运行的 .NET Framework 应用程序域将用于加载和运行已针对目标版本和配置文件编译的程序集的。 如果当前运行的 .NET Framework 版本具有可影响使用目标版本编译的代码兼容性的可选行为，则它可以根据需要启用或禁用这些行为以提高兼容性。 当应用程序通过在单独的应用程序域中运行使用 .NET Framework 的多个版本编译的外接程序时，这会很有用。  
  
 对于客户端应用程序， <xref:System.AppDomainSetup.TargetFrameworkName%2A>属性的值<xref:System.Runtime.Versioning.TargetFrameworkAttribute>从属性中推断出来。 在[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]和更高版本中，此属性基于项目的 "**目标框架**" 属性的设置自动添加到程序集中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
