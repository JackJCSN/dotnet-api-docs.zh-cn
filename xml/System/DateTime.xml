<Type Name="DateTime" FullName="System.DateTime">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2913ac631716124524e0466e0ecb6e05f47a4349" /><Meta Name="ms.sourcegitcommit" Value="101e237579339f500467ba198ec0d3471dec4e4b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/17/2019" /><Meta Name="ms.locfileid" Value="67150053" /></Metadata><TypeSignature Language="C#" Value="public struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DateTime extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.DateTime&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.DateTime&gt;, class System.IFormattable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.DateTime" />
  <TypeSignature Language="VB.NET" Value="Public Structure DateTime&#xA;Implements IComparable, IComparable(Of DateTime), IConvertible, IEquatable(Of DateTime), IFormattable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type DateTime = struct&#xA;    interface IFormattable&#xA;    interface IConvertible&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示时间上的一刻，通常以日期和当天的时间表示。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

## <a name="quick-links-to-example-code"></a>示例代码的快速链接

[!INCLUDE[interactive-note](~/includes/csharp-interactive-with-utc-note.md)]

本文包括使用的几个示例`DateTime`类型：

**初始化示例**      
- [调用构造函数](#initialization-01)
- [调用隐式默认构造函数](#initialization-02)
- [分配的返回值](#initialization-03)
- [分析一个字符串，表示日期和时间](#initialization-04)
- [Visual Basic 语法来初始化日期和时间](#initialization-05)

**格式设置`DateTime`以字符串形式的对象**  
- [使用默认日期时间格式](#formatting-01)
- [设置日期和时间使用非特定区域性的格式](#formatting-02)
- [使用标准或自定义格式字符串的日期时间格式](#formatting-03)
- [指定一个格式字符串和特定区域性](#formatting-04)
- [使用 web 服务的 ISO 8601 标准日期时间格式](#formatting-05)

**分析字符串作为`DateTime`对象**  
- [使用`Parse`或`TryParse`将字符串转换为日期和时间](#parsing-01)
- [使用`ParseExact`或`TryParseExact`将已知格式的字符串转换](#parsing-02)
- [将从 ISO 8601 字符串表示形式转换为日期和时间](#parsing-03)

**`DateTime` 解决方法**  
- [探索的日期和时间值的分辨率](#resolution-01)
- [比较相等性的公差范围内](#comparison-01)

**区域性和日历**  
- [显示使用区域性特定日历的日期和时间值](#calendars-01)
- [分析字符串根据区域性特定的日历](#calendars-02)
- [初始化的日期和时间从特定区域性的日历](#calendars-03)
- [访问使用特定区域性的日历的日期和时间属性](#calendars-04)
- [检索使用区域性特定日历年的某一周](#calendars-05)

**持久性**  
- [为本地时区中的字符串保留日期和时间值](#persistence-01)
- [为区域性和时间的固定格式中的字符串保留日期和时间值](#persistence-02)
- [保留日期和时间值作为整数](#persistence-03)
- [使用保留的日期和时间值 `XmlSerializer`](#persistence-04)
- [使用保留的日期和时间值 `BinaryFormatter`](#persistence-05)
- [保留日期和时间值的时区数据](#persistence-06)

## <a name="quick-links-to-remarks-topics"></a>快速链接到备注主题。

本部分包含有关的许多常见用法主题`DateTime`结构：
  
- [正在初始化`DateTime`对象](#initializing-a-datetime-object)
- [日期时间值和其字符串表示形式](#datetime-values-and-their-string-representations)
- [从字符串分析的日期时间值](#parsing-datetime-values-from-strings)
- [日期时间值](#datetime-values)
- [DateTime 操作](#datetime-operations)
- [日期时间解决方法](#datetime-resolution)
- [日期时间值和日历](#datetime-values-and-calendars)
- [保存日期时间值](#persisting-datetime-values)
- [DateTime vs。TimeSpan](#datetime-vs-timespan)
- [比较相等性的公差范围内](#comparing-for-equality-within-tolerance)
- [COM 互操作注意事项](#com-interop-considerations)
   
<xref:System.DateTime>值类型表示日期和时间的值范围从 00:00:00 （午夜），1 月 1 日 0001 午夜 11:59:59 止 （基督纪元） 通过 11:59:59 PM，到公元 9999 年 12 月 31 日 (C.E.)在公历。  
  
时间值以调用计时周期数为 100 毫微秒为单位进行衡量。 特定日期是自午夜 12:00，公元 0001 年 1 月 1 日以来的计时周期数 (C.E.)在<xref:System.Globalization.GregorianCalendar>日历。 数不包括将闰秒所添加的计时周期数。 例如，计时周期值 31241376000000000l 表示的日期 0100 年 1 月 1 日，星期五午夜 12:00:00。 一个<xref:System.DateTime>值始终表示上下文的显式或默认日历中。  
  
> [!NOTE]
>  如果您正在使用计时周期值，你想要将转换为其他时间间隔，如分钟或秒，则应使用<xref:System.TimeSpan.TicksPerDay?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerHour?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerMinute?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerSecond?displayProperty=nameWithType>，或<xref:System.TimeSpan.TicksPerMillisecond?displayProperty=nameWithType>常量来执行此转换。 例如，若要添加的秒数表示的时钟周期到指定数值<xref:System.DateTime.Second%2A>组成部分<xref:System.DateTime>值，可以使用表达式`dateValue.Second + nTicks/Timespan.TicksPerSecond`。  

您可以查看这篇文章的示例的整个集的源中任意一种[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/)或[C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/)从 GitHub 上的 docs 存储库。

> [!NOTE]
>  一种替代方法<xref:System.DateTime>结构，使用日期和时间值中特定时区为<xref:System.DateTimeOffset>结构。 <xref:System.DateTimeOffset>结构将日期和时间信息存储在私有<xref:System.DateTime>字段和所依据的日期和时间的分钟数与 UTC 的差异在私有<xref:System.Int16>字段。 这使得<xref:System.DateTimeOffset>值以反映特定时区中的时间，而<xref:System.DateTime>值可以明确反映仅 UTC 和本地时区的时间。 有关何时使用的讨论<xref:System.DateTime>结构或<xref:System.DateTimeOffset>结构处理日期和时间值时，请参阅[选择之间 DateTime、 DateTimeOffset、 TimeSpan 和 TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md)。  
  
### <a name="initializing-a-datetime-object"></a>初始化一个 DateTime 对象  

可以将初始值分配到一个新`DateTime`以多种不同方式的值：

- 调用构造函数，在其中指定参数的值，两者中任何一个，或使用隐式默认构造函数。
- 分配`DateTime`到属性或方法的返回值。
- 分析`DateTime`值的字符串表示形式。
- 使用 Visual Basic 特定的语言功能来实例化`DateTime`。 

下面的代码段显示每个的示例：

#### <a name="invoke-constructors"></a>调用构造函数

调用的重载任一<xref:System.DateTime>指定元素 （如年、 月和日或计时周期数） 的日期和时间值的构造函数。 下面的代码创建一个特定的日期使用<xref:System.DateTime>构造函数指定年、 月、 日、 小时、 分钟和秒。  

<a name="initialization-01"></a> [!code-vb[System.DateTime.Instantiation#1](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#1)]  
[!code-csharp[System.DateTime.Instantiation#1](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#1)]

在调用`DateTime`结构的隐式默认构造函数时所需`DateTime`初始化为其默认值。 (有关值类型的隐式默认构造函数的详细信息，请参阅[值类型](~/docs/csharp/language-reference/keywords/value-types.md)。)某些编译器还支持声明<xref:System.DateTime>而无需显式将值分配给它的值。 创建没有显式初始化的值也会导致的默认值。 下面的示例阐释<xref:System.DateTime>C# 和 Visual Basic 中的隐式默认构造函数以及<xref:System.DateTime>声明没有在 Visual Basic 中的分配。  

<a name="initialization-02"></a> [!code-vb[System.DateTime.Instantiation#5](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#5)]  
[!code-csharp-interactive[System.DateTime.Instantiation#5](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#5)]
    
#### <a name="assigning-a-computed-value"></a>分配一个计算的值

可以分配<xref:System.DateTime>对象的属性或方法返回的日期和时间值。 下面的示例将当前日期和时间、 当前的协调世界时 (UTC) 日期和时间和当前日期为三个新<xref:System.DateTime>变量。  

<a name="initialization-03"></a> [!code-vb[System.DateTime.Instantiation#3](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#3)]  
[!code-csharp[System.DateTime.Instantiation#3](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#3)]

#### <a name="parsing-a-string-that-represents-a-datetime"></a>分析一个字符串，表示日期时间

<xref:System.DateTime.Parse%2A>， <xref:System.DateTime.ParseExact%2A>， <xref:System.DateTime.TryParse%2A>，和<xref:System.DateTime.TryParseExact%2A>方法都将字符串转换为其等效的日期和时间值。 下面的示例使用<xref:System.DateTime.Parse%2A>并<xref:System.DateTime.ParseExact%2A>方法来分析字符串并将其转换为<xref:System.DateTime>值。 第二个格式使用支持的窗体[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)标准层以表示的日期和时间字符串格式。 此标准表示形式通常用于传输中的 web 服务的日期信息。

<a name="initialization-04"></a> [!code-vb[System.DateTime.Instantiation#4](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#4)]  
[!code-csharp[System.DateTime.Instantiation#4](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#4)]

<xref:System.DateTime.TryParse%2A>并<xref:System.DateTime.TryParseExact%2A>方法指示字符串是否是有效表示形式<xref:System.DateTime>值，以及如果是，执行这一转换。  

#### <a name="language-specific-syntax-for-visual-basic"></a>对于 Visual Basic 的特定于语言的语法

以下 Visual Basic 语句初始化新<xref:System.DateTime>值。  

<a name="initialization-05"></a> [!code-vb[System.DateTime.Instantiation#2](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#2)]  

### <a name="datetime-values-and-their-string-representations"></a>日期时间值和其字符串表示形式  

在内部，所有<xref:System.DateTime>值表示为 0001 年 1 月 1 日午夜 12:00:00 以来所经历的计时周期 （100 纳秒间隔数） 数。 实际<xref:System.DateTime>值时显示此值的显示的方式无关。 外观<xref:System.DateTime>值是将值转换为其字符串表示形式的格式设置操作的结果。  
  
日期和时间值的外观是依赖于区域性、 国际标准、 应用程序要求和个人首选项。 <xref:System.DateTime>结构格式化日期和时间值通过重载的灵活性<xref:System.DateTime.ToString%2A>。 默认值<xref:System.DateTime.ToString?displayProperty=nameWithType>方法返回使用当前区域性的短日期和长时间模式的日期和时间值的字符串表示形式。 下面的示例使用默认值<xref:System.DateTime.ToString?displayProperty=nameWithType>方法。 它显示的日期和时间使用当前区域性的短日期和长时间模式。 EN-US 区域性是在其运行该示例的计算机上的当前区域性。  
  
<a name="formatting-01"></a> [!code-csharp[System.DateTime.Formatting#1](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#1)]
[!code-vb[System.DateTime.Formatting#1](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#1)]  

您可能需要设置特定区域性中的日期，以支持 web 方案服务器可能在从客户端不同的区域性的格式。 指定区域性使用<xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法来创建在特定区域性的短日期和长时间表示形式。 下面的示例使用<xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法来显示日期和时间使用 FR-FR 区域性的短日期和长时间模式。  
  
<a name="formatting-02"></a> [!code-csharp-interactive[System.DateTime.Formatting#2](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#2)]
[!code-vb[System.DateTime.Formatting#2](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#2)]  

 其他应用程序可能需要不同的字符串表示形式的日期。 <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法返回通过使用当前区域性的格式设置约定的标准或自定义格式说明符定义的字符串表示形式。 下面的示例使用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法以显示完整的日期和时间模式 en-us 区域性，在其运行该示例的计算机上的当前区域性。  
  
<a name="formatting-03"></a> [!code-csharp[System.DateTime.Formatting#3](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#3)]
[!code-vb[System.DateTime.Formatting#3](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#3)]  

 最后，可以指定的区域性和格式使用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。 下面的示例使用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法以显示完整的日期和时间模式为 FR-FR 区域性。  

<a name="formatting-04"></a> [!code-csharp-interactive[System.DateTime.Formatting#4](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#4)]
[!code-vb[System.DateTime.Formatting#4](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#4)]  

<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>重载还可用使用自定义格式字符串来指定其他格式。 下面的示例演示如何设置格式字符串使用[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)通常用于 web 服务的标准格式。 Iso 8601 格式不具有相应的标准格式字符串。

<a name="formatting-05"></a> [!code-csharp-interactive[System.DateTime.Formatting#5](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#5)]
[!code-vb[System.DateTime.Formatting#5](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#5)]  

有关格式设置的详细信息<xref:System.DateTime>值，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  

### <a name="parsing-datetime-values-from-strings"></a>从字符串分析的日期时间值

分析日期和时间的字符串表示形式转换<xref:System.DateTime>值。 通常情况下，日期和时间字符串有两个不同的用法，在应用程序中：  
  
-   日期和时间采用各种形式，并反映当前区域性或特定区域性的约定。 例如，应用程序允许的用户当前区域性为 EN-US 以"2013 年 12 月 15 日"或"2013 年 12 月 15 日"的形式输入日期值。 它允许的用户当前区域性为 en-gb 以"12/15/2013"或"15 2013 年 12 月。"的形式输入日期值  
  
-   预定义的格式表示日期和时间。 例如，应用程序序列化作为"20130103"独立于其运行该应用程序的区域性的日期。 应用程序可能需要在当前区域性的短日期格式输入日期。
  
您使用<xref:System.DateTime.Parse%2A>或<xref:System.DateTime.TryParse%2A>方法将字符串转换为区域性使用的常见日期和时间格式之一<xref:System.DateTime>值。 下面的示例演示如何使用<xref:System.DateTime.TryParse%2A>转换到不同的区域性特定格式的日期字符串<xref:System.DateTime>值。 将当前区域性更改为英语 （英国），并调用<xref:System.DateTime.GetDateTimeFormats>方法生成的日期和时间的字符串数组。 然后将每个元素传递到的数组<xref:System.DateTime.TryParse%2A>方法。 示例输出显示在分析方法已能够成功地将每个特定于区域性的日期和时间字符串转换。  
  
<a name="parsing-01"></a> [!code-csharp-interactive[System.DateTime.Parsing#1](~/samples/snippets/csharp/System.DateTime/Parsing.cs#1)]
[!code-vb[System.DateTime.Parsing#1](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#1)]  

您使用<xref:System.DateTime.ParseExact%2A>并<xref:System.DateTime.TryParseExact%2A>方法将字符串必须匹配特定的格式或格式转换<xref:System.DateTime>值。 作为分析方法的参数指定一个或多个日期和时间格式字符串。 下面的示例使用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法将必须为"yyyyMMdd"格式或"HHmmss"格式的字符串转换<xref:System.DateTime>值。  
  
<a name="parsing-02"></a> [!code-csharp[System.DateTime.Parsing#2](~/samples/snippets/csharp/System.DateTime/Parsing.cs#2)]
[!code-vb[System.DateTime.Parsing#2](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#2)]  

一个常见用途<xref:System.DateTime.ParseExact%2A>是要转换的字符串表示形式从 web 服务，通常在[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)标准格式。 下面的代码显示了要使用的正确的格式字符串：

<a name="parsing-03"></a> [!code-csharp-interactive[System.DateTime.Parsing#3](~/samples/snippets/csharp/System.DateTime/Parsing.cs#3)]
[!code-vb[System.DateTime.Parsing#3](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#3)]  

如果无法分析一个字符串，<xref:System.DateTime.Parse%2A>和<xref:System.DateTime.ParseExact%2A>方法引发异常。 <xref:System.DateTime.TryParse%2A>并<xref:System.DateTime.TryParseExact%2A>方法返回<xref:System.Boolean>值，该值指示转换是否成功。 应使用<xref:System.DateTime.TryParse%2A>或<xref:System.DateTime.TryParseExact%2A>性能很重要的方案中的方法。 日期和时间字符串在分析操作往往具有高故障率，并且异常处理将耗费大量资源。 如果用户输入字符串，请使用这些方法或来自未知源。 
  
有关分析日期和时间值的详细信息，请参阅[分析日期和时间字符串](~/docs/standard/base-types/parsing-datetime.md)。  

### <a name="datetime-values"></a>日期时间值

时间值中的说明<xref:System.DateTime>类型通常会表示使用协调世界时 (UTC) 标准。 协调世界时是国际上认可的名称为格林威治标准时间 （格林威治标准时间）。 协调世界时是经度零度，UTC 原点在测量的时间。 夏时制不适用为 UTC。  
  
本地时间是相对于某个特定时区。 时区是时区偏移量与相关联。 时区偏移量是时区的以小时的 UTC 起始点的偏移量。 此外，本地时间有可能受夏时制，这将添加或减去的时间间隔调整。 通过将时区偏移量添加到 UTC 和调整为夏时制如有必要计算本地时间。 从 UTC 原点的时区偏移量为零。  
  
在文件中是适用于计算、 比较和存储日期和时间的 UTC 时间。 适用于在桌面应用程序的用户界面中显示本地时间。 此外需要使用大量其他时区的时区感知应用程序 （例如许多 Web 应用程序）。  
  
如果<xref:System.DateTime.Kind%2A>的属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>，它是未指定所表示的时间是否是本地时间、 UTC 时间或某些其他时区中的某个时间。  

### <a name="datetime-resolution"></a>日期时间解决方法
  
> [!NOTE]
>  作为执行日期和时间算术运算的替代方法<xref:System.DateTime>值度量经过的时间，可以使用<xref:System.Diagnostics.Stopwatch>类。  
  
<xref:System.DateTime.Ticks%2A>属性所表达的秒的一千万分之一单位中的日期和时间值。 <xref:System.DateTime.Millisecond%2A>属性返回的千分之几秒的日期和时间值中。 使用重复的调用<xref:System.DateTime.Now%2A?displayProperty=nameWithType>属性来测量运行时间是依赖于系统时钟。 Windows 7 和 Windows 8 系统上的系统时钟有大约 15 毫秒。 此解析影响较小的时间间隔小于 100 毫秒。 
  
下面的示例说明了对系统时钟的分辨率的当前日期和时间值的依赖。 在示例中，外部循环重复执行 20 次，并延迟外部循环内部循环。 如果外部循环计数器的值为 10，调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法引入了五个位数毫秒延迟。 下面的示例演示返回的毫秒数`DateTime.Now.Milliseconds`属性更改仅在调用后的<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>。  

<a name="resolution-01"></a> [!code-csharp-interactive[System.DateTime.Resolution#1](~/samples/snippets/csharp/System.DateTime/Resolution.cs#1)]
[!code-vb[System.DateTime.Resolution#1](~/samples/snippets/visualbasic/System.DateTime/Resolution.vb#1)]  

### <a name="datetime-operations"></a>DateTime 操作  

计算使用<xref:System.DateTime>结构，如<xref:System.DateTime.Add%2A>或<xref:System.DateTime.Subtract%2A>，不会修改该结构的值。 相反，计算返回一个新<xref:System.DateTime>结构，其值是计算的结果。  
  
时区 （如 UTC 和本地时间，或两个时区之间） 之间的转换操作会考虑夏时制，但算术运算和比较运算不这样做。  
  
<xref:System.DateTime>结构本身提供了用于从一个时区转换为另一种有限的支持。 可以使用<xref:System.DateTime.ToLocalTime%2A>方法将 UTC 转换为本地时间，也可以使用<xref:System.DateTime.ToUniversalTime%2A>方法将从从当地时间转换为 UTC。 但是，一套完整的时区转换方法现已推出<xref:System.TimeZoneInfo>类。 转换时间时区中的任何其他时间使用这些方法中的任何一个世界的时区的时间。  
  
计算和比较的<xref:System.DateTime>对象是有意义的仅当这些对象表示在相同的时区的时间。 可以使用<xref:System.TimeZoneInfo>对象来表示<xref:System.DateTime>值的时区，尽管两个松散耦合。 一个<xref:System.DateTime>对象不具有该属性返回一个对象，表示该日期和时间值的时区。 <xref:System.DateTime.Kind%2A>属性指示如果`DateTime`表示 UTC，本地时间，或者是未指定。 中的时区感知应用程序，您必须依赖于一些外部机制来确定在其中时区<xref:System.DateTime>创建对象。 可以使用结构来包装<xref:System.DateTime>值和<xref:System.TimeZoneInfo>对象，表示<xref:System.DateTime>值的时区。 有关详细信息中计算和比较与使用 UTC<xref:System.DateTime>值，请参阅[日期和时间执行算术运算](~/docs/standard/datetime/performing-arithmetic-operations.md)。  
  
每个<xref:System.DateTime>成员隐式使用公历来执行其操作。 例外情况是隐式指定日历的方法。 其中包括指定日历的构造函数和方法参数与派生自<xref:System.IFormatProvider>，如<xref:System.Globalization.DateTimeFormatInfo?displayProperty=nameWithType>。  
  
操作的成员<xref:System.DateTime>类型考虑到闰年和在每月天数等的帐户详细信息。  

## <a name="datetime-values-and-calendars"></a>日期时间值和日历  

.NET Framework 类库包括多个日历类，所有这些派生自<xref:System.Globalization.Calendar>类。  它们是：  
  
-   <xref:System.Globalization.ChineseLunisolarCalendar> 类。  
-   <xref:System.Globalization.EastAsianLunisolarCalendar> 类。  
-   <xref:System.Globalization.GregorianCalendar> 类。  
-   <xref:System.Globalization.HebrewCalendar> 类。  
-   <xref:System.Globalization.HijriCalendar> 类。  
-   <xref:System.Globalization.JapaneseCalendar> 类。  
-   <xref:System.Globalization.JapaneseLunisolarCalendar> 类。  
-   <xref:System.Globalization.JulianCalendar> 类。  
-   <xref:System.Globalization.KoreanCalendar> 类。  
-   <xref:System.Globalization.KoreanLunisolarCalendar> 类。  
-   <xref:System.Globalization.PersianCalendar> 类。  
-   <xref:System.Globalization.TaiwanCalendar> 类。  
-   <xref:System.Globalization.TaiwanLunisolarCalendar> 类。  
-   <xref:System.Globalization.ThaiBuddhistCalendar> 类。  
-   <xref:System.Globalization.UmAlQuraCalendar> 类。  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

每个区域性使用的默认日历，定义其只读<xref:System.Globalization.CultureInfo.Calendar%2A?displayProperty=nameWithType>属性。 每个区域性可能会支持一个或多个日历定义其只读<xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType>属性。 特定于当前使用的日历<xref:System.Globalization.CultureInfo>对象由定义其<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>属性。 它必须是之一中找到的日历<xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType>数组。  
  
区域性的当前日历是该区域性的所有格式设置操作中使用。 例如，泰国佛区域性的默认日历是由表示泰国佛教日历<xref:System.Globalization.ThaiBuddhistCalendar>类。  当<xref:System.Globalization.CultureInfo>对象，表示泰国佛区域性使用日期和时间格式设置操作中，默认情况下使用泰国佛教日历。 公历时才使用区域性的<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>更改属性，如以下示例所示：  

<a name="calendars-01"></a> [!code-csharp[System.DateTime.Calendar#1](~/samples/snippets/csharp/System.DateTime/Calendar.cs#1)]
[!code-vb[System.DateTime.Calendar#1](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#1)]  

如以下示例所示，区域性的当前日历还使用该区域性的所有分析操作中。  
  
<a name="calendars-02"></a> [!code-csharp[System.DateTime.Calendar#2](~/samples/snippets/csharp/System.DateTime/Calendar.cs#2)]
[!code-vb[System.DateTime.Calendar#2](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#2)]  

实例化<xref:System.DateTime>值使用通过调用日期和时间 （年、 月和日的数） 的元素在特定日历[DateTime 构造函数](xref:System.DateTime.%23ctor%2A)包括`calendar`参数并将其传递<xref:System.Globalization.CultureInfo.Calendar%2A>对象，表示该日历。 下面的示例使用中的日期和时间元素<xref:System.Globalization.ThaiBuddhistCalendar>日历。  
  
<a name="calendars-03"></a> [!code-csharp[System.DateTime.Calendar#3](~/samples/snippets/csharp/System.DateTime/Calendar.cs#3)]
[!code-vb[System.DateTime.Calendar#3](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#3)]  

<xref:System.DateTime> 构造函数不包含`calendar`参数假定为公历日历中的单位表示的日期和时间元素。  
  
所有其他<xref:System.DateTime>属性和方法使用公历。 例如，<xref:System.DateTime.Year%2A?displayProperty=nameWithType>属性返回公历，年份和<xref:System.DateTime.IsLeapYear%28System.Int32%29?displayProperty=nameWithType>方法假设`year`参数是公历日历中的每一年。  每个<xref:System.DateTime>使用公历日历以来的成员都有相应的成员<xref:System.Globalization.CultureInfo.Calendar%2A>类，该类使用特定的日历。 例如，<xref:System.Globalization.Calendar.GetYear%2A?displayProperty=nameWithType>方法返回在特定日历年和<xref:System.Globalization.Calendar.IsLeapYear%2A?displayProperty=nameWithType>方法将解释`year`特定日历的年数字作为参数。 下面的示例使用这两个<xref:System.DateTime>和相应成员的<xref:System.Globalization.ThaiBuddhistCalendar>类。  
  
<a name="calendars-04"></a> [!code-csharp[System.DateTime.Calendar#4](~/samples/snippets/csharp/System.DateTime/Calendar.cs#4)]
[!code-vb[System.DateTime.Calendar#4](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#4)]  

<xref:System.DateTime>结构包含<xref:System.DateTime.DayOfWeek%2A>属性返回公历日历中的日期是星期几。 它不包括成员，可用于检索年份的周数。 若要检索一年中的一周，调用单个日历<xref:System.Globalization.Calendar.GetWeekOfYear%2A?displayProperty=nameWithType>方法。 下面的示例进行了这方面的演示。  
  
<a name="calendars-05"></a> [!code-csharp[System.DateTime.Calendar#5](~/samples/snippets/csharp/System.DateTime/Calendar.cs#5)]
[!code-vb[System.DateTime.Calendar#5](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#5)]  

有关日期和日历的详细信息，请参阅[使用日历](~/docs/standard/datetime/working-with-calendars.md)。  
  
### <a name="persisting-datetime-values"></a>保存日期时间值  

您可以保留<xref:System.DateTime>四种方法中的值：  
  
-   您[将其转换为字符串](#persisting-values-as-strings)并保留字符串。  
-   您[将其转换为 64 位整数值](#persisting-values-as-integers)(值<xref:System.DateTime.Ticks%2A>属性) 和保留整数。  
-   您[序列化的日期时间值](#serializing-datetime-values)。  
-   您[序列化以及时区信息的日期时间值](#serializing-datetime-and-time-zone-data)。  
  
必须确保还原的例程<xref:System.DateTime>值不会丢失数据或引发的异常无论何种技术选择。 <xref:System.DateTime> 值应往返。 也就是说，原始值和还原的值应为相同。 如果原始<xref:System.DateTime>值表示单个时间实例，它应识别的是同一时刻的还原时的时间。  
  
#### <a name="persisting-values-as-strings"></a>以字符串形式的持久保存值  

已成功还原<xref:System.DateTime>保持以字符串形式的值遵循以下规则：  
  
-   做出有关特定于区域性的格式设置还原为当你保存的位置的字符串时相同的假设。 若要确保在当前区域性为不同于系统保存的区域性的系统时，可以还原字符串，调用<xref:System.DateTime.ToString%2A>重载使用固定区域性的约定保存字符串。 调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>或<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>重载来还原该字符串使用固定区域性的约定。 永远不会使用<xref:System.DateTime.ToString>， <xref:System.DateTime.Parse%28System.String%29>，或<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29>重载，它使用当前线程区域性的约定。  
  
-   如果该日期表示为单个时刻，请确保它表示同一时间点还原时，即使在不同的时区。 将转换<xref:System.DateTime>前将其保存的值为协调世界时 (UTC)。 此外可以序列化的值以及时区信息。 有关此方法的详细信息，请参阅[序列化日期时间和时区数据](#serializing-datetime-and-time-zone-data)。  
  
 最常见的错误时保存所做<xref:System.DateTime>以字符串形式的值是依靠默认值或当前区域性的格式设置约定。 如果当前区域性不同保存和还原字符串时，会出现问题。 下面的示例说明了这些问题。 它将保存使用这种情况下为英语 （美国） 的当前区域性的格式设置约定的五个日期。 它会还原使用不同的区域性，在这种情况下为英语 （英国） 的格式设置约定的日期。 由于两个区域性的格式设置约定各不相同，因此无法还原两个日期，和剩余的三个日期被错误地解释。 此外，如果原始的日期和时间值表示单个时刻，还原时间不正确，因为丢失时区信息。  
  
<a name="persistence-01"></a> [!code-csharp[System.DateTime.Persistence#1](~/samples/snippets/csharp/System.DateTime/Persistence.cs#1)]
[!code-vb[System.DateTime.Persistence#1](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#1)]  

保存/还原<xref:System.DateTime>值成功，请执行以下步骤：  
  
1.  如果此值表示单个时刻的时间，将它们转换从从当地时间为 UTC 通过调用<xref:System.DateTime.ToUniversalTime%2A>方法。  
1.  将日期转换为其字符串表示形式，通过调用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29>或<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>重载。 通过指定使用固定区域性的格式设置约定<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>作为`provider`参数。 指定的值应使用"O"或"R"标准格式字符串往返。  
  
若要还原的持久<xref:System.DateTime>值而不丢失数据，请执行以下步骤：  
  
1.  通过调用分析的数据<xref:System.DateTime.ParseExact%2A>或<xref:System.DateTime.TryParseExact%2A>重载。 指定<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>作为`provider`参数，并使用相同的标准格式字符串所用的`format`在转换过程的参数。 包括<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>中的值`styles`参数。  
1.  如果<xref:System.DateTime>值表示单个时刻，调用<xref:System.DateTime.ToLocalTime%2A>方法，将已分析的日期从 UTC 转换为本地时间。  
  
以下示例使用固定区域性和"O"标准格式字符串，请确保<xref:System.DateTime>保存和还原的值表示的时间内不考虑系统、 区域性或特定于时区的源和目标系统中是同一时刻。  
  
<a name="persistence-02"></a> [!code-csharp[System.DateTime.Persistence#2](~/samples/snippets/csharp/System.DateTime/Persistence.cs#2)]
[!code-vb[System.DateTime.Persistence#2](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#2)]  

#### <a name="persisting-values-as-integers"></a>持久保存值作为整数  

您可以保留日期和时间作为<xref:System.Int64>值，该值表示计时周期数。 在这种情况下，您无需考虑的系统区域性<xref:System.DateTime>值是保留和还原。  
  
若要持久保存<xref:System.DateTime>为整数的值：  
  
-   如果<xref:System.DateTime>值表示单个时刻，将其转换为 UTC，通过调用<xref:System.DateTime.ToUniversalTime%2A>方法。  
-   检索所表示的计时周期数<xref:System.DateTime>值从其<xref:System.DateTime.Ticks%2A>属性。  
  
若要还原<xref:System.DateTime>已保存为整数的值：  
  
1.  实例化一个新<xref:System.DateTime>对象通过传递<xref:System.Int64>值设为<xref:System.DateTime.%23ctor%28System.Int64%29>构造函数。  
1.  如果<xref:System.DateTime>值表示单个时刻，它从 UTC 转换为本地时间通过调用<xref:System.DateTime.ToLocalTime%2A>方法。  
  
下面的示例仍然存在一个数组<xref:System.DateTime>美国中的系统上的整数值。 它在 UTC 时区的系统上将其还原。 包含整数的文件包括<xref:System.Int32>值，该值指示的总数<xref:System.Int64>紧挨着它的值。  
  
<a name="persistence-03"></a> [!code-csharp[System.DateTime.Persistence#3](~/samples/snippets/csharp/System.DateTime/Persistence.cs#3)]
[!code-vb[System.DateTime.Persistence#3](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#3)]  

<a name="serializing-datetime-values"></a>
#### <a name="serializing-datetime-values"></a>序列化的日期时间值  

您可以保留<xref:System.DateTime>值通过序列化到流或文件，然后还原它们通过反序列化。 <xref:System.DateTime> 一些指定的对象格式序列化数据。 它们反序列化时，将还原对象。 格式化程序或序列化程序，如<xref:System.Xml.Serialization.XmlSerializer>或<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>，处理序列化和反序列化的过程。 有关序列化和类型的序列化.NET Framework 支持的详细信息，请参阅[序列化](~/docs/standard/serialization/index.md)。
  
下面的示例使用<xref:System.Xml.Serialization.XmlSerializer>类进行序列化和反序列化<xref:System.DateTime>值。 这些值表示所有闰年天内，第 21 世纪中。 如果当前区域性为英语 （英国） 的系统上运行该示例，将输出表示结果。 因为已反序列化<xref:System.DateTime>对象本身，代码无需处理日期和时间格式的区域性差异。  
  
<a name="persistence-04"></a> [!code-csharp[System.DateTime.Persistence#4](~/samples/snippets/csharp/System.DateTime/Persistence.cs#4)]
[!code-vb[System.DateTime.Persistence#4](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#4)]  

前面的示例不包括时间信息。 如果<xref:System.DateTime>值表示某个时刻，表示为本地时间，将它转换从从当地时间为 UTC 之前通过调用序列化<xref:System.DateTime.ToUniversalTime%2A>方法。 在反序列化后，它从 UTC 转换为本地时间通过调用<xref:System.DateTime.ToLocalTime%2A>方法。 下面的示例使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>类来序列化<xref:System.DateTime>美国的系统上的数据太平洋标准时区并以其在美国中的系统上反序列化中央标准区域。  
  
<a name="persistence-05"></a> [!code-csharp[System.DateTime.Persistence#5](~/samples/snippets/csharp/System.DateTime/Persistence.cs#5)]
[!code-vb[System.DateTime.Persistence#5](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#5)]  

<a name="serializing-datetime-and-time-zone-data"></a>
#### <a name="serializing-datetime-and-time-zone-data"></a>序列化日期时间和时区的数据  

所有前面的示例假定<xref:System.DateTime>值表示为本地时间。 代码转换 UTC 与当地时间之间的值，使其反映在源和目标系统上的同一时刻。 <xref:System.DateTime> 值还可能反映在非本地时区与 UTC 时间的时间。 因为<xref:System.DateTime>结构不识别时区，则必须序列化都<xref:System.DateTime>值和<xref:System.TimeZoneInfo>对象，表示其时区。 创建同时包含其字段类型<xref:System.DateTime>值和其所在的时区。 下面的示例定义`DateWithTimeZone`结构。  
  
<a name="persistence-06"></a> [!code-csharp[System.DateTime.Persistence#6](~/samples/snippets/csharp/System.DateTime/DateWithTimeZone.cs#6)]
[!code-vb[System.DateTime.Persistence#6](~/samples/snippets/visualbasic/System.DateTime/DateWithTimeZone.vb#6)]  

> [!IMPORTANT]
>  `DateWithTimeZone`接下来两个示例，该序列化和反序列化的数组中使用结构`DateWithTimeZone`对象。 您可以查看这篇文章的示例的整个集的源中任意一种[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/)或[C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/)从 GitHub 上的 docs 存储库。
  
通过使用`DateWithTimeZone`结构，稍后可以保存日期和时间以及时区信息。 下面的示例使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>类来序列化的数组`DateWithTimeZone`对象。  
  
[!code-csharp[System.DateTime.Persistence#7](~/samples/snippets/csharp/System.DateTime/Persistence.cs#7)]
[!code-vb[System.DateTime.Persistence#7](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#7)]  

下面的示例然后调用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>方法来反序列化。  
  
[!code-csharp[System.DateTime.Persistence#8](~/samples/snippets/csharp/System.DateTime/Persistence.cs#8)]
[!code-vb[System.DateTime.Persistence#8](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#8)]  

### <a name="datetime-vs-timespan"></a>DateTime vs。TimeSpan  

<xref:System.DateTime>并<xref:System.TimeSpan>的值类型的差异在于<xref:System.DateTime>表示时间的某个时刻，而<xref:System.TimeSpan>表示时间间隔。 可以用的一个实例减去<xref:System.DateTime>从另一个用来获取<xref:System.TimeSpan>对象，表示它们之间的时间间隔。 也可以添加一个值为正<xref:System.TimeSpan>与当前<xref:System.DateTime>若要获取<xref:System.DateTime>值，该值表示将来的日期。  
  
可以添加或减去的时间间隔从<xref:System.DateTime>对象。 时间间隔可以是负数或正数，并且它们可以表示以刻度为单位，例如单位秒，或作为<xref:System.TimeSpan>对象。  

### <a name="comparing-for-equality-within-tolerance"></a>比较相等性的公差范围内

用于相等性比较<xref:System.DateTime>确切的有效值。 这意味着两个值必须表示为相同数量的计时周期将被视为相等。 该精度通常是不必要或甚至对于许多应用程序不正确。 通常情况下，你想要测试是否<xref:System.DateTime>对象是**大致相等**。 

下面的示例演示如何比较大致等效<xref:System.DateTime>值。 声明它们相等时，它接受差异的一小块边距。  
  
<a name="comparison-01"></a> [!code-csharp[System.DateTime.Comparisons#1](~/samples/snippets/csharp/System.DateTime/DateTimeComparisons.cs#1)]
[!code-vb[System.DateTime.Comparisons#1](~/samples/snippets/visualbasic/System.DateTime/DateTimeComparisons.vb#1)]  

### <a name="com-interop-considerations"></a>COM 互操作注意事项  

一个<xref:System.DateTime>值传输到 COM 应用程序，然后传输回托管应用程序，被认为是往返。 但是，<xref:System.DateTime>仅指定时间的值不往返正如您所料。  
  
如果您保存/还原仅时间，如下午 3 点、 最后一个日期和时间为公历公元 1899 年 12 月 30 日 下午 3:00，而不是 1 月 1日日公元 0001 年 在下午 3:00 .NET Framework 和 COM 假定默认日期时指定只在时间。 但是，COM 系统假定公元，1899 年 12 月 30 日的基日期时.NET Framework 采用年 1 月 1 日公元 0001 年的基日期  
  
当仅在时间从.NET Framework 传递到 COM 时，执行特殊处理，将时间转换为 com 使用的格式 当仅在时间从 COM 传递到.NET Framework 时，因为这会破坏合法的日期和时间或 1899 年 12 月 30 日之前不执行任何特殊处理。 如果日期从 COM 启动其往返，.NET Framework 和 COM 以保留日期。  
  
.NET Framework 和 COM 的行为意味着，如果你的应用程序往返<xref:System.DateTime>，仅指定一次，你的应用程序必须记得修改或忽略的错误的日期，从最后<xref:System.DateTime>对象。  
     
 ]]></format>
    </remarks>
    <threadsafe>此类型所有成员都是线程安全。 看起来要修改实例状态的成员实际上返回使用新值进行初始化的新实例。 作为使用任何其他类型，读取和写入对共享变量包含此类型的实例必须受到使用锁来确保线程安全性。</threadsafe>
    <altmember cref="T:System.DateTimeOffset" />
    <altmember cref="T:System.TimeSpan" />
    <altmember cref="T:System.Globalization.Calendar" />
    <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
    <altmember cref="T:System.TimeZoneInfo" />
    <related type="Article" href="~/docs/standard/datetime/choosing-between-datetime.md">在 DateTime、DateTimeOffset、TimeSpan 和 TimeZoneInfo 之间进行选择</related>
    <related type="Article" href="~/docs/standard/datetime/working-with-calendars.md">使用日历</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">示例：.NET Framework 4 格式设置实用工具</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.DateTime" /> 结构的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 -&gt; DateTime" Usage="new System.DateTime ticks" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ticks">一个日期和时间，以公历 0001 年 1 月 1 日 00:00:00.000 以来所经历的以 100 纳秒为间隔的间隔数来表示。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的刻度数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例演示一个<xref:System.DateTime>构造函数。  
  
 [!code-cpp[datetime.ctor_Int64#1](~/samples/snippets/cpp/VS_Snippets_CLR/datetime.ctor_Int64/CPP/ticks.cpp#1)]
 [!code-csharp[datetime.ctor_Int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/datetime.ctor_Int64/CS/ticks.cs#1)]
 [!code-vb[datetime.ctor_Int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/datetime.ctor_Int64/VB/ticks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ticks" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int64 * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (ticks, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="kind" Type="System.DateTimeKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ticks">一个日期和时间，以公历 0001 年 1 月 1 日 00:00:00.000 以来所经历的以 100 纳秒为间隔的间隔数来表示。</param>
        <param name="kind">枚举值之一，该值指示 <paramref name="ticks" /> 是指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的计时周期数以及协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ticks" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月和日。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`为年、 月和天公历日历中的。 若要实例化<xref:System.DateTime>值在另一个日历中，调用使用年、 月和日<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 为生成的一天的时间<xref:System.DateTime>表示午夜 (00: 00:00)。 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>构造函数实例化<xref:System.DateTime>值。 该示例还阐释了此重载创建<xref:System.DateTime>其时间组成部分等于午夜的值 (0:00)。  
  
 [!code-csharp[System.DateTime.Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#1)]
 [!code-vb[System.DateTime.Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <paramref name="calendar" /> 中的年数）。</param>
        <param name="month">月（1 到 <paramref name="calendar" /> 中的月数）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="calendar">用于解释 <paramref name="year" />、<paramref name="month" /> 和 <paramref name="day" /> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月和日。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为生成的一天的时间<xref:System.DateTime>表示午夜 (00: 00:00)。 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，并`day`取决于`calendar`。 如果不能使用以表示指定的日期和时间引发异常`calendar`。  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

 <xref:System.Globalization>命名空间提供了多个日历，包括<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.PersianCalendar>对象。 由于波斯日历不能指定为区域性的默认日历，显示日期与波斯历需要单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚） 和当前区域性的默认日历更改为回历。 因为回历是当前区域性的默认日历，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原先前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample2.cs#2)]
 [!code-vb[System.DateTime.Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月、日、小时、分钟和秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 此构造函数将解释`year`， `month`，和`day`为年、 月和天公历日历中的。 若要实例化<xref:System.DateTime>值在另一个日历中，调用使用年、 月和日<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%2A>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#3)]
 [!code-vb[System.DateTime.Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hour" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="minute" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="second" Type="System.Int32" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="kind" Type="System.DateTimeKind" Index="6" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="kind">枚举值之一，该值指示 <paramref name="year" />、<paramref name="month" />、<paramref name="day" />、<paramref name="hour" />、<paramref name="minute" /> 和 <paramref name="second" /> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定年、月、日、小时、分钟、秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`为年、 月和天公历日历中的。 若要实例化<xref:System.DateTime>值在另一个日历中，调用使用年、 月和日<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#7)]
 [!code-vb[System.DateTime.Constructor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hour" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="minute" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="second" Type="System.Int32" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <paramref name="calendar" /> 中的年数）。</param>
        <param name="month">月（1 到 <paramref name="calendar" /> 中的月数）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="calendar">用于解释 <paramref name="year" />、<paramref name="month" /> 和 <paramref name="day" /> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的年、月、日、小时、分钟和秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，并`day`取决于`calendar`。 如果不能使用以表示指定的日期和时间引发异常`calendar`。  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

 <xref:System.Globalization>命名空间提供了多个日历，包括<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.PersianCalendar>对象。 由于波斯日历不能指定为区域性的默认日历，显示日期与波斯历需要单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚） 和当前区域性的默认日历更改为回历。 因为回历是当前区域性的默认日历，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原先前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample4.cs#4)]
 [!code-vb[System.DateTime.Constructor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23 
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月、日、小时、分钟、秒和毫秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`为年、 月和天公历日历中的。 若要实例化<xref:System.DateTime>值在另一个日历中，调用使用年、 月和日<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#5)]
 [!code-vb[System.DateTime.Constructor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hour" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="minute" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="second" Type="System.Int32" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecond" Type="System.Int32" Index="6" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="kind" Type="System.DateTimeKind" Index="7" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="kind">枚举值之一，该值指示 <paramref name="year" />、<paramref name="month" />、<paramref name="day" />, <paramref name="hour" />、<paramref name="minute" />、<paramref name="second" /> 和 <paramref name="millisecond" /> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定年、月、日、小时、分钟、秒、毫秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`为年、 月和天公历日历中的。 若要实例化<xref:System.DateTime>值在另一个日历中，调用使用年、 月和日<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#8)]
 [!code-vb[System.DateTime.Constructor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hour" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="minute" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="second" Type="System.Int32" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecond" Type="System.Int32" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <paramref name="calendar" /> 中的年数）。</param>
        <param name="month">月（1 到 <paramref name="calendar" /> 中的月数）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="calendar">用于解释 <paramref name="year" />、<paramref name="month" /> 和 <paramref name="day" /> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月、日、小时、分钟、秒和毫秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，并`day`取决于`calendar`。 如果不能使用以表示指定的日期和时间引发异常`calendar`。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

 <xref:System.Globalization>命名空间提供了多个日历，包括<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.PersianCalendar>对象。 由于波斯日历不能指定为区域性的默认日历，显示日期与波斯历需要单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚） 和当前区域性的默认日历更改为回历。 因为回历是当前区域性的默认日历，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原先前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample6.cs#6)]
 [!code-vb[System.DateTime.Constructor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar,System.DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="new DateTime : int * int * int * int * int * int * int * System.Globalization.Calendar * DateTimeKind -&gt; DateTime" Usage="new System.DateTime (year, month, day, hour, minute, second, millisecond, calendar, kind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="month" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="day" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hour" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="minute" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="second" Type="System.Int32" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecond" Type="System.Int32" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="kind" Type="System.DateTimeKind" Index="8" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <paramref name="calendar" /> 中的年数）。</param>
        <param name="month">月（1 到 <paramref name="calendar" /> 中的月数）。</param>
        <param name="day">日（1 到 <paramref name="month" /> 中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="calendar">用于解释 <paramref name="year" />、<paramref name="month" /> 和 <paramref name="day" /> 的日历。</param>
        <param name="kind">枚举值之一，该值指示 <paramref name="year" />、<paramref name="month" />、<paramref name="day" />, <paramref name="hour" />、<paramref name="minute" />、<paramref name="second" /> 和 <paramref name="millisecond" /> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月、日、小时、分钟、秒、毫秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 允许值为`year`， `month`，并`day`参数取决于`calendar`参数。 如果不能使用以表示指定的日期和时间引发异常`calendar`。  
  
 对于应用程序的可移植性的日期和时间数据或一定的程度的时区感知非常重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

 <xref:System.Globalization>命名空间提供了多个日历，包括<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数两次实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.PersianCalendar>对象。 由于波斯日历不能指定为区域性的默认日历，显示日期与波斯历需要单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>通过使用值<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚） 和当前区域性的默认日历更改为回历。 因为回历是当前区域性的默认日历，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原先前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample9.cs#9)]
 [!code-vb[System.DateTime.Constructor#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
- 或 - 
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
- 或 - 
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
- 或 - 
 <paramref name="hour" /> 小于 0 或大于 23。  
  
- 或 - 
 <paramref name="minute" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="second" /> 小于 0 或大于 59。  
  
- 或 - 
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public DateTime Add (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Add(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Add(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Add(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Add : TimeSpan -&gt; DateTime" Usage="dateTime.Add value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">正或负时间间隔。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定 <see cref="T:System.TimeSpan" /> 的值添加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的时间间隔之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.DateTime.Add%2A>方法以在单个操作中添加多个类型的时间间隔 （天、 小时、 分钟、 秒或毫秒为单位）。 此方法的行为等同于加法运算符。 <xref:System.DateTime>结构还支持专用的加法 (如<xref:System.DateTime.AddDays%2A>， <xref:System.DateTime.AddHours%2A>，和<xref:System.DateTime.AddMinutes%2A>) 为每个时间间隔。  
  
 <xref:System.DateTime.Add%2A>方法将考虑闰年和的中时执行日期计算一个月的天数。  
  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。 <xref:System.DateTime.Kind%2A>属性的新<xref:System.DateTime>实例是否与当前实例相同。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Add%2A>方法。 它会计算一周的 36 天 （864 小时） 从当前日期。  
  
 [!code-cpp[DateTime.Add#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Add/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Add/CS/class1.cs#1)]
 [!code-vb[DateTime.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Add/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="M:System.TimeSpan.Add(System.TimeSpan)" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddDays">
      <MemberSignature Language="C#" Value="public DateTime AddDays (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddDays(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddDays(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDays (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddDays(double value);" />
      <MemberSignature Language="F#" Value="member this.AddDays : double -&gt; DateTime" Usage="dateTime.AddDays value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的天数。 <paramref name="value" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的天数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的天数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分的`value`是一天的小数部分。 例如，4.5 相当于 4 天 12 小时 0 分 0 秒，0 毫秒，0 刻度。  
  
 `value`参数舍入为最接近的毫秒。  
  
 <xref:System.DateTime.AddDays%2A>方法将考虑闰年和的中时执行日期计算一个月的天数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddDays%2A>方法来确定日期是星期几 36 天晚于当前日期。  
  
 [!code-cpp[DateTime.AddDays#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.AddDays/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.AddDays#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.AddDays/CS/class1.cs#1)]
 [!code-vb[DateTime.AddDays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.AddDays/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddHours">
      <MemberSignature Language="C#" Value="public DateTime AddHours (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddHours(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddHours(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddHours (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddHours(double value);" />
      <MemberSignature Language="F#" Value="member this.AddHours : double -&gt; DateTime" Usage="dateTime.AddHours value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的小时数。 <paramref name="value" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的小时数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的小时数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。 <xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象是相同的`value`。  
  
 小数部分的`value`是一小时的小数部分。 例如，4.5 相当于 4 小时 30 分 0 秒，0 毫秒，0 刻度。  
  
 `value`参数舍入为最接近的毫秒。  
  
 如果结果为非终止重复十进制数字，将不会超过一小时的时间间隔转换为一小部分可能涉及到精度损失。 （例如，一分钟是 0.016667 小时。）如果这是有问题，则可以使用<xref:System.DateTime.Add%2A>方法，它使你可以在单个方法调用中指定的时间间隔的多个类型，并且不需要将转换为一小时的小数部分的时间间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddHours%2A>方法将大量整数和小数部分值添加到日期和时间。 它还说明了通过将该方法传递包含小数部分的值引起的精度损失。  
  
 [!code-csharp[System.DateTime.AddHours#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.AddHours/cs/AddHours1.cs#1)]
 [!code-vb[System.DateTime.AddHours#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.AddHours/vb/AddHours1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddMilliseconds">
      <MemberSignature Language="C#" Value="public DateTime AddMilliseconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMilliseconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMilliseconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMilliseconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMilliseconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMilliseconds : double -&gt; DateTime" Usage="dateTime.AddMilliseconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的毫秒数。 <paramref name="value" /> 参数可以是负数也可以是正数。 请注意，该值被舍入到最近的整数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的毫秒数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的毫秒数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分的`value`是以毫秒为单位的小数部分。 例如，4.5 等效于 4 毫秒 5000 个时钟周期，其中 1 毫秒 = 10000 刻度。  
  
 `value`参数舍入为最接近的整数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddMilliseconds%2A>方法将添加一毫秒和 1.5 毫秒到<xref:System.DateTime>值。 然后，它将显示每个新值并显示它的原始值之间的差异。 不同之处被显示为时间跨度和计时周期数。 示例将其清除，一种毫秒等于 10000 个计时周期。 它还显示毫秒小数部分舍入之前执行加法;<xref:System.DateTime>添加到原始日期 1.5 毫秒得到的值为 2 毫秒大于原始日期。  
  
 [!code-csharp[System.DateTime.AddMilliseconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmilliseconds/cs/addmilliseconds2.cs#1)]
 [!code-vb[System.DateTime.AddMilliseconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmilliseconds/vb/addmilliseconds2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddMinutes">
      <MemberSignature Language="C#" Value="public DateTime AddMinutes (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMinutes(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMinutes(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMinutes (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMinutes(double value);" />
      <MemberSignature Language="F#" Value="member this.AddMinutes : double -&gt; DateTime" Usage="dateTime.AddMinutes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的分钟数。 <paramref name="value" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的分钟数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的分钟数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分的`value`是一分钟的小数部分。 例如，4.5 相当于 4 分 30 秒，0 毫秒，0 刻度。  
  
 `value`参数舍入为最接近的毫秒。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddMinutes%2A>方法将大量整数和小数部分值添加到日期和时间。  
  
 [!code-cpp[System.DateTime.AddMinutes#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.addminutes/cpp/addminutes1.cpp#1)]
 [!code-csharp[System.DateTime.AddMinutes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addminutes/cs/addminutes1.cs#1)]
 [!code-vb[System.DateTime.AddMinutes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addminutes/vb/addminutes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddMonths">
      <MemberSignature Language="C#" Value="public DateTime AddMonths (int months);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMonths(int32 months) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMonths(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMonths (months As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMonths(int months);" />
      <MemberSignature Language="F#" Value="member this.AddMonths : int -&gt; DateTime" Usage="dateTime.AddMonths months" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="months" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="months">月份数。 <paramref name="months" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的月数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="months" /> 所表示的时间之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>对象。 相反，它会返回一个新<xref:System.DateTime>对象，其值是此操作的结果。  
  
 <xref:System.DateTime.AddMonths%2A>方法计算生成的月和年，同时考虑闰年和在一个月的天数，然后调整所产生的日部分<xref:System.DateTime>对象。 如果结果的日期不是结果的月份中的有效日期，则使用生成的每月的最后一个有效的日期。 例如，年 3 月 31 + 1 个月 = 4 月 30 日和年 3 月 31-1 个月 = 2 月 28 日的非-闰年和年 2 月 29 为闰年。  
  
 所生成的时间的日部分<xref:System.DateTime>对象保持与此实例相同。  
  
   
  
## Examples  
 下面的示例将介于零和十五个月添加到 2015 年 12 月的最后一天。 在这种情况下，AddMonths 方法返回的每个月的最后一天的日期，并能够成功处理闰年。  
  
 [!code-csharp[System.DateTime.AddMonths#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmonths/cs/addmonths1.cs#1)]
 [!code-vb[System.DateTime.AddMonths#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmonths/vb/addmonths1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。  
  
- 或 - 
 <paramref name="months" /> 小于 -120,000 或大于 120,000。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddSeconds">
      <MemberSignature Language="C#" Value="public DateTime AddSeconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddSeconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddSeconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSeconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddSeconds(double value);" />
      <MemberSignature Language="F#" Value="member this.AddSeconds : double -&gt; DateTime" Usage="dateTime.AddSeconds value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的秒数。 <paramref name="value" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的秒数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的秒数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分的`value`秒的小数部分。 例如，4.5 相当于 4 秒、 500 毫秒和 0 刻度。  
  
 `value`参数舍入为最接近的毫秒。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddSeconds%2A>方法将 30 秒和秒数添加到一天中<xref:System.DateTime>值。 然后，它将显示每个新值并显示它的原始值之间的差异。 不同之处被显示为时间跨度和计时周期数。  
  
 [!code-csharp[System.DateTime.AddSeconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addseconds/cs/addseconds1.cs#1)]
 [!code-vb[System.DateTime.AddSeconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addseconds/vb/addseconds1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddTicks">
      <MemberSignature Language="C#" Value="public DateTime AddTicks (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddTicks(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddTicks(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTicks (value As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddTicks(long value);" />
      <MemberSignature Language="F#" Value="member this.AddTicks : int64 -&gt; DateTime" Usage="dateTime.AddTicks value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">以 100 纳秒为单位的计时周期数。 <paramref name="value" /> 参数可以是正数也可以是负数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的刻度数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的时间之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Int64" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="AddYears">
      <MemberSignature Language="C#" Value="public DateTime AddYears (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddYears(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddYears(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddYears (value As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddYears(int value);" />
      <MemberSignature Language="F#" Value="member this.AddYears : int -&gt; DateTime" Usage="dateTime.AddYears value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">年份数。 <paramref name="value" /> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的年份数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的年份数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此设置的值<xref:System.DateTime>对象。 相反，它会返回一个新<xref:System.DateTime>对象，其值是此操作的结果。  
  
 <xref:System.DateTime.AddYears%2A>方法计算生成的年考虑到闰年。 所生成的月份和日期时间的部分<xref:System.DateTime>对象保持与此实例相同。  
  
 如果当前实例表示在闰年中的闰日，返回值取决于目标日期：  
  
-   如果`value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType>也是闰年，返回值表示该年闰日。 例如，如果四年添加到 2012 年 2 月 29 日，返回的日期是 2016 年 2 月 29 日。  
  
-   如果`value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType>不是闰年，返回值表示该年闰日的前一天。 例如，如果一年添加到 2012 年 2 月 29 日，返回的日期是 2013 年 2 月 28 日。  
  
 下面的示例演示如何使用<xref:System.DateTime.AddYears%2A>方法替换<xref:System.DateTime>值，该值表示闰年天。 它显示的日期之前的 15 年和遵循 15 年 2000 年 2 月 29 日。  
  
 [!code-csharp[System.DateTime.AddYears#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addyears/cs/addyears1.cs#1)]
 [!code-vb[System.DateTime.AddYears#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addyears/vb/addyears1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 或生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (t1 As DateTime, t2 As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Compare : DateTime * DateTime -&gt; int" Usage="System.DateTime.Compare (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>对两个 <see cref="T:System.DateTime" /> 的实例进行比较，并返回一个指示第一个实例是早于、等于还是晚于第二个实例的整数。</summary>
        <returns>有符号数字，指示 <paramref name="t1" /> 和 <paramref name="t2" /> 的相对值。  
  
 <list type="table"><listheader><term> 值类型 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="t1" /> 早于 <paramref name="t2" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="t1" /> 与 <paramref name="t2" /> 相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="t1" /> 晚于 <paramref name="t2" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定之间的关系`t1`到`t2`，则<xref:System.DateTime.Compare%2A>方法进行比较<xref:System.DateTime.Ticks%2A>属性`t1`和`t2`但会忽略其<xref:System.DateTime.Kind%2A>属性。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Compare%2A>方法。  
  
 [!code-csharp[System.DateTime.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.compare/cs/compare1.cs#1)]
 [!code-vb[System.DateTime.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.compare/vb/compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值与指定的 <see cref="T:System.DateTime" /> 值相比较，并指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个重载<xref:System.DateTime.CompareTo%2A>方法返回一个有符号的数字，指示此实例的相关值和`value`参数下, 表中所示。  
  
|值|描述|  
|-----------|-----------------|  
|小于零|此实例早于 `value`。|  
|零|此实例与 `value` 相同。|  
|大于零|此实例晚于 `value`。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(DateTime value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : DateTime -&gt; int&#xA;override this.CompareTo : DateTime -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要与当前类型进行比较的对象。</param>
        <summary>将此实例的值与指定的 <see cref="T:System.DateTime" /> 值相比较，并返回一个整数，该整数指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <returns>有符号数字，指示此实例和 <paramref name="value" /> 参数的相对值。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 描述 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例早于 <paramref name="value" />。  
  
 </description></item><item><term> 零 
 </term><description> 此实例与 <paramref name="value" /> 相同。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例晚于 <paramref name="value" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定当前实例与的关系`value`，则<xref:System.DateTime.CompareTo%2A>方法进行比较<xref:System.DateTime.Ticks%2A>的当前实例的属性和`value`但会忽略其<xref:System.DateTime.Kind%2A>属性。  然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 您可以执行此操作通过比较的值及其<xref:System.DateTime.Kind%2A>属性。  
  
 此方法实现<xref:System.IComparable%601?displayProperty=nameWithType>接口，并且执行略微优于<xref:System.DateTime.CompareTo%28System.Object%29?displayProperty=nameWithType>方法重载，因为它不需要转换`value`参数的对象。  
  
   
  
## Examples  
 下面的示例实例化三个<xref:System.DateTime>对象，一个表示今天的日期，另一个表示一年以前，日期和第三个，它表示日期在未来的 1 年。 然后，它调用<xref:System.DateTime.CompareTo%28System.DateTime%29>方法，并显示比较结果。  
  
 [!code-csharp[DateTime.CompareTo.2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo.2/CS/CompareTo_CS1_24564.cs#1)]
 [!code-vb[DateTime.CompareTo.2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo.2/VB/CompareTo_VB1_24564.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="dateTime.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要比较的装箱对象，或 <see langword="null" />。</param>
        <summary>将此实例的值与包含指定的 <see cref="T:System.DateTime" /> 值的指定对象相比较，并返回一个整数，该整数指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 描述 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例早于 <paramref name="value" />。  
  
 </description></item><item><term> 零 
 </term><description> 此实例与 <paramref name="value" /> 相同。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例晚于 <paramref name="value" />，或 <paramref name="value" /> 为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定当前实例与的关系`value`，则<xref:System.DateTime.CompareTo%2A>方法进行比较<xref:System.DateTime.Ticks%2A>的当前实例的属性和`value`但会忽略其<xref:System.DateTime.Kind%2A>属性。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 您可以执行此操作通过比较的值及其<xref:System.DateTime.Kind%2A>属性。  
  
 任何实例<xref:System.DateTime>，而不考虑其值被视为大于`null`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.CompareTo%2A>方法。  
  
 [!code-cpp[DateTime.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.CompareTo/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo/CS/class1.cs#1)]
 [!code-vb[DateTime.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.DateTime" />。</exception>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Date" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime" Usage="System.DateTime.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的日期部分。</summary>
        <value>一个新对象，其日期与此实例相同，时间值设置为午夜 12:00:00 (00:00:00)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.DateTime.Kind%2A>属性所返回的<xref:System.DateTime>值是当前实例相同。  
  
 因为<xref:System.DateTime>类型表示这两个日期和时间在单个类型非常重要，避免错误解释返回日期<xref:System.DateTime.Date%2A>属性设置为日期和时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Date%2A>属性来提取日期部分<xref:System.DateTime>值，该值具有其时间组成部分设置为零 (0:00:00 或午夜)。 它还演示了，具体取决于在显示时使用的格式字符串<xref:System.DateTime>值，时间部分可以继续在格式化输出中显示。  
  
 [!code-cpp[System.DateTime.Date#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Date/cpp/date1.cpp#1)]
 [!code-csharp[System.DateTime.Date#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Date/cs/Date1.cs#1)]
 [!code-vb[System.DateTime.Date#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Date/vb/Date1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Day">
      <MemberSignature Language="C#" Value="public int Day { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Day" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Day" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Day As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Day { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Day : int" Usage="System.DateTime.Day" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期为该月中的第几天。</summary>
        <value>日组成部分，表示为 1 和 31 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Day%2A>属性始终返回月份中的一天在公历日历中，即使当前<xref:System.DateTime>值实例化使用某些其他日历或如果当前线程区域性的默认日历不是公历。 若要检索特定日期使用某些其他日历月中的日期，调用该日历的<xref:System.Globalization.Calendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法。 下面的示例使用这两个<xref:System.DateTime.Day%2A>属性和<xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法来检索其中的每月天数<xref:System.DateTime>实例化时使用在伊斯兰日历的值。  
  
 [!code-csharp[System.DateTime.Day#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day1.cs#1)]
 [!code-vb[System.DateTime.Day#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day1.vb#1)]  
  
 同样，下面的示例使用这两个<xref:System.DateTime.Day%2A>属性和<xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法来检索当前线程区域性时 ar-SA，这将为其默认日历使用回历的当月日期。  
  
 [!code-csharp[System.DateTime.Day#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day2.cs#2)]
 [!code-vb[System.DateTime.Day#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day2.vb#2)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Day%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfWeek">
      <MemberSignature Language="C#" Value="public DayOfWeek DayOfWeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DayOfWeek DayOfWeek" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfWeek" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfWeek As DayOfWeek" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DayOfWeek DayOfWeek { DayOfWeek get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfWeek : DayOfWeek" Usage="System.DateTime.DayOfWeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DayOfWeek</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期是星期几。</summary>
        <value>一个枚举常量，指示此 <see cref="T:System.DateTime" /> 值是星期几。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的常量值<xref:System.DayOfWeek>枚举的范围从<xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>到<xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>。 如果强制转换为一个整数，其值的范围是从零 (指示<xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>) 为 6 (表示<xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>)。  
  
 <xref:System.DateTime.DayOfWeek%2A>属性将返回一个枚举的常量; 它不反映系统的区域和语言设置。 若要检索表示特定日期的本地化的星期几名称的字符串，调用的重载之一<xref:System.DateTime.ToString%2A>方法，包括`format`参数并将其传递要么`ddd`或`dddd`自定义格式字符串。 有关详细信息，请参阅[如何：从特定日期中提取星期几](~/docs/standard/base-types/how-to-extract-the-day-of-the-week-from-a-specific-date.md)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.DayOfWeek%2A>属性和<xref:System.DayOfWeek?displayProperty=nameWithType>枚举。  
  
 [!code-cpp[DateTime.DayOfWeek#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DayOfWeek/CPP/dow.cpp#1)]
 [!code-csharp[DateTime.DayOfWeek#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DayOfWeek/CS/dow.cs#1)]
 [!code-vb[DateTime.DayOfWeek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DayOfWeek/VB/dow.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="DayOfYear">
      <MemberSignature Language="C#" Value="public int DayOfYear { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DayOfYear" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfYear" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfYear As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DayOfYear { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfYear : int" Usage="System.DateTime.DayOfYear" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期是该年中的第几天。</summary>
        <value>该年中的第几天，表示为 1 和 366 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DayOfYear%2A>属性考虑闰年在内时它会计算一年中的天。 属性值始终反映在公历日历中，而不考虑当前线程区域性的当前日历年的某一天。 若要检索的不同日历中每年一天，请调用<xref:System.Globalization.Calendar.GetDayOfYear%2A?displayProperty=nameWithType>该日历的方法。  
  
   
  
## Examples  
 下面的示例用公历日历显示 2010年 2020 年 12 月 31 日的年度的天。 请注意，该示例显示 12 月 31 日是闰年中该年的第 366 天。  
  
 [!code-csharp[System.DateTime.DayOfYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.dayofyear/cs/dayofyear2.cs#1)]
 [!code-vb[System.DateTime.DayOfYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.dayofyear/vb/dayofyear2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.Calendar.GetDayOfYear(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="DaysInMonth">
      <MemberSignature Language="C#" Value="public static int DaysInMonth (int year, int month);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DaysInMonth(int32 year, int32 month) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.DaysInMonth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DaysInMonth (year As Integer, month As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DaysInMonth(int year, int month);" />
      <MemberSignature Language="F#" Value="static member DaysInMonth : int * int -&gt; int" Usage="System.DateTime.DaysInMonth (year, month)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年。</param>
        <param name="month">月（介于 1 到 12 之间的一个数字）。</param>
        <summary>返回指定年和月中的天数。</summary>
        <returns>指定 <paramref name="month" /> 中 <paramref name="year" /> 中的天数。  
  
例如，如果 <paramref name="month" /> 等于 2（表示二月），则返回值为 28 或 29，具体取决于 <paramref name="year" /> 是否为闰年。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DaysInMonth%2A>方法始终会解释`month`和`year`按月份和年份公历日历即使公历日历不是当前区域性的当前日历。 若要在特定日历的指定月份中的天数，调用该日历的<xref:System.Globalization.Calendar.GetDaysInMonth%2A>方法。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.DateTime.DaysInMonth%2A>方法来确定在 2001 年 7 月、 年 2 月天数 1998 年 （非-闰年） 和 1996 年 2 月 （闰年）。  
  
 [!code-cpp[DateTime.DaysInMonth#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DaysInMonth/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DaysInMonth/CS/class1.cs#1)]
 [!code-vb[DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DaysInMonth/VB/class1.vb#1)]  
  
 下面的示例显示在每个月的整数数组中指定一年中的天数。  
  
 [!code-csharp[System.DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.daysinmonth/cs/daysinmonth3.cs#1)]
 [!code-vb[System.DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.daysinmonth/vb/daysinmonth3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="month" /> 小于 1 或大于 12。  
  
- 或 - 
 <paramref name="year" /> 小于 1 或大于 9999。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个 <see cref="T:System.DateTime" /> 对象，或者一个 <see cref="T:System.DateTime" /> 实例和另一个对象或 <see cref="T:System.DateTime" /> 是否具有相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(DateTime value);" />
      <MemberSignature Language="F#" Value="override this.Equals : DateTime -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例的值是否等于指定 <see cref="T:System.DateTime" /> 实例的值。</summary>
        <returns>如果 <see langword="true" /> 参数与此实例的值相等，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和`value`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>属性值不会为确定相等性测试中。  
  
 此方法实现<xref:System.IEquatable%601?displayProperty=nameWithType>接口，并且执行略微优于<xref:System.DateTime.Equals%2A>方法因为`value`参数无需转换为对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dateTime.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="value" /> 的实例并且等于此实例的值，则为 <see cref="T:System.DateTime" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和`value`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>属性值不会为确定相等性测试中。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member Equals : DateTime * DateTime -&gt; bool" Usage="System.DateTime.Equals (t1, t2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>返回一个值，该值指示的两个 <see cref="T:System.DateTime" /> 实例是否具有同一个日期和时间值。</summary>
        <returns>如果两个值相等，则为，<see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t1` 并`t2`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>属性值不会为确定相等性测试中。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-cpp[DateTime.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Equals/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Equals/CS/class1.cs#1)]
 [!code-vb[DateTime.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Equals/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FromBinary">
      <MemberSignature Language="C#" Value="public static DateTime FromBinary (long dateData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromBinary(int64 dateData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromBinary(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBinary (dateData As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromBinary(long dateData);" />
      <MemberSignature Language="F#" Value="static member FromBinary : int64 -&gt; DateTime" Usage="System.DateTime.FromBinary dateData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateData" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dateData">64 位带符号整数，它对 2 位字段的 <see cref="P:System.DateTime.Kind" /> 属性以及 62 位字段的 <see cref="P:System.DateTime.Ticks" /> 属性进行了编码。</param>
        <summary>反序列化一个 64 位二进制值，并重新创建序列化的 <see cref="T:System.DateTime" /> 初始对象。</summary>
        <returns>一个对象，它等效于由 <see cref="T:System.DateTime" /> 方法序列化的 <see cref="M:System.DateTime.ToBinary" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.DateTime.ToBinary%2A>方法将当前值转换<xref:System.DateTime>为二进制值的对象。 随后，使用二进制值和<xref:System.DateTime.FromBinary%2A>方法来重新创建原始<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  在某些情况下，<xref:System.DateTime>返回值<xref:System.DateTime.FromBinary%2A>方法不是与原始<xref:System.DateTime>值提供给<xref:System.DateTime.ToBinary%2A>方法。 有关详细信息，请参阅下一部分中，"本地时间调整"。  
  
## <a name="local-time-adjustment"></a>本地时间调整  
 表示本地时间，即协调通用时间调整为本地时区<xref:System.DateTime>结构，其<xref:System.DateTime.Kind%2A>属性具有值<xref:System.DateTimeKind.Local>。 还原本地时<xref:System.DateTime>值由生成的二进制表示形式<xref:System.DateTime.ToBinary%2A>方法，<xref:System.DateTime.FromBinary%2A>方法可能会调整重新创建的值，以使是否不等于原始值。 在下列条件下，可能会出现这种情况：  
  
-   如果本地<xref:System.DateTime>由一个时区中序列化对象<xref:System.DateTime.ToBinary%2A>方法，然后反序列化中通过不同的时区<xref:System.DateTime.FromBinary%2A>方法中，表示所生成的本地时间<xref:System.DateTime>自动调整对象为第二个时区。  
  
     例如，考虑<xref:System.DateTime>对象，表示本地时间的下午 3 点 在美国执行应用程序使用太平洋时区<xref:System.DateTime.ToBinary%2A>方法以将其转换<xref:System.DateTime>为二进制值的对象。 在美国执行的另一个应用程序然后使用东部标准时间时区<xref:System.DateTime.FromBinary%2A>方法将转换为一个新的二进制值<xref:System.DateTime>对象。 新值<xref:System.DateTime>对象是下午 6 时，这表示时间作为原始的下午 3 点到相同的点 值，但将会调整为美国东部时区中的本地时间。  
  
-   如果本地的二进制表示形式<xref:System.DateTime>值表示本地时区的系统中的无效时间<xref:System.DateTime.FromBinary%2A>是调用，该时间会调整，这样就有效。  
  
     例如，从标准时间转换为夏时制发生在美国太平洋时区中 2010 年 3 月 14 日，上午 2:00，此时时间前进一小时，上午 3:00 此小时间隔为无效的时间，即，不存在该时区的时间间隔。 下面的示例演示时的时间内此范围转换为二进制值通过<xref:System.DateTime.ToBinary%2A>方法，然后通过还原<xref:System.DateTime.FromBinary%2A>方法中，原始值调整为有效的时间。 您可以确定是否特定日期和时间值也可能受到修改将其传递到<xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType>方法，该示例作为演示。  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>版本的注意事项  
 从.NET Framework 2.0 版中，开始<xref:System.DateTime>结构包含私有类型的字段，它指示是否在指定的时间本地时间、 协调世界时 (UTC)，还是两者皆未，连接到专用的计时周期字段，其中包含指定的日期和时间的 100 纳秒为刻度数。 可以通过访问的计时周期数<xref:System.DateTime.Ticks%2A>属性和 theKind 字段可以访问与<xref:System.DateTime.Kind%2A>属性。  
  
 在.NET Framework 2.0 中，如果您序列化之前<xref:System.DateTime>对象而使用序列化接口，如不是手动<xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>，你需要仅计时周期中的数据进行序列化<xref:System.DateTime>。 从.NET Framework 2.0 开始，必须还序列化类型的数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="dateData" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.ToBinary" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTime">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTime (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTime(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTime(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTime (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTime(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTime : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTime fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">以计时周期表示的 Windows 文件时间。</param>
        <summary>将指定的 Windows 文件时间转换为等效的本地时间。</summary>
        <returns>一个表示本地时间的对象，等效于由 <paramref name="fileTime" /> 参数表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，它表示午夜 12:00，公元 1601 年 1 月 1 日起经过的 100 纳秒间隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间记录时应用程序创建、 访问，或写入文件。  
  
 `fileTime`参数指定以 100 毫微秒表示的文件时间。  
  
 从.NET Framework 2.0 版开始，返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.FromFileTime%2A>方法。  
  
 [!code-cpp[DateTime.FromFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.FromFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.FromFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.FromFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileTime" /> 小于零或表示大于 <see cref="F:System.DateTime.MaxValue" /> 的时间。</exception>
        <block subset="none" type="usage"><para>通常，<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法还原<see cref="T:System.DateTime" />保存的值<see cref="M:System.DateTime.ToFileTime" />方法。 但是，可能在以下情况下不同的两个值： 
-如果序列化和反序列化<see cref="T:System.DateTime" />值出现在不同时区中。 例如，如果<see cref="T:System.DateTime" />值时间为中午 12:30 在美国东部标准时间时区被序列化，并在美国然后反序列化太平洋时区，中午 12:30 的原始值 调整为上午 9:30 以反映两个时区之间的差异。  
  
-如果<see cref="T:System.DateTime" />序列化的值表示本地时区中的无效时间。 在这种情况下，<see cref="M:System.DateTime.ToFileTime" />方法调整还原<see cref="T:System.DateTime" />值，使其在本地时区表示有效的时间。  
  
例如，从标准时间到夏时制的转换发生在美国在 2010 年 3 月 14 日凌晨 2:00，此时时间前进一小时，上午 3 点到太平洋时区 此小时间隔为无效的时间，即，不存在该时区的时间间隔。 下面的示例演示时的时间内此范围转换为长整型值通过<see cref="M:System.DateTime.ToFileTime" />方法，然后通过还原<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法中，原始值调整为有效的时间。 您可以确定是否特定日期和时间值也可能受到修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，该示例作为演示。  
  
[!code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [!code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTimeUtc (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTimeUtc(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTimeUtc(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTimeUtc (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTimeUtc(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTimeUtc : int64 -&gt; DateTime" Usage="System.DateTime.FromFileTimeUtc fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">以计时周期表示的 Windows 文件时间。</param>
        <summary>将指定的 Windows 文件时间转换为等效的 UTC 时间。</summary>
        <returns>一个表示 UTC 时间的对象，等效于由 <paramref name="fileTime" /> 参数表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，它表示午夜 12:00，公元 1601 年 1 月 1 日起经过的 100 纳秒间隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间记录时应用程序创建、 访问，或写入文件。  
  
 `fileTime`参数指定以 100 毫微秒表示的文件时间。  
  
 从.NET Framework 2.0 版开始，返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fileTime" /> 小于零或表示大于 <see cref="F:System.DateTime.MaxValue" /> 的时间。</exception>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.DateTime.FromFileTime(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FromOADate">
      <MemberSignature Language="C#" Value="public static DateTime FromOADate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromOADate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromOADate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOADate (d As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromOADate(double d);" />
      <MemberSignature Language="F#" Value="static member FromOADate : double -&gt; DateTime" Usage="System.DateTime.FromOADate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">OLE 自动化日期值。</param>
        <summary>返回与指定的 OLE 自动化日期等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它表示与 <paramref name="d" /> 相同的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `d`参数是的双精度浮点数，它将日期表示的基日期，1899 年 12 月 30 日午夜之前或之后的天数。 符号和整数部分`d`编码日期为正或负天的偏移量从 30 1899 年 12 月和值的小数部分的绝对值`d`将编码为天从午夜的偏移量的一小部分的时间。 `d` 必须是介于负 657435.0 到正 2958465.99999999 之间的值。  
  
 请注意，由于日期进行编码的方式，有两种方法来表示任何时间的 30 1899 年 12 月。 例如，-0.5，0.5 意味着中午 1899 年 12 月 30 天的偏移量加或减基零天仍然是基本的日期，因此从午夜的半天位移是中午。  
  
 请参阅<xref:System.DateTime.ToOADate%2A>的 OLE 自动化的详细信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日期不是有效的 OLE 自动化日期值。</exception>
        <altmember cref="M:System.DateTime.ToOADate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDateTimeFormats">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值转换为标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  不应假定该多次调用<xref:System.DateTime.GetDateTimeFormats%2A>重载将返回相同的数据。 具体取决于特定的重载中，如果当前区域性更改，用户会替代单个的区域性设置，或系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : unit -&gt; string[]" Usage="dateTime.GetDateTimeFormats " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串数组<xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType>方法等效于将单独调用返回的字符串数组组合<xref:System.DateTime.GetDateTimeFormats%28System.Char%29?displayProperty=nameWithType>方法使用"d"、"D"、"f"、"F"、"g"、"G"、"m"、"o"、"r"、"s"、"t"、"T"、"u"、"U"和"y"标准格式字符串。 有关标准格式说明符的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 使用当前区域性中的信息设置的返回值的每个元素的格式。 有关当前区域性的区域性特定格式设置信息的详细信息，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，不应假定对方法的多个调用将返回相同的数据。 如果当前区域性更改，用户会替代单个的区域性设置，或系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType>方法。 它将显示计算机的当前区域性，在这种情况下为 EN-US 中使用的所有可能的标准日期和时间格式的日期的字符串表示形式。  
  
 [!code-cpp[DateTime.GetDateTimeFormats#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.GetDateTimeFormats#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#1)]
 [!code-vb[DateTime.GetDateTimeFormats#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#1)]  
  
 该示例显示以下输出：  
  
```  
7/28/2009  
7/28/09  
07/28/09  
07/28/2009  
09/07/28  
2009-07-28  
28-Jul-09  
Tuesday, July 28, 2009  
July 28, 2009  
Tuesday, 28 July, 2009  
28 July, 2009  
Tuesday, July 28, 2009 5:23 AM  
Tuesday, July 28, 2009 05:23 AM  
Tuesday, July 28, 2009 5:23  
Tuesday, July 28, 2009 05:23  
July 28, 2009 5:23 AM  
July 28, 2009 05:23 AM  
July 28, 2009 5:23  
July 28, 2009 05:23  
Tuesday, 28 July, 2009 5:23 AM  
Tuesday, 28 July, 2009 05:23 AM  
Tuesday, 28 July, 2009 5:23  
Tuesday, 28 July, 2009 05:23  
28 July, 2009 5:23 AM  
28 July, 2009 05:23 AM  
28 July, 2009 5:23  
28 July, 2009 05:23  
Tuesday, July 28, 2009 5:23:15 AM  
Tuesday, July 28, 2009 05:23:15 AM  
Tuesday, July 28, 2009 5:23:15  
Tuesday, July 28, 2009 05:23:15  
July 28, 2009 5:23:15 AM  
July 28, 2009 05:23:15 AM  
July 28, 2009 5:23:15  
July 28, 2009 05:23:15  
Tuesday, 28 July, 2009 5:23:15 AM  
Tuesday, 28 July, 2009 05:23:15 AM  
Tuesday, 28 July, 2009 5:23:15  
Tuesday, 28 July, 2009 05:23:15  
28 July, 2009 5:23:15 AM  
28 July, 2009 05:23:15 AM  
28 July, 2009 5:23:15  
28 July, 2009 05:23:15  
7/28/2009 5:23 AM  
7/28/2009 05:23 AM  
7/28/2009 5:23  
7/28/2009 05:23  
7/28/09 5:23 AM  
7/28/09 05:23 AM  
7/28/09 5:23  
7/28/09 05:23  
07/28/09 5:23 AM  
07/28/09 05:23 AM  
07/28/09 5:23  
07/28/09 05:23  
07/28/2009 5:23 AM  
07/28/2009 05:23 AM  
07/28/2009 5:23  
07/28/2009 05:23  
09/07/28 5:23 AM  
09/07/28 05:23 AM  
09/07/28 5:23  
09/07/28 05:23  
2009-07-28 5:23 AM  
2009-07-28 05:23 AM  
2009-07-28 5:23  
2009-07-28 05:23  
28-Jul-09 5:23 AM  
28-Jul-09 05:23 AM  
28-Jul-09 5:23  
28-Jul-09 05:23  
7/28/2009 5:23:15 AM  
7/28/2009 05:23:15 AM  
7/28/2009 5:23:15  
7/28/2009 05:23:15  
7/28/09 5:23:15 AM  
7/28/09 05:23:15 AM  
7/28/09 5:23:15  
7/28/09 05:23:15  
07/28/09 5:23:15 AM  
07/28/09 05:23:15 AM  
07/28/09 5:23:15  
07/28/09 05:23:15  
07/28/2009 5:23:15 AM  
07/28/2009 05:23:15 AM  
07/28/2009 5:23:15  
07/28/2009 05:23:15  
09/07/28 5:23:15 AM  
09/07/28 05:23:15 AM  
09/07/28 5:23:15  
09/07/28 05:23:15  
2009-07-28 5:23:15 AM  
2009-07-28 05:23:15 AM  
2009-07-28 5:23:15  
2009-07-28 05:23:15  
28-Jul-09 5:23:15 AM  
28-Jul-09 05:23:15 AM  
28-Jul-09 5:23:15  
28-Jul-09 05:23:15  
July 28  
July 28  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
5:23 AM  
05:23 AM  
5:23  
05:23  
5:23:15 AM  
05:23:15 AM  
5:23:15  
05:23:15  
2009-07-28 05:23:15Z  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15  
Tuesday, July 28, 2009 12:23:15  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15  
July 28, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15  
28 July, 2009 12:23:15  
July, 2009  
July, 2009  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char -&gt; string[]" Usage="dateTime.GetDateTimeFormats format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="format">标准日期和时间格式字符串。</param>
        <summary>将此实例的值转换为指定的标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <returns>符串数组，其中每个元素都表示此实例的以 <paramref name="format" /> 标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format`参数可以是任何标准日期和时间格式说明符。 其中包括 d、 D、 f、 F、 g、 G、 M （或 m），O （或 o），R （或 r），s、 t、 T、 u、 U 和 Y （或 y）。 有关详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 使用当前区域性中的信息设置的返回值的每个元素的格式。 有关当前区域性的区域性特定格式设置信息的详细信息，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，不应假定对方法的多个调用将返回相同的数据。 如果当前区域性更改，用户会替代单个的区域性设置，或系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.Char%29>方法。 它显示为当前区域性使用长日期格式说明符 ("D") 的日期的字符串表示形式。  
  
 [!code-csharp[DateTime.GetDateTimeFormats#3](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#3)]
 [!code-vb[DateTime.GetDateTimeFormats#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的标准日期和时间格式说明符。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，它提供有关此实例的区域性特定格式设置信息。</param>
        <summary>将此实例的值转换为标准日期和时间格式说明符和指定的区域性特定格式信息支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串数组<xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType>方法等效于将单独调用返回的字符串数组组合<xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法使用"d"、"D"、"f"、"F"、"g"、"G"、"m"、"o"、"r"、"s"、"t"、"T"、"u"、"U"和"y"标准格式字符串。 有关标准格式说明符的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素使用提供的特定于区域性的信息进行格式化`provider`。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，您不应假定对方法的多个调用将返回相同的数据，除非`provider`是<xref:System.Globalization.CultureInfo>表示固定区域性的对象。 如果用户重写的单独的区域性设置，此方法返回的数据可以更改`provider`或系统的区域性数据进行更新，则如果`provider`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType>方法。 它显示为 FR-FR 区域性使用的所有可能的标准日期和时间格式的日期的字符串表示形式。  
  
 [!code-cpp[DateTime.GetDateTimeFormats#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#2)]
 [!code-csharp[DateTime.GetDateTimeFormats#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#2)]
 [!code-vb[DateTime.GetDateTimeFormats#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#2)]  
  
 该示例显示以下输出：  
  
```  
28/07/2009  
28/07/09  
28.07.09  
28-07-09  
2009-07-28  
mardi 28 juillet 2009  
28 juil. 09  
28 juillet 2009  
mardi 28 juillet 2009 05:23  
mardi 28 juillet 2009 5:23  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23  
28 juil. 09 5:23  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23  
28 juillet 2009 5:23  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
mardi 28 juillet 2009 05:23:15  
mardi 28 juillet 2009 5:23:15  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23:15  
28 juil. 09 5:23:15  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23:15  
28 juillet 2009 5:23:15  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
28/07/2009 05:23  
28/07/2009 5:23  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23  
28/07/09 5:23  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23  
28.07.09 5:23  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23  
28-07-09 5:23  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23  
2009-07-28 5:23  
2009-07-28 05.23  
2009-07-28 05 h 23  
28/07/2009 05:23:15  
28/07/2009 5:23:15  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23:15  
28/07/09 5:23:15  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23:15  
28.07.09 5:23:15  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23:15  
28-07-09 5:23:15  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23:15  
2009-07-28 5:23:15  
2009-07-28 05.23  
2009-07-28 05 h 23  
28 juillet  
28 juillet  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
05:23  
5:23  
05.23  
05 h 23  
05:23:15  
5:23:15  
05.23  
05 h 23  
2009-07-28 05:23:15Z  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12.23  
mardi 28 juillet 2009 12 h 23  
28 juil. 09 12:23:15  
28 juil. 09 12:23:15  
28 juil. 09 12.23  
28 juil. 09 12 h 23  
28 juillet 2009 12:23:15  
28 juillet 2009 12:23:15  
28 juillet 2009 12.23  
28 juillet 2009 12 h 23  
juillet 2009  
juillet 2009  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char, provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeFormats : char * IFormatProvider -&gt; string[]" Usage="dateTime.GetDateTimeFormats (format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准和时间格式字符串。</param>
        <param name="provider">一个对象，它提供有关此实例的区域性特定格式设置信息。</param>
        <summary>将此实例的值转换为指定的标准日期和时间格式说明符和区域性特定格式信息支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 格式参数可以是任何标准日期和时间格式说明符。 其中包括 d、 D、 f、 F、 g、 G、 M （或 m），O （或 o），R （或 r），s、 t、 T、 u、 U 和 Y （或 y）。 有关详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素使用提供的特定于区域性的信息进行格式化`provider`。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，您不应假定对方法的多个调用将返回相同的数据，除非`provider`是<xref:System.Globalization.CultureInfo>表示固定区域性的对象。 如果用户重写的单独的区域性设置，此方法返回的数据可以更改`provider`或系统的区域性数据进行更新，则如果`provider`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29>方法。 它将显示使用 FR-FR 区域性的短日期格式说明符 ("d") 的日期的字符串表示形式。  
  
 [!code-csharp[DateTime.GetDateTimeFormats#4](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#4)]
 [!code-vb[DateTime.GetDateTimeFormats#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的标准日期和时间格式说明符。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dateTime.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="dateTime.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回值类型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.DateTime" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.DateTime" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hour">
      <MemberSignature Language="C#" Value="public int Hour { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Hour" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Hour" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hour As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Hour { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Hour : int" Usage="System.DateTime.Hour" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的小时部分。</summary>
        <value>小时组成部分，表示为 0 和 23 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.DateTime.Hour%2A>始终使用 24 小时制表示属性。 若要检索的字符串表示的日期和时间采用 12 小时制的小时，请调用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>或<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法使用"h"自定义格式说明符。 例如:  
  
 [!code-csharp[System.DateTime.Hour#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Hour/cs/Hour1.cs#1)]
 [!code-vb[System.DateTime.Hour#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Hour/vb/Hour1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Hour%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsDaylightSavingTime" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDaylightSavingTime () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime();" />
      <MemberSignature Language="F#" Value="member this.IsDaylightSavingTime : unit -&gt; bool" Usage="dateTime.IsDaylightSavingTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示此 <see cref="T:System.DateTime" /> 实例是否在当前时区的夏时制范围内。</summary>
        <returns>如果 <see langword="true" /> 属性的值为 <see cref="P:System.DateTime.Kind" /> 或 <see cref="F:System.DateTimeKind.Local" />，并且 <see cref="F:System.DateTimeKind.Unspecified" /> 的此实例的值在当前时区的夏时制范围内，则为 <see cref="T:System.DateTime" />；如果 <see langword="false" /> 为 <see cref="P:System.DateTime.Kind" />，则为 <see cref="F:System.DateTimeKind.Utc" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否当前<xref:System.DateTime>值处于夏时制范围内的本地时区，该值由返回<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>属性。 您可以确定时间区域是否支持检索的值来夏时制其<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A?displayProperty=nameWithType>属性。 对于观察夏令时的时区，可以确定从夏令时转换发生通过检索<xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType>时区的返回数组<xref:System.TimeZoneInfo.GetAdjustmentRules%2A?displayProperty=nameWithType>属性。  
  
 如果当前<xref:System.DateTime>值表示本地时区中的不明确或无效的时间，该方法返回`false`。  
  
 上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.IsDaylightSavingTime%2A>方法识别只是将当前的调整规则，确定当前实例是否为夏令时时。 因此，该方法可能无法准确报告的当前实例是否是夏令时时间段内当前的调整规则生效之前。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="IsLeapYear">
      <MemberSignature Language="C#" Value="public static bool IsLeapYear (int year);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLeapYear(int32 year) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsLeapYear(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLeapYear (year As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLeapYear(int year);" />
      <MemberSignature Language="F#" Value="static member IsLeapYear : int -&gt; bool" Usage="System.DateTime.IsLeapYear year" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">四位数年份。</param>
        <summary>返回指定的年份是否为闰年的指示。</summary>
        <returns>如果 <see langword="true" /> 是闰年，则为 <paramref name="year" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `year` 指定为 4 位基 10 数字;例如，1996。  
  
 `year` 始终解释为公历日历中每一年。 若要确定某个特定年度是否为闰年中一些其他日历，请调用日历对象的`IsLeapYear`方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.IsLeapYear%2A>方法，以确定 1994年和 2014年之间的年份是闰年。 该示例还说明了结果时<xref:System.DateTime.AddYears%2A>方法用于将一年添加到闰日。  
  
 [!code-csharp[System.DateTime.IsLeapYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/cs/IsLeapYear1.cs#1)]
 [!code-vb[System.DateTime.IsLeapYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/vb/IsLeapYear1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="year" /> 小于 1 或大于 9999。</exception>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public DateTimeKind Kind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeKind Kind" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Kind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Kind As DateTimeKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTimeKind Kind { DateTimeKind get(); };" />
      <MemberSignature Language="F#" Value="member this.Kind : DateTimeKind" Usage="System.DateTime.Kind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示由此实例表示的时间是基于本地时间、协调世界时 (UTC)，还是两者皆否。</summary>
        <value>用于指示当前时间表示的含义的枚举值之一。 默认值为 <see cref="F:System.DateTimeKind.Unspecified" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以显式设置<xref:System.DateTime.Kind%2A>属性的新<xref:System.DateTime>到特定的值<xref:System.DateTimeKind>值通过调用<xref:System.DateTime.SpecifyKind%2A>方法。  
  
 <xref:System.DateTime.Kind%2A>属性允许<xref:System.DateTime>值可以明确反映协调世界时 (UTC) 还是本地时间。 与此相反，<xref:System.DateTimeOffset>结构可以明确反映任何时区中的任何时间为单个点的时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性会影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MaxValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxValue : DateTime" Usage="System.DateTime.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.DateTime" /> 的最大可能值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值等效于 23:59:59.9999999(informatica UTC，12 月 31 日在公历日历中，00:00:00 UTC，10000 年 1 月 1 日之前的一个 100 毫微秒刻度线的 9999。  
  
 某些日历，如<xref:System.Globalization.ThaiBuddhistCalendar>，支持早于上部的日期范围<xref:System.DateTime.MaxValue>。 在这些情况下，尝试访问<xref:System.DateTime.MaxValue>变量赋值或格式设置和分析操作中可能会引发<xref:System.ArgumentOutOfRangeException>。 而不是检索的值<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，可以检索的值中指定的区域性的最新有效的日期值<xref:System.Globalization.Calendar.MaxSupportedDateTime?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.DateTime>对象表示通过其构造函数<xref:System.Int64>值，该值表示计时周期数。 调用构造函数之前, 示例可确保此值是大于或等于`DateTime.MinValue.Ticks`且小于或等于`DateTime.MaxValue.Ticks`。 如果不是，引发<xref:System.ArgumentOutOfRangeException>。  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.DateTime.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Millisecond">
      <MemberSignature Language="C#" Value="public int Millisecond { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Millisecond" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Millisecond" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Millisecond As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Millisecond { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Millisecond : int" Usage="System.DateTime.Millisecond" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的毫秒部分。</summary>
        <value>毫秒组成部分，表示为 0 和 999 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以显示的字符串表示形式<xref:System.DateTime.Millisecond%2A>通过使用"fff"格式说明符的属性。 例如，下面的代码显示在日期和时间在控制台中包含的毫秒数的字符串。  
  
 [!code-csharp[System.DateTime.Millisecond#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#1)]
 [!code-vb[System.DateTime.Millisecond#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#1)]  
  
 此外可以通过使用"o"标准格式说明符来显示与其他组件的日期和时间值的毫秒数部分。 例如:  
  
 [!code-csharp[System.DateTime.Millisecond#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#2)]
 [!code-vb[System.DateTime.Millisecond#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#2)]  
  
 但是，"o"格式说明符的设计用于显示比往返或存储不太<xref:System.DateTime>值。 此外可以使用自定义格式字符串，如以下示例所示显示毫秒以及其他日期和时间组件。  
  
 [!code-csharp[System.DateTime.Millisecond#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#3)]
 [!code-vb[System.DateTime.Millisecond#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#3)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Millisecond%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Minute">
      <MemberSignature Language="C#" Value="public int Minute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Minute" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Minute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minute As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Minute { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Minute : int" Usage="System.DateTime.Minute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的分钟部分。</summary>
        <value>分钟组成部分，表示为 0 和 59 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Minute%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MinValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MinValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinValue : DateTime" Usage="System.DateTime.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.DateTime" /> 的最小可能值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为等效于 00:00:00.0000000 UTC，1 月 1 日 0001，公历日历中。  
  
 <xref:System.DateTime.MinValue> 定义的日期和时间分配到未初始化<xref:System.DateTime>变量。 下面的示例阐释了这一点。  
  
 [!code-csharp[System.DateTime.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#1)]
 [!code-vb[System.DateTime.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#1)]  
  
 <xref:System.DateTime.MinValue>并<xref:System.DateTime.MaxValue>属性可用于确保将它传递到前一个值位于受支持的范围内<xref:System.DateTime>构造函数。 示例部分中的代码说明了这种用法。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.DateTime>对象表示通过其构造函数<xref:System.Int64>值，该值表示计时周期数。 调用构造函数之前, 示例可确保此值是大于或等于`DateTime.MinValue.Ticks`且小于或等于`DateTime.MaxValue.Ticks`。 如果不是，引发<xref:System.ArgumentOutOfRangeException>。  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Month">
      <MemberSignature Language="C#" Value="public int Month { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Month" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Month" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Month As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Month { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Month : int" Usage="System.DateTime.Month" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的月份部分。</summary>
        <value>月组成部分，表示为 1 和 12 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Month%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Now">
      <MemberSignature Language="C#" Value="public static DateTime Now { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Now" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Now" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Now As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Now { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Now : DateTime" Usage="System.DateTime.Now" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.DateTime" /> 对象，该对象设置为此计算机上的当前日期和时间，表示为本地时间。</summary>
        <value>其值为当前日期和时间的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Now%2A>属性返回<xref:System.DateTime>值，该值表示当前日期和本地计算机上的时间。 请注意，没有之间的差异<xref:System.DateTime>值，该值表示 0001 年 1 月 1 日午夜以来所经历的计时周期数和的字符串表示形式的<xref:System.DateTime>值，该值表示的日期和时间值中特定于特定于区域性的格式。 有关格式设置的日期和时间值的信息，请参阅<xref:System.DateTime.ToString%2A>方法。 下面的示例显示了大量特定于区域性的格式中的短日期和时间字符串。  
  
 [!code-cpp[System.DateTime.Now#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now1.cpp#2)]
 [!code-csharp[System.DateTime.Now#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now1.cs#2)]
 [!code-vb[System.DateTime.Now#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now1.vb#2)]  
  
 此属性的解决方法取决于系统计时器，具体取决于基础操作系统。 它通常必须介于 0.5 和 15 毫秒。 因此，重复调用<xref:System.DateTime.Now%2A>短时间间隔，例如一个循环中的属性可能返回相同的值。  
  
 <xref:System.DateTime.Now%2A>属性通常用于衡量性能。 但是，由于其低的分辨率，不适合用作基准测试工具。 更好的替代方法是使用<xref:System.Diagnostics.Stopwatch>类。  
  
 从.NET Framework 2.0 版开始，返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
> [!NOTE]
>  此外可以使用<xref:System.DateTimeOffset.Now%2A?displayProperty=nameWithType>属性来检索当前本地日期和时间。 它允许明确地表示为单个点的时间，这会使该时间值便携式计算机上本地时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Now%2A>和<xref:System.DateTime.UtcNow%2A>属性来检索当前本地日期和时间和当前通用协调 (UTC) 日期和时间。 它然后使用多个区域性的格式设置约定的值以及显示的字符串，其<xref:System.DateTime.Kind%2A>属性。  
  
 [!code-cpp[System.DateTime.Now#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now2.cpp#3)]
 [!code-csharp[System.DateTime.Now#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now2.cs#3)]
 [!code-vb[System.DateTime.Now#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.Now" />
        <altmember cref="P:System.DateTime.UtcNow" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static DateTime operator + (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Addition(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Addition(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator +(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( + ) : DateTime * TimeSpan -&gt; DateTime" Usage="d + t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">要添加的日期和时间值。</param>
        <param name="t">待添加的时间间隔。</param>
        <summary>将指定的时间间隔加到指定的日期和时间以生成新的日期和时间。</summary>
        <returns>一个对象，它是 <paramref name="d" /> 和 <paramref name="t" /> 值的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[此运算符的等效方法是 <xref:System.DateTime.Add%28System.TimeSpan%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示了加法运算符。  
  
 [!code-cpp[DateTime Operators#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#1)]
 [!code-csharp[DateTime Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#1)]
 [!code-vb[DateTime Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Equality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : DateTime * DateTime -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个对象。</param>
        <param name="d2">要比较的第二个对象。</param>
        <summary>确定 <see cref="T:System.DateTime" /> 的两个指定的实例是否相等。</summary>
        <returns>如果 <see langword="true" /> 和 <paramref name="d1" /> 表示同一日期和时间，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Equality%2A>运算符确定两个<xref:System.DateTime>值是否相等的通过比较其计时周期数。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示了相等运算符。  
  
 [!code-cpp[DateTime Operators#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#2)]
 [!code-csharp[DateTime Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#2)]
 [!code-vb[DateTime Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.DateTime" /> 是否晚于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>如果 <see langword="true" /> 晚于 <paramref name="t1" />，则为 <paramref name="t2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThan%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &gt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定一个指定的 <see cref="T:System.DateTime" /> 表示的日期和时间等于还是晚于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>如果 <see langword="true" /> 等于或晚于 <paramref name="t1" />，则为 <paramref name="t2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThanOrEqual%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Inequality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : DateTime * DateTime -&gt; bool" Usage="System.DateTime.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个对象。</param>
        <param name="d2">要比较的第二个对象。</param>
        <summary>确定 <see cref="T:System.DateTime" /> 的两个指定的实例是否不等。</summary>
        <returns>如果 <see langword="true" /> 和 <paramref name="d1" /> 不表示同一日期和时间，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Inequality%2A>运算符确定两个<xref:System.DateTime>值是否不相等通过比较其计时周期数。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt; t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.DateTime" /> 是否早于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>如果 <see langword="true" /> 早于 <paramref name="t1" />，则为 <paramref name="t2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThan%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(DateTime t1, DateTime t2);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : DateTime * DateTime -&gt; bool" Usage="t1 &lt;= t2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定一个指定的 <see cref="T:System.DateTime" /> 表示的日期和时间等于还是早于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>如果 <paramref name="t1" /> 等于或早于 <paramref name="t2" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThanOrEqual%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从指定的 <see cref="T:System.DateTime" /> 减去指定的 <see cref="T:System.DateTime" /> 或 <see cref="T:System.TimeSpan" />。</summary>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static TimeSpan operator - (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Subtraction(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As DateTime, d2 As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeSpan operator -(DateTime d1, DateTime d2);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * DateTime -&gt; TimeSpan" Usage="d1 - d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要从中减去的日期和时间值（被减数）。</param>
        <param name="d2">要减去的日期和时间值（减数）。</param>
        <summary>将指定的日期和时间与另一个指定的日期和时间相减，返回一个时间间隔。</summary>
        <returns><paramref name="d1" /> 和 <paramref name="d2" /> 之间的时间间隔；即 <paramref name="d1" /> 减去 <paramref name="d2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Subtraction%28System.DateTime%2CSystem.DateTime%29>方法不考虑的值<xref:System.DateTime.Kind%2A>这两个属性<xref:System.DateTime>值时执行该减法运算。 相减之前<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 否则，结果将包括在各时区之间的差异。  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.op_Subtraction%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>方法才会认为时区时执行该减法运算之间的差异。  
  
 此运算符的等效方法是 <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static DateTime operator - (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Subtraction(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator -(DateTime d, TimeSpan t);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTime * TimeSpan -&gt; DateTime" Usage="d - t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">要从其中减去的日期和时间值。</param>
        <param name="t">待减去的时间间隔。</param>
        <summary>从指定的日期和时间减去指定的时间间隔，返回新的日期和时间。</summary>
        <returns>一个对象，其值为 <paramref name="d" /> 的值减去 <paramref name="t" /> 的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中的计时周期值减去`t`中的计时周期值`d`。  
  
 此运算符的等效方法是 <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Subtract(System.TimeSpan)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.TimeSpan" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 本节内容：  
  
- [我调用哪个方法？](#Tasks)
- [要分析的字符串](#StringToParse)
- [分析和区域性约定](#Culture)
- [分析和样式元素](#Styles)
- [返回值和 DateTime.Kind](#kind)
 
<a name="Tasks"></a>   
### <a name="which-method-do-i-call"></a>我调用哪个方法？  
  
|功能|Call|  
|--------|----------|  
|通过使用当前区域性的约定来分析日期和时间字符串。|<xref:System.DateTime.Parse%28System.String%29> 重载|  
|通过使用特定区域性的约定来分析日期和时间字符串。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 重载 (请参阅[分析和区域性约定](#Culture))|  
|分析日期和时间字符串，使用特殊的样式元素 （如空格或无空格）。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> 重载|  
|分析日期和时间必须采用特定格式的字符串。|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> 或 <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>|
|分析日期和时间字符串并转换为 UTC 或本地时间。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> 重载|  
|分析日期和时间字符串，而无需处理的异常。|<xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> 方法|  
|还原 （往返） 创建的日期和时间值的格式设置操作。|"O"或"r"标准格式将字符串传递给<xref:System.DateTime.ToString%28System.String%29>方法，并调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载，并 <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>|  
|分析跨计算机 （和可能是区域性） 的边界的固定格式的日期和时间字符串。|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> 或<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法|  
  
<a name="StringToParse"></a>   
### <a name="the-string-to-parse"></a>要分析的字符串  
 <xref:System.DateTime.Parse%2A>方法尝试将转换到的日期和时间值的字符串表示形式及其<xref:System.DateTime>等效。 尝试将输入的字符串而不引发完全分析<xref:System.FormatException>异常。  
  
> [!IMPORTANT]
>  如果在分析操作将因无法识别的字符串格式，而失败<xref:System.DateTime.Parse%2A>方法会抛出<xref:System.FormatException>，而<xref:System.DateTime.TryParse%2A>方法将返回`false`。 因为异常处理可能很昂贵，所以应使用<xref:System.DateTime.Parse%2A>时应在分析操作成功，因为输入的源是受信任。 <xref:System.DateTime.TryParse%2A> 当分析故障有可能，特别是因为输入的源不受信任，或具有合理的默认值将替换为不成功分析字符串，则是更可取。   

 要分析字符串可以采用以下形式之一：  
  
-   使用日期和时间部分字符串。  
  
-   包含日期但没有时间部分的字符串。 如果不存在时组件，该方法假定午夜 12:00。 如果日期组件具有两位数年份，它将转换为基于年份<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>的当前区域性的当前日历或指定的区域性的当前日历 (如果使用非 null 使用重载`provider`参数)。  
  
- 具有包括仅月份和年份的日期组件，但没有日期号数部分的字符串。 该方法假定该月的第一天。

- 具有包括仅月和日的日期组件，但没有年份部分的字符串。 该方法假定当前年份。

-   具有一次，但不包含日期组成部分的字符串。 该方法假定当前日期，除非您调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载，并包含<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>中`styles`参数，在其中用例方法采用的 1 月 1 日的日期 0001。  

- 具有包含仅在一小时和 AM/PM 指示符，与不包含日期组成部分的时间组件的字符串。 该方法假定当前日期和时间为没有分钟并且没有秒数。 可以通过调用来更改此行为<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载，并包含<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>中`styles`参数，在其中用例方法采用的 1 月 1 日的日期 0001。

-   一个字符串，包含时区信息且符合 ISO 8601。 在以下示例中，第一个字符串指定协调世界时 (UTC) 和第二个指定的时间是 7 小时的时区中早于 UTC:  
  
    "2008-11-01T19:35:00.0000000Z"   
    "2008-11-01T19:35:00.0000000-07:00"  
  
-   一个字符串，包含格林威治标准时间指示符和符合 RFC 1123 时间格式;例如：  
  
     "周六，01 2008 年 11 月 19:35:00 GMT"  
  
-   一个字符串，包含日期和时间以及时区偏移量信息;例如：  
  
     "03/01/2009 05:42:00 -5:00"  

下面的示例通过使用这种情况下是 EN-US 区域性的当前区域性的格式设置约定分析中每个这些格式的字符串：

[!code-csharp[Default parsing](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse6.cs)]
[!code-vb[Default parsing](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse6.vb)]  
  
 如果输入的字符串表示闰日，在闰年中使用的分析方法在日历中 (请参阅[分析和区域性约定](#Culture))，则<xref:System.DateTime.Parse%2A>方法已成功分析字符串。 如果输入的字符串表示闰日中非-闰年，则该方法将引发<xref:System.FormatException>。  
  
 因为<xref:System.DateTime.Parse%2A>方法会尝试分析日期的字符串表示形式，并且通过使用当前或指定的区域性，尝试跨不同的区域性分析字符串的格式设置规则的时间可能会失败。 若要分析跨不同的区域设置特定日期和时间格式，请使用的重载之一<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法并提供格式说明符。  
  
<a name="Culture"></a>   
### <a name="parsing-and-cultural-conventions"></a>分析和区域性约定  
 所有重载<xref:System.DateTime.Parse%2A>方法是区分区域性的除非要分析的字符串 (这由`s`下表中) 是否符合 ISO 8601 模式。 在分析操作使用中的格式设置信息<xref:System.Globalization.DateTimeFormatInfo>对象，它派生的如下所示：  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

|如果调用|和`provider`是|格式设置信息派生自|  
|-----------------|-----------------------|--------------------------------------------|  
|<xref:System.DateTime.Parse%28System.String%29>|-|当前线程区域性 (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>属性)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|一个<xref:System.Globalization.DateTimeFormatInfo>对象|指定<xref:System.Globalization.DateTimeFormatInfo>对象|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|`null`|当前线程区域性 (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>属性)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|一个<xref:System.Globalization.CultureInfo>对象|<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> 属性|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|自定义<xref:System.IFormatProvider>实现|<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 方法|  
  
 当格式设置信息派生自<xref:System.Globalization.DateTimeFormatInfo>对象，<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>属性定义分析操作中使用的日历。  
  
 如果使用分析日期和时间字符串<xref:System.Globalization.DateTimeFormatInfo>对象的自定义不同的标准区域性的设置，请使用<xref:System.DateTime.ParseExact%2A>方法而不是<xref:System.DateTime.Parse%2A>方法来提高成功转换的可能性。 非标准日期和时间字符串可以是复杂且难以分析。 <xref:System.DateTime.Parse%2A>方法会尝试分析具有多个隐式分析模式，所有这些可能会失败的字符串。 与此相反，<xref:System.DateTime.ParseExact%2A>方法要求您显式指定一个或多个可能会成功的确切的分析模式。 有关详细信息，请参阅中的"DateTimeFormatInfo 和动态数据"部分<xref:System.Globalization.DateTimeFormatInfo>主题。  
  
> [!IMPORTANT]
>  请注意特定区域性的格式设置约定是动态的并且可以会有所变化。 这意味着，依赖于默认值 （当前） 区域性或格式设置约定的分析操作指定<xref:System.IFormatProvider>对象，表示固定区域性以外区域性意外可能会失败，如果发生以下任一情况：  
>   
> -   特定于区域性的数据或作为对.NET Framework 的现有版本的更新结果的.NET Framework 的主要或次要版本之间发生了更改。  
> -   特定于区域性的数据将反映用户首选项，可以通过改变计算机到计算机或会话到另一个会话。  
> -   特定于区域性的数据表示标准区域性或自定义区域性的设置将覆盖一个替换区域性。  
>   
>  若要防止在分析数据和时间字符串与区域性数据中的更改关联的问题，可以通过使用固定区域性分析日期和时间字符串，也可以调用<xref:System.DateTime.ParseExact%2A>或<xref:System.DateTime.TryParseExact%2A>方法并指定所需的格式要分析的字符串。 如果要序列化和反序列化日期和时间数据，你可以使用固定区域性的格式设置约定或可序列化和反序列化<xref:System.DateTime>以二进制格式的值。  
>   
>  有关详细信息，请参阅中的"动态区域性数据"部分<xref:System.Globalization.CultureInfo>主题和"保存日期时间值"部分中<xref:System.DateTime>主题。  
  
<a name="Styles"></a>   
### <a name="parsing-and-style-elements"></a>分析和样式元素  
 所有<xref:System.DateTime.Parse%2A>重载忽略输入字符串中的前导、 内部或尾随空白字符 (这由`s`下表中)。 日期和时间可以使用的前导空格和尾随数字符号字符 （"#"，U + 0023），对括起来并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 此外，<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载具有`styles`包含的一个或多个成员的参数<xref:System.Globalization.DateTimeStyles>枚举。 此参数定义如何`s`应解释和分析操作应如何转换`s`为日期和时间。 下表描述了每个效果<xref:System.Globalization.DateTimeStyles>上分析操作的成员。  
  
|DateTimeStyles 成员|在转换时的效果|  
|---------------------------|--------------------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC，按如下所示：<br /><br /> -如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>值设为UTC，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。<br />-如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。<br />-在所有其他情况下，该标志不起作用。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|忽略此值。 中的日期和时间元素始终允许使用内部的空白区域`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|忽略此值。 中的日期和时间元素始终允许前导空白字符`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|忽略此值。 中的日期和时间元素始终允许尾随空白`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部空格和尾随空格。 这是默认行为。 不能重写通过提供更具限制性<xref:System.Globalization.DateTimeStyles>枚举值，如<xref:System.Globalization.DateTimeStyles.None>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少假定任何时区信息，本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少假定任何时区信息，UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.None>|虽然有效，但将忽略此值。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止的日期和时间字符串转换<xref:System.DateTime>值，该值表示本地时间与它<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 通常情况下，通过调用创建此类字符串<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法和通过使用"o"、"r"或"u"标准格式说明符。|  

<a name="kind"></a>   
### <a name="the-return-value-and-datetimekind"></a>返回值和 DateTime.Kind

`DateTime.Parse`重载返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind>属性包含时区信息。 它可能表示的时间：

- 协调世界时 (<xref:System.DateTimeKind.Utc?displayProperty=fullName>)。
- 在本地时区内的时间 (<xref:System.DateTimeKind.Local?displayProperty=fullName>)。
- 未知时区中的时间 (xref:System.DateTimeKind.Unspecified?displayProperty=fullName >)。
 
 通常情况下，<xref:System.DateTime.Parse%2A>方法将返回<xref:System.DateTime>对象，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 但是，<xref:System.DateTime.Parse%2A>方法可能还执行时区转换和设置的值<xref:System.DateTime.Kind%2A>属性的值不同，决定`s`和`styles`参数：  
  
|如果|时区转换|类型属性|  
|--------|--------------------------|-------------------|  
|`s` 包含时区信息。|日期和时间转换为时间以本地时区。|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|`s` 包含时区信息，并`styles`包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志。|日期和时间转换为协调世界时 (UTC)。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`s` 包含 Z 或格林威治标准时间的时区指示符，并`styles`包括<xref:System.Globalization.DateTimeStyles.RoundtripKind>标志。|日期和时间被解释为 UTC。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
  
 下面的示例将为包含时间的本地时区的时区信息的日期字符串：  
  
 [!code-csharp[System.DateTime.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse2.cs#2)]
 [!code-vb[System.DateTime.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse2.vb#2)]  

  此外可以保留的日期和时间的值<xref:System.DateTime.Kind%2A>属性的格式设置和使用分析操作期间<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志。 下面的示例演示如何<xref:System.Globalization.DateTimeStyles.RoundtripKind>标志影响分析操作上<xref:System.DateTime>通过使用"o"、"r"或"u"格式说明符将转换为字符串的值。  
  
 [!code-csharp[System.DateTime.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse5.cs#5)]
 [!code-vb[System.DateTime.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse5.vb#5)]  
  
## Examples

调用的大量示例`DateTime.Parse`方法散布在整个[备注](#remarks)这篇文章的以及为各个文档中的部分`DateTime.Parse`重载。

[!INCLUDE[interactive-note](~/includes/csharp-interactive-with-utc-note.md)]

此外可以下载一组完整的`DateTime.Parse`中包含的示例[适用于 C#.NET Core 2.0 项目](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/DateTime.Parse.zip)和一个[适用于 Visual Basic.NET Core 2.0 项目](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/DateTime.Parse.zip)，从[dotnet /示例 GitHub 存储库](https://github.com/dotnet/samples)。

 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
        <altmember cref="Overload:System.DateTime.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; DateTime" Usage="System.DateTime.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <summary>使用当前线程区域性的约定将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
如果`s`包含时区信息，该方法返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，并将转换的日期和时间以`s`为本地时间。 否则为它不执行任何时区转换并返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。

此重载试图分析`s`使用当前区域性的格式设置约定。 当前的区域性将由<xref:System.Globalization.CultureInfo.CurrentCulture>属性。 若要分析使用特定区域性的格式设置约定的字符串，请调用<xref:System.DateTime.Parse(System.String,System.IFormatProvider)>或<xref:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)>重载。

此重载将尝试进行分析`s`通过使用<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType>样式。

## <a name="example"></a>示例

下面的示例分析由多个日期和时间值的字符串表示形式：

- 使用默认的格式提供程序，它提供用于生成此示例输出的计算机的当前线程区域性的格式设置约定。 此示例的输出反映了 EN-US 区域性的格式设置约定。

- 使用默认样式值，即<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWIthType>。 

它处理<xref:System.FormatException>方法尝试使用其他一些区域性分析日期和时间的字符串表示形式时引发的异常的格式设置约定。 它还演示如何为成功分析不使用当前线程区域性的格式设置约定的日期和时间值。  
  
 [!code-csharp[System.DateTime.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.DateTime.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse1.vb#1)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不包含日期和时间的有效字符串表示形式。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式信息。  请参阅[分析和区域性约定](#Culture)</param>
        <summary>使用指定的区域性特定格式设置信息，将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
如果`s`包含时区信息，该方法返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，并将转换的日期和时间以`s`为本地时间。 否则为它不执行任何时区转换并返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。

此重载将尝试进行分析`s`通过使用<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType>样式。

## <a name="example"></a>示例

下面的示例通过使用 EN-US、 FR-FR 和 DE-DE 区域性的约定来分析日期字符串的数组。 它演示了可跨不同的区域性以不同的方式解释的单一日期的字符串表示形式。  
  
[!code-csharp[System.DateTime.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse3.cs#3)]
[!code-vb[System.DateTime.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不包含日期和时间的有效字符串表示形式。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider = null, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional provider As IFormatProvider = null, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">包含要分析的字符串的内存范围。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式信息。  请参阅[分析和区域性约定](#Culture)</param>
        <param name="styles">枚举值的按位组合，用于指示 <paramref name="s" /> 成功执行分析操作所需的样式元素以及定义如何根据当前时区或当前日期解释已分析日期的样式元素。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的区域性特定格式设置信息和格式类型，将包含日期和时间的字符串表示形式的内存范围转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="provider" /> 和 <paramref name="styles" /> 指定。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不包含日期和时间的有效字符串表示形式。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider, styles As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.Parse (s, provider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。  请参阅[分析和区域性约定](#Culture)</param>
        <param name="styles">枚举值的按位组合，用于指示 <paramref name="s" /> 成功执行分析操作所需的样式元素以及定义如何根据当前时区或当前日期解释已分析日期的样式元素。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的区域性特定格式设置信息和格式类型，将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="provider" /> 和 <paramref name="styles" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此方法的重载将日期和时间转换`s`，并设置<xref:System.DateTime.Kind%2A>属性所返回的<xref:System.DateTime>值，如下所示：

|如果 |时区转换|类型属性|   
|-----|-----|-----|  
|`s` 不包含时区信息。|无。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|
|`s` 包含时区信息。|为在本地时区内时间|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|
|`s` 包含时区信息和样式包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志。|为协调世界时 (UTC)|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|
|`s` 包含 Z 或格林威治标准时间的时区指示符，并`styles`包括<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>。|无。|<xref:System.DateTimeKind.Utc>| 

## <a name="example"></a>示例

下面的示例演示<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法，并显示的值<xref:System.DateTime.Kind%2A>生成的属性<xref:System.DateTime>值。  
  
[!code-csharp[System.DateTime.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse4.cs#4)]
[!code-vb[System.DateTime.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不包含日期和时间的有效字符串表示形式。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-round-trip-date-and-time-values.md">如何：往返日期和时间值</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配，否则会引发异常。</summary>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <remarks>
          <format type="text/markdown"><![CDATA[  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">用于定义所需的 <paramref name="s" /> 格式的格式说明符。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式信息。</param>
        <summary>使用指定的格式和区域性特定格式信息，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="format" /> 和 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法分析的日期，必须在所定义的格式的字符串表示形式`format`参数。 它还需要\<日期 > 和\<时间 > 日期和时间的字符串表示形式中的元素出现在指定的顺序`format`，并且`s`不有任何空格，而不是允许使用的`format`. 如果`format`用于定义一个日期包含任何时间元素，并且分析操作成功，则生成<xref:System.DateTime>值具有时间为午夜 (00: 00:00)。 如果`format`定义的时间与任何日期元素，并且分析操作成功，则生成<xref:System.DateTime>值具有的日期`DateTime.Now.Date`。  
  
 如果`s`不的表示时间以特定时区和分析操作成功，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果`s`确实表示特定时区中的时间和`format`允许存在的时区信息 (例如，如果`format`等同于"o"、"r"或"u"标准格式说明符，或如果它包含"z"、"zz"或"zzz"自定义格式说明符）<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  

 `format`参数是一个包含单一的标准格式说明符或一个或多个自定义格式说明符用于定义所需的格式的字符串`s`。 有关有效的格式设置代码的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)或[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
> [!NOTE]
>  如果`format`是一种自定义格式模式，不包含日期或时间分隔符 （例如"yyyyMMddHHmm")，则使用固定区域性的`provider`参数和最宽的窗体的每个自定义格式说明符。 例如，如果你想要在格式模式中指定小时数，指定较宽的形式"HH"，而不是更窄的窗体"H"。  
  
 特定日期和时间的符号和字符串 （例如，在某个特定的语言中星期几的名称） 中使用`s`由定义`provider`参数，因为是精确的格式`s`如果`format`是一种标准格式说明符的字符串。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象及其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和格式设置`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ParseExact%2A>方法。  
  
 [!code-csharp[System.DateTime.ParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/ParseExact1.cs#1)]
 [!code-vb[System.DateTime.ParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/ParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 或 <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 或 <paramref name="format" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="s" /> 不包含与 <paramref name="format" /> 中指定的模式相对应的日期和时间。  
  
- 或 - 
<paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <block subset="none" type="usage"><para>在中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<see cref="Overload:System.DateTime.ParseExact" />方法会抛出<see cref="T:System.FormatException" />如果要分析的字符串包含的小时组件和 AM/PM 指示符不在协议中的。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="formats" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, format, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">用于定义所需的 <paramref name="s" /> 格式的格式说明符。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="style">枚举值的按位组合，提供有关以下内容的附加信息：<paramref name="s" />、可能出现在 <paramref name="s" /> 中的样式元素或从 <paramref name="s" /> 到 <see cref="T:System.DateTime" /> 值的转换。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的格式、区域性特定的格式信息和样式将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配，否则会引发异常。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="format" />、<paramref name="provider" /> 和 <paramref name="style" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的日期，必须在定义的格式的字符串表示形式`format`参数。 它还要求中的日期和时间元素`s`出现在指定的顺序`format`。 如果`s`不匹配的模式`format`参数，并具有定义的任何变体`style`参数，该方法将引发<xref:System.FormatException>。 与此相反，<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的字符串表示形式中任何一种可识别的格式提供程序的格式的日期<xref:System.Globalization.DateTimeFormatInfo>对象。 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法还允许中的日期和时间元素`s`以任何顺序出现。  
  
 如果`s`参数只包含时间和当前日期使用没有日期，除非`style`参数包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅日期没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部或尾随空格字符。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>并<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`包含时区信息，如有必要，转换为本地时间的时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志将协调世界时 (UTC) 转换为本地时间并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `format`参数定义的所需的模式`s`参数。 它可以包含从一个或多个自定义格式说明符[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或单个标准格式说明符，用于标识预定义的模式，从[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果在自定义格式模式中不使用日期或时间分隔符，使用固定区域性的`provider`参数和最宽的窗体的每个自定义格式说明符。 例如，如果你想要在该模式指定小时数，指定较宽的形式"HH"，而不是更窄的窗体"H"。  
  
> [!NOTE]
>  而不是要求`s`符合一种格式以便分析操作成功，您可以调用<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法并指定多个允许的格式。 这使得更有可能会成功分析操作。  
  
 `styles`参数包含一个或多个成员<xref:System.Globalization.DateTimeStyles>枚举，用于确定是否以及其中的空白区域未定义由`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每隶属<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC。 如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>为 UTC 值并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，该标志没有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的该空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空格`format`可以显示在开头`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空格`format`可以在的终端显示`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定的`s`可能包含前导、 内部空格和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少的任何时区信息，假定它是表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少的任何时区信息，则假定其值表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间的返回值的日期设置为不包含日期信息`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 中提供的以外的任何空格`format`允许。 如果`s`缺少所返回的日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息中存在`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值日期和时间与它<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标记主要阻止 UTC 时间的转换为本地时间。|  
  
 特定日期和时间的符号和字符串 （例如，在某个特定的语言中星期几的名称） 中使用`s`由定义`provider`参数，因为是精确的格式`s`如果`format`是一种标准格式说明符的字符串。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象及其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和格式设置`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29>方法。 请注意，字符串"2009 年 5 月 01 日上午 8:30"不能成功分析时`styles`参数等于<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>因为不允许前导空格`format`。 此外，字符串"2009 年 5 月 01 日 09:00"不能与成功分析`format`的"MM/dd/yyyyhh:mm"因为日期字符串前面不带前导零的月份数作为`format`要求。  
  
 [!code-csharp[System.DateTime.ParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact2.cs#2)]
 [!code-vb[System.DateTime.ParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 或 <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 或 <paramref name="format" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="s" /> 不包含与 <paramref name="format" /> 中指定的模式相对应的日期和时间。  
  
- 或 - 
<paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <block subset="none" type="usage"><para>在中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<see cref="Overload:System.DateTime.ParseExact" />方法会抛出<see cref="T:System.FormatException" />如果要分析的字符串包含的小时组件和 AM/PM 指示符不在协议中的。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTime" Usage="System.DateTime.ParseExact (s, formats, provider, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="formats"><paramref name="s" /> 的允许格式的数组。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式信息。</param>
        <param name="style">枚举值的一个按位组合，指示 <paramref name="s" /> 所允许的格式。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的格式数组、区域性特定格式信息和样式，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须至少与指定的格式之一完全匹配，否则会引发异常。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="formats" />、<paramref name="provider" /> 和 <paramref name="style" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的日期的任何一种分配到的模式匹配的字符串表示形式`formats`参数。 如果字符串`s`与任何定义的变体不匹配。 这些模式的任一`styles`参数，该方法将引发<xref:System.FormatException>。 除了比较`s`到多个格式设置模式，而非单个的格式设置模式，此重载的行为完全相同<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法。  
  
 `s`参数包含要分析的日期和时间。 如果`s`参数只包含时间和当前日期使用没有日期，除非`style`参数包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅日期没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部，或尾随空格字符比允许的格式字符串中的一个其他`formats`。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>并<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`包含时区信息，如有必要，转换为本地时间的时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志将协调世界时 (UTC) 转换为本地时间和设置无法<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `formats`参数包含数组的模式，其中之一`s`必须完全匹配分析操作成功。 中的模式`formats`参数从的一个或多个自定义格式说明符组成[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或单个标准格式说明符，用于从标识预定义的模式，[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果在自定义格式模式中不使用日期或时间分隔符，使用固定区域性的`provider`参数和最宽的窗体的每个自定义格式说明符。 例如，如果你想要在该模式指定小时数，指定较宽的形式"HH"，而不是更窄的窗体"H"。  
  
 `styles`参数包含一个或多个成员<xref:System.Globalization.DateTimeStyles>枚举，用于确定是否以及其中的空白区域未定义由`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每隶属<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC。 如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>为 UTC 值并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，该标志没有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的该空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空格`format`可以显示在开头`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空格`format`可以在的终端显示`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定的`s`可能包含前导、 内部空格和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少的任何时区信息，假定它是表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少的任何时区信息，则假定其值表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间的返回值的日期设置为不包含日期信息`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 中提供的以外的任何空格`format`允许。 如果`s`缺少所返回的日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息中存在`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为日期和时间与它<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标记主要阻止 UTC 时间的转换为本地时间。|  
  
 特定日期和时间的符号和字符串 （例如，在某个特定的语言中星期几的名称） 中使用`s`由定义`provider`参数，因为是精确的格式`s`如果`format`是一种标准格式说明符的字符串。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象及其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和格式设置`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，以确保可以成功地分析多种可能的格式字符串。  
  
 [!code-csharp[System.Datetime.ParseExact#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact3.cs#3)]
 [!code-vb[System.Datetime.ParseExact#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 或 <paramref name="formats" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 是一个空字符串。  
  
- 或 - 
<paramref name="formats" /> 的一个元素为空字符串。  
  
- 或 - 
 <paramref name="s" /> 不包含与 <paramref name="formats" /> 中任意元素相对应的日期和时间。  
  
- 或 - 
<paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <block subset="none" type="usage"><para>在中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<see cref="Overload:System.DateTime.ParseExact" />方法会抛出<see cref="T:System.FormatException" />如果要分析的字符串包含的小时组件和 AM/PM 指示符不在协议中的。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para></block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Second">
      <MemberSignature Language="C#" Value="public int Second { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Second" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Second" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Second As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Second { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Second : int" Usage="System.DateTime.Second" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的秒部分。</summary>
        <value>秒组成部分，表示为 0 和 59 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Second%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpecifyKind">
      <MemberSignature Language="C#" Value="public static DateTime SpecifyKind (DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime SpecifyKind(valuetype System.DateTime value, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SpecifyKind (value As DateTime, kind As DateTimeKind) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime SpecifyKind(DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="F#" Value="static member SpecifyKind : DateTime * DateTimeKind -&gt; DateTime" Usage="System.DateTime.SpecifyKind (value, kind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="kind" Type="System.DateTimeKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">日期和时间。</param>
        <param name="kind">枚举值之一，该值指示新对象是表示本地时间、UTC，还是两者皆否。</param>
        <summary>创建新的 <see cref="T:System.DateTime" /> 对象，该对象具有与指定的 <see cref="T:System.DateTime" /> 相同的刻度数，但是根据指定的 <see cref="T:System.DateTimeKind" /> 值的指示，指定为本地时间或协调世界时 (UTC)，或者两者皆否。</summary>
        <returns>一个新对象，它与由 <paramref name="value" /> 参数和由 <see cref="T:System.DateTimeKind" /> 参数指定的 <paramref name="kind" /> 值代表的对象具有相同刻度数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.DateTime>对象包含指示的时间值基于本地时间、 协调世界时 (UTC)，还是两者皆未，并以 100 毫微秒刻度为单位测量的计时周期字段包含时间值的类型字段。 <xref:System.DateTime.SpecifyKind%2A>方法创建一个新<xref:System.DateTime>对象使用指定`kind`参数和原始的时间值。  
  
> [!IMPORTANT]
>  返回<xref:System.DateTime>值不表示相同即时作为及时`value`参数，和<xref:System.DateTime.SpecifyKind%2A>不是一个时区转换方法。 相反，则会使指定的时间`value`参数保持不变，并设置<xref:System.DateTime.Kind%2A>属性设置为`kind`。 有关时区转换的信息，请参阅[转换时区时间](~/docs/standard/datetime/converting-between-time-zones.md)。  
  
 <xref:System.DateTime.SpecifyKind%2A>方法可在其中接收的互操作性方案中<xref:System.DateTime>对象未指定的类型字段中，但你可以确定由独立于表示计时周期字段表示本地时间还是基于 UTC。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性会影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">.NET Framework 应用程序中的 COM 互操作性 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此实例中减去指定的时间或持续时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public TimeSpan Subtract (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan Subtract(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan Subtract(DateTime value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : DateTime -&gt; TimeSpan" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">要减去的日期和时间值。</param>
        <summary>从此实例中减去指定的日期和时间。</summary>
        <returns>一个时间间隔，它等于此实例所表示的日期和时间减去 <paramref name="value" /> 所表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.DateTime%29>方法确定两个日期之间的差异。 若要减去的时间间隔从当前实例，调用<xref:System.DateTime.Subtract%28System.TimeSpan%29>方法。 要减去的当前实例中的一个特定的时间间隔，调用将这段时间间隔添加到当前日期，该方法并提供的方法参数为负值。 例如，若要从当前日期的两个月中减去，请调用<xref:System.DateTime.AddMonths%28System.Int32%29>值为-2 的方法。  
  
 日期和时间的当前实例是早于`value`，该方法将返回<xref:System.TimeSpan>表示负时间跨度的对象。 所有非零值属性的值 (如<xref:System.TimeSpan.Days%2A>或<xref:System.TimeSpan.Ticks%2A>) 为负。  
  
 <xref:System.DateTime.Subtract%28System.DateTime%29>方法不考虑的值<xref:System.DateTime.Kind%2A>这两个属性<xref:System.DateTime>值时执行该减法运算。 相减之前<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 否则，结果将包括在各时区之间的差异。  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29?displayProperty=nameWithType>方法才会认为时区时执行该减法运算之间的差异。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">结果小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public DateTime Subtract (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Subtract(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Subtract(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : TimeSpan -&gt; DateTime" Usage="dateTime.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">待减去的时间间隔。</param>
        <summary>从此实例中减去指定持续时间。</summary>
        <returns>一个对象，它等于此实例所表示的日期和时间减去 <paramref name="value" /> 所表示的时间间隔。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29>方法返回从当前实例指定的时间间隔差值的日期。 若要确定两个日期之间的时间间隔，请调用<xref:System.DateTime.Subtract%28System.DateTime%29>方法。 要减去的当前实例中的一个特定的时间间隔，调用将这段时间间隔添加到当前日期，该方法并提供的方法参数为负值。 例如，若要从当前日期的两个月中减去，请调用<xref:System.DateTime.AddMonths%28System.Int32%29>值为-2 的方法。  
  
 此方法不会更改此设置的值<xref:System.DateTime>。 相反，它会返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 通常，<xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法中减去<xref:System.TimeSpan>对象，表示正时间跨度并返回<xref:System.DateTime>早于的日期和时间的当前实例的值。 但是，如果<xref:System.TimeSpan>对象表示负时间跨度，<xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法将返回<xref:System.DateTime>晚的日期和时间的当前实例的值。  
  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法允许您以减去相应的包含的时间 （指定的小时数） 和指定的分钟数等的多个单位的时间间隔。 要从中减去的时间 （例如年、 月或天） 的单个单元<xref:System.DateTime>实例，您可以负的数值作为参数传递到任何以下方法：  
  
-   <xref:System.DateTime.AddYears%2A>以减去相应的特定于当前日期和时间实例的年数。  
  
-   <xref:System.DateTime.AddMonths%2A>以减去相应的特定于当前日期和时间实例的月份数。  
  
-   <xref:System.DateTime.AddDays%2A>要减去从当前日期和时间实例在特定天数。  
  
-   <xref:System.DateTime.AddHours%2A>以减去相应的特定于当前日期和时间实例的小时数。  
  
-   <xref:System.DateTime.AddMinutes%2A>以减去相应的特定于当前日期和时间实例的分钟数。  
  
-   <xref:System.DateTime.AddSeconds%2A>以减去相应的特定的从当前日期和时间实例的秒数。  
  
-   <xref:System.DateTime.AddMilliseconds%2A>以减去相应的特定于当前日期和时间实例的毫秒数。  
  
-   <xref:System.DateTime.AddTicks%2A>以减去相应的特定自当前日期和时间实例以时钟周期数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">结果小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.TimeSpan" />
        <related type="Article" href="~/docs/standard/datetime/performing-arithmetic-operations.md">使用日期和时间执行算术运算</related>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>返回当前 <see cref="T:System.DateTime" /> 对象。</summary>
        <returns>当前对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">所需类型。</param>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象转换为指定类型的对象。</summary>
        <returns>由 <paramref name="type" /> 参数指定的类型的对象，其值与当前 <see cref="T:System.DateTime" /> 对象等效。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException"><see cref="T:System.DateTime" /> 类型不支持此转换。</exception>
        <altmember cref="T:System.Convert" />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">要填充数据的对象。</param>
        <param name="context">此序列化的目标。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>使用序列化当前的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象所需的所有数据填充 <see cref="T:System.DateTime" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充`info`参数与<xref:System.DateTime.Ticks%2A>和<xref:System.DateTime.Kind%2A>属性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="Ticks">
      <MemberSignature Language="C#" Value="public long Ticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Ticks" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Ticks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ticks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Ticks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Ticks : int64" Usage="System.DateTime.Ticks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示此实例的日期和时间的计时周期数。</summary>
        <value>表示此实例的日期和时间的计时周期数。 该值介于 <see langword="DateTime.MinValue.Ticks" /> 和 <see langword="DateTime.MaxValue.Ticks" /> 之间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个计时周期表示一百纳秒，即一千万分之一秒。 1 毫秒内有 10,000 个计时周期，即 1 秒内有 1,000 万个计时周期。  
  
 此属性的值表示 0001 年 1 月 1 日午夜 12:00:00 以来所经历的 100 纳秒间隔数 (0: 00:00 年 1 月 1 日 UTC 0001，公历日历中的)，表示<xref:System.DateTime.MinValue?displayProperty=nameWithType>。 它不包括归因于闰秒为单位的计时周期数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Ticks%2A>属性，以显示第 21 个世纪以来所经历的计时周期数，并实例化<xref:System.TimeSpan>对象。 <xref:System.TimeSpan>对象用来显示使用多个其他时间间隔的时间。  
  
 [!code-csharp[System.DateTime.Ticks#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Ticks/cs/Ticks.cs#1)]
 [!code-vb[System.DateTime.Ticks#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Ticks/vb/Ticks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeOfDay">
      <MemberSignature Language="C#" Value="public TimeSpan TimeOfDay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeOfDay" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.TimeOfDay" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfDay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeOfDay { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeOfDay : TimeSpan" Usage="System.DateTime.TimeOfDay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的当天的时间。</summary>
        <value>一个时间间隔，它表示当天自午夜以来已经过时间的部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.DateTime.Date%2A>属性。 它将返回<xref:System.DateTime>值，该值表示不带其时间部分，日期<xref:System.DateTime.TimeOfDay%2A>属性将返回<xref:System.TimeSpan>值，该值表示<xref:System.DateTime>值的时间部分。  
  
 如果你想要显示的时间或检索的一天的时间的字符串表示形式<xref:System.DateTime>值，可以改为调用的重载<xref:System.DateTime.ToString%2A>方法具有`format`参数或使用[复合格式设置](~/docs/standard/base-types/composite-formatting.md)功能与"t"或"T"标准格式字符串。  
  
   
  
## Examples  
 下面的示例显示的值<xref:System.DateTime.TimeOfDay%2A>属性的数组<xref:System.DateTime>值。 它还对照了与返回复合格式设置操作中的"t"标准格式字符串的字符串的返回值。  
  
 [!code-csharp[System.DateTime.TimeOfDay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.timeofday/cs/timeofday1.cs#1)]
 [!code-vb[System.DateTime.TimeOfDay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.timeofday/vb/timeofday1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="ToBinary">
      <MemberSignature Language="C#" Value="public long ToBinary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToBinary() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToBinary" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBinary () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToBinary();" />
      <MemberSignature Language="F#" Value="member this.ToBinary : unit -&gt; int64" Usage="dateTime.ToBinary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象序列化为一个 64 位二进制值，该值随后可用于重新创建 <see cref="T:System.DateTime" /> 对象。</summary>
        <returns>64 位有符号整数，它对 <see cref="P:System.DateTime.Kind" /> 和 <see cref="P:System.DateTime.Ticks" /> 属性进行了编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.DateTime.ToBinary%2A>方法将当前值转换<xref:System.DateTime>为二进制值的对象。 随后，使用二进制值和<xref:System.DateTime.FromBinary%2A>方法来重新创建原始<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  在某些情况下，<xref:System.DateTime>返回值<xref:System.DateTime.FromBinary%2A>方法不是与原始<xref:System.DateTime>值提供给<xref:System.DateTime.ToBinary%2A>方法。 有关详细信息，请参阅下一部分中，"本地时间调整"。  
  
## <a name="local-time-adjustment"></a>本地时间调整  
 表示本地时间，即协调通用时间调整为本地时区<xref:System.DateTime>结构，其<xref:System.DateTime.Kind%2A>属性具有值<xref:System.DateTimeKind.Local>。 还原本地时<xref:System.DateTime>值由生成的二进制表示形式<xref:System.DateTime.ToBinary%2A>方法，<xref:System.DateTime.FromBinary%2A>方法可能会调整重新创建的值，以使是否不等于原始值。 在下列条件下，可能会出现这种情况：  
  
-   如果本地<xref:System.DateTime>由一个时区中序列化对象<xref:System.DateTime.ToBinary%2A>方法，然后反序列化中通过不同的时区<xref:System.DateTime.FromBinary%2A>方法中，表示所生成的本地时间<xref:System.DateTime>自动调整对象为第二个时区。  
  
     例如，考虑<xref:System.DateTime>对象，表示本地时间的下午 3 点 在美国执行应用程序使用太平洋时区<xref:System.DateTime.ToBinary%2A>方法以将其转换<xref:System.DateTime>为二进制值的对象。 在美国执行的另一个应用程序使用东部标准时间时区<xref:System.DateTime.FromBinary%2A>方法将转换为一个新的二进制值<xref:System.DateTime>对象。 新值<xref:System.DateTime>对象是下午 6 时，这表示时间作为原始的下午 3 点到相同的点 值，但将会调整为美国东部时区中的本地时间。  
  
-   如果本地的二进制表示形式<xref:System.DateTime>值表示本地时区的系统中的无效时间<xref:System.DateTime.FromBinary%2A>是调用，该时间会调整，这样就有效。  
  
     例如，从标准时间到夏时制的转换发生在美国在 2010 年 3 月 14 日凌晨 2:00，此时时间前进一小时，上午 3 点到太平洋时区 此小时间隔为无效的时间，即，不存在该时区的时间间隔。 下面的示例演示时的时间内此范围转换为二进制值通过<xref:System.DateTime.ToBinary%2A>方法，然后通过还原<xref:System.DateTime.FromBinary%2A>方法中，原始值调整为有效的时间。 您可以确定是否特定日期和时间值也可能受到修改将其传递到<xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType>方法，该示例作为演示。  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>版本的注意事项  
 从.NET Framework 2.0 版中，开始<xref:System.DateTime>结构组成的私有类型字段，指示指定的时间值基于本地时间、 协调世界时 (UTC)，还是两者皆未和一个专用的计时周期字段，其中包含指定的日期和时间的 100 纳秒为刻度数。 计时周期数字段可以访问与<xref:System.DateTime.Ticks%2A>属性和类型字段都可以访问与<xref:System.DateTime.Kind%2A>属性。  
  
 在.NET Framework 2.0 中，如果您序列化之前<xref:System.DateTime>对象而使用序列化接口，如不是手动<xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>，只需序列化中的计时周期数据<xref:System.DateTime>结构。 从 2.0 版开始，必须还序列化类型的数据。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.FromBinary(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="Today">
      <MemberSignature Language="C#" Value="public static DateTime Today { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Today" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Today" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Today As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Today { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Today : DateTime" Usage="System.DateTime.Today" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前日期。</summary>
        <value>一个对象，设置为当天日期，其时间组成部分设置为 00:00:00。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从.NET Framework 2.0 版开始，返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Local>。  
  
 它将返回当前日期不包括当前时间，因为<xref:System.DateTime.Today%2A>属性是适用于仅使用日期的应用程序中使用。 有关详细信息，请参阅[选择之间 DateTime、 DateTimeOffset、 TimeSpan 和 TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md)。 与此相反，<xref:System.DateTime.TimeOfDay%2A>属性返回当前日期未的当前时间和<xref:System.DateTime.Now%2A>属性返回当前日期和当前时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Date%2A>属性来检索当前日期。 它还阐释了如何<xref:System.DateTime>可使用一些标准日期和时间格式字符串的格式设置值。 请注意通过第三个调用生成的输出<xref:System.DateTime.ToString%28System.String%29>方法使用 g 格式说明符来包含时间部分，为零。  
  
 [!code-csharp[System.DateTime.Today#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Today/cs/Today1.cs#1)]
 [!code-vb[System.DateTime.Today#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Today/vb/Today1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Now" />
        <altmember cref="P:System.DateTime.TimeOfDay" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTime">
      <MemberSignature Language="C#" Value="public long ToFileTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTime () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTime();" />
      <MemberSignature Language="F#" Value="member this.ToFileTime : unit -&gt; int64" Usage="dateTime.ToFileTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为 Windows 文件时间。</summary>
        <returns>表示为 Windows 文件时间的当前 <see cref="T:System.DateTime" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，它表示午夜 12:00，公元 1601 年 1 月 1 日起经过的 100 纳秒间隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间记录时应用程序创建、 访问，或写入文件。  
  
 <xref:System.DateTime.ToFileTime%2A>方法使用<xref:System.DateTime.Kind%2A>属性来确定是否当前<xref:System.DateTime>对象是本地时间、 UTC 时间或未指定的类型的时间被视为本地时间。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToFileTime%2A>方法。  
  
 [!code-cpp[DateTime.ToFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">所生成的文件时间将表示公元 1601 年 1 月 1 日午夜 12:00 之前的日期和时间。 UTC。</exception>
        <block subset="none" type="usage"><para>通常，<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法还原<see cref="T:System.DateTime" />保存的值<see cref="M:System.DateTime.ToFileTime" />方法。 但是，可能在以下情况下不同的两个值： 
-如果序列化和反序列化<see cref="T:System.DateTime" />值出现在不同时区中。 例如，如果<see cref="T:System.DateTime" />值时间为中午 12:30 在美国东部标准时间时区被序列化，并在美国然后反序列化太平洋时区，中午 12:30 的原始值 调整为上午 9:30 以反映两个时区之间的差异。  
  
-如果<see cref="T:System.DateTime" />序列化的值表示本地时区中的无效时间。 在这种情况下，<see cref="M:System.DateTime.ToFileTime" />方法调整还原<see cref="T:System.DateTime" />值，使其在本地时区表示有效的时间。  
  
例如，从标准时间到夏时制的转换发生在美国在 2010 年 3 月 14 日凌晨 2:00，此时时间前进一小时，上午 3 点到太平洋时区 此小时间隔为无效的时间，即，不存在该时区的时间间隔。 下面的示例演示时的时间内此范围转换为长整型值通过<see cref="M:System.DateTime.ToFileTime" />方法，然后通过还原<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法中，原始值调整为有效的时间。 您可以确定是否特定日期和时间值也可能受到修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，该示例作为演示。  
  
[!code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)] [!code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToFileTimeUtc" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTimeUtc">
      <MemberSignature Language="C#" Value="public long ToFileTimeUtc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTimeUtc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTimeUtc" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTimeUtc () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTimeUtc();" />
      <MemberSignature Language="F#" Value="member this.ToFileTimeUtc : unit -&gt; int64" Usage="dateTime.ToFileTimeUtc " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为 Windows 文件时间。</summary>
        <returns>表示为 Windows 文件时间的当前 <see cref="T:System.DateTime" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，它表示午夜 12:00，公元 1601 年 1 月 1 日起经过的 100 纳秒间隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间记录时应用程序创建、 访问，或写入文件。  
  
 <xref:System.DateTime.ToFileTimeUtc%2A>方法使用<xref:System.DateTime.Kind%2A>属性来确定是否当前<xref:System.DateTime>对象是本地时间、 UTC 时间或未指定的类型的时间被视为 UTC 时间。 如果是本地时间，它将时间转换为 UTC 之前执行到 Windows 文件时间转换。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">所生成的文件时间将表示公元 1601 年 1 月 1 日午夜 12:00 之前的日期和时间。 UTC。</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToFileTimeUtc" />方法有时会使用以将本地时间转换为 UTC，并随后通过调用恢复<see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" />方法后跟<see cref="M:System.DateTime.ToLocalTime" />方法。 但是，如果原始时间表示本地时区的时间无效，则两个本地时间值不会相等。 有关其他信息，请参阅<see cref="M:System.DateTime.ToLocalTime" />方法。</para></block>
        <altmember cref="M:System.DateTime.ToFileTime" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToLocalTime">
      <MemberSignature Language="C#" Value="public DateTime ToLocalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToLocalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLocalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLocalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToLocalTime();" />
      <MemberSignature Language="F#" Value="member this.ToLocalTime : unit -&gt; DateTime" Usage="dateTime.ToLocalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为本地时间。</summary>
        <returns>一个对象，其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Local" />，并且其值为等效于当前 <see cref="T:System.DateTime" /> 对象的值的本地时间；如果经转换的值过大以至于不能由 <see cref="F:System.DateTime.MaxValue" /> 对象表示，则为 <see cref="T:System.DateTime" />，或者，如果经转换的值过小以至于不能表示为 <see cref="F:System.DateTime.MinValue" /> 对象，则为 <see cref="T:System.DateTime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地时间等于的协调世界时 (UTC) 时间加上 UTC 偏移量。 有关的 UTC 偏移量的详细信息，请参阅<xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>。 转换还会考虑适用于由当前时间的夏时制规则<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.ToLocalTime%2A>方法从 UTC 转换为本地时间时识别只是将当前的调整规则。 因此，当前的调整规则生效之前的转换可能不准确反映 UTC 与当地时间之间的差异。  
  
 从.NET Framework 版本 2.0 中，返回的值开始<xref:System.DateTime.ToLocalTime%2A>方法通过确定<xref:System.DateTime.Kind%2A>属性与当前<xref:System.DateTime>对象。 下表描述了可能的结果。  
  
|类型|结果|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|此实例<xref:System.DateTime>转换为本地时间。|  
|<xref:System.DateTimeKind.Local>|不执行任何转换。|  
|<xref:System.DateTimeKind.Unspecified>|此实例的<xref:System.DateTime>被假定为 UTC 时间，并执行转换像<xref:System.DateTime.Kind%2A>了<xref:System.DateTimeKind.Utc>。|  
  
> [!NOTE]
>  <xref:System.DateTime.ToLocalTime%2A>方法将<xref:System.DateTime>为本地时间与 utc 之间的值。 若要将任何指定时区的时间转换为本地时间，使用<xref:System.TimeZoneInfo.ConvertTime%2A?displayProperty=nameWithType>方法。  
  
 由转换返回的值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性始终返回<xref:System.DateTimeKind.Local>。 返回有效结果，因此，即使<xref:System.DateTime.ToLocalTime%2A>重复应用于相同<xref:System.DateTime>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToLocalTime%2A>方法。 请注意，确切的输出取决于当前区域性和其运行的系统的本地时区。  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性会影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>可以使用<see cref="M:System.DateTime.ToLocalTime" />方法来还原本地日期和时间值转换为 UTC<see cref="M:System.DateTime.ToUniversalTime" />或<see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" />方法。 但是，如果原始时间表示本地时区的时间无效，它将不匹配的已还原的值。 当<see cref="M:System.DateTime.ToLocalTime" />方法将时间从 UTC 转换为本地时区，它也会使其成为有效的时间调整本地时区。  
  
例如，从标准时间到夏时制的转换发生在美国在 2010 年 3 月 14 日凌晨 2:00，此时时间前进一小时，上午 3 点到太平洋时区 此小时间隔为无效的时间，即，不存在该时区的时间间隔。 下面的示例演示时的时间内此范围转换为 UTC<see cref="M:System.DateTime.ToUniversalTime" />方法，然后通过还原<see cref="M:System.DateTime.ToLocalTime" />方法中，原始值调整为有效的时间。 您可以确定是否特定日期和时间值也可能受到修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，该示例作为演示。  
  
[!code-csharp[System.DateTime.ToLocalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolocaltime/cs/tolocaltime1.cs#1)] [!code-vb[System.DateTime.ToLocalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolocaltime/vb/tolocaltime1.vb#1)]</para></block>
        <altmember cref="T:System.TimeZone" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.TimeZone.GetDaylightChanges(System.Int32)" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
      </Docs>
    </Member>
    <Member MemberName="ToLongDateString">
      <MemberSignature Language="C#" Value="public string ToLongDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongDateString();" />
      <MemberSignature Language="F#" Value="member this.ToLongDateString : unit -&gt; string" Usage="dateTime.ToLongDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的长日期字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的长日期字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象的格式使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongDatePattern%2A>与当前线程区域性关联的属性。 返回值是通过指定"D"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!NOTE]
>  返回的字符串<xref:System.DateTime.ToLongDateString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongDatePattern?displayProperty=nameWithType>属性。 例如，对于 EN-US 区域性，标准的长日期模式通常是"dddd，MMMM dd，yyyy";对于 DE-DE 区域性中，它是"dddd，d。 MMMM yyyy";对于 JA-JP 区域性，它是"yyyy '年 AM 月日必须"。 请注意，其值可以有所不同的.NET 实现和它的版本、 操作系统和其版本和用户自定义。

[!INCLUDE[culture-sensitive formatting](~/includes/thread-formatting.md)]
  
## Examples

下面的示例演示<xref:System.DateTime.ToLongDateString%2A>方法。  
  
[!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
[!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToLongTimeString">
      <MemberSignature Language="C#" Value="public string ToLongTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToLongTimeString : unit -&gt; string" Usage="dateTime.ToLongTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的长时间字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的长时间字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

当前值<xref:System.DateTime>对象的格式使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"T"返回的值相同[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!NOTE]
>  返回的字符串<xref:System.DateTime.ToLongTimeString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A?displayProperty=nameWithType>属性。 例如，对于 EN-US 区域性，标准很长时间模式为"h:mm: ss tt";对于 DE-DE 区域性中，它是"hh: mm:";对于 JA-JP 区域性，它是"h:mm: ss"。 请注意，其值可以有所不同的.NET 实现和它的版本、 操作系统和其版本和用户自定义。

[!INCLUDE[culture-sensitive-formatting](~/includes/thread-formatting.md)]
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToLongTimeString%2A>方法。  
  
 [!code-csharp[System.DateTime.ToLongTimeString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolongtimestring/cs/sls.cs#1)]
 [!code-vb[System.DateTime.ToLongTimeString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolongtimestring/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToOADate">
      <MemberSignature Language="C#" Value="public double ToOADate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 ToOADate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToOADate" />
      <MemberSignature Language="VB.NET" Value="Public Function ToOADate () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double ToOADate();" />
      <MemberSignature Language="F#" Value="member this.ToOADate : unit -&gt; double" Usage="dateTime.ToOADate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为等效的 OLE 自动化日期。</summary>
        <returns>一个双精度浮点数，它包含与此实例的值等效的 OLE 自动化日期。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个浮点数，其不可或缺的组件是之前或之后 30 1899 年 12 月，日午夜天数，其小数部分表示除以 24 该天的时间作为实现的 OLE 自动化日期。 例如，午夜 1899 年 12 月 31 日由表示 1.0;上午 6 时，由 2.25; 表示 1900 年 1 月 1午夜 1899 年 12 月 29 为由-1.0;和上午 6 到 1899 年 12 月 29-1.25 由表示。  
  
 基础 OLE 自动化日期是 1899 年 12 月 30 日午夜。 最小的 OLE 自动化日期是 1 年 1 月 0100年午夜。 最大的 OLE 自动化日期等同于<xref:System.DateTime.MaxValue?displayProperty=nameWithType>、 31 年 12 月的那一刻 9999。  
  
 <xref:System.DateTime.ToOADate%2A>方法会抛出<xref:System.OverflowException>如果当前实例表示的日期晚于<xref:System.DateTime.MaxValue>和早于 0100 January1，午夜。 但是，如果当前实例的值为<xref:System.DateTime.MinValue>，该方法返回 0。  
  
 有关 OLE 自动化的详细信息，请参阅[MSDN 库](https://go.microsoft.com/fwlink/?linkid=37118)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">此实例的值无法表示为 OLE 自动化日期。</exception>
        <altmember cref="T:System.Double" />
        <altmember cref="M:System.DateTime.FromOADate(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ToShortDateString">
      <MemberSignature Language="C#" Value="public string ToShortDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortDateString();" />
      <MemberSignature Language="F#" Value="member this.ToShortDateString : unit -&gt; string" Usage="dateTime.ToShortDateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的短日期字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的短日期字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象的格式使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"d"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!NOTE]
>  返回的字符串<xref:System.DateTime.ToShortDateString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern?displayProperty=nameWithType>属性。 例如，对于 EN-US 区域性，标准的短日期模式是"年-月-日";对于 DE-DE 区域性中，它是"dd。MM.yyyy";对于 JA-JP 区域性，它是"yyyy/MM/dd"。 请注意，其值可以有所不同的.NET 实现和它的版本、 操作系统和其版本和用户自定义。

[!INCLUDE[culture-sensitive formatting](~/includes/thread-formatting.md)]

## Examples  
 下面的示例演示<xref:System.DateTime.ToShortDateString%2A>方法。 它还表明，调用的结果<xref:System.DateTime.ToShortDateString%2A>方法等同于调用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>使用"d"作为 format 参数的方法。  
  
 [!code-csharp[System.DateTime.ToShortDateString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/cs/ToShortDateString.cs#1)]
 [!code-vb[System.DateTime.ToShortDateString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/vb/ToShortDateString.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToShortTimeString">
      <MemberSignature Language="C#" Value="public string ToShortTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortTimeString();" />
      <MemberSignature Language="F#" Value="member this.ToShortTimeString : unit -&gt; string" Usage="dateTime.ToShortTimeString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的短时间字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的短时间字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

当前值<xref:System.DateTime>对象的格式使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortTimePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"t"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!NOTE]
>  返回的字符串<xref:System.DateTime.ToShortTimeString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortTimePattern?displayProperty=nameWithType>属性。 例如，对于 EN-US 区域性，标准短时间模式为"h:mm tt";对于 DE-DE 区域性中，它是"hh: mm";对于 JA-JP 区域性，它是"H:mm"。 请注意，其值可以有所不同的.NET 实现和它的版本、 操作系统和其版本和用户自定义。 

[!INCLUDE[culture-sensitive formatting](~/includes/thread-formatting.md)]

## Examples  
 下面的示例演示<xref:System.DateTime.ToShortTimeString%2A>方法。  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dateTime.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用当前的区域性格式约定将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.DateTime" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象的格式使用常规日期和时间格式说明符 (G)。 若要设置使用特定的日期和时间格式说明符的格式，请调用<xref:System.DateTime.ToString%28System.String%29>方法。 若要设置其特定区域性使用的常规日期和时间格式说明符 (G) 格式，请调用<xref:System.DateTime.ToString%28System.IFormatProvider%29>方法。 若要使用特定的日期和时间格式说明符和特定区域性的约定对其设置的格式，请调用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29>方法。  
  
 此方法使用派生自当前区域性的格式设置信息。 具体而言，它结合了返回的自定义格式字符串<xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A>并<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A>的属性<xref:System.Globalization.DateTimeFormatInfo>返回的对象`Thread.CurrentThread.CurrentCulture.DateTimeFormat`属性。 有关更多信息，请参见<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。 另一个重载<xref:System.DateTime.ToString%2A>方法使您能够指定的区域性的格式设置的使用并定义输出模式的<xref:System.DateTime>值。  
  
   
  
## Examples  
 下面的示例演示如何的字符串表示形式<xref:System.DateTime>返回值<xref:System.DateTime.ToString>方法取决于当前区域性。 它为 FR-FR 为 JA-JP 从 EN-US 更改当前线程区域性。 在每种情况下调用<xref:System.DateTime.ToString>方法以返回使用该区域性的日期和时间值的字符串表示形式。  
  
 [!code-csharp[System.DateTime.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.DateTime.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此日期和时间超出了当前区域性所用日历支持的日期范围。</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString" />方法返回的日期和时间的字符串表示形式中使用当前区域性的日历。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或更高版本比<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置的范围之外的日期格式<see cref="T:System.Globalization.HijriCalendar" />类时的当前区域性为阿拉伯语 （叙利亚）。  
  
[!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception2.cs#2)] [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception2.vb#2)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="dateTime.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式信息将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 指定的当前 <paramref name="provider" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象的格式使用常规日期和时间格式说明符 (G) 格式使用短日期模式和长时间模式的输出。  
  
 短日期和长时间模式的格式由定义`provider`参数。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示在返回的字符串中反映其格式设置约定的区域性。 <xref:System.Globalization.DateTimeFormatInfo>返回对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义返回的字符串的格式设置。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   实现一个自定义对象<xref:System.IFormatProvider>接口。 其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.DateTimeFormatInfo>使用与当前区域性关联的对象。 有关更多信息，请参见<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例显示的日期和时间使用的字符串表示形式<xref:System.Globalization.CultureInfo>代表五个不同区域的对象。  
  
 [!code-csharp[System.DateTime.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString4.cs#3)]
 [!code-vb[System.DateTime.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">日期和时间超出了 <paramref name="provider" /> 所用日历支持的日期范围。</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.IFormatProvider)" />方法返回的日期和时间的字符串表示形式中使用代表的区域性的日历<paramref name="provider" />参数。 由定义其日历<see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" />属性。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或更高版本比<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置的范围之外的日期格式<see cref="T:System.Globalization.JapaneseCalendar" />类。  
  
[!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception1.cs#1)] [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception1.vb#1)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="dateTime.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义日期和时间格式字符串。</param>
        <summary>使用指定的格式和当前区域性的格式约定将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 指定的当前 <paramref name="format" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ToString%28System.String%29>方法返回使用当前区域性的; 有关详细信息的格式设置约定的特定格式的日期和时间值的字符串表示形式，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
 `format`参数应包含单个格式说明符 (请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) 或自定义格式模式 (请参阅[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md))，它定义返回的字符串的格式。 如果`format`是`null`或使用空字符串，常规格式说明符，G。  
  
 此方法的一些用途包括：  
  
-   获取一个字符串在当前区域性的短日期和时间格式显示日期和时间。 若要执行此操作，您可以使用"G"格式说明符。  
  
-   获取一个字符串，包含月份和年份。 若要执行此操作，您可以使用"MM/yyyy"格式字符串。 格式字符串使用当前区域性的日期分隔符。  
  
-   获取一个字符串，包含的日期和时间以特定格式。 例如，"MM/dd/yyyyHH:mm"格式字符串中以固定格式显示日期和时间字符串如"19 / 03 / / 2013年 18:06"。 格式字符串使用"/"作为固定的日期分隔符，而不考虑特定于区域性的设置。  
  
-   可用于序列化的日期字符串获取压缩格式的日期。 例如，"yyyyMMdd"格式字符串将显示与任何日期分隔符后跟两位数月份和两位数日期的四位数年份。  
  
 以下示例使用这三个格式字符串来显示日期和时间值使用 EN-US 和 FR-FR 区域性的约定。  
  
 [!code-csharp[System.DateTime.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring5.cs#5)]
 [!code-vb[System.DateTime.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring5.vb#5)]  
  
   
  
## Examples  
 以下示例使用的每个标准日期和时间格式字符串和自定义日期和时间格式字符串的选择集要显示的字符串表示形式<xref:System.DateTime>值。 该示例的线程当前区域性为 EN-US。  
  
 [!code-csharp[System.DateTime.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString2.cs#2)]
 [!code-vb[System.DateTime.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 的长度为 1，而且它不是为 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 定义的格式说明符字符之一。  
  
- 或 - 
 <paramref name="format" /> 不包含有效的自定义格式模式。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">此日期和时间超出了当前区域性所用日历支持的日期范围。</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.String)" />方法返回的日期和时间的字符串表示形式中使用当前区域性的日历。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或更高版本比<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置的范围之外的日期格式<see cref="T:System.Globalization.HebrewCalendar" />类时的当前区域性是希伯来语 （以色列）。  
  
[!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception3.cs#3)] [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception3.vb#3)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="dateTime.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义日期和时间格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 和 <paramref name="format" /> 指定的当前 <paramref name="provider" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format`参数可以包含单个格式说明符 (请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) 或自定义格式模式 (请参阅[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md))。 如果`format`是`null`或空字符串 ("")，使用标准格式说明符，"G"。  
  
 `provider`参数定义与标准格式说明符，以及符号和日期和时间组件的名称相对应的模式。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示在返回的字符串中反映其格式设置约定的区域性。 <xref:System.Globalization.DateTimeFormatInfo>返回对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义返回的字符串的格式设置。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   实现一个自定义对象<xref:System.IFormatProvider>接口。 其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.DateTimeFormatInfo>关联与当前使用区域性。 有关更多信息，请参见<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 以下示例使用每个标准日期时间格式字符串来显示日期和时间为四个不同的区域性的字符串表示形式。  
  
 [!code-csharp[System.DateTime.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring3.cs#4)]
 [!code-vb[System.DateTime.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring3.vb#4)]  
  
 下面的示例演示的格式设置的不同方式<xref:System.DateTime>值使用固定条件<xref:System.Globalization.DateTimeFormatInfo>。  
  
 [!code-cpp[Classic DateTime.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DateTime.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic DateTime.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 的长度为 1，而且它不是为 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 定义的格式说明符字符之一。  
  
- 或 - 
 <paramref name="format" /> 不包含有效的自定义格式模式。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">日期和时间超出了 <paramref name="provider" /> 所用日历支持的日期范围。</exception>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />方法返回的日期和时间的字符串表示形式中使用的日历<paramref name="provider" />参数。 由定义其日历<see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" />属性。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或更高版本比<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置的范围之外的日期格式<see cref="T:System.Globalization.UmAlQuraCalendar" />类。  
  
[!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception4.cs#4)] [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception4.vb#4)]</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">示例：.NET Framework 4 格式设置实用工具</related>
      </Docs>
    </Member>
    <Member MemberName="ToUniversalTime">
      <MemberSignature Language="C#" Value="public DateTime ToUniversalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToUniversalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToUniversalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUniversalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToUniversalTime();" />
      <MemberSignature Language="F#" Value="member this.ToUniversalTime : unit -&gt; DateTime" Usage="dateTime.ToUniversalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为协调世界时 (UTC)。</summary>
        <returns>一个对象，其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Utc" />，并且其值为等效于当前 <see cref="T:System.DateTime" /> 对象的值的 UTC；如果经转换的值过大以至于不能由 <see cref="F:System.DateTime.MaxValue" /> 对象表示，则为 <see cref="T:System.DateTime" />，或者，如果经转换的值过小以至于不能表示为 <see cref="F:System.DateTime.MinValue" /> 对象，则为 <see cref="T:System.DateTime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 协调世界时 (UTC) 等于的本地时间减的 UTC 偏移量。 有关的 UTC 偏移量的详细信息，请参阅<xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>。 转换还会考虑适用于由当前时间的夏时制规则<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.ToUniversalTime%2A>方法从本地时间转换为 UTC 时识别只是将当前的调整规则。 因此，当前的调整规则生效之前的转换可能不准确地反映本地时间与 UTC 之间的差异。  
  
 从.NET Framework 版本 2.0 中，返回的值开始<xref:System.DateTime.ToUniversalTime%2A>方法通过确定<xref:System.DateTime.Kind%2A>属性与当前<xref:System.DateTime>对象。 下表描述了可能的结果。  
  
|类型|结果|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|不执行任何转换。|  
|<xref:System.DateTimeKind.Local>|当前<xref:System.DateTime>对象转换为 UTC。|  
|<xref:System.DateTimeKind.Unspecified>|当前<xref:System.DateTime>对象被假定为本地时间，并执行转换像<xref:System.DateTime.Kind%2A>了<xref:System.DateTimeKind.Local>。|  
  
> [!NOTE]
>  <xref:System.DateTime.ToUniversalTime%2A>方法将<xref:System.DateTime>值从从当地时间为 UTC。 若要将时间转换为 UTC 非本地时间区域中，使用<xref:System.TimeZoneInfo.ConvertTimeToUtc%28System.DateTime%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType>方法。 若要转换其相对于 UTC 的偏移量已知的时间，使用<xref:System.DateTimeOffset.ToUniversalTime%2A>方法。  
  
 如果日期和时间实例值是不明确的时间，此方法假设它是标准时间。 （不明确时间是指可以映射到标准时间或在本地时区的夏令时）如果日期和时间实例值是无效时间，此方法只需减去本地时区的 UTC 偏移量以返回 UTC 中的本地时间。 （无效的时间是指因夏令时调整规则的应用程序而不存在。）  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToUniversalTime%2A>方法。  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性会影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.DateTime.ToUniversalTime" />方法有时用来将本地时间转换为 UTC。 <see cref="M:System.DateTime.ToLocalTime" />然后调用方法来还原原始的本地时间。 但是，如果原始时间表示本地时区的时间无效，则两个本地时间值不会相等。 有关其他信息和示例，请参阅<see cref="M:System.DateTime.ToLocalTime" />方法。  
  
上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<see cref="M:System.DateTime.ToUniversalTime" />方法只识别当前调整规则的本地时区，并将其应用于所有日期，包括低级别日期 （即早于当前的调整的开始日期规则）。 在上运行的应用程序[!INCLUDE[winxp](~/includes/winxp-md.md)]需要从历史上看准确的本地日期和时间计算通过使用必须解决此行为<see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" />方法来检索<see cref="T:System.TimeZoneInfo" />对象，它对应于本地时区，并调用其<see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" />方法。  
  
下面的示例说明了之间的差异<see cref="M:System.DateTime.ToUniversalTime" />并<see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" />上的方法[!INCLUDE[winxp](~/includes/winxp-md.md)]位于美国。 第一个的两个方法调用适用于 2006 年的日期的当前时区调整规则 （这在 2007 年开始生效）。 当前的调整规则提供了在 3 月; 的第二个星期日为夏时制转换上一个规则，这实际上是在 2006 年，提供为夏时制年 4 月的第一个星期日发生转换。 仅在第三个方法调用准确地执行此历史日期和时间的转换。  
  
[!code-csharp[System.DateTime.ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.touniversaltime/cs/touniversaltime.cs#1)] [!code-vb[System.DateTime.ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.touniversaltime/vb/touniversaltime.vb#1)]</para></block>
        <altmember cref="M:System.DateTime.ToLocalTime" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="dateTime.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <altmember cref="Overload:System.DateTime.Parse" />
        <remarks>
          <format type="text/markdown"><![CDATA[  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.DateTime.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <see cref="T:System.DateTime" /> 中包含的日期和时间等效的 <paramref name="s" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <paramref name="s" /> 参数为 <see langword="null" />，是空字符串 ("") 或者不包含日期和时间的有效字符串表示形式，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 参数成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法是类似于<xref:System.DateTime.Parse%28System.String%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29>方法不会引发异常，如果转换失败。  
  
 将字符串`s`在当前使用的格式设置信息分析<xref:System.Globalization.DateTimeFormatInfo>对象，它由当前线程区域性隐式提供。  
  
 如果可能，此方法尝试忽略无法识别的数据，并填充缺少的月、 日和年信息与当前日期。 如果`s`包含仅日期而没有时间，此方法假设时间为午夜 12:00。 如果`s`包括一个日期组件的两位数年份，它将转换为值的基础的当前区域性的当前日历中每年<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>属性。 任何前导、 内部或尾随空格字符中的`s`将被忽略。 日期和时间可以使用的前导空格和尾随数字符号字符 （' #'，U + 0023），对括起来并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 因为<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法会尝试分析日期的字符串表示形式，并使用当前区域性，尝试分析跨不同的区域性特定字符串的格式设置规则的时间可以失败或返回不同的结果。 如果将跨不同的区域设置分析特定的日期和时间格式，请使用<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法或的重载之一<xref:System.DateTime.TryParseExact%2A>方法并提供格式说明符。  
  
 如果`s`闰日，在闰年中当前日历，方法分析的字符串表示形式`s`成功。 如果`s`闰日中非-闰年当前区域性的当前日历中的字符串表示形式，分析操作将失败，该方法将返回`false`。  
  
 如果`s`不包含任何时区信息，`result`包含<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>方法返回时。 如果要分析的字符串包含时区信息`result`包含<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>方法返回时。  
  
   
  
## Examples  
 下面的示例将传递到的日期和时间字符串的数目<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.DateTime.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.TryParse/cpp/datetime.tryparse1.cpp#1)]
 [!code-csharp[System.DateTime.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/TryParse1.cs#1)]
 [!code-vb[System.DateTime.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/TryParse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>格式设置受当前的属性<see cref="T:System.Globalization.DateTimeFormatInfo" />对象，它默认情况下派生自**区域和语言选项**控制面板中的项。 <see cref="Overload:System.DateTime.TryParse" />方法可以意外失败，并返回<see langword="False" />如果当前<see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" />和<see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" />属性设置为相同的值。</para></block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">示例：.NET Framework 4 格式设置实用工具</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParse (s, provider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="styles">枚举值的按位组合，该组合定义如何根据当前时区或当前日期解释已分析日期。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <see cref="T:System.DateTime" /> 中包含的日期和时间等效的 <paramref name="s" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <paramref name="s" /> 参数为 <see langword="null" />，是空字符串 ("") 或者不包含日期和时间的有效字符串表示形式，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的区域性特定格式信息和格式设置样式，将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 参数成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析字符串可包含日期、 时间和时区信息。 它是类似于<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法不会引发异常，如果转换失败。  
  
 此方法将尝试忽略无法识别的数据和分析`s`完全。 如果`s`包含时间但没有日期，通过默认的替换当前日期的方法; 如果`styles`包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>标志，它将替代`DateTime.Date.MinValue`。 如果`s`包含日期，但没有时间，12:00 午夜用作默认的时间。 如果存在日期但其年份部分只有两位数字组成，它将转换为一年`provider`上的值基于参数的当前日历<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>属性。 任何前导、 内部或尾随空格字符中的`s`将被忽略。 日期和时间可以使用的前导空格和尾随数字符号字符 （' #'，U + 0023），对括起来并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 由定义的日期和时间元素，以及名称和符号中日期和时间，使用特定有效格式`provider`可以为以下任何参数：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示的格式设置中使用的区域性`s`参数。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义中使用的格式`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象，用于定义中使用的格式`s`。  
  
-   一个自定义 <xref:System.IFormatProvider> 实现。 其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>方法将返回<xref:System.Globalization.DateTimeFormatInfo>对象，用于定义中使用的格式`s`。  
  
 如果 `provider` 为 `null`，则使用当前区域性。  
  
 如果`s`闰日，在闰年中当前日历，方法分析的字符串表示形式`s`成功。 如果`s`闰日中非-闰年的当前日历中的字符串表示形式`provider`，分析操作失败，并且该方法将返回`false`。  
  
 `styles`参数定义的已分析的字符串和分析操作应如何处理它的确切解释。 它可以是一个或多个成员的<xref:System.Globalization.DateTimeStyles>枚举，如下表中所述。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC。 如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>为 UTC 值并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，该标志没有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|虽然有效，但将忽略此值。 中的日期和时间元素允许内部的空白区域`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|虽然有效，但将忽略此值。 中的日期和时间元素允许前导空白字符`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|虽然有效，但将忽略此值。 中的日期和时间元素允许存在尾随空格`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部空格和尾随空格。 这是默认行为。 不能重写通过提供更具限制性<xref:System.Globalization.DateTimeStyles>枚举值，如<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少的任何时区信息，假定它是表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少的任何时区信息，则假定其值表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.None>|虽然有效，但将忽略此值。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止的日期和时间字符串转换<xref:System.DateTime>值替换其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 通常情况下，通过调用创建此类字符串<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法使用"o"、"r"或"u"标准格式说明符。|  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>除非`styles`标志指示，否则。 如果`s`时区偏移量的信息，包括<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法执行任何必要的时间转换并返回以下值之一：  
  
-   一个<xref:System.DateTime>其日期和时间反映了本地时间和它的值<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
-   或者，如果`styles`包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志，<xref:System.DateTime>值的日期和时间反映 UTC 并且其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 重写此行为，只需使用<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志。  
  
## <a name="parsing-custom-cultures"></a>分析自定义区域性  
 如果您要分析生成的自定义区域性的日期和时间字符串，使用<xref:System.DateTime.TryParseExact%2A>方法而不是<xref:System.DateTime.TryParse%2A>方法以提高分析操作成功的可能性。 自定义区域性日期和时间字符串可以是复杂且难以分析。 <xref:System.DateTime.TryParse%2A>方法会尝试将字符串与多个隐式分析模式，所有这些可能会失败。 与此相反，<xref:System.DateTime.TryParseExact%2A>方法要求您显式指定一个或多个可能会成功的确切的分析模式。  
  
 有关自定义区域性的详细信息，请参阅<xref:System.Globalization.CultureAndRegionInfoBuilder?displayProperty=nameWithType>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.DateTime.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/tryparse2.cs#2)]
 [!code-vb[System.DateTime.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
- 或 - 
 <paramref name="styles" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="provider" /> 是一个非特定区域性，并且不能在分析操作中使用。</exception>
        <block subset="none" type="usage"><para>格式设置受当前的属性<see cref="T:System.Globalization.DateTimeFormatInfo" />对象，它提供由<paramref name="provider" />参数。 <see cref="Overload:System.DateTime.TryParse" />方法可以意外失败，并返回<see langword="False" />如果当前<see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" />和<see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" />属性设置为相同的值。</para></block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

[!INCLUDE[japanese-era-note](~/includes/calendar-era.md)]

         ]]></format>
        </remarks>
        <altmember cref="Overload:System.DateTime.ParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="formats" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, format, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">所需的 <paramref name="s" /> 格式。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="style">一个或多个枚举值的按位组合，指示 <paramref name="s" /> 允许使用的格式。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <see cref="T:System.DateTime" /> 中包含的日期和时间等效的 <paramref name="s" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <paramref name="s" /> 或 <paramref name="format" /> 参数为 <see langword="null" />，或者为空字符串，或者未包含对应于 <paramref name="format" /> 中指定的模式的日期和时间，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的格式、区域性特定的格式信息和样式将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析的日期，必须在所定义的格式的字符串表示形式`format`参数。 它是类似于<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法不会引发异常，如果转换失败。  
  
 `s`参数包含要分析的日期和时间，而且必须在定义的格式`format`参数。 如果日期、 时间和时区元素中存在`s`，他们必须也显示在指定的顺序`format`。 如果`format`用于定义一个日期包含任何时间元素，并且分析操作成功，则生成<xref:System.DateTime>值具有时间为午夜 (00: 00:00)。 如果`format`定义的时间与任何日期元素，并且分析操作成功，则生成<xref:System.DateTime>默认情况下的值具有的日期`DateTime.Now.Date`，或者它具有的日期`DateTime.MinValue.Date`如果`styles`包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志。 `style`参数确定是否`s`参数可以包含前导、 内部或尾随空格字符。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>并<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果 s 包含时区信息，如有必要，为本地时间转换的时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志将协调世界时 (UTC) 转换为本地时间和设置无法<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `format`参数包含对应于预期的格式模式`s`参数。 中的模式`format`参数从的一个或多个自定义格式说明符组成[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或单个标准格式说明符，用于从标识预定义的模式，[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果在自定义格式模式中不使用日期或时间分隔符，使用固定区域性的`provider`参数和最宽的窗体的每个自定义格式说明符。 例如，如果你想要在该模式指定小时数，指定较宽的形式"HH"，而不是更窄的窗体"H"。  
  
> [!NOTE]
>  而不是要求`s`符合一种格式以便分析操作成功，您可以调用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法并指定多个允许的格式。 这使得更有可能会成功分析操作。  
  
 特定日期和时间的符号和字符串 （例如，在某个特定的语言中星期几的名称） 中使用`s`由定义`provider`参数，因为是精确的格式`s`如果`format`是一种标准格式说明符的字符串。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象及其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和格式设置`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
 `styles`参数包含一个或多个成员<xref:System.Globalization.DateTimeStyles>枚举，用于确定是否以及其中的空白区域未定义由`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每隶属<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC。 如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>为 UTC 值并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，该标志没有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的该空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空格`format`可以显示在开头`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空格`format`可以在的终端显示`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定的`s`可能包含前导、 内部空格和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少的任何时区信息，假定它是表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少的任何时区信息，则假定其值表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间的返回值的日期设置为不包含日期信息`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 中提供的以外的任何空格`format`允许。 如果`s`缺少所返回的日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息中存在`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值替换其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标记主要阻止 UTC 时间的转换为本地时间。|  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。 请注意，字符串"2009 年 5 月 01 日上午 8:30"不能成功分析时`styles`参数等于<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>因为不允许前导空格`format`。 此外，字符串"2009 年 5 月 01 日 09:00"不能与成功分析`format`的"MM/dd/yyyyhh:mm"因为日期字符串前面不带前导零的月份数作为`format`要求。  
  
 [!code-csharp[System.DateTime.TryParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact1.cs#1)]
 [!code-vb[System.DateTime.TryParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
- 或 - 
 <paramref name="styles" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <block subset="none" type="usage"><para>在中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<see cref="Overload:System.DateTime.TryParseExact" />方法将返回<see langword="false" />如果要分析的字符串包含的小时组件和 AM/PM 指示符不在协议中的。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para></block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTime.TryParseExact (s, formats, provider, style, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="formats" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.DateTime" RefType="out" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="formats"><paramref name="s" /> 的允许格式的数组。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式信息。</param>
        <param name="style">枚举值的一个按位组合，指示 <paramref name="s" /> 所允许的格式。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <see cref="T:System.DateTime" /> 中包含的日期和时间等效的 <paramref name="s" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <paramref name="s" /> 或 <paramref name="formats" /> 为 <see langword="null" />，<paramref name="s" /> 或 <paramref name="formats" /> 的某个元素为空字符串， 或者 <paramref name="s" /> 的格式与 <paramref name="formats" /> 中的格式模式所指定的格式都不完全匹配，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的格式数组、区域性特定格式信息和样式，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须至少与指定的格式之一完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <returns>如果 <see langword="true" /> 参数成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析的日期的任何一种分配到的模式匹配的字符串表示形式`formats`参数。 就像<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法中，除<xref:System.DateTime.TryParseExact%2A>方法不会引发异常，如果转换失败。  
  
 `s`参数包含要分析的日期和时间。 如果`s`参数只包含时间和当前日期使用没有日期，除非`style`参数包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅日期没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部，或尾随空格字符比允许的格式字符串中的一个其他`formats`。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>并<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果 s 包含时区信息，如有必要，为本地时间转换的时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以通过更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志将协调世界时 (UTC) 转换为本地时间和设置无法<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `formats`参数包含数组的模式，其中之一`s`必须完全匹配分析操作成功。 中的模式`formats`参数包含一个或多个自定义格式说明符，从[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或单个标准格式说明符，用于从标识预定义的模式，[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果在自定义格式模式中不使用日期或时间分隔符，使用固定区域性的`provider`参数和最宽的窗体的每个自定义格式说明符。 例如，如果你想要在该模式指定小时数，指定较宽的形式"HH"，而不是更窄的窗体"H"。  
  
 特定日期和时间的符号和字符串 （例如，在某个特定的语言中星期几的名称） 中使用`s`由定义`provider`参数，因为是精确的格式`s`如果`format`是一种标准格式说明符的字符串。 `provider`参数可以是任何以下：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>返回的对象及其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和格式设置`s`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
 `styles`参数包含一个或多个成员<xref:System.Globalization.DateTimeStyles>枚举，用于确定是否以及其中的空白区域未定义由`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每隶属<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`和，如果有必要，将其转换为 UTC。 如果`s`包含时区偏移量，或者如果`s`不包含任何时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>将返回<xref:System.DateTime>为 UTC 值并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息，但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法对字符串进行分析、 对返回不执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，该标志没有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的该空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空格`format`可以显示在开头`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空格`format`可以在的终端显示`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定的`s`可能包含前导、 内部空格和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定如果`s`缺少的任何时区信息，假定它是表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，则<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定如果`s`缺少的任何时区信息，则假定其值表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>值与 UTC 与本地时间和集及其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间的返回值的日期设置为不包含日期信息`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 中提供的以外的任何空格`format`允许。 如果`s`缺少所返回的日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息中存在`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值替换其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标记主要阻止 UTC 时间的转换为本地时间。|  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法，以确保可以成功地分析多种可能的格式字符串。  
  
 [!code-csharp[System.Datetime.TryParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact2.cs#2)]
 [!code-vb[System.Datetime.TryParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
- 或 - 
 <paramref name="styles" /> 包含无效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <block subset="none" type="usage"><para>在中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<see cref="Overload:System.DateTime.TryParseExact" />方法将返回<see langword="false" />如果要分析的字符串包含的小时组件和 AM/PM 指示符不在协议中的。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para></block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-datetime.md">在 .NET Framework 中分析日期和时间字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="UnixEpoch">
      <MemberSignature Language="C#" Value="public static readonly DateTime UnixEpoch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime UnixEpoch" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.UnixEpoch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnixEpoch As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime UnixEpoch;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnixEpoch : DateTime" Usage="System.DateTime.UnixEpoch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcNow">
      <MemberSignature Language="C#" Value="public static DateTime UtcNow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime UtcNow" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.UtcNow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UtcNow As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime UtcNow { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcNow : DateTime" Usage="System.DateTime.UtcNow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.DateTime" /> 对象，该对象设置为此计算机上的当前日期和时间，表示为协调通用时间 (UTC)。</summary>
        <value>其值为当前 UTC 日期和时间的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的解决方法取决于系统计时器，具体取决于基础操作系统。 它通常必须介于 0.5 和 15 毫秒。

 从.NET Framework 2.0 版开始，返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。

 使用的替代方法<xref:System.DateTime.UtcNow%2A>是<xref:System.DateTimeOffset.UtcNow%2A?displayProperty=nameWithType>。 日期和时间值分配为协调世界时 (UTC)，则表示前者<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>到其<xref:System.DateTime.Kind%2A>属性，后者将分配日期和时间值的 UTC 时间的偏移量 (等于<xref:System.TimeSpan.Zero?displayProperty=nameWithType>)。
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性会影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcNow" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="Year">
      <MemberSignature Language="C#" Value="public int Year { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Year" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Year" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Year As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Year { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Year : int" Usage="System.DateTime.Year" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的年份部分。</summary>
        <value>年份（介于 1 和 9999 之间）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Year%2A>属性返回公历日历中的当前实例的年份。 它不返回使用当前区域性的默认日历的年份。 若要检索使用特定日历的年份，可以调用该日历的`GetYear`方法，如以下代码所示。  
  
 [!code-csharp[System.DateTime.Year#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Year/cs/Year.cs#1)]
 [!code-vb[System.DateTime.Year#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Year/vb/Year.vb#1)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Year%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
  </Members>
</Type>