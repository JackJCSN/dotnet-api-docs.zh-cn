<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70405943" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持 .NET 类层次结构中的所有类，并为派生类提供低级别服务。 这是所有 .NET 类的最终基类；它是类型层次结构的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语言通常不需要类来声明继承<xref:System.Object> ，因为继承是隐式的。  
  
 因为 .net 中的所有类都是<xref:System.Object>从派生的，所以<xref:System.Object>类中定义的每个方法都可用于系统中的所有对象。 派生类可以和重写其中一些方法，其中包括：  
  
-   <xref:System.Object.Equals%2A>-支持对象之间的比较。  
  
-   <xref:System.Object.Finalize%2A>-在自动回收对象之前执行清理操作。  
  
-   <xref:System.Object.GetHashCode%2A>-生成与对象的值相对应的数字以支持使用哈希表。  
  
-   <xref:System.Object.ToString%2A>-制造描述类的实例的用户可读文本字符串。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果正在设计的类（如集合）必须处理任何类型的对象，则可以创建接受<xref:System.Object>类的实例的类成员。 但是，对类型进行装箱和取消装箱的过程会产生性能开销。 如果你知道新类将经常处理某些值类型，则可以使用以下两种策略之一来最大程度地减少装箱成本。  
  
-   创建接受<xref:System.Object>类型的常规方法，并创建一组特定于类型的方法重载，这些重载接受你希望类经常处理的每个值类型。 如果存在接受调用参数类型的特定于类型的方法，则不会发生任何装箱并调用类型特定的方法。 如果没有与调用参数类型匹配的方法参数，则将参数装箱，并调用常规方法。  
  
-   将类型及其成员设计为使用泛型。 当你创建类的实例并指定泛型类型参数时，公共语言运行时将创建一个封闭式泛型类型。 泛型方法是类型特定的，可以在不装箱调用参数的情况下调用。  
  
 尽管有时需要开发接受和返回<xref:System.Object>类型的通用类，但你可以通过提供类型特定的类来处理常用类型，从而提高性能。 例如，提供特定于设置和获取布尔值的类可消除装箱和取消装箱布尔值的成本。  
  
   
  
## Examples  
 下面的示例定义了从<xref:System.Object>类派生的点类型，并重写了<xref:System.Object>类的许多虚方法。 此外，该示例还演示了如何调用<xref:System.Object>类的多个静态和实例方法。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型的<see langword="Shared" />公共静态（在 Visual Basic）成员是线程安全的。 实例成员不一定是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类中的构造函数调用，但也可用于直接创建<xref:System.Object>类的实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个对象实例是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前对象。</summary>
        <returns>如果指定的对象等于当前对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和`obj`参数之间的比较类型取决于当前实例是引用类型还是值类型。  
  
-   如果当前实例是引用类型，则<xref:System.Object.Equals%28System.Object%29>方法会测试引用相等性，并调用<xref:System.Object.Equals%28System.Object%29>方法等效于调用<xref:System.Object.ReferenceEquals%2A>方法。 引用相等性意味着比较的对象变量引用相同的对象。 下面的示例说明了此类比较的结果。 它`Person`定义了一个类，该类是一个引用类型，它`Person`调用类构造函数来实例化`Person` `person2`两个`person1a`新的对象，这些对象具有相同的值。 它还分配`person1a`给另一个对象`person1b`变量。 如示例的输出所示，和`person1a` `person1b`相等，因为它们引用相同的对象。 但是， `person1a`和`person2`不相等，但它们具有相同的值。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   如果当前实例是值类型，则<xref:System.Object.Equals%28System.Object%29>方法会测试值是否相等。 值相等性意味着：  
  
    -   这两个对象属于同一类型。 如下面的示例所示， <xref:System.Byte>值为12的对象不<xref:System.Int32>等于值为12的对象，因为这两个对象具有不同的运行时类型。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   这两个对象的公共字段和私有字段的值相等。 下面的示例测试值是否相等。 它`Person`定义结构（值类型），并`Person`调用类构造函数来`person1`实例化两个具有相同`Person`值的新`person2`对象和。 如示例中的输出所示，尽管这两个对象变量引用不同的对象`person1` ， `person2`但它们相等，因为它们对于私有`personName`字段具有相同的值。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 因为该类是 .NET Framework 中所有类型的基类<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> ，所以方法为所有其他类型提供默认的相等比较。 <xref:System.Object> 但类型通常会重写<xref:System.Object.Equals%2A>方法以实现值相等性。 有关详细信息，请参阅调用方的说明和对继承者的说明部分。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当对<xref:System.Object.Equals%28System.Object%29> <xref:System.Object.Equals%28System.Object%29>中的类调用方法重载时，它将为不重写的类提供默认行为。 [!INCLUDE[wrt](~/includes/wrt-md.md)] 这是 .NET Framework 为[!INCLUDE[wrt](~/includes/wrt-md.md)]提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时的 .NET Framework 支持](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)）。 中的[!INCLUDE[wrt](~/includes/wrt-md.md)]类不会<xref:System.Object>继承，当前无法实现<xref:System.Object.Equals%28System.Object%29>方法。 但是，当<xref:System.Object.ToString%2A>你在C#或 Visual Basic <xref:System.Object.Equals%28System.Object%29>代码中<xref:System.Object.GetHashCode%2A>使用它们时，它们看起来具有、和方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]用C#或 Visual Basic 编写的类可以重写<xref:System.Object.Equals%28System.Object%29>方法重载。  
  
## <a name="notes-for-callers"></a>调用方说明  
 派生类经常重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法以实现值相等性。 此外，类型通常还向`Equals`方法提供附加的强类型重载，这通常是通过<xref:System.IEquatable%601>实现接口来实现的。 当调用`Equals`方法来测试相等性时，应知道当前实例是否会重写<xref:System.Object.Equals%2A?displayProperty=nameWithType> ，并了解对`Equals`方法的特定调用的解析方式。 否则，你可能会执行与预期不同的相等性测试，方法可能会返回意外值。  
  
 下面的示例进行了这方面的演示。 它用相同<xref:System.Text.StringBuilder>的字符串实例化三个对象，然后对`Equals`方法进行四次调用。 第一个方法调用返回`true`，其余三个返回。 `false`  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 在第一种情况下，将<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>调用强类型化方法重载，该重载用于测试值相等性。 由于分配给这两个<xref:System.Text.StringBuilder>对象的字符串相等，因此该方法返回。 `true` 但是， <xref:System.Text.StringBuilder>不会重<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>写。 <xref:System.Text.StringBuilder>因此，当对象被强制转换<xref:System.Object>为时，如果<xref:System.Text.StringBuilder>将实例分配给类型<xref:System.Object>的变量，并且<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法传递两个<xref:System.Text.StringBuilder>对象，则默认值 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>调用方法。 由于<xref:System.Text.StringBuilder>是引用类型，因此这等效于将两个<xref:System.Text.StringBuilder>对象传递给<xref:System.Object.ReferenceEquals%2A>方法。 尽管所有三<xref:System.Text.StringBuilder>个对象都包含相同的字符串，但是它们引用三个不同的对象。 因此，这三个方法调用返回`false`。  
  
 通过调用<xref:System.Object.ReferenceEquals%2A>方法，可以将当前的对象与另一个对象进行比较以便引用相等性。 在 Visual Basic 中，还可以使用`is`关键字（ `If Me Is otherObject Then ...`例如）。  
  
## <a name="notes-for-inheritors"></a>对继承者的说明  
 定义自己的类型时，该类型将继承其基类型的`Equals`方法所定义的功能。 下表列出了`Equals`方法的默认实现，该方法适用于 .NET Framework 中的类型的主要类别。  
  
|类型类别|定义的相等|注释|  
|-------------------|-------------------------|--------------|  
|直接从派生的类<xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性;等效于调用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|结构|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等性;使用反射直接进行逐字节比较或逐字段比较。|  
|枚举|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必须具有相同的枚举类型和基础值。|  
|委托|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委托必须具有相同的调用列表类型。|  
|接口|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性。|  
  
 对于值类型，应始终重写<xref:System.Object.Equals%2A>，因为依赖于反射的相等性测试会降低性能。 您还可以重写引用类型的<xref:System.Object.Equals%2A>的默认实现，以测试值相等性而不是引用相等性，并定义值相等性的精确含义。 如果两个<xref:System.Object.Equals%2A>对象`true`具有相同的值，则此类实现将返回，即使它们不是相同的实例。 类型的实施器决定对象的值是什么，但它通常是存储在对象的实例变量中的部分或全部数据。 例如， <xref:System.String>对象的值基于字符串的字符<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> ; 方法会重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，以便为任意两个包含相同字符`true`的字符串实例返回相同的顺序。  
  
 下面的示例演示如何重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，以测试值是否相等。 它重写<xref:System.Object.Equals%2A> `Person`类的方法。 如果`Person`接受其相等的基类实现，则只有`Person`当两个对象引用单个对象时，它们才相等。 但在这种情况下， `Person`如果两个对象具有相同的`Person.Id`属性值，则这两个对象相等。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 除了重写<xref:System.Object.Equals%2A>外，还可以<xref:System.IEquatable%601>实现接口，以提供相等的强类型测试。  
  
 对于<xref:System.Object.Equals%28System.Object%29>方法的所有实现，以下语句必须为 true。 在列表中， `x` `y`、和`z`表示不**为 null**的对象引用。  
  
-   `x.Equals(x)`返回`true`，但涉及浮点类型的情况除外。 请参阅[ISO/IEC/IEEE 60559:2011，信息技术--微处理器系统-浮点运算](https://www.iso.org/standard/57469.html)。  
  
-   `x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。  
  
-   `x.Equals(y)`如果和均为`y` `true` ， `NaN` 则返回。  `x`  
  
-   如果`(x.Equals(y) && y.Equals(z))`返回`true`，则`x.Equals(z)`返回。 `true`  
  
-   如果不修改`x.Equals(y)` `x`和引用的对象， `y`则连续调用将返回相同的值。  
  
-   `x.Equals(null)` 返回 `false`。  
  
 的<xref:System.Object.Equals%2A>实现不得引发异常; 它们应始终返回值。 例如`obj` ，如果<xref:System.ArgumentNullException>为`null`，则该<xref:System.Object.Equals%2A>方法应返回`false` ，而不是引发。  
  
 重写<xref:System.Object.Equals%28System.Object%29>时，请遵循以下准则：  
  
-   实现<xref:System.IComparable>的类型必须重<xref:System.Object.Equals%28System.Object%29>写。  
  
-   重写<xref:System.Object.Equals%28System.Object%29>的类型还必须<xref:System.Object.GetHashCode%2A>重写; 否则，哈希表可能无法正常工作。  
  
-   应考虑实现<xref:System.IEquatable%601>接口，以支持强类型化测试是否相等。 你<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>的实现应返回与<xref:System.Object.Equals%2A>一致的结果。  
  
-   如果您的编程语言支持运算符重载，而您为给定类型重载了相等运算符，则您还必须<xref:System.Object.Equals%28System.Object%29>重写方法以返回与相等运算符相同的结果。 这有助于确保使用<xref:System.Object.Equals%2A> （ <xref:System.Collections.ArrayList>如和<xref:System.Collections.Hashtable>）的类库代码的行为与应用程序代码使用相等运算符的方式一致。  
  
### <a name="guidelines-for-reference-types"></a>引用类型的准则  
 以下准则适用于替代<xref:System.Object.Equals%28System.Object%29>引用类型：  
  
-   如果类型<xref:System.Object.Equals%2A>的语义基于该类型表示某个值的情况，请考虑重写。  
  
-   大多数引用类型不得重载相等运算符（即使它们重写<xref:System.Object.Equals%2A>）。 但是，如果要实现的引用类型应具有值语义（如复数类型），则必须重写相等运算符。  
  
-   不应覆盖<xref:System.Object.Equals%2A>可变引用类型。 这是因为， <xref:System.Object.Equals%2A>重写要求你还<xref:System.Object.GetHashCode%2A>重写方法，如前一部分中所述。 这意味着可变引用类型的实例的哈希代码在其生存期内可能会更改，这可能会导致对象在哈希表中丢失。  
  
### <a name="guidelines-for-value-types"></a>值类型的准则  
 以下准则适用于重写<xref:System.Object.Equals%28System.Object%29>值类型：  
  
-   如果要定义的值类型包括一个或多个字段的值为引用类型，则应重写<xref:System.Object.Equals%28System.Object%29>。 提供的<xref:System.Object.Equals%28System.Object%29>实现对其字段为所有值类型的值类型执行逐字节的比较，但它使用反射来执行字段中包含引用类型的值类型的 <xref:System.ValueType> 逐字段比较。  
  
-   如果重写<xref:System.Object.Equals%2A> ，并且你的开发语言支持运算符重载，则必须重载相等运算符。  
  
-   应该实现<xref:System.IEquatable%601>接口。 调用强类型<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可避免对`obj`参数进行装箱。  
  
   
  
## Examples  
 下面的示例演示一个`Point` <xref:System.Object.Equals%2A>重写方法以提供值相等性的类，以及`Point3D`一个派生自`Point`的类。 因为`Point`重<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>写可测试值相等性， <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>所以不会调用方法。 但是， `Point3D.Equals`调用`Point.Equals`是`Point`因为实现 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方式可提供值相等性。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 方法将进行检查以确保`obj`参数不为**null** ，并且它引用与此对象相同的类型的实例。 `Point.Equals` 如果任一检查失败，则该方法`false`将返回。  
  
 `Point.Equals` 方法 <xref:System.Object.GetType%2A> 调用方法来确定两个对象的运行时类型是否相同。 `obj is Point`如果该方法在C#或`TryCast(obj, Point)` Visual Basic 中使用了窗体的检查，则在的派生`true`类的实例`obj`的`Point`情况下，检查将返回，即使`obj`和当前实例的运行时类型不相同。 验证两个对象的类型是否相同，方法强制转换`obj`为类型`Point`并返回比较两个对象的实例字段的结果。  
  
 在`Point3D.Equals`中，将`Point.Equals`在执行其他操作<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>之前调用继承的方法（重写）。 因为`Point3D`是一个密封的类 (在 Visual Basic 中为 `NotInheritable`)，签入窗体`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中是足以确保`obj`是`Point3D`对象。 如果它是一个`Point3D`对象，则会将其强制`Point`转换为对象，并传递给的基类<xref:System.Object.Equals%2A>实现。 仅当继承`Point.Equals`的方法返回`true`时，方法才会`z`比较派生类中引入的实例字段。  
  
 下面的示例定义了`Rectangle`一个类，该类在内部实现一个`Point`矩形作为两个对象。 类还将重<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>写以提供值相等性。 `Rectangle`  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 某些语言（如C#和） Visual Basic 支持运算符重载。 当类型重载相等运算符时，它还必须重写<xref:System.Object.Equals%28System.Object%29>方法以提供相同的功能。 这通常通过使用重载的相等<xref:System.Object.Equals%28System.Object%29>运算符编写方法来完成，如以下示例中所示。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 由于`Complex`是值类型，因此不能从派生。  因此<xref:System.Object.Equals%28System.Object%29> ，对方法的重写不需要<xref:System.Object.GetType%2A>调用来确定每个对象的确切运行时类型，但可以改为使用`is`中C#的运算符或`TypeOf` Visual Basic 中的运算符来检查`obj`参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的对象实例是否被视为相等。</summary>
        <returns>如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法指示两个`objA`对象`objB`是否相等。 它还使你能够测试值为**null**的对象是否相等。 它比较`objA`和`objB`以确定是否相等，如下所示：  
  
-   它确定两个对象是否表示相同的对象引用。 如果是这样，则该方法`true`返回。 此测试等效于调用<xref:System.Object.ReferenceEquals%2A>方法。 此外，如果`objA`和`objB`均为**null**，则该方法返回`true`。  
  
-   它确定`objA`或`objB`是否为**null**。 如果是，则返回`false`。  
  
-   如果两个对象不表示相同的对象引用，并且两者都不为**null**， `objA`则`Equals`调用。（`objB`）并返回结果。 这意味着，如果`objA` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>重写方法，则将调用此重写。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法，并将其<xref:System.Object.ReferenceEquals%2A>与方法进行比较。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用于在销毁对象之前对当前对象占用的非托管资源执行清理操作。 方法是受保护的，因此只能通过此类或派生类访问。  
  
 本节内容：  
  
-   [终止的工作方式](#How)  
  
-   [实施者注意事项](#Notes)  
  
-   [SafeHandle 替代项](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>终止的工作方式  
 类不提供<xref:System.Object.Finalize%2A>方法的实现，垃圾回收器不会将派生自<xref:System.Object>的类型标记为终止，除非它们重写<xref:System.Object.Finalize%2A>方法。 <xref:System.Object>  
  
 如果类型确实重写<xref:System.Object.Finalize%2A>方法，则垃圾回收器会将类型的每个实例的条目添加到称为终止队列的内部结构。 终止队列包含托管堆中的所有对象的条目，在垃圾回收器可以回收内存之前，必须先运行终止代码。 然后，垃圾回收器会<xref:System.Object.Finalize%2A>在以下条件下自动调用方法：  
  
-   在垃圾回收器发现对象不可访问后，除非已通过调用<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法免除了该对象的终止。  
  
-   **仅在 .NET Framework**的情况下，在应用程序域的关闭过程中，除非该对象免于终止。 在关闭期间，即使仍可访问的对象也会完成。  
  
 <xref:System.Object.Finalize%2A>仅在给定的实例上自动调用一次，除非该对象是使用之类<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>的机制重新注册的， <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>并且随后未调用方法。  
  
 <xref:System.Object.Finalize%2A>操作具有以下限制：  
  
-   不确定终结器执行时的准确时间。 若要确保类的实例的资源的确定性版本，请实现`Close`方法或<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>提供实现。  
  
-   不能保证两个对象的终结器以任何特定顺序运行，即使一个对象引用另一个对象也是如此。 也就是说，如果对象 A 具有对对象 B 的引用，并且都具有终结器，	在对象 A 的终结器启动时，对象 B 可能已被终结。  
  
-   不指定终结器在其上运行的线程。  
  
 在<xref:System.Object.Finalize%2A>以下异常情况下，该方法可能无法运行到完成或根本不会运行：  
  
-   如果另一个终结器无限期阻止（进入无限循环，则会尝试获取它永远无法获取的锁定，等等）。 因为运行时尝试运行终结器来完成，所以如果终结器无限期阻塞，则可能不会调用其他终结器。  
  
-   如果进程终止，无需给运行时提供清理的机会。 在这种情况下，运行时的进程终止通知是 DLL_PROCESS_DETACH 通知。  
  
 仅在关闭过程中，运行时继续完成对象，但可继续减少可终结对象的数量。  
  
 如果<xref:System.Object.Finalize%2A>或的<xref:System.Object.Finalize%2A>替代引发了异常，并且运行时不是由覆盖默认策略的应用程序承载，则运行时将终止进程，而不会`try`终止活动/ `finally`块或执行终结器。 如果终结器无法释放或销毁资源，则此行为可确保进程完整性。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>重写 Finalize 方法 
 应为使用<xref:System.Object.Finalize%2A>非托管资源的类（例如，在垃圾回收过程中丢弃使用非托管资源的文件句柄或数据库连接）进行重写。 不应实现<xref:System.Object.Finalize%2A>托管对象的方法，因为垃圾回收器会自动释放托管资源。  
  
> [!IMPORTANT]
>  如果对象可用于包装非托管资源，则建议的替代方法是使用安全句柄实现 dispose 模式，而不是重 <xref:System.Object.Finalize%2A> 写。  <xref:System.Runtime.InteropServices.SafeHandle> 有关详细信息，请参阅[SafeHandle 替代](#SafeHandle)部分。  
  
 默认<xref:System.Object.Finalize%2A?displayProperty=nameWithType>情况下，此方法不执行任何操作， <xref:System.Object.Finalize%2A>但你应仅在必要时重写，并且仅释放非托管资源。 如果某个终止操作运行，则回收内存要花费更长时间，因为它需要至少两个垃圾回收。 此外，还应为仅引用<xref:System.Object.Finalize%2A>类型重写方法。 公共语言运行时仅终结引用类型。 它忽略值类型上的终结器。  

该<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法的范围为`protected`。 重写类中的方法时，应保持此有限范围。 通过使<xref:System.Object.Finalize%2A>方法受到保护，可以防止应用程序的用户直接调用对象的<xref:System.Object.Finalize%2A>方法。
  
 派生类型中<xref:System.Object.Finalize%2A>的每个实现都必须调用其基类型的<xref:System.Object.Finalize%2A>实现。 这是允许应用程序代码调用<xref:System.Object.Finalize%2A>的唯一情况。 对象的<xref:System.Object.Finalize%2A>方法不应在其基类以外的任何对象上调用方法。 这是因为调用的其他对象可以与调用对象同时收集，如公共语言运行时关闭的情况。 
  
> [!NOTE]
>  C#编译器不允许重写<xref:System.Object.Finalize%2A>方法。 而是通过实现类的[析构函数](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)来提供终结器。 C#析构函数自动调用其基类的析构函数。  
>   
>  视觉C++对象还提供其自己的语法来<xref:System.Object.Finalize%2A>实现方法。 有关详细信息，请参阅[如何：定义和使用类和结构C++（/cli）](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)中的 "析构函数和终结器" 一节。  
  
 由于垃圾回收是不确定的，因此，在垃圾回收器执行终止时，您不会精确地知道。 若要立即释放资源，还可以选择实现[dispose 模式](~/docs/standard/garbage-collection/implementing-dispose.md)和<xref:System.IDisposable>接口。 实现可由类的使用者调用以释放非托管资源，并且可以<xref:System.IDisposable.Dispose%2A>在未调用方法<xref:System.Object.Finalize%2A>的情况下使用方法来释放非托管资源。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>  
  
 <xref:System.Object.Finalize%2A>几乎可以执行任何操作，包括 resurrecting 一个对象（即，在垃圾回收过程中清除对象后使对象再次可访问）。 但是，对象只能复活一次;<xref:System.Object.Finalize%2A>在垃圾回收期间，不能对复活对象调用。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 备用方法  
 创建可靠的终结器通常很难，因为你无法对应用程序的状态进行假设，并且因为未处理的系统<xref:System.OutOfMemoryException>异常<xref:System.StackOverflowException> （如和）终止终结器。 您可以使用从<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>类派生的对象来包装非托管资源，并在不使用终结器的情况下实现 dispose 模式，而不是实现类的终结器以释放非托管资源。 .NET Framework 提供<xref:Microsoft.Win32?displayProperty=nameWithType>命名空间中的以下类，这些类派生自<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>：  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>是文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>是内存映射的文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>指向非托管内存块的指针的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 是加密句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>是管道句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>是注册表项的句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>是等待句柄的包装类。  
  
 下面的示例将[dispose 模式](~/docs/standard/garbage-collection/implementing-dispose.md)与安全句柄一起使用，而<xref:System.Object.Finalize%2A>不是重写方法。 它定义一个`FileAssociation`类，该类包装有关处理具有特定文件扩展名的文件的应用程序的注册表信息。 Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函数调用<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>将两`out`个作为参数返回的注册表句柄传递到构造函数。 然后，该类型`Dispose`的受保护方法`SafeRegistryHandle.Dispose`会调用方法来释放这两个句柄。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下面的示例验证当重<xref:System.Object.Finalize%2A>写<xref:System.Object.Finalize%2A>的对象被销毁时调用的方法。 请注意，在生产应用程序中， <xref:System.Object.Finalize%2A>将重写方法以释放由该对象占用的非托管资源。 另请注意， C#该示例提供析构函数，而不<xref:System.Object.Finalize%2A>是重写方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 有关替代<xref:System.Object.Finalize%2A>方法的其他示例， <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>请参见方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作为默认哈希函数。</summary>
        <returns>当前对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 哈希代码是一个数字值，用于在基于哈希的集合（ <xref:System.Collections.Generic.Dictionary%602>如类<xref:System.Collections.Hashtable> 、类或从<xref:System.Collections.DictionaryBase>类派生的类型）中插入和标识对象。 <xref:System.Object.GetHashCode%2A>方法为需要快速检查对象相等性的算法提供此哈希代码。  
  
> [!NOTE]
>  有关哈希表中的哈希代码和其他哈希代码算法如何使用哈希代码的信息，请参阅维基百科中的[哈希函数](https://en.wikipedia.org/wiki/Hash_function)条目。  
  
 相等的两个对象返回的哈希代码相等。 但是，反之亦然：相等的哈希代码不意味着对象相等，因为不同（不相等）对象可以具有相同的哈希代码。 此外，.net 不保证<xref:System.Object.GetHashCode%2A>方法的默认实现，并且此方法返回的值可能在 .net 实现之间有所不同，例如 .NET Framework 和 .net Core 的不同版本以及平台（如32位和64位平台。 出于这些原因，请不要将此方法的默认实现用作唯一对象标识符以进行哈希处理。 下面是两个结果：  
  
-   不应假定相等哈希代码意味着对象相等。  
  
-   永远不应在创建它的应用程序域之外保留或使用哈希代码，因为相同的对象可能会在应用程序域、进程和平台之间进行哈希运算。  
  
> [!WARNING]
>  哈希代码适用于基于哈希表的集合中的高效插入和查找。 哈希代码不是永久值。 出于此原因：  
>   
> -   不要序列化哈希代码值或将其存储在数据库中。  
> -   不要使用哈希代码作为密钥来检索键控集合中的对象。  
> -   不要跨应用程序域或进程发送哈希代码。 在某些情况下，可以基于每个进程或每个应用程序域来计算哈希代码。  
> -   如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。 对于加密哈希，请使用派生自<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>类的类。  
> -   不要测试哈希代码是否相等，以确定两个对象是否相等。 （不相等的对象可以具有相同的哈希代码。）若要测试是否相等，请<xref:System.Object.ReferenceEquals%2A>调用<xref:System.Object.Equals%2A>或方法。  
  
 <xref:System.Object.GetHashCode%2A>方法可由派生类型重写。 如果<xref:System.Object.GetHashCode%2A>未重写，则通过<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>调用基类的方法计算引用类型的哈希代码，该方法根据对象的引用计算哈希代码; 有关详细信息，请参阅<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 换言之，该<xref:System.Object.ReferenceEquals%2A>方法返回`true`的两个对象具有相同的哈希代码。 如果值类型不重写<xref:System.Object.GetHashCode%2A>，则<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基类的方法使用反射根据类型字段的值来计算哈希代码。 换句话说，其字段具有相等值的值类型具有相同的哈希代码。 有关替代<xref:System.Object.GetHashCode%2A>的详细信息，请参阅 "对继承者的说明" 部分。  
  
> [!WARNING]
>  如果重写<xref:System.Object.GetHashCode%2A>方法，则还应重写<xref:System.Object.Equals%2A>，反之亦然。 如果在测试<xref:System.Object.Equals%2A>两个`true`对象是否相等时重写的方法返回， <xref:System.Object.GetHashCode%2A>则重写的方法必须为这两个对象返回相同的值。  
  
 如果用作哈希表中的键的对象不提供有用的<xref:System.Object.GetHashCode%2A>实现，则可以通过向<xref:System.Collections.Hashtable>类构造函数的重载之一<xref:System.Collections.IEqualityComparer>提供实现来指定哈希代码提供程序。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当你在[!INCLUDE[wrt](~/includes/wrt-md.md)]中<xref:System.Object.GetHashCode%2A>的类上调用方法时，它将为不重写<xref:System.Object.GetHashCode%2A>的类提供默认行为。 这是 .NET Framework 为[!INCLUDE[wrt](~/includes/wrt-md.md)]提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时的 .NET Framework 支持](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)）。 中的[!INCLUDE[wrt](~/includes/wrt-md.md)]类不继承<xref:System.Object>，当前未实现。 <xref:System.Object.GetHashCode%2A> 但是，当<xref:System.Object.ToString%2A>你在C#或 Visual Basic <xref:System.Object.Equals%28System.Object%29>代码中<xref:System.Object.GetHashCode%2A>使用它们时，它们看起来具有、和方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]用C#或 Visual Basic 编写的<xref:System.Object.GetHashCode%2A>类可以重写方法。  
  
   
  
## Examples  
 为具有相同或更小范围<xref:System.Int32>的数字值计算哈希代码的最简单方法之一是只返回该值。 下面的示例演示了一个`Number`结构的实现。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常，类型具有多个数据字段，这些字段可参与生成哈希代码。 生成哈希代码的一种方法是使用`XOR (eXclusive OR)`操作来合并这些字段，如以下示例中所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前面的示例返回相同的哈希代码（n1、n2）和（n2，n1），因此可能会产生比预期更多的冲突。 提供了许多解决方案，以便这些情况下的哈希代码不完全相同。 一种是返回`Tuple`对象的哈希代码，该对象反映每个字段的顺序。 下面的示例演示使用<xref:System.Tuple%602>类的可能的实现。 但请注意，实例化`Tuple`对象的性能开销可能会显著影响在哈希表中存储大量对象的应用程序的整体性能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二种替代解决方案涉及通过将连续字段的哈希代码左移两位或更多位，来加权单个哈希代码。 最佳方式，而不是被丢弃，超过位31的位应换行，而不是丢弃。 由于C#和 Visual Basic 中的左移运算符会丢弃 bits，这需要创建左移和换行方法，如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 然后，下面的示例使用此 shift 和 wrap 方法计算前面的示例中使用的`Point`结构的哈希代码。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>使用哈希函数可以快速生成与对象的值相对应的数字（哈希代码）。 哈希函数通常是特定于每个类型的，因此，为实现唯一性，必须使用至少一个实例字段作为输入。 不应使用静态字段的值来计算哈希代码。  
  
对于派生自<see cref="T:System.Object" />的类，只有当派生类将相等定义<see cref="M:System.Object.GetHashCode" />为引用相等性时，该<see langword="GetHashCode" />方法才能委托给基类实现。 <see cref="M:System.Object.GetHashCode" />对于引用类型，的默认实现返回的哈希代码等效于<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法返回的哈希代码。 可对不可<see cref="M:System.Object.GetHashCode" />变引用类型重写。 通常，对于可变引用类型，应仅在以下<see cref="M:System.Object.GetHashCode" />情况下重写： 
-可以计算不可变的字段中的哈希代码;或 
-可以确保可变对象的哈希代码在依赖于其哈希代码的集合中时不会更改。  
  
否则，你可能会认为可变对象会在哈希表中丢失。 如果选择替代<see cref="M:System.Object.GetHashCode" />可变引用类型，您的文档应清楚地说明，当对象存储在哈希表中时，您的类型的用户不应修改对象值。  
  
对于值类型， <see cref="M:System.ValueType.GetHashCode" />提供使用反射的默认哈希代码实现。 你应考虑重写它以获得更好的性能。  
  
 <block subset="none" type="note"><para>  
 有关以各种方式计算哈希代码的详细信息和示例，请参阅 "示例" 部分。  
  
</para></block>  
  
 哈希函数必须具有以下属性： 
-如果两个对象的比较结果相等<see cref="M:System.Object.GetHashCode" /> ，则每个对象的方法必须返回相同的值。 但是，如果两个对象的比较结果不相等， <see cref="M:System.Object.GetHashCode" />则这两个对象的方法不必返回不同的值。  
  
-对于<see cref="M:System.Object.GetHashCode" />对象状态不会修改确定对象的[system.object](xref:System.Object.Equals*)方法返回值的对象状态，对象的方法必须始终返回相同的哈希代码。 请注意，这仅适用于当前执行的应用程序，并且如果重新运行应用程序，则可以返回不同的哈希代码。  
  
-为了获得最佳性能，哈希函数应为所有输入生成偶数分布，其中包括大量聚集输入。 这意味着，对对象状态的小修改应该会导致对生成的哈希代码进行较大的修改，以获得最佳的哈希表性能。  
  
-哈希函数的计算成本应较低。  
  
<see cref="M:System.Object.GetHashCode" /> -方法不应引发异常。  
  
例如， <see cref="M:System.String.GetHashCode" /> <see cref="T:System.String" />类提供的方法的实现返回相同字符串值的相同哈希代码。 因此，如果<see cref="T:System.String" />两个对象表示相同的字符串值，则它将返回相同的哈希代码。 此外，该方法使用字符串中的所有字符生成合理随机分发的输出，即使在某些范围内对输入进行群集（例如，许多用户的字符串可能只包含低于128的 ASCII 字符，但字符串可以包含任何 65535 Unicode 字符）。  
  
在类上提供良好的哈希函数可能会显著影响将这些对象添加到哈希表的性能。 在具有提供哈希函数的良好实现的键的哈希表中，搜索元素会采用固定时间（例如，O （1）操作）。 在包含哈希函数实现的哈希表中，搜索的性能取决于哈希表中的项数（例如，O （`n`）运算），其中`n`是哈希表中的项数。 恶意用户可以输入增加冲突数量的数据，这可能会显著降低依赖于哈希表的应用程序的性能，但在以下情况下： 
-哈希函数产生频繁冲突。  
  
-当哈希表中的大量对象产生相等或近似相等的哈希代码时。  
  
-当用户输入从中计算哈希代码的数据时。  
  
重写<see cref="M:System.Object.GetHashCode" />的派生类还必须<see cref="M:System.Object.Equals(System.Object)" />重写以确保两个被视为相等的对象具有相同的哈希<see cref="T:System.Collections.Hashtable" />代码; 否则，该类型可能无法正常工作。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的 <see cref="T:System.Type" />。</summary>
        <returns>当前实例的准确运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为<xref:System.Object?displayProperty=nameWithType>是 .net 类型系统中所有类型的基类<xref:System.Object.GetType%2A> ，所以方法可用于返回<xref:System.Type>表示所有 .net 类型的对象。 .NET 可识别以下五类类型：  
  
-   派生自<xref:System.Object?displayProperty=nameWithType>的类  
  
-   值类型，派生自<xref:System.ValueType?displayProperty=nameWithType>。  
  
-   接口，从<xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0 开始派生。  
  
-   派生自<xref:System.Enum?displayProperty=nameWithType>的枚举。  
  
-   委托，派生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 如果两个`x`对象`y`具有相同的运行时类型`Object.ReferenceEquals(x.GetType(),y.GetType())` ， `true`则返回。 下面的示例将<xref:System.Object.GetType%2A>方法<xref:System.Object.ReferenceEquals%2A>与方法一起使用，以确定一个数值是否为与另外两个数值相同的类型。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  若要确定某个对象是否为特定类型，可以使用您的语言的类型比较关键字或构造。 例如，你可以在中使用`TypeOf…Is` Visual Basic `is`或关键字中的构造C#。  
  
 此<xref:System.Object.GetType%2A>方法由派生自<xref:System.Object>的所有类型继承。 这意味着，除了使用自己的语言的比较关键字外，还可以使用<xref:System.Object.GetType%2A>方法来确定特定对象的类型，如下面的示例所示。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 对象公开与当前<xref:System.Object>的类关联的元数据。 <xref:System.Type>  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Object.GetType%2A>返回当前实例的运行时类型。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Object" /> 的浅表副本。</summary>
        <returns>当前 <see cref="T:System.Object" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>方法创建一个浅表副本，方法是创建一个新的对象，然后将当前对象的非静态字段复制到新的对象。 如果字段是值类型，则执行字段的逐位副本。 如果字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象及其复本引用相同的对象。  
  
 例如，假设有一个名为 X 的对象引用对象 A 和 B。对象 B 反过来引用对象 C。X 的浅表副本创建新的对象 X2，后者同时引用对象 A 和 B。与之相比，X 的深层副本会创建一个新的对象 X2，该对象引用作为 A 和 B 的副本的新对象 A2 和 B2，进而引用新的对象 C2，这是 C 的副本。该示例说明了浅层和深层复制操作之间的差异。  
  
 如果<xref:System.Object.MemberwiseClone%2A>方法执行的浅层复制操作不能满足您的需要，可以通过多种方式实现深层复制操作。 其中包括：  
  
-   调用要复制的对象的类构造函数，以创建具有从第一个对象获取的属性值的第二个对象。 这假设对象的值由其类构造函数完全定义。  
  
-   <xref:System.Object.MemberwiseClone%2A>调用方法以创建对象的浅表副本，然后将新对象的值与原始对象的值相同，分配给任何属性或其值为引用类型的字段。 该`DeepCopy`示例中的方法演示了这种方法。  
  
-   序列化要深层复制的对象，然后将序列化的数据还原到其他对象变量。  
  
-   使用带有递归的反射来执行深层复制操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Object.MemberwiseClone%2A>方法。 它定义了`ShallowCopy`一种方法， <xref:System.Object.MemberwiseClone%2A>该方法调用方法以对`Person`对象执行浅表复制操作。 它还定义了`DeepCopy`对`Person`对象执行深层复制操作的方法。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 在此示例中， `Person.IdInfo`属性`IdInfo`返回对象。 如示例的输出所`Person`示，当通过<xref:System.Object.MemberwiseClone%2A>调用方法克隆对象时，克隆`Person`的对象是原始对象的独立副本，只不过它们共享相同`Person.IdInfo`的对象引用。 因此，修改克隆的`Person.IdInfo`属性会更改原始对象的`Person.IdInfo`属性。 另一方面，执行深层复制操作时，可以修改克隆`Person`的对象（包括其`Person.IdInfo`属性），而不会影响原始对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</summary>
        <returns>如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或两者均为 null，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法和相等运算符不同<xref:System.Object.ReferenceEquals%2A> ，方法不能被重写。 <xref:System.Object.Equals%2A> 因此，如果要测试两个对象引用是否相等，并且不确定`Equals`方法的实现，则可以<xref:System.Object.ReferenceEquals%2A>调用方法。  
  
 但是，在这两种情况<xref:System.Object.ReferenceEquals%2A>下，方法的返回值可能看起来是异常的：  
  
-   比较值类型时。 如果`objA` <xref:System.Object.ReferenceEquals%2A>和`objB`是值类型，则在将其传递给方法之前将它们装箱。 这意味着，如果和`objA` `objB`均表示值类型的同一个实例，则<xref:System.Object.ReferenceEquals%2A>方法仍返回`false`，如下面的示例所示。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     有关装箱值类型的信息，请参阅[装箱和取消装箱](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。  
  
-   比较字符串时。 如果`objA` <xref:System.Object.ReferenceEquals%2A> `true`和`objB`是字符串，则在暂存字符串时，方法将返回。 它不会执行值相等性测试。  在下面的示例中`s1` ， `s2`和相等，因为它们是单个暂存字符串的两个实例。 不过， `s3`和`s4`不相等，因为虽然它们具有相同的字符串值，但不会对该字符串进行暂留。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     有关字符串暂留的详细信息， <xref:System.String.IsInterned%2A?displayProperty=nameWithType>请参阅。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Object.ReferenceEquals%2A>确定两个对象是否为同一个实例。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前对象的字符串。</summary>
        <returns>表示当前对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>是 .NET Framework 中的主要格式设置方法。 它将对象转换为其字符串表示形式，以便它适合于显示。 （有关 .NET Framework 中格式设置支持的信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。）<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法的默认实现返回对象类型的完全限定名称。  
  
> [!IMPORTANT]
>  您可能已通过从另一类型成员列表中的链接来访问此页。 这是因为该类型不会重<xref:System.Object.ToString%2A?displayProperty=nameWithType>写。 相反，它将继承<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法的功能。  
  
 类型经常重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供更适合特定类型的字符串表示形式。 类型还经常重载<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供对格式字符串或区分区域性的格式设置的支持。  
  
 本节内容：  
  
 [默认的对象 ToString （）方法](#Default)   
 [重写对象 ToString （）方法](#Overriding)   
 [重载 ToString 方法](#Overloading)   
 [扩展对象 ToString 方法](#Extending)   
 [Windows 运行时的说明](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>默认的对象 ToString （）方法  
 <xref:System.Object.ToString%2A>方法的默认实现返回的类型<xref:System.Object>的完全限定名称，如下面的示例所示。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 由于<xref:System.Object>是 .NET Framework 中所有引用类型的基类，因此此行为是由不<xref:System.Object.ToString%2A>重写方法的引用类型继承的。 下面的示例阐释了这一点。 它定义一个名为`Object1`的类，该类接受所有<xref:System.Object>成员的默认实现。 其<xref:System.Object.ToString%2A>方法返回对象的完全限定类型名称。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>重写对象 ToString （）方法  
 类型通常会重<xref:System.Object.ToString%2A?displayProperty=nameWithType>写方法以返回表示对象实例的字符串。 例如， <xref:System.Char>基类型（如、 <xref:System.Int32>和<xref:System.String> ）提供<xref:System.Object.ToString%2A>的实现返回对象所表示的值的字符串形式。 下面的示例定义了一个类`Object2`，用于<xref:System.Object.ToString%2A>重写方法以返回类型名称及其值。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 下表列出了 .net 中的类型类别，并指示它们是否重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
|类型类别|重写对象 ToString （）|行为|  
|-------------------|-----------------------------------|--------------|  
|类|n/a|n/a|  
|结构|是（<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>）|与 `Object.ToString()` 相同|  
|枚举|是（<xref:System.Enum.ToString?displayProperty=nameWithType>）|成员名称|  
|接口|No|n/a|  
|委托|No|n/a|  
  
 有关替代<xref:System.Object.ToString%2A>的其他信息，请参阅对继承者的说明部分。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>重载 ToString 方法  
 除了重写无参数<xref:System.Object.ToString?displayProperty=nameWithType>的方法之外，许多类型还`ToString`重载方法以提供接受参数的方法的版本。 最常见的是，这样做是为了提供对可变格式设置和区分区域性的格式设置的支持。  
  
 下面的示例重载`ToString`方法以返回一个结果字符串，其中包含`Automobile`类的各个字段的值。 它定义了四个格式字符串： G，它返回模型名称和年份;D：返回模型名称、年份和门的数量;C，返回柱面的名称、年份和数量;和，返回包含所有四个字段值的字符串。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 下面的示例调用重载<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>的方法，以显示货币值的区分区域性的格式设置。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 有关格式字符串和区分区域性的格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。 有关数字值支持的格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 有关日期和时间值支持的格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>扩展对象 ToString 方法  
 因为类型继承了默认<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，所以你可能会发现它不需要的行为，并需要对其进行更改。 这对于数组和集合类尤其如此。 尽管可能需要`ToString`数组或集合类的方法来显示其成员的值，但它将显示类型完全限定的类型名称，如下面的示例所示。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 您可以使用多个选项来生成所需的结果字符串。  
  
-   如果类型是数组、集合对象或实现<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>接口的对象，则可以使用中`foreach` C#的语句或 Visual Basic 中的`For Each...Next`构造来枚举其元素。  
  
-   如果`sealed`类不是（在中C#）或`NotInheritable` （在 Visual Basic 中），则可以开发从要自定义其<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法的基类继承的包装类。 至少需要执行以下操作：  
  
    1.  实现任何所需的构造函数。 派生类不继承它们的基类构造函数。  
  
    2.  重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以返回所需的结果字符串。  
  
     下面的示例定义了<xref:System.Collections.Generic.List%601>类的包装类。 它重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以显示集合的每个方法的值，而不是完全限定的类型名称。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   开发可返回所需结果字符串的[扩展方法](~/docs/standard/design-guidelines/extension-methods.md)。 请注意，不能以这<xref:System.Object.ToString%2A?displayProperty=nameWithType>种方式重写默认方法（即，扩展类（in C#）或模块（在 Visual Basic 中）不能具有名`ToString`为的无参数方法，此方法可调用以替代原始类型的 `ToString`方法。 必须为无参数`ToString`替换提供其他名称。  
  
     下面<xref:System.Collections.Generic.List%601>的示例定义扩展类的两个方法：一个无参数`ToString2`的方法， `ToString` <xref:System.String>以及一个具有表示格式字符串的参数的方法。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当你在[!INCLUDE[wrt](~/includes/wrt-md.md)]中<xref:System.Object.ToString%2A>的类上调用方法时，它将为不重写<xref:System.Object.ToString%2A>的类提供默认行为。 这是 .NET Framework 为[!INCLUDE[wrt](~/includes/wrt-md.md)]提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时的 .NET Framework 支持](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)）。 中的[!INCLUDE[wrt](~/includes/wrt-md.md)]类不会<xref:System.Object>继承， <xref:System.Object.ToString%2A>也不总是实现。 但是，当<xref:System.Object.ToString%2A>你在C#或 Visual Basic 代码<xref:System.Object.Equals%28System.Object%29>中使用<xref:System.Object.GetHashCode%2A>它们时，它们始终具有、和方法，并且 .NET Framework 为这些方法提供了默认行为。  
  
 从开始[!INCLUDE[wrt](~/includes/wrt-md.md)] <xref:System.Object.ToString%2A?displayProperty=nameWithType>，公共语言运行时将对对象使用 IStringable，然后再回退到的默认实现。 [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]用C#或 Visual Basic 编写的<xref:System.Object.ToString%2A>类可以重写方法。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 接口  
 [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) <xref:System.Object.ToString%2A?displayProperty=nameWithType> [!INCLUDE[wrt](~/includes/wrt-md.md)] [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)从开始，包含一个 IStringable 接口，该接口的单一方法 IStringable 提供与提供的基本格式设置支持。 [!INCLUDE[win81](~/includes/win81-md.md)] 若要防止歧义，不应在托管类型上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
 当本机代码或使用 JavaScript 或C++/cx 等语言编写的代码调用托管对象时，它们看起来实现了[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 公共语言运行时将从[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)到的调用自动将调用<xref:System.Object.ToString%2A?displayProperty=nameWithType>路由到，事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)未在托管对象上实现。  
  
> [!WARNING]
>  由于公共语言运行时自动实现应用[](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]所有托管类型的 IStringable，因此，我们建议你不要提供自己的[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现。 在[](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)从`ToString` 、 [!INCLUDE[wrt](~/includes/wrt-md.md)] /cx 或 JavaScript 调用时， C++实现 IStringable 可能会导致意外的行为。  
  
 如果选择在[!INCLUDE[wrt](~/includes/wrt-md.md)]组件中导出的公共托管类型中实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，则以下限制适用：  
  
-   只能在 "类实现" 关系中定义[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口，例如  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     接  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     口。  
  
-   无法在接口上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
-   不能将参数声明为[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)类型。  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能是方法、属性或字段的返回类型。  
  
-   你无法通过使用如下所示的方法定义，从基类中隐藏[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反， [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现必须始终重写基类实现。 只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。  
  
 请注意，在各种条件下，从本机代码到实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隐藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现的托管类型的调用可能会产生意外行为。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现自己的类型时，应重写<see cref="M:System.Object.ToString" />方法以返回对这些类型有意义的值。 需要更好地控制格式设置<see cref="M:System.Object.ToString" />的派生类可以<see cref="T:System.IFormattable" />实现接口。 它<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />的方法使你能够定义用于控制格式设置的格式字符串， <see cref="T:System.IFormatProvider" />并使用可为区域性特定的格式设置提供的对象。  
  
<see cref="M:System.Object.ToString" />方法的重写应遵循以下准则： 
-返回的字符串应该是友好的，可供人们阅读。  
  
-返回的字符串应唯一标识对象实例的值。  
  
-返回的字符串应尽可能短，以便调试器能够显示它。  
  
-重写不应返回<see cref="F:System.String.Empty" />或为空字符串。 <see cref="M:System.Object.ToString" />  
  
<see cref="M:System.Object.ToString" /> -重写不应引发异常。  
  
-如果实例的字符串表示形式区分区域性或可通过多种方式进行格式化，则实现<see cref="T:System.IFormattable" />接口。  
  
-如果返回的字符串包含敏感信息，则应首先请求适当的权限。 如果请求成功，则可以返回敏感信息;否则，应返回排除敏感信息的字符串。  
  
<see cref="M:System.Object.ToString" /> -重写应没有可观察到的副作用，以避免调试中的复杂。 例如，对<see cref="M:System.Object.ToString" />方法的调用不应更改实例字段的值。  
  
-如果您的类型实现了分析方法（ <see langword="Parse" />或<see langword="TryParse" />方法、构造函数或从字符串实例化类型实例的其他静态方法），则应确保该<see cref="M:System.Object.ToString" />方法返回的字符串可以是转换为对象实例的。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
  </Members>
</Type>
