<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="27a5a54cf0b066193ccd803fbf6159e1a3ce530f" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67250288" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持 .NET 类层次结构中的所有类，并为派生类提供低级别服务。 这是所有 .NET 类的最终基类；它是类型层次结构的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语言通常不需要的类声明从继承<xref:System.Object>因为继承是隐式。  
  
 因为.NET 中的所有类都派生自<xref:System.Object>，在中定义的每个方法<xref:System.Object>类是所有的对象中的可用系统中。 派生类可以和重写其中的某些方法，包括：  
  
-   <xref:System.Object.Equals%2A> -支持对象之间的比较。  
  
-   <xref:System.Object.Finalize%2A> -自动回收对象之前，请执行清理操作。  
  
-   <xref:System.Object.GetHashCode%2A> 生成对应于对象的值的数字，以支持使用哈希表。  
  
-   <xref:System.Object.ToString%2A> — 生成描述类的实例的用户可读文本字符串。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果您正在设计的类，如集合，必须处理任何类型的对象，可以创建接受的实例的类成员<xref:System.Object>类。 但是，装箱和取消装箱类型的过程会带来性能开销。 如果您知道您的新类将频繁地处理某些值类型可以使用两个策略之一来装箱的成本降至最低。  
  
-   创建一个接受的常规方法<xref:System.Object>类型和一组特定于类型的方法重载接受每个类要频繁处理预期的值类型。 如果存在的特定于类型的方法接受调用的参数类型，没有值类型装箱会发生，并调用特定于类型的方法。 如果没有任何方法自变量调用的参数类型相匹配，该参数进行装箱，并调用常规方法。  
  
-   设计你的类型和其成员来使用泛型。 创建您的类的实例并指定泛型类型参数时，公共语言运行时将创建封闭式泛型类型。 泛型方法是特定于类型，可以不装箱调用参数的情况下调用。  
  
 虽然有时很有必要，若要开发通用类，接受并返回<xref:System.Object>类型，您可以通过提供特定于类型的类来处理常用的类型提高性能。 例如，提供特定于设置和获取布尔值的类消除了装箱和取消装箱的布尔值的成本。  
  
   
  
## Examples  
 下面的示例定义一个派生自类型<xref:System.Object>并重写虚拟方法的许多<xref:System.Object>类。 此外，该示例演示如何调用许多静态和实例方法的<xref:System.Object>类。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员是线程安全。 不保证实例成员都是线程安全。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类中的构造函数调用此构造函数，但它还可用于直接创建的实例<xref:System.Object>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个对象实例是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前对象。</summary>
        <returns>如果指定的对象等于当前对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例比较的类型和`obj`参数取决于当前实例是引用类型或值类型。  
  
-   如果当前实例是引用类型，<xref:System.Object.Equals%28System.Object%29>方法测试的引用相等性，并调用<xref:System.Object.Equals%28System.Object%29>方法相当于调用<xref:System.Object.ReferenceEquals%2A>方法。 引用相等性指进行比较的对象变量引用同一对象。 下面的示例说明了此类比较的结果。 它定义`Person`类，该类是引用类型，并调用`Person`类构造函数来实例化两个新`Person`对象，`person1a`和`person2`，其中具有相同的值。 它还会将分配`person1a`到另一个对象变量， `person1b`。 如示例所示，输出`person1a`和`person1b`因为它们引用同一个对象是否相等。 但是，`person1a`和`person2`是否不相等，尽管它们具有相同的值。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   如果当前实例是值类型，<xref:System.Object.Equals%28System.Object%29>方法测试的值相等性。 值相等性意味着：  
  
    -   两个对象都属于同一类型。 如下面的示例所示，<xref:System.Byte>的值为 12 的对象不等于<xref:System.Int32>的值为 12，因为两个对象具有不同的运行时类型的对象。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   两个对象的公共和私有字段的值相等。 下面的示例测试值相等。 它定义`Person`结构，它是值类型，并调用`Person`类构造函数来实例化两个新`Person`对象，`person1`和`person2`，其中具有相同的值。 如示例输出所示，虽然两个对象变量引用不同的对象，但`person1`并`person2`相等，因为它们具有相同的值为私有`personName`字段。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 因为<xref:System.Object>类是.NET Framework 中的所有类型的基类<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法对于所有其他类型提供默认的相等性比较。 但是，类型通常覆盖<xref:System.Object.Equals%2A>方法来实现值相等性。 有关详细信息，请参阅说明调用方和说明的继承者节。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当您调用<xref:System.Object.Equals%28System.Object%29>中的类上的方法重载[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不替代的类提供的默认行为<xref:System.Object.Equals%28System.Object%29>。 这是.NET Framework 提供了有关支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持的 Windows 应用商店应用程序和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并不实现<xref:System.Object.Equals%28System.Object%29>方法。 但是，它们显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 提供的默认行为，这些方法时。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 在 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.Equals%28System.Object%29>方法重载。  
  
## <a name="notes-for-callers"></a>调用方的说明  
 经常重写派生的类<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法来实现值相等性。 此外，类型也经常提供到另一个强类型的重载`Equals`方法，通常通过实现<xref:System.IEquatable%601>接口。 当您调用`Equals`方法来测试相等性，您应该知道的当前实例是否重写<xref:System.Object.Equals%2A?displayProperty=nameWithType>，并了解如何为特定的调用`Equals`方法得到解决。 否则为你可能要为确定相等性不同于您的预期，执行测试，该方法可能返回意外的值。  
  
 下面的示例进行了这方面的演示。 它实例化三<xref:System.Text.StringBuilder>具有相同的字符串对象，并将对四个调用`Equals`方法。 第一种方法调用返回`true`，和剩余的三个返回`false`。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 在第一个的情况下，强类型化<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>方法重载，它的值相等性测试，名为。 因为这些字符串分配到两个<xref:System.Text.StringBuilder>对象是否相等，则该方法返回`true`。 但是，<xref:System.Text.StringBuilder>不重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。 正因为如此，当<xref:System.Text.StringBuilder>对象强制转换为<xref:System.Object>，当<xref:System.Text.StringBuilder>实例分配给类型的变量<xref:System.Object>，以及何时<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法传递两个<xref:System.Text.StringBuilder>的对象，默认<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>调用方法。 因为<xref:System.Text.StringBuilder>是引用类型，这相当于将传递两个<xref:System.Text.StringBuilder>对象添加到<xref:System.Object.ReferenceEquals%2A>方法。 虽然所有这三个<xref:System.Text.StringBuilder>对象包含相同的字符串，它们是指三个不同的对象。 因此，以下三个方法调用返回`false`。  
  
 您可以通过调用比较当前对象与另一个对象引用相等性<xref:System.Object.ReferenceEquals%2A>方法。 在 Visual Basic 中，您还可以使用`is`关键字 (例如， `If Me Is otherObject Then ...`)。  
  
## <a name="notes-for-inheritors"></a>继承者说明  
 在定义您自己的类型时，该类型继承定义的功能`Equals`其基类型的方法。 下表列出的默认实现`Equals`主要类别的.NET Framework 中的类型的方法。  
  
|类型类别|所定义的相等|注释|  
|-------------------|-------------------------|--------------|  
|直接从派生类 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性;等效于调用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|结构|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等性;直接逐字节比较或使用反射的逐个字段比较。|  
|枚举|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必须具有相同的枚举类型和相同的基础值。|  
|委托|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委托必须具有相同的调用列表的相同类型。|  
|接口|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性。|  
  
 对于值类型，则应始终重写<xref:System.Object.Equals%2A>，这是因为依赖反射的相等性测试产品/服务性能不佳。 此外可以重写的默认实现<xref:System.Object.Equals%2A>对于引用类型的值是否相等，而不是引用相等性测试并定义值相等性的精确意义。 此类实现<xref:System.Object.Equals%2A>返回`true`如果两个对象具有相同的值，即使它们不是同一个实例。 该类型的实施者决定什么构成对象的值，但通常某些或所有存储的数据对象的实例变量中。 例如，值<xref:System.String>对象所基于的; 在字符串的字符<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>方法重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法以返回`true`对于任何两个字符串包含相同的字符顺序相同的实例。  
  
 下面的示例演示如何重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法来测试值相等性。 它将替代<xref:System.Object.Equals%2A>方法`Person`类。 如果`Person`接受的相等性，其基本类实现两个`Person`对象会引用单个对象，它们才相等。 但是，在这种情况下，两个`Person`对象是否相等，如果它们具有相同的值为`Person.Id`属性。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 除了重写<xref:System.Object.Equals%2A>，可以实现<xref:System.IEquatable%601>接口，以提供强类型化的测试相等性。  
  
 下面的语句必须为 true 的所有实现<xref:System.Object.Equals%28System.Object%29>方法。 在列表中， `x`， `y`，并`z`表示对象引用了不**null**。  
  
-   `x.Equals(x)` 返回`true`，涉及浮点类型的情况除外。 请参阅[ISO/IEC/IEEE 60559:2011、 信息技术-微处理器系统-浮点算术](https://www.iso.org/standard/57469.html)。  
  
-   `x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。  
  
-   `x.Equals(y)` 返回`true`如果这两个`x`并`y`是`NaN`。  
  
-   如果`(x.Equals(y) && y.Equals(z))`将返回`true`，然后`x.Equals(z)`返回`true`。  
  
-   后续调用`x.Equals(y)`返回相同的值，只要引用的对象`x`和`y`不会被修改。  
  
-   `x.Equals(null)` 返回 `false`。  
  
 实现<xref:System.Object.Equals%2A>不得引发异常; 它们应始终返回一个值。 例如，如果`obj`是`null`，则<xref:System.Object.Equals%2A>方法应返回`false`而不是引发<xref:System.ArgumentNullException>。  
  
 重写时，请遵循以下准则<xref:System.Object.Equals%28System.Object%29>:  
  
-   类型实现<xref:System.IComparable>必须重写<xref:System.Object.Equals%28System.Object%29>。  
  
-   类型重写<xref:System.Object.Equals%28System.Object%29>还必须重写<xref:System.Object.GetHashCode%2A>; 否则为哈希表可能无法正常工作。  
  
-   您应该考虑实施<xref:System.IEquatable%601>接口以支持强类型化测试是否相等。 你<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>实现应返回与一致的结果<xref:System.Object.Equals%2A>。  
  
-   如果您的编程语言支持运算符重载，并且重载相等运算符对于给定的类型，还必须重写<xref:System.Object.Equals%28System.Object%29>方法以返回与相等运算符相同的结果。 这有助于确保使用该类库代码<xref:System.Object.Equals%2A>(如<xref:System.Collections.ArrayList>和<xref:System.Collections.Hashtable>) 的行为方式与应用程序代码使用相等运算符的方法一致。  
  
### <a name="guidelines-for-reference-types"></a>对于引用类型的指导原则  
 以下准则适用于重写<xref:System.Object.Equals%28System.Object%29>为引用类型：  
  
-   考虑重写<xref:System.Object.Equals%2A>如果类型的语义是基于对的这一事实，该类型表示某些值。  
  
-   大多数引用类型必须不能重载相等运算符，即使它们重写<xref:System.Object.Equals%2A>。 但是，如果要实现一个引用类型，用于具有值的语义，如复杂的数字类型，必须重写相等运算符。  
  
-   不应重写<xref:System.Object.Equals%2A>可变引用类型上。 这是因为在重写<xref:System.Object.Equals%2A>需要，还可以覆盖<xref:System.Object.GetHashCode%2A>方法，如在上一部分中所述。 这意味着在其生存期内，这可能导致丢失的对象的哈希表中可以更改可变引用类型的实例的哈希代码。  
  
### <a name="guidelines-for-value-types"></a>对于值类型的指导原则  
 以下准则适用于重写<xref:System.Object.Equals%28System.Object%29>对于值类型：  
  
-   如果您要定义包含一个或多个字段的值类型的值是引用类型，则应重写<xref:System.Object.Equals%28System.Object%29>。 <xref:System.Object.Equals%28System.Object%29>提供实现<xref:System.ValueType>执行逐字节比较，对于值类型，它的字段都是值类型，但它使用反射来执行的字段包含引用类型的值类型按字段比较。  
  
-   如果重写<xref:System.Object.Equals%2A>和您的开发语言支持运算符重载，则必须重载相等运算符。  
  
-   应实现<xref:System.IEquatable%601>接口。 调用强类型化<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可避免装箱`obj`参数。  
  
   
  
## Examples  
 下面的示例演示`Point`类，并重写<xref:System.Object.Equals%2A>方法以提供值相等性和一个`Point3D`类派生自`Point`。 因为`Point`重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>来测试值相等性<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>不会调用方法。 但是，`Point3D.Equals`调用`Point.Equals`因为`Point`实现<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供值相等性的方式。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals`方法检查，确保`obj`参数不是**null**和它引用此对象与相同类型的实例。 如果任一检查失败，该方法返回`false`。  
  
 `Point.Equals`方法调用<xref:System.Object.GetType%2A>方法来确定两个对象的运行时类型是否相同。 如果使用的方法的窗体复选`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中，检查将返回`true`情况下在其中`obj`是派生的类的实例`Point`，即使`obj`和当前实例不属于相同的运行时类型。 验证这两个对象是否相同的类型，方法强制转换`obj`键入`Point`并返回比较两个对象的实例字段的结果。  
  
 在中`Point3D.Equals`，继承`Point.Equals`方法，这会重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>，任何其他操作完成之前调用。 因为`Point3D`是一个密封的类 (在 Visual Basic 中为 `NotInheritable`)，签入窗体`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中是足以确保`obj`是`Point3D`对象。 如果它是`Point3D`对象，它被强制转换为`Point`对象，并传递到基类实现的<xref:System.Object.Equals%2A>。 仅当继承`Point.Equals`方法将返回`true`没有方法比较`z`实例在派生类中引入的字段。  
  
 下面的示例定义`Rectangle`类，该类在内部实现为两个矩形`Point`对象。 `Rectangle`类还重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供的值是否相等。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 C# 和 Visual Basic 等某些语言支持运算符重载。 当某个类型重载相等运算符时，它还必须重写<xref:System.Object.Equals%28System.Object%29>方法以提供相同的功能。 这通常通过编写实现<xref:System.Object.Equals%28System.Object%29>方面重载的相等运算符，如以下示例所示的方法。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 因为`Complex`是值类型，不能从派生。  因此，对重写<xref:System.Object.Equals%28System.Object%29>方法无需调用<xref:System.Object.GetType%2A>若要确定精确的运行时键入的每个对象，但可以改为使用`is`C# 中的运算符或`TypeOf`运算符在 Visual Basic 中检查的类型`obj`参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的对象实例是否被视为相等。</summary>
        <returns>如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法指示是否两个对象，`objA`和`objB`，是否相等。 它还使您要测试其值为的对象**null**是否相等。 它将进行比较`objA`和`objB`为确定相等性，如下所示：  
  
-   它确定两个对象是否表示相同的对象引用。 如果这样，该方法返回`true`。 此测试是否等效于调用<xref:System.Object.ReferenceEquals%2A>方法。 此外，如果这两个`objA`并`objB`都**null**，该方法将返回`true`。  
  
-   它确定是否是`objA`或`objB`是**null**。 如果有，则返回`false`。  
  
-   如果两个对象不表示相同的对象引用，并且二者均**null**，它将调用`objA`。`Equals`(`objB`) 并返回结果。 这意味着，如果`objA`重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，调用此重写。  
  
   
  
## Examples  
 下面的示例阐释<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法并将其与比较<xref:System.Object.ReferenceEquals%2A>方法。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用于执行清理操作销毁该对象前所持有的当前对象的非托管资源。 该方法受保护，因此仅通过此类或派生类可访问。  
  
 本节内容：  
  
-   [终止的工作原理](#How)  
  
-   [实施者的说明](#Notes)  
  
-   [SafeHandle 备用方法](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>终止的工作原理  
 <xref:System.Object>类提供的实现不<xref:System.Object.Finalize%2A>方法，并在垃圾回收器将派生自的类型未标记<xref:System.Object>终止除非它们重写<xref:System.Object.Finalize%2A>方法。  
  
 如果类型重写<xref:System.Object.Finalize%2A>方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。 终止队列中包含托管堆垃圾回收器可以回收其内存之前，必须运行其终止代码中的所有对象的项。 然后，垃圾回收器调用<xref:System.Object.Finalize%2A>在以下情况下自动的方法：  
  
-   垃圾回收器已发现对象是不可访问，除非该对象具有已通过调用从终止免除后<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
-   **仅限.NET Framework 上**，在关闭应用程序域，除非该对象是免于终止的对象。 在关闭期间，最终完成甚至仍可访问的对象。  
  
 <xref:System.Object.Finalize%2A> 自动只调用一次的给定实例上的对象重新注册使用类似于一种机制，除非<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>和<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>尚未随后调用方法。  
  
 <xref:System.Object.Finalize%2A> 操作具有以下限制：  
  
-   当终结器执行的确切时间未定义。 若要确保您的类的实例实现的资源的确定性释放`Close`方法，或者提供<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现。  
  
-   两个对象的终结器不能保证任何特定顺序运行即使到另一个对象引用。 也就是说，如果对象 A 具有对对象 B 的引用，并且都具有终结器，	在对象 A 的终结器启动时，对象 B 可能已被终结。  
  
-   终结器运行的线程未指定。  
  
 <xref:System.Object.Finalize%2A>方法可能无法运行完成，或可能根本无法运行以下例外情况：  
  
-   如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。 由于运行时尝试运行终结器来完成，其他可能不调用终结器是如果终结器块无限期。  
  
-   如果在进程终止而无需使运行时有机会清理。 在这种情况下，运行时的第一次通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。  
  
 在运行时将继续完成在关闭过程的对象，仅当可终结对象数继续减少。  
  
 如果<xref:System.Object.Finalize%2A>或的重写<xref:System.Object.Finalize%2A>引发异常，并在运行时不重写默认策略的应用程序承载，运行时终止过程，并没有主动`try` / `finally`块或执行终结器。 如果终结器不能释放或销毁资源，此行为可确保进程的完整性。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>重写 Finalize 方法 
 应重写<xref:System.Object.Finalize%2A>使用非托管的资源，例如文件句柄或使用它们的托管的对象在垃圾回收期间将被丢弃时必须发布的数据库连接的类。 不应实现<xref:System.Object.Finalize%2A>方法管理的对象，因为垃圾回收器自动释放托管的资源。  
  
> [!IMPORTANT]
>  如果<xref:System.Runtime.InteropServices.SafeHandle>对象可包装非托管的资源，建议的替代项是实现使用安全句柄的释放模式并不重写<xref:System.Object.Finalize%2A>。 有关详细信息，请参阅[SafeHandle 备用方法](#SafeHandle)部分。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法默认情况下，不执行任何操作，但应重写<xref:System.Object.Finalize%2A>才有必要，并且只释放非托管的资源。 通常需要运行终止操作，如果要长得多，因为它需要至少两个垃圾回收回收内存。 此外，应重写<xref:System.Object.Finalize%2A>方法的引用类型。 公共语言运行时仅确定引用类型。 它将忽略值类型上的终结器。  

作用域<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法是`protected`。 在您的类中重写该方法时，您应维护此限制的作用域。 通过将保持<xref:System.Object.Finalize%2A>受保护的方法，您将阻止从调用对象的应用程序的用户<xref:System.Object.Finalize%2A>直接方法。
  
 每个实现<xref:System.Object.Finalize%2A>派生类型中必须调用其基类型实现<xref:System.Object.Finalize%2A>。 这是其中的应用程序代码可以调用的唯一情况<xref:System.Object.Finalize%2A>。 对象的<xref:System.Object.Finalize%2A>上任何对象，而非其基本类的方法不应调用一种方法。 这是因为被调用的其他对象可能在被回收时调用的对象，如在公共语言运行时关闭的情况下。 
  
> [!NOTE]
>  C# 编译器不允许你重写<xref:System.Object.Finalize%2A>方法。 相反，通过实现提供终结器[析构函数](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)为您的类。 C# 析构函数自动调用其基类的析构函数。  
>   
>  VisualC++还提供用于实现其自己的语法<xref:System.Object.Finalize%2A>方法。 有关详细信息，请参阅的"析构函数和终结器"部分[如何：定义和使用类和结构 (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)。  
  
 垃圾回收是不确定的因为您不知道准确地说当垃圾回收器执行终止。 释放资源立即，您还可以选择实现[释放模式](~/docs/standard/garbage-collection/implementing-dispose.md)和<xref:System.IDisposable>接口。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现可由使用者类的释放非托管的资源，并且你可以使用<xref:System.Object.Finalize%2A>方法来释放非托管的资源的事件中<xref:System.IDisposable.Dispose%2A>不会调用方法。  
  
 <xref:System.Object.Finalize%2A> 后它已清除垃圾回收期间，可以执行几乎任何操作，包括复活 （亦即，使该对象可访问再次） 的对象。 但是，该对象能够仅重新一次;<xref:System.Object.Finalize%2A>垃圾回收期间不能在来恢复对象上调用。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 备用方法  
 创建可靠的终结器通常是很困难，因为不能应用程序的状态做出假设，因为未经处理的系统异常，如<xref:System.OutOfMemoryException>和<xref:System.StackOverflowException>终止终结器。 而不是实现您的类的终结器释放非托管的资源，可以使用一个对象，派生自<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>类来包装非托管的资源，然后实现 dispose 模式，其中没有终结器。 .NET Framework 提供了中的以下类<xref:Microsoft.Win32?displayProperty=nameWithType>派生自的命名空间<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 为文件句柄的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 为内存映射文件句柄的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是指向非托管内存块的指针的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>，和<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>是加密的句柄的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道句柄的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是对一个注册表项的句柄的包装器类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是一个等待句柄的包装器类。  
  
 下面的示例使用[释放模式](~/docs/standard/garbage-collection/implementing-dispose.md)使用安全句柄而不是替代<xref:System.Object.Finalize%2A>方法。 它定义`FileAssociation`包装有关处理具有特定文件扩展名的文件的应用程序的注册表信息的类。 作为返回两个注册表句柄`out`参数的 Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函数调用传递给<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>构造函数。 类型的受保护`Dispose`方法随后调用`SafeRegistryHandle.Dispose`方法来释放这些两个句柄。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下面的示例验证<xref:System.Object.Finalize%2A>对象的重写时，调用方法<xref:System.Object.Finalize%2A>被销毁。 注意，在生产应用程序，<xref:System.Object.Finalize%2A>方法将被重写释放由对象拥有的非托管的资源。 另请注意，C# 示例提供了析构函数而不是替代<xref:System.Object.Finalize%2A>方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 有关其他示例重写<xref:System.Object.Finalize%2A>方法，请参阅<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作为默认哈希函数。</summary>
        <returns>当前对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 哈希代码是用于插入和标识基于哈希的集合中的对象，例如数值<xref:System.Collections.Generic.Dictionary%602>类，<xref:System.Collections.Hashtable>类或从派生的类型<xref:System.Collections.DictionaryBase>类。 <xref:System.Object.GetHashCode%2A>方法适用于需要快速检查的对象是否相等的算法提供此哈希代码。  
  
> [!NOTE]
>  有关如何在哈希表中使用的哈希代码的信息以及某些其他哈希代码算法，请参阅[哈希函数](https://en.wikipedia.org/wiki/Hash_function)维基百科中的条目。  
  
 是相等的相等返回哈希代码的两个对象。 但是，反过来则不适用： 相等哈希代码并不表示对象是否相等，因为不同的 （不相等） 对象可以具有相同哈希代码。 此外，.NET 不保证的默认实现<xref:System.Object.GetHashCode%2A>方法，并且此方法所返回的.NET 实现，如.NET Framework 和.NET Core 的不同版本和平台，例如 32 位之间可能不同的值和64 位平台。 出于这些原因，请不要用于此方法的默认实现的唯一对象标识符作为哈希目的。 从此请执行以下两种结果：  
  
-   不应假定相等哈希代码表示对象是否相等。  
  
-   应永远不会持久保存或在其中创建它，应用程序域之外使用的哈希代码，因为相同的对象可能哈希处理跨应用程序域、 进程和平台。  
  
> [!WARNING]
>  哈希代码旨在高效插入和基于哈希表的集合中查找。 哈希代码不是永久的值。 出于此原因：  
>   
> -   请勿序列化哈希代码值或将其存储在数据库中。  
> -   不使用的哈希代码作为键来从键控集合中检索对象。  
> -   不在应用程序域或进程之间发送的哈希代码。 在某些情况下，可能会在每个进程或每个应用程序域基础上计算的哈希代码。  
> -   不要使用而不是返回的加密哈希函数，如果需要加密型强哈希值的哈希代码。 对于加密哈希，请使用派生自的类<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>类。  
> -   测试的哈希代码，以确定两个对象相等。 （不相等的对象可以有相同的哈希代码。）若要测试相等性，请调用<xref:System.Object.ReferenceEquals%2A>或<xref:System.Object.Equals%2A>方法。  
  
 <xref:System.Object.GetHashCode%2A>派生类型可以重写方法。 如果<xref:System.Object.GetHashCode%2A>是未重写，哈希代码为引用类型计算通过调用<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>方法的基类，计算哈希代码基于对象的引用; 有关详细信息，请参阅<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 换而言之，两个对象为其<xref:System.Object.ReferenceEquals%2A>方法将返回`true`具有相同哈希代码。 如果值类型不会重写<xref:System.Object.GetHashCode%2A>，则<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基类的方法使用反射来计算基于类型的字段的值的哈希代码。 换而言之，其字段具有相等的值的值类型具有相同哈希代码。 有关重写<xref:System.Object.GetHashCode%2A>，请参阅"对继承者说明"部分。  
  
> [!WARNING]
>  如果重写<xref:System.Object.GetHashCode%2A>方法，您还应该重写<xref:System.Object.Equals%2A>，反之亦然。 如果被重写<xref:System.Object.Equals%2A>方法将返回`true`两个对象是否相等，被重写的测试时<xref:System.Object.GetHashCode%2A>方法必须返回两个对象相同的值。  
  
 如果用作哈希表中的键的对象不提供的有用实现<xref:System.Object.GetHashCode%2A>，可以通过提供指定哈希代码提供程序<xref:System.Collections.IEqualityComparer>实现的重载之一<xref:System.Collections.Hashtable>类构造函数。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当您调用<xref:System.Object.GetHashCode%2A>方法中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不替代的类提供的默认行为<xref:System.Object.GetHashCode%2A>。 这是.NET Framework 提供了有关支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持的 Windows 应用商店应用程序和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并不实现<xref:System.Object.GetHashCode%2A>。 但是，它们显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 提供的默认行为，这些方法时。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 在 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.GetHashCode%2A>方法。  
  
   
  
## Examples  
 若要计算具有相同或比范围较小的数字值的哈希代码的最简单方式之一<xref:System.Int32>类型是只需返回该值。 下面的示例显示了此类实现`Number`结构。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常情况下，类型具有多个数据字段可以参与生成的哈希代码。 若要生成的哈希代码的一种方法是组合使用这些字段`XOR (eXclusive OR)`操作，如下面的示例中所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前面的示例返回相同的哈希代码 (n1，n2) 和 (n2，n1)，因此可能会生成比需要的多个冲突。 提供多种解决方案，以便在这些情况下的哈希代码并不完全相同。 一个是要返回的哈希代码`Tuple`反映每个字段的顺序的对象。 下面的示例演示使用的可能实现<xref:System.Tuple%602>类。 但请注意，该实例化的性能开销`Tuple`对象可能会显著影响哈希表中存储大量对象的应用程序的整体性能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二种替代解决方案涉及的两个或多个位由连续的字段的哈希代码进行左移权重的单个哈希代码。 理想情况下，而不是被放弃，移出第 31 位应环绕在周围，而不被放弃。 由于将丢弃由 C# 和 Visual Basic 中的左移运算符，这就需要创建一个左的 shift 包装方法如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 下面的示例然后使用此 shift 包装方法来计算的哈希代码`Point`上述示例中使用的结构。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>哈希函数用于快速生成对象的值相对应的数字 （哈希代码）。 哈希函数通常特定于每种类型，和的唯一性，必须使用至少一个实例字段作为输入。 不应使用静态字段的值来计算哈希代码。  
  
类派生自<see cref="T:System.Object" />，则<see langword="GetHashCode" />方法可以委托给基类<see cref="M:System.Object.GetHashCode" />实现仅当在派生的类定义为引用相等性的相等性。 默认实现<see cref="M:System.Object.GetHashCode" />对于引用类型返回的哈希代码，它等效于返回的<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法。 您可以重写<see cref="M:System.Object.GetHashCode" />对于不可变的引用类型。 一般情况下，对于可变引用类型，则应重写<see cref="M:System.Object.GetHashCode" />仅当： 
-您可以计算从不可变; 的字段的哈希代码或 
-你可以确保可变对象的哈希代码不会更改而该对象包含在一个集合，其中依赖于其哈希代码。  
  
否则，您可能认为可变对象在哈希表中丢失。 如果您选择要重写<see cref="M:System.Object.GetHashCode" />可变引用类型，您的文档，应使其清除，而该对象存储在哈希表，您的类型的用户不应修改对象值。  
  
对于值类型，<see cref="M:System.ValueType.GetHashCode" />提供默认哈希代码实现使用反射。 应考虑重写它的更好的性能。  
  
 <block subset="none" type="note"><para>  
 有关详细信息和计算中有许多种哈希代码的示例，请参阅示例部分。  
  
</para></block>  
  
 哈希函数必须具有以下属性： 
-如果两个对象的比较结果相等，<see cref="M:System.Object.GetHashCode" />为每个对象的方法必须返回相同的值。 但是，如果两个对象不相等，比较<see cref="M:System.Object.GetHashCode" />两个对象的方法不需要返回不同的值。  
  
-<see cref="M:System.Object.GetHashCode" />对象的方法必须一致地返回相同的哈希代码，只要没有确定的对象的返回值的对象状态不修改[System.Object.Equals](xref:System.Object.Equals*)方法。 请注意这是仅对应用程序，当前执行的则返回 true，如果再次运行该应用程序可以返回不同的哈希代码。  
  
-对于获得最佳性能，哈希函数应生成均匀分布于所有输入，包括大量已群集化的输入。 含意是对对象状态的小修改应导致大型修改哈希表的最佳性能的生成哈希代码。  
  
哈希函数应为便宜的计算。  
  
-<see cref="M:System.Object.GetHashCode" />方法不应引发异常。  
  
例如，实现<see cref="M:System.String.GetHashCode" />方法提供的<see cref="T:System.String" />类返回的相同的字符串值完全相同的哈希代码。 因此，两个<see cref="T:System.String" />对象返回相同的哈希代码，如果它们表示相同的字符串值。 此外，该方法使用的所有字符在字符串中生成合理地随机分布的输出，即使输入群集中的某些范围 (例如，许多用户可能只包含较低 128 ASCII 字符，即使的字符串字符串可以包含任何 65535 个 Unicode 字符）。  
  
在类上提供一个好的哈希函数会严重影响将这些对象添加到哈希表的性能。 在使用提供的哈希函数的良好实现的密钥哈希表中，搜索的元素所用常量时间内的 （例如，o （1） 操作）。 在与差劲的实现哈希函数的哈希表中，搜索的性能取决于哈希表中的项的数目 (例如，O (`n`) 操作，其中`n`是哈希表中的项数)。 恶意用户可以输入数据增多的冲突，这会显著降低取决于哈希表，在以下情况下的应用程序的性能： 
-当哈希函数生成频繁发生冲突。  
  
-当较大比例的哈希表中的对象生成的相等或大约等于另一个哈希代码。  
  
-当用户输入的数据从其计算哈希代码。  
  
派生类重写<see cref="M:System.Object.GetHashCode" />还必须重写<see cref="M:System.Object.Equals(System.Object)" />以保证将被视为相等的两个对象具有相同的哈希代码; 否则为<see cref="T:System.Collections.Hashtable" />类型可能无法正常工作。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的 <see cref="T:System.Type" />。</summary>
        <returns>当前实例的准确运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为<xref:System.Object?displayProperty=nameWithType>用于所有类型的.net 都类型系统，是的基类<xref:System.Object.GetType%2A>方法可用于返回<xref:System.Type>表示所有.NET 类型的对象。 .NET 可以识别以下五个类别的类型：  
  
-   派生自的类<xref:System.Object?displayProperty=nameWithType>，  
  
-   值类型，派生自<xref:System.ValueType?displayProperty=nameWithType>。  
  
-   接口，派生自<xref:System.Object?displayProperty=nameWithType>从.NET Framework 2.0 开始。  
  
-   枚举，派生自<xref:System.Enum?displayProperty=nameWithType>。  
  
-   委托，它派生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 两个对象`x`并`y`具有相同的运行时类型`Object.ReferenceEquals(x.GetType(),y.GetType())`返回`true`。 下面的示例使用<xref:System.Object.GetType%2A>方法替换<xref:System.Object.ReferenceEquals%2A>方法，以确定一个数值是否与其他两个数值相同的类型。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  若要确定对象是否为特定类型，可以使用你的语言的类型比较关键字或构造。 例如，可以使用`TypeOf…Is`在 Visual Basic 中构造或`is`C# 中的关键字。  
  
 <xref:System.Object.GetType%2A>方法由派生的所有类型的继承<xref:System.Object>。 这意味着，除了使用您自己的语言比较关键字，你可以使用<xref:System.Object.GetType%2A>方法来确定特定对象的类型，如以下示例所示。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>对象会公开与当前的类关联的元数据<xref:System.Object>。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Object.GetType%2A>返回当前实例的运行时类型。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Object" /> 的浅表副本。</summary>
        <returns>当前 <see cref="T:System.Object" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>方法通过创建一个新对象，然后将当前对象的非静态字段复制到新的对象来创建卷影副本。 如果某个字段的值类型，则执行字段的按位复制。 如果字段是引用类型，则复制引用，但被引用的对象;因此，原始对象和其克隆引用同一对象。  
  
 例如，考虑一个名为 X 的引用对象 A 和 B，反过来，引用对象 c。 对象X 的浅表副本创建新对象 X2，它还引用对象 A 和 b。与此相反，X 的深层副本创建引用 A2 和 B2，是的一个副本的新对象的新对象 X2 和 B.B2 反过来引用新对象 C2，这是 C 的副本。该示例阐释了 shallow 和深层复制操作之间的差异。  
  
 通过多种方式实现深层复制操作，如果通过执行浅表副本操作<xref:System.Object.MemberwiseClone%2A>方法不符合你的需求。 其中包括：  
  
-   调用类构造函数可以使用从第一个对象的属性值创建第二个对象要复制的对象。 这假定，对象的值完全由其类构造函数中定义。  
  
-   调用<xref:System.Object.MemberwiseClone%2A>方法来创建一个对象的浅表副本，然后将其值是对任何属性或字段的值是引用类型的原始对象相同的新对象。 `DeepCopy`方法在示例中演示了此方法。  
  
-   序列化对对象进行深层复制，然后将序列化的数据还原到不同的对象变量。  
  
-   递归使用反射来执行深层复制操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Object.MemberwiseClone%2A>方法。 它定义`ShallowCopy`方法，以调用<xref:System.Object.MemberwiseClone%2A>方法来对其执行浅表副本操作`Person`对象。 它还定义了`DeepCopy`执行深层复制操作的方法`Person`对象。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 在此示例中，`Person.IdInfo`属性返回`IdInfo`对象。 如示例所示，输出时`Person`克隆对象时通过调用<xref:System.Object.MemberwiseClone%2A>方法中，克隆`Person`对象是原始对象的独立副本，只不过它们共用同一个`Person.IdInfo`对象引用。 结果是，修改的克隆`Person.IdInfo`属性更改原始对象的`Person.IdInfo`属性。 但是，执行深层复制操作时，克隆`Person`对象，包括其`Person.IdInfo`可以修改属性，而不会影响原始对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</summary>
        <returns>如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或两者均为 null，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Object.Equals%2A>方法和相等运算符<xref:System.Object.ReferenceEquals%2A>不能重写方法。 因此，如果你想要测试两个对象是否相等的引用而您不确定的实现`Equals`方法时，可以调用<xref:System.Object.ReferenceEquals%2A>方法。  
  
 但是，返回值的<xref:System.Object.ReferenceEquals%2A>方法似乎存在异常中这两种方案：  
  
-   比较值类型。 如果`objA`并`objB`是值类型，它们装箱传递到之前<xref:System.Object.ReferenceEquals%2A>方法。 这意味着，如果这两个`objA`并`objB`表示的值类型的相同实例<xref:System.Object.ReferenceEquals%2A>方法不过返回`false`，如下面的示例所示。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     有关装箱值类型的信息，请参阅[装箱和取消装箱](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。  
  
-   当比较字符串。 如果`objA`并`objB`都是字符串，<xref:System.Object.ReferenceEquals%2A>方法将返回`true`如果字符串暂留。 它不会执行测试的值相等。  在以下示例中，`s1`和`s2`因为它们是单一的暂存字符串的两个实例是否相等。 但是，`s3`和`s4`是否不相等，因为尽管它们都具有相同的字符串值，但该字符串未被暂存。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     有关字符串暂留的详细信息，请参阅<xref:System.String.IsInterned%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Object.ReferenceEquals%2A>以确定两个对象是否相同的实例。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前对象的字符串。</summary>
        <returns>表示当前对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 主版本号，格式设置.NET Framework 中的方法。 以便它适合于显示，它将对象转换为其字符串表示形式。 (有关格式设置支持.NET Framework 中的信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。)默认实现<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法返回对象的类型的完全限定的名称。  
  
> [!IMPORTANT]
>  你可能已达到了此页关注另一种类型的成员列表中的链接。 这是因为该类型不重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 相反，它将继承的功能<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
 经常重写类型<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以提供特定类型的更适合字符串表示形式。 类型也经常重载<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以提供支持的格式字符串或区分区域性的格式。  
  
 本节内容：  
  
 [默认 object.tostring （） 方法](#Default)   
 [重写 object.tostring （） 方法](#Overriding)   
 [重载的 ToString 方法](#Overloading)   
 [扩展 Object.ToString 方法](#Extending)   
 [Windows 运行时的注意事项](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>默认 object.tostring （） 方法  
 默认实现<xref:System.Object.ToString%2A>方法返回的类型的完全限定的名称<xref:System.Object>，如下面的示例所示。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 因为<xref:System.Object>是所有引用类型的基类在.NET Framework 中，此行为由继承不会重写的引用类型<xref:System.Object.ToString%2A>方法。 下面的示例阐释了这一点。 它定义一个名为`Object1`接受所有的默认实现<xref:System.Object>成员。 其<xref:System.Object.ToString%2A>方法返回对象的完全限定的类型名称。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>重写 object.tostring （） 方法  
 类型通常重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以返回一个字符串，表示的对象实例。 例如，基类型，如<xref:System.Char>， <xref:System.Int32>，并<xref:System.String>提供<xref:System.Object.ToString%2A>返回该对象表示的值的字符串形式的实现。 下面的示例定义了一个类`Object2`，重写<xref:System.Object.ToString%2A>方法返回的类型名称及其值。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 下表列出了在.NET 中的类型类别，并指示它们是否重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
|类型类别|Overrides Object.ToString()|行为|  
|-------------------|-----------------------------------|--------------|  
|类|n/a|n/a|  
|结构|是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|与 `Object.ToString()` 相同|  
|枚举|是 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|成员名称|  
|接口|No|n/a|  
|委托|No|n/a|  
  
 重写，请参阅备注继承者部分以了解更多信息<xref:System.Object.ToString%2A>。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>重载的 ToString 方法  
 除了重写的无参数<xref:System.Object.ToString?displayProperty=nameWithType>方法中，许多类型重载`ToString`方法以提供接受参数的方法的版本。 大多数情况下，这可为变量的格式设置和区分区域性的格式提供支持。  
  
 以下示例重载`ToString`方法以返回包含的各个字段的值的结果字符串`Automobile`类。 它定义了四个格式字符串：G，它将返回的模型名称和年;D，返回模型名称、 两年和门; 数C，它将返回模型名称、 两年和柱面;和一个，它将返回所有四个字段值的字符串。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 下面的示例调用重载<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法以显示货币值的区分区域性的格式。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 格式字符串和区分区域性的格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。 有关支持的数字值的格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 有关支持的日期和时间值的格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>扩展 Object.ToString 方法  
 一个类型继承默认值，因此<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法中，你可能会查找其行为不需要并想要对其进行更改。 这是如此的数组和集合类。 而会按预期`ToString`方法以显示其成员的值的数组或集合类，它改为将显示类型的完全限定的类型名称，如以下示例所示。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 具有多个选项以生成要将结果字符串。  
  
-   如果类型是数组、 集合对象或实现的对象<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>接口，可以使用枚举及其元素`foreach`C# 中的语句或`For Each...Next`在 Visual Basic 中构造。  
  
-   如果此类不是`sealed`（在 C# 中) 或`NotInheritable`（在 Visual Basic 中)，可以开发一个包装类，其继承的基类<xref:System.Object.ToString%2A?displayProperty=nameWithType>你想要自定义的方法。 至少，这需要你以下：  
  
    1.  实现任何必要的构造函数。 派生的类不会继承其基类构造函数。  
  
    2.  重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以返回你希望的结果字符串。  
  
     下面的示例定义的包装类<xref:System.Collections.Generic.List%601>类。 它将替代<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法来显示每种方法的集合而不是完全限定的类型名称的值。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   开发[扩展方法](~/docs/standard/design-guidelines/extension-methods.md)返回所需的结果字符串。 请注意，不能重写默认值<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以这种方式 (即扩展类 （在 C# 中) 或 （在 Visual Basic) 的模块不能具有名为的无参数方法`ToString`的调用来代替原始类型`ToString`方法. 必须将提供有关在无参数的其他名称`ToString`替换。  
  
     下面的示例定义两个扩展的方法<xref:System.Collections.Generic.List%601>类： 无参数`ToString2`方法，和一个`ToString`方法替换<xref:System.String>表示格式字符串的参数。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当您调用<xref:System.Object.ToString%2A>方法中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不替代的类提供的默认行为<xref:System.Object.ToString%2A>。 这是.NET Framework 提供了有关支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持的 Windows 应用商店应用程序和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并不总是实现<xref:System.Object.ToString%2A>。 但是，它们始终显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供默认行为时。  
  
 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，将使用公共语言运行时[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)上[!INCLUDE[wrt](~/includes/wrt-md.md)]再回退到的默认实现对象<xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 在 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.ToString%2A>方法。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 接口  
 从开始[!INCLUDE[win81](~/includes/win81-md.md)]，则[!INCLUDE[wrt](~/includes/wrt-md.md)]包括[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口的单一方法[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)，提供了基本格式设置支持相媲美提供的<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 若要避免产生混乱，不应实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)上托管类型。  
  
 通过本机代码或 JavaScript 或 C + 等语言编写的代码调用时的托管的对象 + /CX 中，它们看起来实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 公共语言运行时自动将路由从调用[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)到<xref:System.Object.ToString%2A?displayProperty=nameWithType>在事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)未在托管对象上实现。  
  
> [!WARNING]
>  因为公共语言运行时自动实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)所有的托管类型中的[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]应用程序，我们建议，不提供你自己[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现。 实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)调用时，可能会导致意外的行为`ToString`从[!INCLUDE[wrt](~/includes/wrt-md.md)]， C++/CX 或 JavaScript。  
  
 如果选择实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中导出的公共托管类型中[!INCLUDE[wrt](~/includes/wrt-md.md)]组件，以下限制适用：  
  
-   您可以定义[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口只能在"类实现"关系，如  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     接  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     口。  
  
-   不能实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口上。  
  
-   不能声明为类型参数[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能为方法、 属性或字段的返回类型。  
  
-   您不能隐藏您[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)通过使用如下所示的方法定义在基类中实现：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反， [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现必须一直重写基类实现。 只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。  
  
 请注意，在各种条件下对实现的托管类型的本机代码中调用[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隐藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现可以产生意外的行为。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当实现你自己的类型时，应重写<see cref="M:System.Object.ToString" />方法以返回有意义的那些类型的值。 需要更好地控制格式设置的派生类<see cref="M:System.Object.ToString" />提供了可以实现<see cref="T:System.IFormattable" />接口。 其<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />方法，您可以定义格式字符串，用于控制格式设置，并使用<see cref="T:System.IFormatProvider" />可提供特定于区域性的格式设置对象。  
  
重写的<see cref="M:System.Object.ToString" />方法应遵循以下准则： 
-返回的字符串应友好且可读的形式。  
  
-返回的字符串应唯一地标识对象实例的值。  
  
-返回的字符串应尽可能短，因此很适合显示由调试器。  
  
-您<see cref="M:System.Object.ToString" />重写不应返回<see cref="F:System.String.Empty" />或 null 字符串。  
  
-您<see cref="M:System.Object.ToString" />重写不应引发异常。  
  
-如果实例的字符串表示形式是区分区域性的或者可通过多种方式进行格式设置，实现<see cref="T:System.IFormattable" />接口。  
  
-如果返回的字符串包含敏感信息，应该首先要求有合适的权限。 如果请求成功，则可以返回的敏感信息;否则，应返回不包含敏感信息的字符串。  
  
-您<see cref="M:System.Object.ToString" />重写应具有任何明显的副作用以避免在调试中的复杂情况。 例如，调用<see cref="M:System.Object.ToString" />方法不应更改的实例字段的值。  
  
-如果你的类型实现分析方法 (或<see langword="Parse" />或<see langword="TryParse" />方法、 构造函数或某些其他实例化从字符串类型的实例的静态方法)，应确保返回的字符串<see cref="M:System.Object.ToString" />方法可以是转换为对象实例。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
  </Members>
</Type>