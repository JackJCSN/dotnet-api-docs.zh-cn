<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2befc53c964784ef05f9a3c02e361d9e6aed9618" /><Meta Name="ms.sourcegitcommit" Value="61757d0366a172cdbc11436deb1c1ffa49d97238" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/28/2019" /><Meta Name="ms.locfileid" Value="67458488" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供有关当前环境和平台的信息以及操作它们的方法。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Environment>类来检索信息，如命令行参数，退出代码、 环境变量设置，内容的调用堆栈、 时间自上一次系统启动，并且公共语言运行时的版本。  
  
   
  
## Examples  
 下面的示例演示如何显示有关当前环境的信息的列表。  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的命令行。</summary>
        <value>包含命令行自变量的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供程序名称和当前进程启动时在命令行上指定任何参数的访问。  
  
 程序名称可以包含路径信息，但不要求必须这样做。 使用<xref:System.Environment.GetCommandLineArgs%2A>方法来检索命令行信息分析并存储在一个字符串数组中。  
  
 为特定数目的字符; 未设置命令行缓冲区的最大大小它根据计算机运行的 Windows 操作系统而异。  
  
   
  
## Examples  
 下面的示例显示了其自己的命令行。  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对于到 PATH 环境变量进行读取访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前工作目录的完全限定路径。</summary>
        <value>包含目录路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据定义，如果此过程以在根目录下的本地或网络驱动器，此属性的值是尾部反斜杠后跟的驱动器名称 (例如，"c:\\")。 如果此过程开始时的子目录中，此属性的值是驱动器和子目录的路径，而无需尾部反斜杠 (例如，"C:\mySubDirectory")。  
  
   
  
## Examples  
 下面的示例演示了如何设置<xref:System.Environment.CurrentDirectory%2A>属性。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已尝试设置为空字符串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException">已尝试设置为 <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">已尝试设置一个找不到的本地路径。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有相应的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于写入到文件或在设置操作中的目录。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问在 get 操作中的路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前托管线程的唯一标识符。</summary>
        <value>一个整数，表示此托管线程的唯一标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">返回到操作系统的退出代码。 使用 0（零）指示处理已成功完成。</param>
        <summary>终止此进程，并将退出代码返回到操作系统。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关`exitCode`参数，使用非零数字表示出现错误。 在您的应用程序，可以在枚举中定义你自己的错误代码和返回基于方案的相应的错误代码。 例如，返回值为 1，表示所需的文件不存在，并且值为 2，以指示该文件是格式不正确。 使用的 Windows 操作系统的退出代码的列表，请参阅[系统错误代码](https://msdn.microsoft.com/library/ms681381.aspx)Windows 文档中。  
  
 调用<xref:System.Environment.Exit%2A>方法不同于使用编程语言的`return`语句按以下方式：  
  
-   <xref:System.Environment.Exit%2A> 始终将终止应用程序。 使用`return`语句可能会终止应用程序，仅当它是在中使用的应用程序入口点，例如在`Main`方法。  
  
-   <xref:System.Environment.Exit%2A> 应用程序将立即终止，即使其他线程正在运行。 如果`return`中的应用程序入口点调用语句时，会导致应用程序只有在所有前台线程已都终止后终止。  
  
-   <xref:System.Environment.Exit%2A> 需要调用方有权调用非托管的代码。 `return`语句则不。  
  
-   如果<xref:System.Environment.Exit%2A>从调用`try`或`catch`块中任何代码`finally`块不会执行。 如果`return`使用语句中的代码`finally`块会执行。  
  
-   如果<xref:System.Environment.Exit%2A>时，将调用中的代码[受约束的执行区域](~/docs/framework/performance/constrained-execution-regions.md)(CER) 正在运行，CER 不会完成执行。 如果`return`使用语句、 CER 完成执行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有足够的安全权限来执行此函数。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置进程的退出代码。</summary>
        <value>包含退出代码的 32 位有符号整数。 默认值为 0（零），这指示已成功完成处理。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Main`方法将返回`void`，可以使用此属性设置将返回给调用环境的退出代码。 如果`Main`不会返回`void`，将忽略此属性。 此属性的初始值为零。  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A>属性是一个有符号的 32 位整数。 若要防止该属性返回退出代码为负，不应使用的值大于或等于 0x80000000。  
  
 使用一个非零数字表示出现错误。 在您的应用程序，可以在枚举中定义你自己的错误代码和返回基于方案的相应的错误代码。 例如，返回值为 1，表示所需的文件不存在和值为 2，以指示该文件是格式不正确。 使用的 Windows 操作系统的退出代码的列表，请参阅[系统错误代码](https://msdn.microsoft.com/library/ms681381\(v=vs.85\))Windows 文档中。  
  
   
  
## Examples  
 下面是一个简单的应用名为 Double.exe 提高一倍，作为命令行自变量传递给它一个整数值。 值将分配到的错误代码<xref:System.Environment.ExitCode%2A>属性以指示错误条件。 请注意，必须添加对要成功编译该示例的 System.Numerics.dll 程序集的引用。  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 该示例然后可以从批处理文件，如下所示，让其错误代码可以访问使用调用`ERRORLEVEL`命令。  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 下图显示通过调用批处理文件产生的一些示例输出。  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 请注意该代码对 Double.exe 是与以下示例中，函数相同，不同之处在于前者定义名为的入口点`Main`且没有返回值，而此示例定义名为的入口点`Main`返回一个整数。  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">包含零个或多个环境变量名的字符串。 每个环境变量都用百分号 (%) 引起来。</param>
        <summary>将嵌入到指定字符串中的每个环境变量的名称替换为该变量的值的等效字符串，然后返回结果字符串。</summary>
        <returns>一个字符串，其中的每个环境变量均被替换为该变量的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM 互操作用于从操作系统检索环境变量。 生成一个多个可能的异常; 如果由于 COM 错误而无法检索环境变量，用于说明失败的原因的 HRESULT也就是说，异常取决于相应的 HRESULT。 有关如何处理 HRESULT 的详细信息，请参阅备注部分的<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType>方法。  
  
 有关设置环境变量才会被替换。 例如，假设`name`是"MyENV = %myenv%"。 如果环境变量，MyENV，设置为 42，此方法返回"MyENV = 42"。 如果未设置 MyENV，不会发生更改;此方法返回"MyENV = %myenv%"。  
  
 返回值的大小被限制为 32 K。  
  
   
  
## Examples  
 下面的示例演示如何获取系统驱动器和系统根变量。  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够访问中的环境变量<paramref name="name" />。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和可选的异常信息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会终止进程，而无需运行任何活动`try` / `finally`块或终结器。
  
 `Environment.FailFast`方法写入`message`字符串保存到 Windows 应用程序事件日志中，创建你的应用程序的转储，然后终止当前进程。 `message`字符串也包含在向 Microsoft 报告错误。  
  
 使用`Environment.FailFast`方法而不是<xref:System.Environment.Exit%2A>方法终止你的应用程序，如果你的应用程序的状态损坏无法修复，并执行应用程序`try` / `finally`块和终结器将损坏程序资源。  
  
 信息是通过使用 Windows 错误报告报告给 Microsoft。 有关详细信息，请参阅[Windows 错误报告：入门](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。  

调用`Environment.FailFast`方法来终止执行调试程序将引发在 Visual Studio 中运行的应用程序<xref:System.ExecutionEngineException>，并自动触发[fatalExecutionEngineError 托管调试助手 (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md).
  
## Examples  
 下面的示例日志条目写入 Windows 应用程序事件日志，并终止当前进程。  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <param name="exception">一个异常，表示导致终止的错误。 通常这是 <see langword="catch" /> 块中的异常。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和异常信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会终止进程，而无需运行任何活动`try` / `finally`块或终结器。  
  
 `Environment.FailFast`方法写入`message`字符串保存到 Windows 应用程序事件日志中，创建你的应用程序的转储，然后终止当前进程。  
  
 信息是通过使用 Windows 错误报告报告给 Microsoft。 有关详细信息，请参阅[Windows 错误报告：入门](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。 向 Microsoft 报告的错误包括`message`和`exception`提供了用于对错误分类的详细信息的信息。 尽管`exception`是未处理，因为该进程将终止，仍获取引发该异常的上下文信息。  
  
 如果`exception`是`null`，或者如果`exception`是不会引发，此方法的操作与相同<xref:System.Environment.FailFast%28System.String%29>方法重载。  
  
 使用`Environment.FailFast`方法而不是<xref:System.Environment.Exit%2A>方法终止你的应用程序，如果你的应用程序的状态损坏无法修复，并执行应用程序`try` / `finally`块和终结器将损坏程序资源。  

调用`Environment.FailFast`方法来终止执行调试程序将引发在 Visual Studio 中运行的应用程序<xref:System.ExecutionEngineException>，并自动触发[fatalExecutionEngineError 托管调试助手 (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md).
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前进程的命令行自变量的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含一个命令行自变量。 第一个元素是可执行文件名，后面的零个或多个元素包含其余的命令行参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的第一个元素包含正在执行的程序的文件名。 未提供的文件的名称时，第一个元素是等于<xref:System.String.Empty?displayProperty=nameWithType>。 剩余的元素包含在命令行中输入的任何其他令牌。  
  
 程序文件名称可以但不是需要，包含路径信息。  
  
 由空格分隔的命令行参数。 两个双引号 （"） 可用于参数中包含空格。 单引号 （'），但是，不提供此功能。  
  
 如果两个或偶数个反斜杠后跟双引号，继续下一步的每个反斜杠对将被替换为一个反斜杠，并且删除双引号。 如果双引号匹配后跟反斜杠，其中包括只是一个为奇数使用一个反斜杠替换为每个前面对并删除剩余的反斜杠;但是，在这种情况下双引号不会删除。  
  
 下表演示了如何命令行参数可以是分隔，并假定`MyApp`作为当前正在执行应用程序。  
  
|在命令行输入|生成命令行参数|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 若要获取作为单个字符串的命令行，请使用<xref:System.Environment.CommandLine%2A>属性。  
  
   
  
## Examples  
 以下示例显示应用程序的命令行参数。  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">系统不支持命令行自变量。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对于到 PATH 环境变量进行读取访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索环境变量的值。</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <summary>从当前进程检索环境变量的值。</summary>
        <returns><paramref name="variable" /> 指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29>方法从当前进程的环境块检索环境变量。 它相当于调用<xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 

若要检索所有环境变量以及它们的值，请调用<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
环境变量名称区分大小写 Linux 和 macOS 上，但在 Windows 上不区分大小写。  
 
### <a name="on-windows-systems"></a>在 Windows 系统上

 在 Windows 系统上当前进程的环境块包括：
 
- 由创建它的父进程提供给它的所有环境变量。 例如，从控制台窗口启动.NET 应用程序继承了所有控制台窗口的环境变量。 

  如果没有父进程，而使用每台计算机和每个用户环境变量。 例如，新的控制台窗口具有它启动时定义的所有每台计算机和每个用户的环境变量。

- 当进程运行时通过调用添加到 process 块的任何变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 在.NET 应用程序终止之前，将始终保留这些环境变量。  
  
如果进程启动后创建了环境变量，可以使用此方法来检索已通过调用创建的变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和 Linux 上，当前进程的环境块包括以下环境变量：

- 由创建它的父进程提供给它的所有环境变量。 对于从 shell 启动.NET 应用程序，这包括在外壳程序中定义的所有环境变量。

- 当进程运行时通过调用添加到 process 块的任何变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 在.NET 应用程序终止之前，将始终保留这些环境变量。  

在 macOS 上.NET core 和 Linux 不支持每台计算机或每个用户环境变量。   
  
## Examples  
 下面的示例使用<xref:System.Environment.GetEnvironmentVariable%2A>方法来检索`windir`环境变量，其中包含 Windows 目录的路径。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 下面的示例尝试检索名为环境变量的值`Test1`从进程环境块。 如果不存在该变量，该示例将创建它，并检索其值。 此示例显示变量的值。 如果该示例创建变量，它还会调用<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每个成员与<xref:System.EnvironmentVariableTarget>枚举，以建立可以仅从当前进程环境块检索到该变量。 最后，如果该示例创建变量，会将其删除。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的值<paramref name="variable" />。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="target"><see cref="T:System.EnvironmentVariableTarget" /> 值之一。 在基于 Unix 的系统上运行的 .NET Core 仅支持 <see cref="F:System.EnvironmentVariableTarget.Process" />。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量的值。</summary>
        <returns><paramref name="variable" /> 和 <paramref name="target" /> 参数指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

若要检索所有环境变量以及它们的值，请调用<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
环境变量名称区分大小写 Linux 和 macOS 上，但在 Windows 上不区分大小写。 

### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows，`target`参数指定是否从当前进程或当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量。 以及任何其他可用于创建.NET 进程的父进程的环境变量，每个用户和每台计算机的所有环境变量会自动都复制到当前进程的环境块。 但是，环境变量添加到当前进程的环境块仅通过调用<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>仅过程的持续期间保留。  
  
### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和 Linux 上`GetEnvironmentVariable(String, EnvironmentVariableTarget)`方法支持`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>仅。 使用调用`target`的值<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>不受支持，并返回`null`。 

每个进程环境变量为：

- 这些继承自父进程，通常用于调用的 shell`dotnet.exe`或启动.NET 应用程序。

- 通过调用定义的那些<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 这些环境变量保留仅直到`dotnet`进程或.NET 应用程序终止。   
  
## Examples

下面的示例创建的环境变量<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>， <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，和<xref:System.EnvironmentVariableTarget.Machine>目标时，将检查操作系统注册表是否包含用户和计算机环境变量，则删除环境变量。 因为.NET 在基于 Unix 的系统上不支持每个用户和每台计算机环境变量，仅<xref:System.Environment.SetEnvironmentVariable(System.String,System.String)>并<xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)>值为<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>成功存储环境变量指向进程环境块。

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 不是有效的 <see cref="T:System.EnvironmentVariableTarget" /> 值。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的值<paramref name="variable" />如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.Process" />(关联枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)， 
or 
对环境变量的完全访问权限如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或<see cref="F:System.EnvironmentVariableTarget.Machine" />(关联枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索所有环境变量名及其值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前进程检索所有环境变量名及其值。</summary>
        <returns>包含所有环境变量名及其值的字典；如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名称和环境变量的值存储在返回的键 / 值对为<xref:System.Collections.IDictionary>。  
  
### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows 系统上`GetEnvironmentVariables`方法将返回以下环境变量：
  
- 所有每台计算机创建的进程，以及它们的值时定义的环境变量。  
  
- 该过程将创建时定义的所有每用户环境变量，以及它们的值。  

- 继承自父进程从中启动或进程运行时添加到 process 块的.NET 应用程序的任何变量。 当进程运行时通过调用添加环境变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 MacOS 和 Linux 上`GetEnvironmentVariables`方法检索的名称和值的继承自父进程启动的所有环境变量`dotnet`范围内定义过程或`dotnet`流程自身。 一次`dotnet`进程结束，这些后一种环境变量停止存在。 

在基于 Unix 的系统上运行的.NET core 不支持每台计算机或每个用户环境变量。   
  
## Examples  
 下面的示例演示<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <exception cref="T:System.OutOfMemoryException">缓冲区内存不足。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的名称和环境变量的值。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.EnvironmentVariableTarget" /> 值之一。 在基于 Unix 的系统上运行的 .NET Core 仅支持 <see cxref="F:System.EnvironmentVariableTarget.Process" />。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索所有环境变量名及其值。</summary>
        <returns>包含 <paramref name="target" /> 参数所指定的源中所有环境变量名及其值的字典；否则，如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

名称和环境变量的值存储在返回的键/值对为<xref:System.Collections.IDictionary>对象。  

### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows 系统上`target`参数指定的源是当前进程、 当前用户的注册表项或在本地计算机的注册表项。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和仅限 Linux 上`target`的值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>支持。 每个进程环境变量继承自父进程 (通常 shell)，用于启动`dotnet`处理或作用域内定义`dotnet`流程自身。 一次 dotnet 进程结束，这些后一种环境变量将不复存在。  

不支持每台计算机和每个用户环境变量。 一个`target`的值<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>返回一个空数组。
  
## Examples

下面的示例创建的环境变量<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>， <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，和<xref:System.EnvironmentVariableTarget.Machine>目标时，将检查操作系统注册表是否包含用户和计算机环境变量，则删除环境变量。 因为.NET 在基于 Unix 的系统上不支持每个用户和每台计算机环境变量，仅<xref:System.Environment.SetEnvironmentVariable(System.String,System.String)>并<xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)>值为<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>成功存储环境变量指向进程环境块。

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方不具有针对 <paramref name="target" /> 的指定值执行此操作的所需权限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 包含非法值。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的名称和环境变量的值，如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.Process" />(关联枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)， 
or 
对环境变量的完全访问权限如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或<see cref="F:System.EnvironmentVariableTarget.Machine" />(关联枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举值之一。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹，如 Program Files、 程序、 系统或启动时，可用来访问公共信息的路径。 特殊文件夹时设置的默认系统，或由用户显式安装的 Windows 版本。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须为中的值之一<xref:System.Environment.SpecialFolder>枚举; 任何其他值将引发异常。  
  
 有关特殊文件夹的详细信息，请参阅[CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664)值主题。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Environment.GetFolderPath%2A>方法来返回并显示与关联的路径`folder`参数。  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持当前平台。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举值之一。</param>
        <param name="option">指定用于访问特殊文件夹的枚举值之一。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径，并使用用于访问特殊文件夹的指定选项。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹，如 Program Files、 程序、 系统或启动时，可用来访问公共信息的路径。 特殊文件夹时设置的默认系统，或由用户显式安装的 Windows 版本。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须为中的值之一<xref:System.Environment.SpecialFolder>枚举; 任何其他值将引发异常。  
  
 有关特殊文件夹的详细信息，请参阅[CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664)值主题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。
或

<paramref name="options" /> 不是 <see cref="T:System.Environment.SpecialFolderOption" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持当前平台。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前计算机中的逻辑驱动器名称的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含逻辑驱动器名称。 例如，如果计算机的硬盘是第一个逻辑驱动器，则返回的第一个元素是“C:\\”。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何显示当前的计算机使用的逻辑驱动器<xref:System.Environment.GetLogicalDrives%2A>方法。  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">此权限所保护的资源的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的应用程序域是否正在卸载或者公共语言运行时 (CLR) 是否正在关闭。</summary>
        <value><see langword="true" /> 如果当前的应用程序域正在卸载或者 CLR 正在关闭;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **仅限.NET framework**:CLR 卸载应用程序域，它具有终结器方法，该应用程序域中的所有对象上运行终结器。 CLR 关闭时，它具有终结器方法的所有对象上启动终结器线程。 <xref:System.Environment.HasShutdownStarted%2A>属性返回`true`仅启动终结器线程后。 如果此属性返回`true`，可以确定是否正在卸载应用程序域或 CLR 本身正在通过调用关闭<xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType>方法。 此方法返回`true`如果称为终结器，因为应用程序域正在卸载或`false`如果 CLR 正在关闭。  
  
 <xref:System.Environment.HasShutdownStarted%2A>属性返回`false`终结器线程未启动。  
  
 通过使用此属性，可以确定是否要访问终止代码中的静态变量。 如果应用程序域或 CLR 正在关闭，您不能可靠地访问具有完成方法并且由静态字段引用的任何对象。 这是因为这些对象可能被终结。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前操作系统是否为 64 位操作系统。</summary>
        <value>如果操作系统为 64 位操作系统，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前进程是否为 64 位进程。</summary>
        <value>如果进程为 64 位进程，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此本地计算机的 NetBIOS 名称。</summary>
        <value>包含此计算机的名称的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从注册表中读取名称时，将在系统启动时建立此计算机的名称。 如果此计算机是群集中的节点，则返回节点的名称。  
  
   
  
## Examples  
 以下示例显示运行的代码示例的计算机的名称。 （计算机名称是示例输出中省略出于安全原因。）  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">无法获取此计算机的名称。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于读取 COMPUTERNAME 的环境变量的访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为此环境定义的换行字符串。</summary>
        <value>对于非 Unix 平台为包含“\r\n”的字符串，对于 Unix 平台则为包含“\n”的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性值<xref:System.Environment.NewLine%2A>是专门针对当前平台和.NET Framework 实现自定义一个常量。 有关在属性值中的转义符的详细信息，请参阅[的字符转义](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)。  
  
 提供的功能<xref:System.Environment.NewLine%2A>通常是条款换行、 换行、 换行符、 回车符、 CRLF、 和行尾的含义。  
  
 <xref:System.Environment.NewLine%2A> 可以与特定于语言的换行符支持如转义字符 '\r' 和 '\n' Microsoft 中的结合使用C#和 C /C++，或`vbCrLf`Microsoft Visual Basic 中。  
  
 <xref:System.Environment.NewLine%2A> 自动追加到处理的文本<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>和<xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例显示三个行由换行符分隔。  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含当前平台标识符和版本号的 <see cref="T:System.OperatingSystem" /> 对象。</summary>
        <value>一个包含平台标识符和版本号的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`Environment.OSVersion`属性不提供可靠的方式来确定确切的操作系统和其版本。 因此，我们不建议使用此方法。 改为： 

- 若要标识操作系统平台，请使用<xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType>方法。 

- 避免编写依赖于报告的操作系统版本的代码。 相反，检查应用程序所需的功能的可用性。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此属性不能获得系统版本。  
  
或 
获得的平台标识符不是 <see cref="T:System.PlatformID" />的成员</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前计算机上的处理器数。</summary>
        <value>指定当前计算机上处理器个数的 32 位有符号整数。 没有默认值。 如果当前计算机包含多个处理器组，则此属性返回可用的逻辑处理器数以供公共语言运行时 (CLR) 使用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理器组和逻辑处理器的详细信息，请参阅[处理器组](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Environment.ProcessorCount%2A>属性。  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建、修改或删除环境变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <paramref name="variable" /> 的值。</param>
        <summary>创建、修改或删除当前进程中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法相当于调用<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>值为重载<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>为`target`参数。  
  
 如果`value`参数不为空 （请参阅删除环境变量在本部分中的空值的定义更高版本的讨论） 和命名的环境变量`variable`参数不存在，环境创建变量并将其分配的内容`value`。 如果文件确实存在，将修改其值。 由于在当前进程的环境块中定义的环境变量，不会保留在过程结束后。  
  
 如果`variable`包含非初始十六进制零字符的零个字符将被视为环境变量名称，并将忽略所有后续字符之前的字符。  
  
 如果`value`包含非初始十六进制零字符的零个字符分配给环境变量并将忽略所有后续字符之前的字符。  
  
 如果`value`为空，命名的环境变量`variable`存在，则删除该环境变量。 如果`variable`不存在，会发生任何错误即使无法执行该操作。 `value` 被视为任何以下情况下为空：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含单个字符，其值为 U + 0000。  
  
## Examples

下面的示例尝试检索名为环境变量的值`Test1`从进程环境块。 如果该变量不存在，此示例将创建变量，并检索其值。 此示例显示变量的值。 适用于 Windows 系统上运行的.NET 实现，它还调用<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每个成员与<xref:System.EnvironmentVariableTarget>枚举，以建立可以仅从当前进程环境块检索到该变量。 （在基于 Unix 的系统上的.NET 实现仅支持变量进程环境块中。）最后，如果该示例创建变量，会将其删除。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> 包含一个长度为零的字符串、一个初始十六进制零字符 (0x00) 或一个等号 ("=")。  
  
- 或 - 
<paramref name="variable" /> 或 <paramref name="value" /> 的长度大于或等于 32,767 个字符。  
  
或 
执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对环境变量的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <paramref name="variable" /> 的值。</param>
        <param name="target">一个用于指定环境变量的位置的枚举值。</param>
        <summary>创建、修改或删除当前进程中或者为当前用户或本地计算机保留的 Windows 操作系统注册表项中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法可让你定义适用于当前进程的环境变量 (<xref:System.EnvironmentVariableTarget.Process>值)。 仅在进程结束前，持久保存所独有的当前进程环境块的环境变量。

此外，在仅，Windows 系统上<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法允许您定义是可用于的计算机运行的所有进程的环境变量 (<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>值) 和由用户运行的所有进程 (<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>值)。 每台计算机和每个用户环境变量会复制到当前进程的环境块。  
 
在 macOS 和 Linux 系统上的.NET Core 上, 调用<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>具有值的方法<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>将被忽略。 
  
 如果`value`参数不为空 （请参阅删除环境变量在本部分中的空值的定义更高版本的讨论） 和命名的环境变量`variable`参数不存在，环境创建变量并将其分配的内容`value`。  如果文件确实存在，将修改其值。  
  
 如果`variable`包含非初始十六进制零字符的零个字符将被视为环境变量名称，并将忽略所有后续字符之前的字符。  
  
 如果`value`包含非初始十六进制零字符的零个字符分配给环境变量并将忽略所有后续字符之前的字符。  
  
 如果`value`为空，命名的环境变量`variable`存在，则删除该环境变量。 `value` 被视为任何以下情况下为空：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含单个字符，其值为 U + 0000。  
  
 如果`variable`不存在，不会出现错误但无法执行该操作。 要小心`target`是<xref:System.EnvironmentVariableTarget.Machine>，因为意外删除会影响整个本地计算机，而不仅仅是当前进程或用户的环境变量。  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine 和 Windows 系统上的 EnvironmentVariableTarget.User

如果`target`是<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，环境变量存储在本地计算机的注册表 HKEY_CURRENT_USER\Environment 项中。 它也会复制到的文件资源管理器以当前用户身份运行的实例。 然后在用户从文件资源管理器启动任何新进程继承该环境变量。  
  
 同样，如果`target`是<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，环境变量存储在本地计算机的注册表的 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment 密钥。 它也会复制到文件资源管理器的所有实例。 然后从文件资源管理器启动任何新进程继承该环境变量。  
  
 如果`target`是<xref:System.EnvironmentVariableTarget.User>或<xref:System.EnvironmentVariableTarget.Machine>，其他应用程序将通过 Windows 通知设置操作的`WM_SETTINGCHANGE`消息。  
  
 如果`target`是<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，我们建议的长度`value`小于 2048年个字符。  
  
## Examples

下面的示例创建的环境变量<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>， <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，和<xref:System.EnvironmentVariableTarget.Machine>目标时，将检查操作系统注册表是否包含用户和计算机环境变量，则删除环境变量。 因为.NET 在基于 Unix 的系统上不支持每个用户和每台计算机环境变量，仅<xref:System.Environment.SetEnvironmentVariable(System.String,System.String)>并<xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)>值为<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>成功存储环境变量指向进程环境块。
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> 包含一个长度为零的字符串、一个初始十六进制零字符 (0x00) 或一个等号 ("=")。  
  
或 
<paramref name="variable" /> 的长度大于或等于 32,767 个字符。  
  
- 或 - 
 <paramref name="target" /> 不是 <see cref="T:System.EnvironmentVariableTarget" /> 枚举的一个成员。  
  
或 
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Machine" /> 或 <see cref="F:System.EnvironmentVariableTarget.User" />，且 <paramref name="variable" /> 的长度大于或等于 255。  
  
或 
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Process" /> ，且 <paramref name="value" /> 的长度大于或等于 32767 个字符。  
  
- 或 - 
执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对环境变量的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前的堆栈跟踪信息。</summary>
        <value>包含堆栈跟踪信息的字符串。 此值可为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A>属性列表中按时间顺序逆序方法调用、 即，首先，描述最新的方法调用和每个方法调用堆栈上列出的堆栈跟踪信息的一行。 但是，<xref:System.Environment.StackTrace%2A>属性可能不报告任意多个方法调用按预期由于优化期间发生代码转换。  
  
> [!NOTE]
>  由类的堆栈跟踪信息的层次结构视图，使用<xref:System.Diagnostics.StackTrace>类。  
  
 <xref:System.Environment.StackTrace%2A>属性设置为每个方法调用的堆栈跟踪信息的格式，如下所示：  
  
 "在`FullClassName`。`MethodName`(`MethodParams`) 中`FileName`： 行`LineNumber`"  
  
 "At"文本前面的三个空格，并且如果调试符号不可用，则省略"in"以开始将整个子字符串。 将占位符`FullClassName`， `MethodName`， `MethodParams`， `FileName`，和`LineNumber`、 将替换为实际值和定义，如下所示：  
  
 FullClassName  
 类，包括命名空间的完整名称。  
  
 `MethodName`  
 方法的名称。  
  
 `MethodParams`  
 参数类型/名称对的列表。 每个对用逗号分隔 （"，"）。 如果省略此信息`MethodName`不带任何参数。  
  
 `FileName`  
 文件的源的名称，其中`MethodName`方法声明。 如果调试符号不可用，则省略此信息。  
  
 `LineNumber`  
 中的行数`FileName`，其中包含从源代码`MethodName`是调用堆栈上的指令。 如果调试符号不可用，则省略此信息。  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>字符串终止的堆栈跟踪的每个行。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Environment.StackTrace%2A>属性。  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于对受权限保护的资源的完全访问。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统目录的完全限定路径。</summary>
        <value>包含目录路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的示例是值的"C:\WinNT\System32"的字符串。  
  
   
  
## Examples  
 以下示例显示运行的代码示例的计算机的系统目录。 （系统目录是示例输出中省略出于安全原因。）  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取操作系统的内存页的字节数。</summary>
        <value>系统内存页中的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 确定是否使用此信息很有用<xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType>选项时使用的内存映射文件。  
  
 在 Windows 中，此值是`dwPageSize`中的成员`SYSTEM_INFO`结构。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于访问系统和用户环境变量。 相关联的异常： 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统启动后经过的毫秒数。</summary>
        <value>一个 32 位带符号整数，它包含自上次启动计算机以来所经过的时间（以毫秒为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值派生自系统计时器，并存储为 32 位有符号整数。 注意，因为它派生自系统计时器的分辨率<xref:System.Environment.TickCount%2A>属性仅限于系统计时器，它通常在 10 到 16 毫秒为单位的范围的解决方法。  
  
> [!IMPORTANT]
>  因为的值<xref:System.Environment.TickCount%2A>属性值是 32 位带符号的整数，如果系统连续，运行<xref:System.Environment.TickCount%2A>从零到将递增<xref:System.Int32.MaxValue?displayProperty=nameWithType>大约 24.9 天，然后跳转到<xref:System.Int32.MinValue?displayProperty=nameWithType>，这是负号，然后递增到下一步 24.9 几天的零。 可以通过调用 Windows 来解决此问题[GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx)函数，它将重置为零大约 49.7 天，或通过调用[GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx)函数。  
  
 <xref:System.Environment.TickCount%2A> 不同于<xref:System.DateTime.Ticks%2A?displayProperty=nameWithType>属性，它是 0001 年 1 月 1 日，12:00 am 起经过的 100 纳秒间隔数。  
  
 使用<xref:System.DateTime.Now%2A?displayProperty=nameWithType>属性来获取当前本地日期和时间在此计算机上的。  
  
   
  
## Examples  
 下面的示例演示如何检索返回值的正值范围<xref:System.Environment.TickCount%2A>属性。 <xref:System.Environment.TickCount%2A>属性之间循环<xref:System.Int32.MinValue?displayProperty=nameWithType>，这是负数，和<xref:System.Int32.MaxValue?displayProperty=nameWithType>49.8 天一次。 此代码示例会删除符号位，以生成一个非负数字，周期介于零和<xref:System.Int32.MaxValue>24.9 天。  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前用户关联的网络域名。</summary>
        <value>与当前用户关联的网络域名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户的域帐户凭据的格式为用户的域名称\\字符和用户名。 使用<xref:System.Environment.UserDomainName%2A>属性来获取用户的域名，而无需用户名称和<xref:System.Environment.UserName%2A>属性来获取不包含域名称的用户名。  例如，如果用户的域名和用户名是 CORPORATENETWORK\john，<xref:System.Environment.UserDomainName%2A>属性将返回"企业网络"。  
  
 <xref:System.Environment.UserDomainName%2A>属性首先尝试获取当前用户的 Windows 帐户名的域名称组件。 如果该尝试失败，此属性尝试获取由提供的用户名相关联的域名<xref:System.Environment.UserName%2A>属性。 如果该尝试失败，因为在主计算机未加入到域，则返回主机计算机名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作系统不支持检索网络域名。</exception>
        <exception cref="T:System.InvalidOperationException">无法检索的网络域名。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">USERDOMAIN 环境变量对的读取权限。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，用以指示当前进程是否在用户交互模式中运行。</summary>
        <value>如果当前进程在用户交互模式中运行，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A>属性报告`false`Windows 进程或运行不通过用户界面的 IIS 这样的服务。 如果此属性为`false`、 不显示模式对话框或消息框，因为没有图形用户界面要与之交互的用户。  
  
   
  
## Examples  
 以下示例显示是否在当前进程在用户交互模式下运行。  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前已登录到操作系统的人员的用户名。</summary>
        <value>登录到操作系统的用户的用户名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.Environment.UserName%2A>属性来标识系统和应用程序安全性或访问时，在当前线程上的用户。 它还可以用于自定义每个用户的特定应用程序。  
 
 在 Windows 上<xref:System.Environment.UserName%2A>属性包装了对 Windows 的调用[GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx)函数。 用户的域帐户凭据的格式为用户的域名称\\字符和用户名。 使用<xref:System.Environment.UserDomainName%2A>属性来获取用户的域名和<xref:System.Environment.UserName%2A>属性来获取用户名称。  
 
 在 Unix 平台上<xref:System.Environment.UserName%2A>属性包装调用`getpwuid_r`函数。
 
 如果 ASP.NET 应用程序在开发环境中，运行<xref:System.Environment.UserName%2A>属性返回当前用户的名称。 在已发布的 ASP.NET 应用程序中，此属性返回 （例如默认应用程序池） 的应用程序池帐户的名称。  
  
   
  
## Examples  
 下面的示例显示启动当前线程的人员的用户名。  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于读取 USERNAME 的环境变量的访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Version" /> 对象，该对象描述公共语言运行时的主版本、次版本、内部版本和修订号。</summary>
        <value>用于显示公共语言运行时版本的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 .NET Framework 版本 4、4.5、4.5.1 和 4.5.2，<xref:System.Environment.Version%2A?displayProperty=nameWithType> 属性返回字符串表现形式具有窗体 `4.0.30319.xxxxx` 的 <xref:System.Version> 对象。 对于.NET Framework 4.6 和更高版本，它具有窗体`4.0.30319.42000`。  
  
> [!WARNING]
>  有关[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更高版本，我们不建议使用<xref:System.Environment.Version%2A>属性来检测运行时; 的版本相反，您可以通过查询注册表来确定公共语言运行时的版本。 有关详细信息，请参阅[如何：确定已安装的 .NET Framework 版本](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md)。  
  
 有关与每个版本的.NET Framework 一起安装的公共语言运行时版本的详细信息，请参阅[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下面的示例显示公共语言运行时的版本。 （省略了版本为安全起见，示例输出中。）  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取映射到进程上下文的物理内存量。</summary>
        <value>一个 64 位带符号整数，包含映射到进程上下文的物理内存字节的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示的计算机运行的代码示例的工作集的大小。  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">此权限所保护的资源的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
