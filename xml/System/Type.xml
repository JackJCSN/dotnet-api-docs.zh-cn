<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86e12cd5d024de5c0e84aa3d936d352176427ed3" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69541080" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d6f12-101">表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-102">`Type`<xref:System.Reflection>功能的根, 是访问元数据的主要方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="d6f12-103">使用的成员<xref:System.Type>获取有关类型声明的信息, 有关类型的成员 (如构造函数、方法、字段、属性和类的事件), 以及部署类的模块和程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="d6f12-104">无论其访问级别如何, 代码都无需权限即可使用反射来获取有关类型及其成员的信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="d6f12-105">代码不需要任何权限即可使用反射来访问公共成员, 或访问级别使其在正常编译过程中可见的其他成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="d6f12-106">但是, 为了使代码能够使用反射来访问通常不可访问的成员 (如私有或内部方法) 或类未继承的类型的受保护字段, 你的代码必须具有<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="d6f12-107">请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="d6f12-108">`Type`是允许多个实现的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="d6f12-109">系统将始终提供派生类`RuntimeType`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="d6f12-110">在反射中, 所有以 word 运行时开头的类在系统中只为每个对象创建一次, 并支持比较运算。</span><span class="sxs-lookup"><span data-stu-id="d6f12-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-111">在多线程方案中, 不要<xref:System.Type>锁定对象以便同步对`static`数据的访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="d6f12-112">其他不能进行控制的代码也可能会锁定您的类类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="d6f12-113">这可能会导致死锁。</span><span class="sxs-lookup"><span data-stu-id="d6f12-113">This might result in a deadlock.</span></span> <span data-ttu-id="d6f12-114">相反, 通过锁定专用`static`对象来同步对静态数据的访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-115">派生类可以访问调用代码的基类的受保护成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="d6f12-116">此外, 还允许访问调用代码的程序集的程序集成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="d6f12-117">作为一种规则, 如果允许在早期绑定代码中访问, 则还允许在后期绑定代码中访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-118">扩展其他接口的接口不会继承扩展接口中定义的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="d6f12-119">本节内容：</span><span class="sxs-lookup"><span data-stu-id="d6f12-119">In this section:</span></span>  
  
 <span data-ttu-id="d6f12-120">[类型对象表示哪些类型？](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="d6f12-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="d6f12-121">[检索类型对象](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="d6f12-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="d6f12-122">比较类型对象是否相等</span><span class="sxs-lookup"><span data-stu-id="d6f12-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="d6f12-123">类型对象表示哪些类型？</span><span class="sxs-lookup"><span data-stu-id="d6f12-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="d6f12-124">此类是线程安全的;多个线程可以同时从该类型的实例读取。</span><span class="sxs-lookup"><span data-stu-id="d6f12-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="d6f12-125"><xref:System.Type>类的实例可以表示以下任何类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="d6f12-126">类</span><span class="sxs-lookup"><span data-stu-id="d6f12-126">Classes</span></span>  
  
-   <span data-ttu-id="d6f12-127">值类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-127">Value types</span></span>  
  
-   <span data-ttu-id="d6f12-128">数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-128">Arrays</span></span>  
  
-   <span data-ttu-id="d6f12-129">接口</span><span class="sxs-lookup"><span data-stu-id="d6f12-129">Interfaces</span></span>  
  
-   <span data-ttu-id="d6f12-130">枚举</span><span class="sxs-lookup"><span data-stu-id="d6f12-130">Enumerations</span></span>  
  
-   <span data-ttu-id="d6f12-131">委托</span><span class="sxs-lookup"><span data-stu-id="d6f12-131">Delegates</span></span>  
  
-   <span data-ttu-id="d6f12-132">构造的泛型类型和泛型类型定义</span><span class="sxs-lookup"><span data-stu-id="d6f12-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="d6f12-133">构造的泛型类型、泛型类型定义和泛型方法定义的类型参数和类型参数</span><span class="sxs-lookup"><span data-stu-id="d6f12-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="d6f12-134">检索类型对象</span><span class="sxs-lookup"><span data-stu-id="d6f12-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="d6f12-135">可以<xref:System.Type>通过以下方式获取与特定类型关联的对象:</span><span class="sxs-lookup"><span data-stu-id="d6f12-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="d6f12-136">实例<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法返回一个<xref:System.Type>对象, 该对象表示实例的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="d6f12-137">由于所有托管类型都派生<xref:System.Object>自<xref:System.Object.GetType%2A> , 因此可在任何类型的实例上调用方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="d6f12-138">下面的示例调用<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法以确定对象数组中每个对象的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="d6f12-139">静态<xref:System.Type.GetType%2A?displayProperty=nameWithType> 方法<xref:System.Type>返回对象, 该对象表示由其完全限定名称指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="d6f12-140">、和方法返回对象`Type` , 这些对象表示在模块中定义的类型。 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType> <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="d6f12-141">第一种方法可用于获取模块中定义的<xref:System.Type>所有公共和私有类型的对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="d6f12-142">(可以`Module` <xref:System.Type.Module%2A?displayProperty=nameWithType>通过或方法<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>获取实例, 也可以通过属性获取的实例。) <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="d6f12-143">对象包含若干方法, 用于检索在程序集中定义的类, 包括<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。 <xref:System.Reflection.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="d6f12-144"><xref:System.Type.FindInterfaces%2A>方法返回某个类型支持的接口类型的筛选列表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="d6f12-145">方法返回表示元素的对象。<xref:System.Type.GetElementType%2A> `Type`</span><span class="sxs-lookup"><span data-stu-id="d6f12-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="d6f12-146"><xref:System.Type.GetInterfaces%2A>和方法<xref:System.Type.GetInterface%2A>返回对象,这些<xref:System.Type>对象表示类型支持的接口类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="d6f12-147">方法返回<xref:System.Type>对象的数组, 这些对象表示由任意一组对象指定的类型。 <xref:System.Type.GetTypeArray%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="d6f12-148">对象是使用类型<xref:System.Object>的数组指定的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="d6f12-149">提供<xref:System.Type.GetTypeFromProgID%2A> 和<xref:System.Type.GetTypeFromCLSID%2A>方法是为了实现 COM 互操作性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="d6f12-150">它们返回一个<xref:System.Type>对象, 该对象表示`ProgID`由或`CLSID`指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="d6f12-151">提供<xref:System.Type.GetTypeFromHandle%2A>方法以实现互操作性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="d6f12-152">它将返回`Type`一个对象, 该对象表示由类句柄指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="d6f12-153">C# C++ 运算符、`GetType`运算符和 Visual Basic 运算符获取`Type`类型的对象。 `typeid` `typeof`</span><span class="sxs-lookup"><span data-stu-id="d6f12-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="d6f12-154">方法返回一个<xref:System.Type>对象, 该对象表示构造的泛型类型 (如果其<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`, 则为开放式构造类型); 否则返回一个封闭式构造类型。 <xref:System.Type.MakeGenericType%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="d6f12-155">泛型类型只能在关闭时进行实例化。</span><span class="sxs-lookup"><span data-stu-id="d6f12-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="d6f12-156"><xref:System.Type.MakeArrayType%2A> C#、`ref`和方法返回<xref:System.Type>分别表示指定类型的数组、指向指定类型的指针和引用参数类型的对象 (在中, <xref:System.Type.MakeByRefType%2A> <xref:System.Type.MakePointerType%2A> `ByRef`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="d6f12-157">比较类型对象是否相等</span><span class="sxs-lookup"><span data-stu-id="d6f12-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="d6f12-158">一个<xref:System.Type>表示类型的对象是唯一的; 即, 当且<xref:System.Type>仅当两个对象表示相同的类型时, 这就引用相同的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="d6f12-159">这允许使用引用相等<xref:System.Type>性比较对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="d6f12-160">下面的示例对表示<xref:System.Type>若干整数值的对象进行比较, 以确定它们是否属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-161">下面的示例演示了的<xref:System.Type>几个典型功能。</span><span class="sxs-lookup"><span data-stu-id="d6f12-161">The following example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="d6f12-162">运算符C# `typeof` ( <xref:System.Type> <xref:System.String>Visual Basic中的运算符)用于获取表示的对象。`GetType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-162">The C# `typeof` operator (`GetType` operator in Visual Basic) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="d6f12-163">在<xref:System.Type> <xref:System.Reflection.MethodInfo> <xref:System.String.Substring%2A?displayProperty=nameWithType>此对象中, 方法用于获取, 它表示采用起始位置和长度的重载。 <xref:System.Type.GetMethod%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A?displayProperty=nameWithType> overload that takes a starting location and a length.</span></span>
  
 <span data-ttu-id="d6f12-164">为了标识重载签名, 该代码示例创建一个临时数组, 其中包含<xref:System.Type>表示`int`的两`Integer`个对象 (在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-165">为精确起见, 数组包含对当前应用程序域中表示<xref:System.Type> `int`的实例的两个引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="d6f12-166">对于任何类型, <xref:System.Type>每个应用程序域只有一个实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="d6f12-167">此代码示例使用<xref:System.Reflection.MethodInfo>来对字符串 "Hello, World!" <xref:System.String.Substring%2A>调用方法, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d6f12-168">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="d6f12-169">当从<see langword="Type" />继承时, 必须重写以下成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="d6f12-170">查看类型信息</span><span class="sxs-lookup"><span data-stu-id="d6f12-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-171">初始化 <see cref="T:System.Type" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-172">此构造函数由派生类在类型对象的构造过程中调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-173">获取在其中声明该类型的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="d6f12-174">对于泛型类型，则获取在其中定义该泛型类型的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="d6f12-175">描述包含当前类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="d6f12-176">对于泛型类型，该实例描述包含泛型类型定义的程序集，而不是创建和使用特定构造类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-177">如果当前<xref:System.Type>对象表示构造泛型类型, 则此属性返回包含泛型类型定义的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="d6f12-178">例如, 假设你创建了一个名为 MyGenerics 的程序集, 该程序集包含`MyGenericStack<T>`泛型`MyGenericStack(Of T)`类型定义 ( `generic<T> ref class MyGenericStack`在C++中为 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="d6f12-179">如果在另一个程序集中`MyGenericStack<int>`创建`MyGenericStack(Of Integer)`的实例 (在 Visual Basic 中), <xref:System.Type.Assembly%2A>则构造类型的属性将返回<xref:System.Reflection.Assembly>一个表示 MyGenerics 的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="d6f12-180">同样, 如果当前<xref:System.Type>对象表示一个未赋值的泛型参数`T`, 则此属性返回包含定义`T`的泛型类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="d6f12-181">如果该<xref:System.Type.Assembly%2A?displayProperty=nameWithType>属性在特定 .net 实现 (如 .net Core 或通用 Windows 平台) 上不可用, 请<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>改用属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="d6f12-182">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-183">下面的示例显示与类关联的程序集名称和该类型的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-184">获取类型的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="d6f12-185"><see cref="T:System.Type" /> 的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称；或者为 <see langword="null" />（如果当前实例表示泛型类型参数）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-186">类型的程序集限定名称包含类型名称 (包括其命名空间), 后跟一个逗号, 然后是程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="d6f12-187">使用<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性获取程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-188">在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="d6f12-189">例如, "ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="d6f12-190">不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="d6f12-191">请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d6f12-192">所有支持公共语言运行时的编译器都发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="d6f12-193">后面</span><span class="sxs-lookup"><span data-stu-id="d6f12-193">Delimiter</span></span>|<span data-ttu-id="d6f12-194">含义</span><span class="sxs-lookup"><span data-stu-id="d6f12-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d6f12-195">反斜杠 (\\)</span><span class="sxs-lookup"><span data-stu-id="d6f12-195">Backslash (\\)</span></span>|<span data-ttu-id="d6f12-196">转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-196">Escape character.</span></span>|  
|<span data-ttu-id="d6f12-197">逗号 (,)</span><span class="sxs-lookup"><span data-stu-id="d6f12-197">Comma (,)</span></span>|<span data-ttu-id="d6f12-198">在程序集名称之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="d6f12-199">加号 (+)</span><span class="sxs-lookup"><span data-stu-id="d6f12-199">Plus sign (+)</span></span>|<span data-ttu-id="d6f12-200">在嵌套类之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="d6f12-201">Period (.)</span><span class="sxs-lookup"><span data-stu-id="d6f12-201">Period (.)</span></span>|<span data-ttu-id="d6f12-202">表示命名空间标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="d6f12-203">方括号 ([])</span><span class="sxs-lookup"><span data-stu-id="d6f12-203">Brackets ([])</span></span>|<span data-ttu-id="d6f12-204">在类型名称后, 表示该类型的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="d6f12-205">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-205">-or-</span></span><br /><br /> <span data-ttu-id="d6f12-206">对于泛型类型, 包含泛型类型参数列表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="d6f12-207">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-207">-or-</span></span><br /><br /> <span data-ttu-id="d6f12-208">在类型参数列表中, 包含程序集限定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="d6f12-209">例如, 类的程序集限定名称可能如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="d6f12-210">如果命名空间包含加号 (例如 TopNamespace + 命名空间), 则加号 (+) 前面将有一个转义符\\(), 以防止将其解释为嵌套分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="d6f12-211">反射会按如下所示发出此字符串:</span><span class="sxs-lookup"><span data-stu-id="d6f12-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="d6f12-212">"+ +"\\变成 "\\++\\\\",而""\\变成 ""。</span><span class="sxs-lookup"><span data-stu-id="d6f12-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="d6f12-213">此限定名称可以保留, 以后用于加载<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="d6f12-214">若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="d6f12-215"><xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="d6f12-216"><xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="d6f12-217">类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="d6f12-218">若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="d6f12-219">空格在除程序集名称之外的所有类型名称组件中都是相关的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="d6f12-220">在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-221">泛型类型的泛型参数本身由程序集名称限定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="d6f12-222">例如, 在的程序集限定类型`MyGenericClass<int>`名称 (`MyGenericClass(Of Integer)`在 Visual Basic 中) 中, `int`扩展<xref:System.Int32>为的程序集限定类型名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="d6f12-223">如果当前<xref:System.Type>对象表示泛型参数, 则此属性返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-224">下面的示例显示与类关联的程序集名称和该类型的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="d6f12-225">下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-226">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-227">获取与 <see cref="T:System.Type" /> 关联的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-228">表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象，除非 <see cref="T:System.Type" /> 表示泛型类型形参，在此情况下该值未指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-229"><xref:System.Reflection.TypeAttributes>枚举的某些成员是表示一组值的掩码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="d6f12-230">每个组都包含一个其基础值为零的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="d6f12-231"><xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>例如, <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>组中成员的基础值为零, 这与<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>组中的<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>成员相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="d6f12-232">因此, 在测试这些值之前, 必须使用掩码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="d6f12-233">说明如示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="d6f12-234">大多数情况下, <xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>和<xref:System.Type.IsSpecialName%2A>等属性比类型属性更易于使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="d6f12-235">如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回泛型类型定义的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="d6f12-236">例如`MyGenericClass<int>` , 为 Visual Basic (`MyGenericClass(Of Integer)`在中为`MyGenericClass<T>` ) 返回的属性是 (`MyGenericClass(Of T)`在 Visual Basic 中) 的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="d6f12-237">如果当前<xref:System.Type>表示泛型类型参数 (即, <xref:System.Type.IsGenericParameter%2A>如果属性返回`true` ), 则此属性返回<xref:System.Reflection.TypeAttributes>的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-238">下面的示例使用<xref:System.Type.Attributes%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-238">The following example uses the <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-239">获取当前 <see cref="T:System.Type" /> 直接从中继承的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="d6f12-240">当前 <see cref="T:System.Type" /> 直接从中继承的 <see cref="T:System.Type" />；或者如果当前 <see langword="null" /> 表示 <see langword="Type" /> 类或一个接口，则为 <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-241">基类型是当前类型直接从中继承的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="d6f12-242"><xref:System.Object>是唯一没有基类型的类型, 因此`null`作为的基<xref:System.Object>类型返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="d6f12-243">接口从零个或多个基接口继承;因此, `null` `Type`如果该对象表示一个接口, 则此属性返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="d6f12-244">可以通过<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>确定基接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-245">如果当前<xref:System.Type>表示构造泛型类型, 则基类型将反映泛型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="d6f12-246">以下面的声明为例：</span><span class="sxs-lookup"><span data-stu-id="d6f12-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="d6f12-247">对于构造类型`C<int>` (`C(Of Integer)`在 Visual Basic 中), 该<xref:System.Type.BaseType%2A>属性返回`B<int>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="d6f12-248">如果当前<xref:System.Type>表示泛型类型定义的类型参数, <xref:System.Type.BaseType%2A>则返回类约束, 即类型参数必须继承的类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="d6f12-249">如果没有类约束, <xref:System.Type.BaseType%2A>则返回。 <xref:System.Object?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d6f12-250">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-251">下面的示例演示如何使用<xref:System.Type.BaseType%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="d6f12-252">下面的示例使用递归列出了在程序集中找到的每个类的完整继承层次结构。</span><span class="sxs-lookup"><span data-stu-id="d6f12-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="d6f12-253">该示例定义了一个名`C`为的类, 该类派生`B`自名为的类, 而后者又派生自`A`名为的类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-254">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-255">获取一个值，该值指示当前 <see cref="T:System.Type" /> 对象是否具有尚未被特定类型替代的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="d6f12-256">如果 <see langword="true" /> 对象本身是泛型类型形参或者具有尚未提供特定类型的类型形参，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-257">若要创建类型的实例, 在类型本身的类型参数、任何封闭泛型类型或任何类型的元素中都不能有泛型类型定义或开放式构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="d6f12-258">另一种说法是, 在递归检查时, 类型不能包含泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="d6f12-259">由于类型可能会很复杂, 因此做出此决定非常困难。</span><span class="sxs-lookup"><span data-stu-id="d6f12-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="d6f12-260">为方便起见, 若要减少出现错误的可能性<xref:System.Type.ContainsGenericParameters%2A> , 属性提供了一种标准方法来区分封闭式构造类型 (可以实例化和开放构造的类型, 这是不可能的)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="d6f12-261">如果属性返回`true`, 则无法实例化该类型。 <xref:System.Type.ContainsGenericParameters%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="d6f12-262"><xref:System.Type.ContainsGenericParameters%2A>属性以递归方式搜索类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="d6f12-263">例如, 它为元素`true`为类型`A<T>` (`A(Of T)`在 Visual Basic 中) 的数组返回, 即使数组本身不是泛型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="d6f12-264">将此与为数组返回<xref:System.Type.IsGenericType%2A> `false`的属性的行为进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="d6f12-265">有关示例类和显示<xref:System.Type.ContainsGenericParameters%2A>属性值的表, 请参阅。 <xref:System.Type.IsGenericType%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-266">下面的示例定义了一个具有两个类型参数的泛型类, 然后定义了第一个派生自第一个类的泛型类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="d6f12-267">派生类的基类具有两个类型参数: 第一个是<xref:System.Int32> , 第二个是派生类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="d6f12-268">该示例显示有关这些泛型类的信息, 包括<xref:System.Type.GenericParameterPosition%2A>属性报告的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-269">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-270">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-271">获取一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />（如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="d6f12-272">如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数，则为一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-273">声明方法是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="d6f12-274">也就是说, 如果<xref:System.Type.DeclaringMethod%2A>不返回`null`, 则`DeclaringMethod.IsGenericMethodDefinition`返回`true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="d6f12-275"><xref:System.Type.DeclaringType%2A> 和<xref:System.Type.DeclaringMethod%2A>属性标识最初定义泛型类型参数的泛型类型定义或泛型方法定义:</span><span class="sxs-lookup"><span data-stu-id="d6f12-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="d6f12-276">如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="d6f12-277">`null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.</span><span class="sxs-lookup"><span data-stu-id="d6f12-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="d6f12-278">获取其<xref:System.Type.IsGenericParameter%2A>属性引发`false`的类型<xref:System.InvalidOperationException>的<xref:System.Type.DeclaringMethod%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="d6f12-279">属性返回的是<xref:System.Reflection.MethodInfo>泛型方法的, 或者<xref:System.Reflection.ConstructorInfo>是泛型构造函数的情况下的。 <xref:System.Reflection.MethodBase> <xref:System.Type.DeclaringMethod%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-280">在 .NET Framework 版本2.0 中, 不支持泛型构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="d6f12-281">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-282">下面的代码示例定义一个具有泛型方法的类, 为该方法分配一个类型自变量, 并调用生成的构造泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="d6f12-283">它还显示有关泛型方法定义和构造方法的信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="d6f12-284">显示泛型方法定义的类型参数的信息时, 在`DisplayGenericMethodInfo`方法中, 示例代码显示了该方法的泛型类型参数的<xref:System.Type.DeclaringMethod%2A>属性值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-285">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-286">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-287">获取用来声明当前的嵌套类型或泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="d6f12-288">如果当前的类型是嵌套类型，则为表示封闭类型的 <see cref="T:System.Type" /> 对象；如果当前的类型是泛型类型的类型参数，则为泛型类型的定义；如果当前的类型是泛型方法的类型参数，则为用来声明泛型方法的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-289">如果当前<xref:System.Type>对象表示泛型类型的类型参数, 则此属性返回泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="d6f12-290">如果当前<xref:System.Type>对象表示泛型方法的类型参数, 则此属性返回包含泛型方法定义的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="d6f12-291">如果类型为泛型, 则返回泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="d6f12-292">也就是说, 下面的代码返回<xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.List%601.ConvertAll%2A>包含泛型方法的泛型类的泛型类型定义:</span><span class="sxs-lookup"><span data-stu-id="d6f12-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="d6f12-293">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>属性标识泛型类型定义或泛型方法定义, 其中泛型类型参数最初定义:</span><span class="sxs-lookup"><span data-stu-id="d6f12-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="d6f12-294">如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="d6f12-295">`null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.</span><span class="sxs-lookup"><span data-stu-id="d6f12-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="d6f12-296">获取其<xref:System.Type.IsGenericParameter%2A>属性引发`false`的类型<xref:System.InvalidOperationException>的<xref:System.Type.DeclaringType%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-297">此示例显示派生类中方法的声明类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-298">获取默认联编程序的引用，该程序实现的内部规则用于选择由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 调用的合适成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-299">系统使用的默认联编程序的引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-300">随公共语言运行时提供的默认联编程序适用于除最特殊的情况以外的所有情况。</span><span class="sxs-lookup"><span data-stu-id="d6f12-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="d6f12-301">如果需要遵循与提供的默认联编程序不同的规则的联编程序, 请定义一个派生自<xref:System.Reflection.Binder>类的类型并`binder`使用其中一个<xref:System.Type.InvokeMember%2A>重载的参数传递该类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="d6f12-302">反射对通用类型系统的可访问性规则建模。</span><span class="sxs-lookup"><span data-stu-id="d6f12-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="d6f12-303">例如, 如果调用方在同一程序集中, 则调用方不需要内部成员的特殊权限。</span><span class="sxs-lookup"><span data-stu-id="d6f12-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="d6f12-304">否则, 调用方需要<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="d6f12-305">这与查找受保护的、私有的成员等的成员一致。</span><span class="sxs-lookup"><span data-stu-id="d6f12-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-306">一般原则是<xref:System.Reflection.Binder.ChangeType%2A>只应执行不会丢失数据的扩大转换。</span><span class="sxs-lookup"><span data-stu-id="d6f12-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="d6f12-307">扩大转换的一个示例是将32位有符号整数的值转换为64位有符号整数的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="d6f12-308">这与收缩转换不同, 后者可能会丢失数据。</span><span class="sxs-lookup"><span data-stu-id="d6f12-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="d6f12-309">收缩转换的一个示例是将64位有符号整数转换为32位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="d6f12-310">下表列出了默认联编程序支持的转换。</span><span class="sxs-lookup"><span data-stu-id="d6f12-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="d6f12-311">源类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-311">Source Type</span></span>|<span data-ttu-id="d6f12-312">目标类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="d6f12-313">任何类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-313">Any type</span></span>|<span data-ttu-id="d6f12-314">其基类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-314">Its base type.</span></span>|  
|<span data-ttu-id="d6f12-315">任何类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-315">Any type</span></span>|<span data-ttu-id="d6f12-316">它实现的接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-316">The interface it implements.</span></span>|  
|<span data-ttu-id="d6f12-317">Char</span><span class="sxs-lookup"><span data-stu-id="d6f12-317">Char</span></span>|<span data-ttu-id="d6f12-318">Unt16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-319">Byte</span><span class="sxs-lookup"><span data-stu-id="d6f12-319">Byte</span></span>|<span data-ttu-id="d6f12-320">Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-321">SByte</span><span class="sxs-lookup"><span data-stu-id="d6f12-321">SByte</span></span>|<span data-ttu-id="d6f12-322">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="d6f12-323">UInt16</span></span>|<span data-ttu-id="d6f12-324">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-325">Int16</span><span class="sxs-lookup"><span data-stu-id="d6f12-325">Int16</span></span>|<span data-ttu-id="d6f12-326">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="d6f12-327">UInt32</span></span>|<span data-ttu-id="d6f12-328">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-329">Int32</span><span class="sxs-lookup"><span data-stu-id="d6f12-329">Int32</span></span>|<span data-ttu-id="d6f12-330">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="d6f12-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="d6f12-331">UInt64</span></span>|<span data-ttu-id="d6f12-332">Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-332">Single, Double</span></span>|  
|<span data-ttu-id="d6f12-333">Int64</span><span class="sxs-lookup"><span data-stu-id="d6f12-333">Int64</span></span>|<span data-ttu-id="d6f12-334">Single、Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-334">Single, Double</span></span>|  
|<span data-ttu-id="d6f12-335">Single</span><span class="sxs-lookup"><span data-stu-id="d6f12-335">Single</span></span>|<span data-ttu-id="d6f12-336">Double</span><span class="sxs-lookup"><span data-stu-id="d6f12-336">Double</span></span>|  
|<span data-ttu-id="d6f12-337">非引用</span><span class="sxs-lookup"><span data-stu-id="d6f12-337">Non-reference</span></span>|<span data-ttu-id="d6f12-338">按引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-339">下面的示例从`DefaultBinder`属性获取默认联编程序, 并通过将`DefaultBinder`值作为参数传递给<xref:System.Type.InvokeMember%2A>, 来调用 MyClass 的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-340">分隔 <see cref="T:System.Type" /> 的命名空间中的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="d6f12-341">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-342">表示 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="d6f12-343">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d6f12-344">下面的代码示例演示`EmptyTypes`了一个`GetConstructor`方法中使用的字段, 用于获取不带参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-345">确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基础系统类型相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d6f12-346">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="d6f12-347">为了使比较成功，<paramref name="o" /> 必须能够被强制转换或转换为类型 <see cref="T:System.Type" /> 的一个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-348">确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 的基础系统类型相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-349">如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d6f12-350">如果 ：此方法也会返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="d6f12-351">
-   <paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="d6f12-352">
-   <paramref name="o" /> 不能强制转换或转换为 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-353">此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-354">它强制`o`转换为类型<xref:System.Type>的对象, 并调用<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-355">下面的示例使用<xref:System.Type.Equals%28System.Object%29>将各种<xref:System.Type>对象实例与各种<xref:System.Object>实例进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="d6f12-356">对于本示例, 特别要注意以下两个方面:</span><span class="sxs-lookup"><span data-stu-id="d6f12-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="d6f12-357"><xref:System.Type> <xref:System.Reflection.TypeInfo>与表示整数<xref:System.Type>返回`true`的对象表示整数的对象比较,<xref:System.Reflection.TypeInfo>因为派生自。</span><span class="sxs-lookup"><span data-stu-id="d6f12-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="d6f12-358">使用`List(Of String)`对象 (封闭式<xref:System.Type>泛型类型) <xref:System.Collections.Generic.IList%601>表示对象 (开放式泛型类型) 的对象比较返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d6f12-359">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-360">确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Type" /> 的基础系统类型相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-361">如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d6f12-362">下面的示例使用`Equals`来比较两个类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-363">表示用在特性上的成员筛选器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="d6f12-364">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-365">此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="d6f12-366">此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。</span><span class="sxs-lookup"><span data-stu-id="d6f12-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="d6f12-367">方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="d6f12-368">可以为类<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>或<xref:System.Reflection.MethodImplAttributes>上的任何一个字段分配值。 `Object`</span><span class="sxs-lookup"><span data-stu-id="d6f12-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="d6f12-369">例如, `Object`可以为指定`FieldAttributes`字段的值, 例如 Public。</span><span class="sxs-lookup"><span data-stu-id="d6f12-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="d6f12-370">在这种情况下, `FilterAttribute`当调用委托时, 仅当`true` `MemberInfo`对象表示的方法使用元数据中的公共字段特性修饰时, 它才会返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-371">下面的示例获取`FilterAttribute`委托, 将其作为参数传递<xref:System.Type.FindMembers%2A>给方法, 并显示指定的成员及其属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-372">表示用于名称的区分大小写的成员筛选器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="d6f12-373">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-374">此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="d6f12-375">此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。</span><span class="sxs-lookup"><span data-stu-id="d6f12-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="d6f12-376">方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="d6f12-377">向`Object`分配一个字符串值, 该字符串值可能包含尾随 "\*" 通配符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="d6f12-378">仅支持通配符结束字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="d6f12-379">例如, `Object`可以为分配值 "Byte \*"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="d6f12-380">在这种情况下, `FilterName`当调用委托时, 只有当`true` `MemberInfo`对象表示的方法具有以 "Byte" 开头的名称时, 它才会返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-381">下面的代码示例获取与该用户定义`Application`类型相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-382">表示用于名称的不区分大小写的成员筛选器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="d6f12-383">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-384">此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="d6f12-385">此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。</span><span class="sxs-lookup"><span data-stu-id="d6f12-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="d6f12-386">方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="d6f12-387">向`Object`分配一个字符串值, 该字符串值可能包含尾随 "\*" 通配符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="d6f12-388">仅支持通配符结束字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="d6f12-389">例如, `Object`可以为分配值 "ByTe \*"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="d6f12-390">在这种情况下, `FilterName`调用委托时, 仅当`MemberInfo`对象表示的方法具有以 "byte" 开头的名称时, 才返回 true, 忽略大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-391">下面的示例获取`MemberFilter`委托, 将其作为参数传递<xref:System.Type.FindMembers%2A>给方法, 并显示以字母 "c" 开头的`String`类的方法及其属性, 忽略大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="d6f12-392">对照 <paramref name="filterCriteria" /> 比较接口的委托。</span><span class="sxs-lookup"><span data-stu-id="d6f12-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="d6f12-393">确定接口是否应包括在返回数组中的搜索判据。</span><span class="sxs-lookup"><span data-stu-id="d6f12-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="d6f12-394">返回表示接口（由当前 <see cref="T:System.Type" /> 所实现或继承）的筛选列表的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-395">一个 <see cref="T:System.Type" /> 对象的数组，它表示由当前 <see cref="T:System.Type" /> 实现或继承的接口的已筛选的列表；如果当前 <see cref="T:System.Type" /> 未实现或继承与筛选器相匹配的接口，则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-396">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="d6f12-397">类提供<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>的和委托<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>还可以用来<xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>代替委托 <xref:System.Reflection.Module?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d6f12-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="d6f12-398">此类实现的所有接口都是在搜索过程中考虑的, 无论是由基类还是此类本身来声明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="d6f12-399">此方法搜索基类层次结构, 并返回每个类实现的每个匹配接口以及这些接口中每个接口实现的所有匹配接口 (即, 返回匹配接口的传递闭包)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="d6f12-400">不返回重复的接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="d6f12-401">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, <xref:System.Type.FindInterfaces%2A>则会搜索在类型参数上的约束中声明的所有接口, 以及通过接口继承的所有接口。在约束中声明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="d6f12-402">如果当前<xref:System.Type>表示泛型类型的类型参数, <xref:System.Type.FindInterfaces%2A>则搜索该类型实现的所有接口, 无论它们是否与约束匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-403"><xref:System.Type.FindInterfaces%2A>即使在非泛型类型上, 也可以返回泛型接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="d6f12-404">例如, 非泛型类型可能实现`IEnumerable<int>` (`IEnumerable(Of Integer)` Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-405">下面的示例查找指定类型实现或继承的指定接口, 然后显示接口名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-406"><paramref name="filter" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-407">调用静态初始值设定项时引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="d6f12-408">枚举值的按位组合，它指示要搜索的成员的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-408">A bitwise combination of the enumeration values that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-409">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-409">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-410">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-410">-or-</span></span> 
 <span data-ttu-id="d6f12-411">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-411"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="d6f12-412">执行比较的委托，如果当前被检查的成员匹配 <see langword="true" />，则返回 <paramref name="filterCriteria" />；否则返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="d6f12-413">确定成员是否在 <see langword="MemberInfo" /> 对象数组中返回的搜索判据。</span><span class="sxs-lookup"><span data-stu-id="d6f12-413">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="d6f12-414"><see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的字段可以和该类提供的 <see langword="FilterAttribute" /> 委托一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-414">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="d6f12-415">返回指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-415">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-416">指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-416">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="d6f12-417">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-417">-or-</span></span> 
<span data-ttu-id="d6f12-418">如果当前 <see cref="T:System.Type" /> 没有与筛选条件相匹配的 <paramref name="memberType" /> 类型的成员，则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-418">An empty array if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d6f12-419">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-419">This method can be overridden by a derived class.</span></span>  
  
<span data-ttu-id="d6f12-420">成员包括属性、方法、字段、事件等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-420">Members include properties, methods, fields, events, and so on.</span></span>  

<span data-ttu-id="d6f12-421"><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>要使`bindingAttr`方法成功检索成员信息, 参数必须包含至少一个和中的至少一个和和。 `FindMembers`</span><span class="sxs-lookup"><span data-stu-id="d6f12-421">For the `FindMembers` method to successfully retrieve member information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

 <span data-ttu-id="d6f12-422">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-422">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-423">指定`BindingFlags.Instance`在搜索中包含实例成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-423">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-424">指定`BindingFlags.Static`在搜索中包含静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-424">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-425">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-425">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-426">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-426">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-427">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-427">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-428">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-428">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-429">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="d6f12-430">若要使用此方法获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-430">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-431">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-431">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
<span data-ttu-id="d6f12-432">如果当前<xref:System.Type>表示泛型类型或泛型方法的类型参数, <xref:System.Type.FindMembers%2A>则会处理由类约束或类型参数的接口约束声明的任何成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-432">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  

<span data-ttu-id="d6f12-433">参数可以是类型<xref:System.Reflection.MemberFilter>的自定义委托, 也可以是以下预定义的委托之一: `filter`</span><span class="sxs-lookup"><span data-stu-id="d6f12-433">The `filter` argument can be a custom delegate of type <xref:System.Reflection.MemberFilter>, or it can be one of the following  predefined delegates:</span></span>

- <span data-ttu-id="d6f12-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, 它使用<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>或<xref:System.Reflection.MethodImplAttributes>位掩码作为`filterCriteria`值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, which uses a<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes> bitmask as the `filterCriteria` value.</span></span>

- <span data-ttu-id="d6f12-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, 使用传递给`filterCriteria`的字符串对每个成员名称执行区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, which performs a case-sensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

- <span data-ttu-id="d6f12-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, 使用传递给`filterCriteria`的字符串对每个成员名称执行不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, which performs a case-insensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

## Examples  
 <span data-ttu-id="d6f12-437">下面的示例查找与指定的搜索条件匹配的类中的所有成员, 然后显示匹配的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-438"><paramref name="filter" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-439">获取该类型的完全限定名称，包括其命名空间，但不包括程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="d6f12-440">该类型的完全限定名，包括其命名空间，但不包括程序集；如果当前实例表示泛型类型参数、数组类型、指针类型或基于类型参数的 <see langword="null" /> 类型，或表示不属于泛型类型定义但包含无法解析的类型参数的泛型类型，则为 <see langword="byref" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-441">例如, 该<xref:System.String>类型的完全限定名为`System.String`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="d6f12-442">将<xref:System.Type.AssemblyQualifiedName%2A>此与由属性返回的程序集限定名称 (包括全名和完整程序集名称) 进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="d6f12-443">如果当前类型表示封闭式泛型类型, 则由<xref:System.Type.FullName%2A>属性返回的字符串中的类型参数由其完整程序集名称限定, 即使泛型类型本身的字符串表示形式不是由它的完整程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="d6f12-444">下面的示例演示了一个类型的 FullName 属性中的差异, 该类型表示泛型类型定义, 另一个表示封闭式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="d6f12-445">如果以下情况`null` , 此属性将返回:</span><span class="sxs-lookup"><span data-stu-id="d6f12-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="d6f12-446">当前<xref:System.Type>对象表示泛型类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="d6f12-447">下面的示例检索<xref:System.Nullable%601>类型的类型参数, 并尝试显示其<xref:System.Type.FullName%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="d6f12-448">当前<xref:System.Type>对象表示数组类型、指针类型`byref`或基于泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="d6f12-449">下面的示例定义一个泛型类型, `Generictype1<T>`其中包含三个方法`Display(T[])`:, 该方法传递类型为 T 的数组;, 它被传递 t 对象; 和`ChangeValue(ref T)`通过引用传递 t 对象。 `HandleT(T)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="d6f12-450">因为C#和 Visual Basic 不允许我们将 T 定义为`HandleT`方法中的指针, 所以, 我们<xref:System.Type.MakePointerType%2A>必须对表示方法的参数类型<xref:System.Type>的对象调用方法, 以创建指向泛型类型的指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="d6f12-451">该示例的输出显示, 在所有三种情况下, <xref:System.Type.FullName%2A>属性为`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="d6f12-452">当前类型包含尚未被特定类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`true`) 替换的泛型类型参数, 但该类型不是泛型类型定义<xref:System.Type.IsGenericTypeDefinition%2A> (即, 属性返回`false`</span><span class="sxs-lookup"><span data-stu-id="d6f12-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="d6f12-453">在下面的示例中`Derived<T>` , 继承`Base<T>`自。</span><span class="sxs-lookup"><span data-stu-id="d6f12-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="d6f12-454">`null` <xref:System.Type.FullName%2A> `Derived<T>`属性获取对象, 该对象表示的基类型, 其属性返回。 <xref:System.Type> <xref:System.Type.BaseType%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="d6f12-455">若要获取<xref:System.Type.FullName%2A>不`null`是的<xref:System.Type.GetGenericTypeDefinition%2A> , 可以使用方法来获取泛型类型定义, 如示例中所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="d6f12-456">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-457">下面的示例显示指定类型的全名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="d6f12-458">下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-459">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-460">获取描述当前泛型类型参数的协变和特殊约束的 <see cref="T:System.Reflection.GenericParameterAttributes" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="d6f12-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="d6f12-461"><see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-462">此属性的值包含一些标志, 这些标志描述当前泛型类型参数是否是协变的, 以及描述任何特殊约束的标志。</span><span class="sxs-lookup"><span data-stu-id="d6f12-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="d6f12-463">使用值选择协变标志, 并<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>使用值选择约束标志。 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="d6f12-464">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-465">下面的代码示例定义了具有两`Test`个具有不同约束的类型参数的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="d6f12-466">当程序执行时, 使用<xref:System.Type.GenericParameterAttributes%2A>属性<xref:System.Type.GetGenericParameterConstraints%2A>和方法检查约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-467">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="d6f12-468">也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-469">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-470">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-471">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-472">当 <see cref="T:System.Type" /> 对象表示泛型类型或泛型方法的类型参数时，获取类型参数在声明它的泛型类型或方法的类型参数列表中的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="d6f12-473">类型参数在定义它的泛型类型或方法的类型参数列表中的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="d6f12-474">位置编号从 0 开始。</span><span class="sxs-lookup"><span data-stu-id="d6f12-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-475"><xref:System.Type.GenericParameterPosition%2A>属性返回类型参数在最初定义该类型参数的泛型类型定义或泛型方法定义的参数列表中的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="d6f12-476"><xref:System.Type.DeclaringType%2A> 和<xref:System.Type.DeclaringMethod%2A>属性标识泛型类型或方法定义:</span><span class="sxs-lookup"><span data-stu-id="d6f12-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="d6f12-477">如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="d6f12-478">`null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.</span><span class="sxs-lookup"><span data-stu-id="d6f12-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="d6f12-479">若要为<xref:System.Type.GenericParameterPosition%2A>属性的值提供正确的上下文, 必须标识类型参数所属的泛型类型或方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="d6f12-480">例如, 请考虑以下代码中泛型方法`GetSomething`的返回值:</span><span class="sxs-lookup"><span data-stu-id="d6f12-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="d6f12-481">返回`GetSomething`的类型取决于提供给类`A`和`GetSomething`自身的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="d6f12-482">你可以获取<xref:System.Reflection.MethodInfo> `GetSomething`的, 以及可以获取返回类型的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="d6f12-483">检查返回类型的类型参数时, <xref:System.Type.GenericParameterPosition%2A>对两者都返回0。</span><span class="sxs-lookup"><span data-stu-id="d6f12-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="d6f12-484">的`V`位置为 0, 因为`V`是类`A`的类型参数列表中的第一个类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="d6f12-485">的`X`位置为 0, 因为`X`是的类型参数列表`GetSomething`中的第一个类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-486">如果当前<xref:System.Type>不表示类型参数, 则调用属性会导致异常。<xref:System.Type.GenericParameterPosition%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="d6f12-487">检查开放式构造类型的类型参数时, 请使用<xref:System.Type.IsGenericParameter%2A>属性告诉它们是类型参数和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="d6f12-488"><xref:System.Type.GenericParameterPosition%2A> <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.DeclaringType%2A>属性为类型`true`参数返回; 您可以使用方法获取其位置, 并使用和属性来确定定义它的泛型方法或类型定义<xref:System.Type.IsGenericParameter%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6f12-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-489">下面的示例定义了一个具有两个类型参数的泛型类, 并定义了第一个派生自第一个类的泛型类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="d6f12-490">派生类的基类具有两个类型参数: 第一个是<xref:System.Int32>, 第二个是派生类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="d6f12-491">该示例显示有关这些泛型类的信息, 包括<xref:System.Type.GenericParameterPosition%2A>属性报告的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-492">当前的类型不表示类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="d6f12-493">也就是说，<see cref="P:System.Type.IsGenericParameter" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-494">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-495">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-496">获取此类型泛型类型参数的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="d6f12-497">此类型的泛型类型参数的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-498">此属性仅获取泛型类型参数;也就是说, 已为当前类型的泛型类型参数指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="d6f12-499">如果当前类型是泛型类型定义, 则此属性返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-500">如果泛型类型在泛型方法或其他泛型类型中使用, 则它的某些泛型类型参数可能是封闭方法或类型的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="d6f12-501">若要获取表示泛型类型定义的类型的泛型类型参数, 请使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d6f12-502">若要获取<xref:System.Reflection.TypeInfo>当前<xref:System.Type>对象的对象, 请使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>扩展方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-503">获取数组中的维数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="d6f12-504">包含当前类型中维数的整数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d6f12-505">下面的示例显示数组中的维度数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-506">此方法的功能在基类中不受支持，并且必须改为在派生类中实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-507">当前类型不是数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-508">在派生类中重写时，实现 <see cref="P:System.Type.Attributes" /> 属性，并获取枚举值的按位组合（它指示与 <see cref="T:System.Type" /> 关联的特性）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitwise combination of enumeration values that indicate the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-509">表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-510">获取当前 <see cref="T:System.Type" /> 的特定构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="d6f12-511">表示需要的构造函数的参数个数、顺序和类型的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="d6f12-512">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-512">-or-</span></span> 
<span data-ttu-id="d6f12-513"><see cref="T:System.Type" /> 对象的空数组，用于获取不带参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="d6f12-514">这样的空数组由 <see langword="static" /> 字段 <see cref="F:System.Type.EmptyTypes" /> 提供。</span><span class="sxs-lookup"><span data-stu-id="d6f12-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-515">搜索其参数与指定数组中的类型匹配的公共实例构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="d6f12-516">为表示某个公共实例构造函数（该构造函数的参数与参数类型数组中的类型匹配）的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-517">此方法重载查找公共实例构造函数, 不能用于获取类初始值设定项 (静态构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (static constructor).</span></span> <span data-ttu-id="d6f12-518">若要获取类初始值设定项, 请使用采用<xref:System.Reflection.BindingFlags>的重载, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-519">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-520">如果请求的构造函数是非公共的, 则此方法`null`返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-521">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-522">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-523">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-524">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-525">下面的示例获取的类型`MyClass`, <xref:System.Reflection.ConstructorInfo>获取对象, 并显示构造函数签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-526"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-527">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-527">-or-</span></span> 
<span data-ttu-id="d6f12-528"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-529"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-530">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-530">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-531">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-531">-or-</span></span> 
 <span data-ttu-id="d6f12-532">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-532"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-533">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-534">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-534">-or-</span></span> 
<span data-ttu-id="d6f12-535">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-536"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="d6f12-537">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-537">-or-</span></span> 
<span data-ttu-id="d6f12-538">获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="d6f12-539">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-539">-or-</span></span> 
 <span data-ttu-id="d6f12-540"><see cref="F:System.Type.EmptyTypes" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-541"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与参数类型数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="d6f12-542">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-543">使用指定绑定约束搜索其参数与指定自变量类型和修饰符匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-544">表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-545">如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="d6f12-546">如果无法选择匹配项`null` , 则返回。 `binder`</span><span class="sxs-lookup"><span data-stu-id="d6f12-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="d6f12-547">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-548">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-549">指定`BindingFlags.Public`在搜索中包括公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-550">指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-551">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-552">若要使用此方法重载获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-552">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-553">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-554">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-555">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-556">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-557">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-558">下面的程序获取类的`MyClass1`类型, <xref:System.Reflection.ConstructorInfo>获取与指定的绑定标志匹配的对象, 并显示该构造函数的签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-559"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-560">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-560">-or-</span></span> 
<span data-ttu-id="d6f12-561"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-562"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-563">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-563">-or-</span></span> 
 <span data-ttu-id="d6f12-564"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-565">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-565">-or-</span></span> 
 <span data-ttu-id="d6f12-566"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-567">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-567">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-568">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-568">-or-</span></span> 
 <span data-ttu-id="d6f12-569">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-569"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-570">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-571">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-571">-or-</span></span> 
<span data-ttu-id="d6f12-572">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="d6f12-573">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-574"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="d6f12-575">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-575">-or-</span></span> 
<span data-ttu-id="d6f12-576">获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-577"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-578">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-579">用指定绑定约束和指定调用约定，搜索其参数与指定参数类型及修饰符匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="d6f12-580">表示符合指定要求的构造函数的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-581">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-582">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-583">如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="d6f12-584">如果无法选择匹配项`null` , 则返回。 `binder`</span><span class="sxs-lookup"><span data-stu-id="d6f12-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="d6f12-585">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-586">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-587">指定`BindingFlags.Public`在搜索中包括公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-588">指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-589">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-590">若要使用此方法获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-590">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-591">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-592">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-593">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-593">Member Type</span></span>|<span data-ttu-id="d6f12-594">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-594">Static</span></span>|<span data-ttu-id="d6f12-595">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-596">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-596">Constructor</span></span>|<span data-ttu-id="d6f12-597">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-597">No</span></span>|<span data-ttu-id="d6f12-598">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-598">No</span></span>|  
|<span data-ttu-id="d6f12-599">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-599">Field</span></span>|<span data-ttu-id="d6f12-600">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-600">No</span></span>|<span data-ttu-id="d6f12-601">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-601">Yes.</span></span> <span data-ttu-id="d6f12-602">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-603">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-603">Event</span></span>|<span data-ttu-id="d6f12-604">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-604">Not applicable</span></span>|<span data-ttu-id="d6f12-605">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-606">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-607">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-607">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-608">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-608">Method</span></span>|<span data-ttu-id="d6f12-609">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-609">No</span></span>|<span data-ttu-id="d6f12-610">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-610">Yes.</span></span> <span data-ttu-id="d6f12-611">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-612">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-612">Nested Type</span></span>|<span data-ttu-id="d6f12-613">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-613">No</span></span>|<span data-ttu-id="d6f12-614">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-614">No</span></span>|  
|<span data-ttu-id="d6f12-615">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-615">Property</span></span>|<span data-ttu-id="d6f12-616">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-616">Not applicable</span></span>|<span data-ttu-id="d6f12-617">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-618">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-619">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-620">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-621">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-622">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-623">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-624">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-625">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-626">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-627">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-628">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-629">下面的示例获取的类型`MyClass1`, <xref:System.Reflection.ConstructorInfo>获取与指定的绑定标志匹配的对象, 并显示构造函数签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-630"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-631">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-631">-or-</span></span> 
<span data-ttu-id="d6f12-632"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-633"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-634">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-634">-or-</span></span> 
 <span data-ttu-id="d6f12-635"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-636">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-636">-or-</span></span> 
 <span data-ttu-id="d6f12-637"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-638">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-638">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-639">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-639">-or-</span></span> 
<span data-ttu-id="d6f12-640">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-640"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-641">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-642">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-642">-or-</span></span> 
<span data-ttu-id="d6f12-643">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="d6f12-644">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-645"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="d6f12-646">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-646">-or-</span></span> 
<span data-ttu-id="d6f12-647">获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-648"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-649">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-650">当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="d6f12-651">表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-652">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-653">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-654">如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="d6f12-655">如果无法选择匹配项`null` , 则返回。 `binder`</span><span class="sxs-lookup"><span data-stu-id="d6f12-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="d6f12-656">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-657">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-658">指定`BindingFlags.Public`在搜索中包括公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-659">指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-660">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-661">此方法实现 <xref:System.Type.GetConstructor%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-662"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-663">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-663">-or-</span></span> 
<span data-ttu-id="d6f12-664"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-665"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-666">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-666">-or-</span></span> 
 <span data-ttu-id="d6f12-667"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-668">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-668">-or-</span></span> 
 <span data-ttu-id="d6f12-669"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-670">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-671">获取当前 <see cref="T:System.Type" /> 的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-672">返回为当前 <see cref="T:System.Type" /> 定义的所有公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-673"><see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 定义的所有公共实例构造函数，但不包括类型初始值设定项（静态构造函数）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="d6f12-674">如果没有为当前 <see cref="T:System.Type" /> 定义公共实例构造函数，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法的定义中的类型参数，则返回 <see cref="T:System.Reflection.ConstructorInfo" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-675"><xref:System.Type.GetConstructors%2A>方法不按特定顺序 (如声明顺序) 返回构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="d6f12-676">你的代码不能依赖于构造函数的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-677">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-678">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-678">Member Type</span></span>|<span data-ttu-id="d6f12-679">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-679">Static</span></span>|<span data-ttu-id="d6f12-680">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-681">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-681">Constructor</span></span>|<span data-ttu-id="d6f12-682">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-682">No</span></span>|<span data-ttu-id="d6f12-683">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-683">No</span></span>|  
|<span data-ttu-id="d6f12-684">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-684">Field</span></span>|<span data-ttu-id="d6f12-685">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-685">No</span></span>|<span data-ttu-id="d6f12-686">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-686">Yes.</span></span> <span data-ttu-id="d6f12-687">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-688">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-688">Event</span></span>|<span data-ttu-id="d6f12-689">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-689">Not applicable</span></span>|<span data-ttu-id="d6f12-690">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-691">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-692">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-692">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-693">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-693">Method</span></span>|<span data-ttu-id="d6f12-694">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-694">No</span></span>|<span data-ttu-id="d6f12-695">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-695">Yes.</span></span> <span data-ttu-id="d6f12-696">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-697">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-697">Nested Type</span></span>|<span data-ttu-id="d6f12-698">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-698">No</span></span>|<span data-ttu-id="d6f12-699">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-699">No</span></span>|  
|<span data-ttu-id="d6f12-700">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-700">Property</span></span>|<span data-ttu-id="d6f12-701">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-701">Not applicable</span></span>|<span data-ttu-id="d6f12-702">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-703">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-704">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-705">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-706">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-707">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-708">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-709">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-710">此方法重载调用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法重载&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在VisualBasic中)。`Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-711">它将找不到类初始值设定项 (静态构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-711">It will not find class initializers (static constructor).</span></span> <span data-ttu-id="d6f12-712">若要查找类初始值设定项, 请使用<xref:System.Reflection.BindingFlags>采用的重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-713">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-714">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.ConstructorInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-715">例如, 如果`C<T>`类具有构造函数<xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `C(T t1)` (`Sub New(ByVal t1 As T)`在 Visual Basic 中), `C<int>` `C(int t1)`则C#将返回表示中的`Sub New(ByVal t1 As Integer)`基本)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="d6f12-716">如果当前<xref:System.Type>表示泛型类型参数, 则该<xref:System.Type.GetConstructors%2A>方法返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-717">此示例显示具有两个实例<xref:System.Type.GetConstructors%2A>构造函数和一个静态构造函数的类的重载的输出。</span><span class="sxs-lookup"><span data-stu-id="d6f12-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="d6f12-718">此代码的输出为:</span><span class="sxs-lookup"><span data-stu-id="d6f12-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="d6f12-719">2</span><span class="sxs-lookup"><span data-stu-id="d6f12-719">2</span></span>  
  
 <span data-ttu-id="d6f12-720">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-720">False</span></span>  
  
 <span data-ttu-id="d6f12-721">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-721">False</span></span>  
  
 <span data-ttu-id="d6f12-722"><xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `IsStatic`因为重载仅使用和, 所以静态构造函数既不由`for`表达式进行计数, 也不由计算。 <xref:System.Type.GetConstructors></span><span class="sxs-lookup"><span data-stu-id="d6f12-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="d6f12-723">若要查找静态构造函数, <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>请使用重载, 并传递、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 `OR` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>组合 (逻辑), 如下面的代码示例所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="d6f12-724">输出如下:</span><span class="sxs-lookup"><span data-stu-id="d6f12-724">Now the output is:</span></span>  
  
 <span data-ttu-id="d6f12-725">3</span><span class="sxs-lookup"><span data-stu-id="d6f12-725">3</span></span>  
  
 <span data-ttu-id="d6f12-726">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-726">False</span></span>  
  
 <span data-ttu-id="d6f12-727">True</span><span class="sxs-lookup"><span data-stu-id="d6f12-727">True</span></span>  
  
 <span data-ttu-id="d6f12-728">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-729">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-729">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-730">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-730">-or-</span></span> 
<span data-ttu-id="d6f12-731">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-731"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-732">当在派生类中重写时，使用指定 <see cref="T:System.Type" /> 搜索为当前 <see langword="BindingFlags" /> 定义的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-733">表示为当前 <see cref="T:System.Reflection.ConstructorInfo" /> 定义的匹配指定绑定约束的所有构造函数的 <see cref="T:System.Type" /> 对象数组，包括类型初始值设定项（如果定义的话）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="d6f12-734">如果当前 <see cref="T:System.Reflection.ConstructorInfo" /> 没有定义构造函数，或者定义的构造函数都不符合绑定约束，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法定义的类型参数，则返回 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="d6f12-735">`bindingAttr`可用于指定是只返回公共构造函数还是返回公共和非公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-735">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
<span data-ttu-id="d6f12-736">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-736">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
- <span data-ttu-id="d6f12-737">`BindingFlags.Static` 与`BindingFlags.NonPublic`一起指定以检索类初始值设定项 (静态构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-737">Specify `BindingFlags.Static` along with `BindingFlags.NonPublic` to retrieve the class initializer (static constructor).</span></span> <span data-ttu-id="d6f12-738">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-738">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>

- <span data-ttu-id="d6f12-739">同时`BindingFlags.Instance` `BindingFlags.NonPublic`指定和和,以检索实例构造函数。`BindingFlags.Public`</span><span class="sxs-lookup"><span data-stu-id="d6f12-739">Specify `BindingFlags.Instance` along with one or both of `BindingFlags.Public` and `BindingFlags.NonPublic` to retrieve instance constructors.</span></span>   
  
<span data-ttu-id="d6f12-740">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-740">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="d6f12-741"><xref:System.Type.GetConstructors%2A>方法不按特定顺序 (如声明顺序) 返回构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-741">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="d6f12-742">你的代码不能依赖于构造函数的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-742">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  

<span data-ttu-id="d6f12-743">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.ConstructorInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-743">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-744">例如, 如果`C<T>`类具有构造函数<xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `C(T t1)` (`Sub New(ByVal t1 As T)`在 Visual Basic 中), `C<int>` `C(int t1)`则C#将返回表示中的`Sub New(ByVal t1 As Integer)`基本)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-744">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
<span data-ttu-id="d6f12-745">如果当前<xref:System.Type>表示泛型类型参数, 则该<xref:System.Type.GetConstructors%2A>方法返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-745">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
## Examples  

<span data-ttu-id="d6f12-746">此示例显示具有两个实例<xref:System.Type.GetConstructors>构造函数和一个静态构造函数的类的重载的输出。</span><span class="sxs-lookup"><span data-stu-id="d6f12-746">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="d6f12-747">此代码的输出为:</span><span class="sxs-lookup"><span data-stu-id="d6f12-747">The output of this code is:</span></span>  
  
 <span data-ttu-id="d6f12-748">2</span><span class="sxs-lookup"><span data-stu-id="d6f12-748">2</span></span>  
  
 <span data-ttu-id="d6f12-749">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-749">False</span></span>  
  
 <span data-ttu-id="d6f12-750">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-750">False</span></span>  
  
 <span data-ttu-id="d6f12-751"><xref:System.Reflection.BindingFlags.Public> <xref:System.Reflection.BindingFlags.Instance> `IsStatic`因为重载仅使用和, 所以静态构造函数既不由`for`表达式进行计数, 也不由计算。 <xref:System.Type.GetConstructors%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-751">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="d6f12-752">若要查找静态构造函数, <xref:System.Type.GetConstructors%2A>请使用重载, 并向其传递<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>、的组合 (逻辑或), 如下面的代码示例所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-752">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="d6f12-753">输出如下:</span><span class="sxs-lookup"><span data-stu-id="d6f12-753">Now the output is:</span></span>  
  
 <span data-ttu-id="d6f12-754">3</span><span class="sxs-lookup"><span data-stu-id="d6f12-754">3</span></span>  
  
 <span data-ttu-id="d6f12-755">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-755">False</span></span>  
  
 <span data-ttu-id="d6f12-756">True</span><span class="sxs-lookup"><span data-stu-id="d6f12-756">True</span></span>  
  
 <span data-ttu-id="d6f12-757">False</span><span class="sxs-lookup"><span data-stu-id="d6f12-757">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-758">搜索为设置了 <see cref="T:System.Type" /> 的当前 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 定义的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-758">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="d6f12-759">表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有默认成员的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-759">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-760">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-760">-or-</span></span> 
<span data-ttu-id="d6f12-761">如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-761">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-762"><xref:System.Type.GetDefaultMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-762">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-763">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-763">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-764">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-764">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="d6f12-765">成员包括属性、方法、字段、事件等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-765">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-766">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-766">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-767">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-767">Member Type</span></span>|<span data-ttu-id="d6f12-768">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-768">Static</span></span>|<span data-ttu-id="d6f12-769">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-769">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-770">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-770">Constructor</span></span>|<span data-ttu-id="d6f12-771">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-771">No</span></span>|<span data-ttu-id="d6f12-772">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-772">No</span></span>|  
|<span data-ttu-id="d6f12-773">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-773">Field</span></span>|<span data-ttu-id="d6f12-774">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-774">No</span></span>|<span data-ttu-id="d6f12-775">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-775">Yes.</span></span> <span data-ttu-id="d6f12-776">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-776">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-777">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-777">Event</span></span>|<span data-ttu-id="d6f12-778">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-778">Not applicable</span></span>|<span data-ttu-id="d6f12-779">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-779">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-780">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-780">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-781">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-781">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-782">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-782">Method</span></span>|<span data-ttu-id="d6f12-783">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-783">No</span></span>|<span data-ttu-id="d6f12-784">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-784">Yes.</span></span> <span data-ttu-id="d6f12-785">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-785">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-786">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-786">Nested Type</span></span>|<span data-ttu-id="d6f12-787">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-787">No</span></span>|<span data-ttu-id="d6f12-788">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-788">No</span></span>|  
|<span data-ttu-id="d6f12-789">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-789">Property</span></span>|<span data-ttu-id="d6f12-790">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-790">Not applicable</span></span>|<span data-ttu-id="d6f12-791">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-791">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-792">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-792">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-793">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-793">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-794">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-794">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-795">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-795">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-796">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-796">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-797">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-797">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-798">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-798">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-799">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-799">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="d6f12-800">例如, 如果类`C<T>`具有一个返回`P` `T`的属性, 则在<xref:System.Type.GetDefaultMembers%2A>中`C<int>`调用`int P`将C#在`Property P As Integer`中返回 (在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-800">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="d6f12-801">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-802">下面的示例获取的默认成员信息`MyClass`并显示默认成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-802">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-803">当在派生类中重写时，返回当前数组、指针或引用类型包含的或引用的对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-803">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-804">当前数组、指针或引用类型包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see langword="null" /> 不是数组或指针，不是按引用传递，或者表示泛型类型或泛型方法的定义中的泛型类型或类型参数，则为 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-804">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-805">此方法`null` <xref:System.Array>为类返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-805">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-806">下面的示例演示如何使用`GetElementType`方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-806">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d6f12-807">要检索其名称的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-807">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d6f12-808">返回当前枚举类型中具有指定值的常数的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-808">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-809">当前枚举类型中具有指定值的成员的名称；如果未找到这样的常数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-809">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-810">当前类型不是一个枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-810">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="d6f12-811">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-811">-or-</span></span> 
 <span data-ttu-id="d6f12-812"><paramref name="value" /> 既不是当前类型，也不具有与当前类型相同的基础类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-812"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-813"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-813"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-814">返回当前枚举类型中各个成员的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-814">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-815">一个数组，其中包含枚举中各个成员的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-815">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-816">返回值数组的元素按枚举常量的二进制值 (即无符号值) 排序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-816">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="d6f12-817">如果数组包含具有相同值的枚举常量, 则不指定其对应名称的顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-817">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-818">当前类型不是一个枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-818">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-819">返回当前枚举类型的基础类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-819">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-820">当前枚举的基础类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-820">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-821">默认情况下, 和 Visual Basic 中C#的枚举的基础类型为<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-821">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="d6f12-822">可以指定其他整数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-822">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-823">当前类型不是一个枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-823">The current type is not an enumeration.</span></span>  
  
 <span data-ttu-id="d6f12-824">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-824">-or-</span></span>  
  
 <span data-ttu-id="d6f12-825">枚举类型无效，因为它包含多个实例字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-825">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-826">返回当前枚举类型中各个常数的值组成的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-826">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-827">包含值的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-827">An array that contains the values.</span></span> <span data-ttu-id="d6f12-828">该数组的元素按枚举常量的二进制值（无符号值）排序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-828">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-829">当前类型不是一个枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-829">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-830">获取由当前 <see cref="T:System.Type" /> 声明或继承的特定事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-830">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-831">该字符串包含事件名称，该事件是由当前 <see cref="T:System.Type" /> 声明或继承的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-831">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-832">返回表示指定的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-832">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="d6f12-833">如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-833">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-834">如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-834">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="d6f12-835">否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-835">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-836">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-836">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-837">搜索包括公共静态和公共实例事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-837">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="d6f12-838">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-838">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-839">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-839">Member Type</span></span>|<span data-ttu-id="d6f12-840">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-840">Static</span></span>|<span data-ttu-id="d6f12-841">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-841">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-842">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-842">Constructor</span></span>|<span data-ttu-id="d6f12-843">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-843">No</span></span>|<span data-ttu-id="d6f12-844">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-844">No</span></span>|  
|<span data-ttu-id="d6f12-845">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-845">Field</span></span>|<span data-ttu-id="d6f12-846">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-846">No</span></span>|<span data-ttu-id="d6f12-847">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-847">Yes.</span></span> <span data-ttu-id="d6f12-848">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-848">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-849">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-849">Event</span></span>|<span data-ttu-id="d6f12-850">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-850">Not applicable</span></span>|<span data-ttu-id="d6f12-851">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-851">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-852">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-852">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-853">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-853">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-854">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-854">Method</span></span>|<span data-ttu-id="d6f12-855">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-855">No</span></span>|<span data-ttu-id="d6f12-856">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-856">Yes.</span></span> <span data-ttu-id="d6f12-857">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-857">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-858">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-858">Nested Type</span></span>|<span data-ttu-id="d6f12-859">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-859">No</span></span>|<span data-ttu-id="d6f12-860">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-860">No</span></span>|  
|<span data-ttu-id="d6f12-861">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-861">Property</span></span>|<span data-ttu-id="d6f12-862">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-862">Not applicable</span></span>|<span data-ttu-id="d6f12-863">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-863">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-864">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-864">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-865">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-865">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-866">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-866">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-867">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-867">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-868">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-868">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-869">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-869">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-870">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-870">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-871">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.EventInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-871">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-872">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-873">下面的示例创建一个<xref:System.Reflection.EventInfo>对象, 并为指定的事件获取按钮类的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-873">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-874"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-874"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-875">字符串包含由当前的 <see cref="T:System.Type" /> 声明或继承的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-875">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-876">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-876">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-877">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-877">-or-</span></span> 
 <span data-ttu-id="d6f12-878">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-878"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-879">当在派生类中重写时，使用指定绑定约束，返回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-879">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-880">如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-880">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-881">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的事件:</span><span class="sxs-lookup"><span data-stu-id="d6f12-881">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-882">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-882">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-883">指定`BindingFlags.Public`在搜索中包括公共事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-883">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-884">指定`BindingFlags.NonPublic`以在搜索中包括非公共事件 (即, 私有事件、内部事件和受保护事件)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-884">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-885">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-885">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-886">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-886">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-887">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-887">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-888">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的事件, 而不搜索只是继承的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-888">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-889">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-889">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-890">如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-890">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="d6f12-891">否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-891">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-892">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.EventInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-892">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-893">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-893">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-894">下面的代码示例使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法在类型中搜索名为 "单击" 的`static`公共或非公共事件 (`Shared`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-894">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-895"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-895"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-896">获取由当前 <see cref="T:System.Type" /> 声明或继承的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-896">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-897">返回由当前 <see cref="T:System.Type" /> 声明或继承的所有公共事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-897">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-898">表示由当前 <see cref="T:System.Reflection.EventInfo" /> 声明或继承的所有公共事件的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-898">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-899">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-899">-or-</span></span> 
<span data-ttu-id="d6f12-900">如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-900">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-901">如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-901">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="d6f12-902">否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-902">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-903"><xref:System.Type.GetEvents%2A>方法不按特定顺序返回事件, 如字母顺序或声明顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-903">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-904">你的代码不能依赖于事件的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-904">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-905">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-905">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="d6f12-906">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-906">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-907">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-907">Member Type</span></span>|<span data-ttu-id="d6f12-908">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-908">Static</span></span>|<span data-ttu-id="d6f12-909">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-909">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-910">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-910">Constructor</span></span>|<span data-ttu-id="d6f12-911">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-911">No</span></span>|<span data-ttu-id="d6f12-912">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-912">No</span></span>|  
|<span data-ttu-id="d6f12-913">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-913">Field</span></span>|<span data-ttu-id="d6f12-914">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-914">No</span></span>|<span data-ttu-id="d6f12-915">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-915">Yes.</span></span> <span data-ttu-id="d6f12-916">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-916">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-917">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-917">Event</span></span>|<span data-ttu-id="d6f12-918">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-918">Not applicable</span></span>|<span data-ttu-id="d6f12-919">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-919">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-920">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-920">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-921">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-921">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-922">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-922">Method</span></span>|<span data-ttu-id="d6f12-923">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-923">No</span></span>|<span data-ttu-id="d6f12-924">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-924">Yes.</span></span> <span data-ttu-id="d6f12-925">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-925">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-926">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-926">Nested Type</span></span>|<span data-ttu-id="d6f12-927">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-927">No</span></span>|<span data-ttu-id="d6f12-928">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-928">No</span></span>|  
|<span data-ttu-id="d6f12-929">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-929">Property</span></span>|<span data-ttu-id="d6f12-930">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-930">Not applicable</span></span>|<span data-ttu-id="d6f12-931">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-931">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-932">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-932">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-933">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-933">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-934">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-934">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-935">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-935">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-936">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-936">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-937">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-937">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-938">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-938">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-939">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.EventInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-939">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-940">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-940">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-941">下面的示例获取对象的<xref:System.Reflection.EventInfo>数组, 获取`Button`类的所有事件, 并显示事件名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-941">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="d6f12-942">若要编译 Visual Basic 示例, 请使用以下命令行:</span><span class="sxs-lookup"><span data-stu-id="d6f12-942">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-943">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-943">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="d6f12-944">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-944">-or-</span></span>

 <span data-ttu-id="d6f12-945">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-945"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-946">当在派生类中重写时，使用指定绑定约束，搜索由当前 <see cref="T:System.Type" /> 声明或继承的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-946">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-947"><see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 所声明或继承的与指定绑定约束匹配的所有事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-947">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="d6f12-948">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-948">-or-</span></span> 
<span data-ttu-id="d6f12-949">如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有事件，或者如果没有一个事件匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-949">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-950"><xref:System.Type.GetEvents%2A>方法不按特定顺序返回事件, 如字母顺序或声明顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-950">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-951">你的代码不能依赖于事件的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-951">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-952">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的事件:</span><span class="sxs-lookup"><span data-stu-id="d6f12-952">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-953">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-953">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-954">指定`BindingFlags.Public`在搜索中包括公共事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-954">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-955">指定`BindingFlags.NonPublic`以在搜索中包括非公共事件 (即, 私有事件、内部事件和受保护事件)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-955">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="d6f12-956">仅返回基类的受保护事件和内部事件;不返回基类上的私有事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-956">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="d6f12-957">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-957">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-958">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-958">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-959">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的事件, 而不搜索只是继承的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-959">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-960">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-960">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-961">如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-961">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="d6f12-962">否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-962">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-963">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.EventInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-964">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-965">下面的示例获取与指定绑定<xref:System.Reflection.EventInfo>标志匹配的对象的数组, 获取`Button`类的所有事件, 并显示事件名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-965">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="d6f12-966">若要编译 Visual Basic 示例, 请使用以下命令行:</span><span class="sxs-lookup"><span data-stu-id="d6f12-966">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-967">获取当前 <see cref="T:System.Type" /> 的特定字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-967">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-968">包含要获取的数据字段的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-968">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-969">搜索具有指定名称的公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-969">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-970">如找到，则为表示具有指定名称的公共字段的对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-970">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-971">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-971">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-972">搜索包括公共静态和公共实例字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-972">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="d6f12-973">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.FieldInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-973">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-974">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-974">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-975">下面的示例获取`Type`指定类的对象, <xref:System.Reflection.FieldInfo>获取该字段的对象, 并显示该字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-975">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-976"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-976"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-977">此 <see cref="T:System.Type" /> 对象是尚未调用其 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法的 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-977">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-978">包含要获取的数据字段的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-978">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-979">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-979">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-980">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-980">-or-</span></span> 
 <span data-ttu-id="d6f12-981">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-981"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-982">使用指定绑定约束搜索指定字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-982">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-983">表示符合指定需求的字段的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-983">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-984">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-984">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-985">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-985">Member Type</span></span>|<span data-ttu-id="d6f12-986">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-986">Static</span></span>|<span data-ttu-id="d6f12-987">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-987">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-988">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-988">Constructor</span></span>|<span data-ttu-id="d6f12-989">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-989">No</span></span>|<span data-ttu-id="d6f12-990">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-990">No</span></span>|  
|<span data-ttu-id="d6f12-991">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-991">Field</span></span>|<span data-ttu-id="d6f12-992">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-992">No</span></span>|<span data-ttu-id="d6f12-993">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-993">Yes.</span></span> <span data-ttu-id="d6f12-994">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-994">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-995">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-995">Event</span></span>|<span data-ttu-id="d6f12-996">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-996">Not applicable</span></span>|<span data-ttu-id="d6f12-997">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-997">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-998">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-998">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-999">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-999">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1000">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1000">Method</span></span>|<span data-ttu-id="d6f12-1001">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1001">No</span></span>|<span data-ttu-id="d6f12-1002">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1002">Yes.</span></span> <span data-ttu-id="d6f12-1003">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1003">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1004">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1004">Nested Type</span></span>|<span data-ttu-id="d6f12-1005">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1005">No</span></span>|<span data-ttu-id="d6f12-1006">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1006">No</span></span>|  
|<span data-ttu-id="d6f12-1007">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1007">Property</span></span>|<span data-ttu-id="d6f12-1008">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1008">Not applicable</span></span>|<span data-ttu-id="d6f12-1009">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1009">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1010">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1010">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1011">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1011">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1012">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1012">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1013">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1013">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1014">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1014">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1015">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1015">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1016">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1016">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1017">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的字段:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1017">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1018">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1018">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1019">指定`BindingFlags.Public`在搜索中包含公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1019">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1020">指定`BindingFlags.NonPublic`以包括搜索中的非公共字段 (即, 私有字段、内部字段和受保护字段)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1020">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1021">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1021">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1022">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1022">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1023">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1023">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1024">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的字段, 而不搜索只是继承的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1024">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1025">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1025">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1026">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.FieldInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1026">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1027">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1028">下面的示例获取`Type`指定类的对象, <xref:System.Reflection.FieldInfo>获取与指定绑定标志匹配的字段的对象, 并显示该字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1028">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1029"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1029"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1030">获取当前 <see cref="T:System.Type" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1030">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1031">返回当前 <see cref="T:System.Type" /> 的所有公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1031">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1032">表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的所有公共字段的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1032">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-1033">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1033">-or-</span></span> 
<span data-ttu-id="d6f12-1034">如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的公共字段，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1034">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1035"><xref:System.Type.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1035">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1036">你的代码不能依赖于字段的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1036">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1037">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1037">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1038">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1038">Member Type</span></span>|<span data-ttu-id="d6f12-1039">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1039">Static</span></span>|<span data-ttu-id="d6f12-1040">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1040">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1041">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1041">Constructor</span></span>|<span data-ttu-id="d6f12-1042">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1042">No</span></span>|<span data-ttu-id="d6f12-1043">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1043">No</span></span>|  
|<span data-ttu-id="d6f12-1044">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1044">Field</span></span>|<span data-ttu-id="d6f12-1045">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1045">No</span></span>|<span data-ttu-id="d6f12-1046">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1046">Yes.</span></span> <span data-ttu-id="d6f12-1047">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1047">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1048">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1048">Event</span></span>|<span data-ttu-id="d6f12-1049">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1049">Not applicable</span></span>|<span data-ttu-id="d6f12-1050">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1050">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1051">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1051">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1052">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1052">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1053">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1053">Method</span></span>|<span data-ttu-id="d6f12-1054">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1054">No</span></span>|<span data-ttu-id="d6f12-1055">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1055">Yes.</span></span> <span data-ttu-id="d6f12-1056">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1056">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1057">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1057">Nested Type</span></span>|<span data-ttu-id="d6f12-1058">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1058">No</span></span>|<span data-ttu-id="d6f12-1059">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1059">No</span></span>|  
|<span data-ttu-id="d6f12-1060">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1060">Property</span></span>|<span data-ttu-id="d6f12-1061">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1061">Not applicable</span></span>|<span data-ttu-id="d6f12-1062">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1062">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1063">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1063">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1064">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1064">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1065">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1065">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1066">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1066">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1067">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1067">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1068">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1068">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1069">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1069">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1070">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.FieldInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1070">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1071">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1071">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1072">下面的示例演示`GetFields()`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1072">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1073">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1073">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="d6f12-1074">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1074">-or-</span></span>

 <span data-ttu-id="d6f12-1075">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1075"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1076">当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1076">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1077">表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的匹配指定绑定约束的所有字段的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1077">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="d6f12-1078">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1078">-or-</span></span> 
<span data-ttu-id="d6f12-1079">如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的字段，或者如果没有一个定义的字段匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1079">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="d6f12-1080"><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索属性信息, 参数必须包含至少一个和, 以及至少一个和中的一个。 `GetFields(BindingFlags)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1080">For the `GetFields(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="d6f12-1081">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的字段:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1081">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
- <span data-ttu-id="d6f12-1082">指定`BindingFlags.Instance`以包括实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1082">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="d6f12-1083">指定`BindingFlags.Static`以包括静态方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1083">Specify `BindingFlags.Static` to include static methods.</span></span> 
    
- <span data-ttu-id="d6f12-1084">指定`BindingFlags.Public`在搜索中包含公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1084">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
- <span data-ttu-id="d6f12-1085">指定`BindingFlags.NonPublic`以包括搜索中的非公共字段 (即, 私有字段、内部字段和受保护字段)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1085">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="d6f12-1086">仅返回基类的受保护字段和内部字段;不返回基类上的私有字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1086">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
- <span data-ttu-id="d6f12-1087">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1087">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="d6f12-1088">单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.PropertyInfo>数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1088">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

<span data-ttu-id="d6f12-1089">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1089">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="d6f12-1090">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的字段, 而不搜索只是继承的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1090">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
<span data-ttu-id="d6f12-1091">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1091">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="d6f12-1092"><xref:System.Type.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1092">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1093">你的代码不能依赖于字段的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1093">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  

 <span data-ttu-id="d6f12-1094">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.FieldInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1094">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1095">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的公共字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1095">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
## Examples  
 <span data-ttu-id="d6f12-1096">下面的示例演示`GetFields(BindingFlags)`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1096">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1097">返回表示封闭式泛型类型的类型参数或泛型类型定义的类型参数的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1097">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1098">表示泛型类型的类型实参的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1098">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="d6f12-1099">如果当前类型不是泛型类型，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1099">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1100">数组元素按它们出现在泛型类型的类型参数列表中的顺序返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1100">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="d6f12-1101">如果当前类型是封闭式构造类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`false`), 则<xref:System.Type.GetGenericArguments%2A>方法返回的数组包含已分配给泛型类型定义的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1101">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="d6f12-1102">如果当前类型是泛型类型定义, 则数组包含类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1102">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="d6f12-1103">如果当前的类型是开放式构造类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`true`), 并且未将特定类型分配给封闭泛型类型或方法的所有类型参数和类型参数, 则数组包含类型和类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1103">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="d6f12-1104"><xref:System.Type.IsGenericParameter%2A>使用属性将它们区分开来。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1104">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="d6f12-1105">有关此方案的演示, 请参阅<xref:System.Type.ContainsGenericParameters%2A>属性的代码示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1105">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1106">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1106">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1107">下面的代码示例使用<xref:System.Type.GetGenericArguments%2A>方法显示构造类型的类型参数及其泛型类型定义的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1107">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="d6f12-1108">此代码示例是为<xref:System.Type.IsGenericTypeDefinition%2A>属性提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1108">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="d6f12-1109">请参阅示例输出的更大示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1109">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-1110">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1110">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="d6f12-1111">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1111">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-1112">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1112">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-1113">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1113">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1114">返回表示当前泛型类型参数约束的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1114">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1115">表示当前泛型类型参数上的约束的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1115">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1116">泛型类型参数上的每个约束都表示为<xref:System.Type>一个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1116">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="d6f12-1117">使用属性来确定约束是否为基类约束; 如果属性返回`false`, 则约束为接口约束。 <xref:System.Type.IsClass%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-1117">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="d6f12-1118">如果类型参数没有类约束, 并且没有接口约束, 则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1118">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="d6f12-1119">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1119">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1120">下面的代码示例定义了具有两`Test`个具有不同约束的类型参数的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1120">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="d6f12-1121">当程序执行时, 使用<xref:System.Type.GenericParameterAttributes%2A>属性<xref:System.Type.GetGenericParameterConstraints%2A>和方法检查约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1121">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-1122">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1122">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="d6f12-1123">也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1123">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-1124">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1124">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1125">返回一个表示可用于构造当前泛型类型的泛型类型定义的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1125">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1126">表示可用于构造当前类型的泛型类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1126">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1127">泛型类型定义是可以从中构造其他类型的模板。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1127">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="d6f12-1128">例如, 从泛型类型定义`G<T>` (用C#语法表示),`G<int>` `G(Of Integer)`在 Visual Basic 或`generic <typename T> ref class G`中C++), 您可以构造并实例化类型 (在 Visual Basic 中)。 `G(Of T)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1128">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="d6f12-1129">给定表示此构造类型的<xref:System.Type.GetGenericTypeDefinition%2A> 对象,方法返回泛型类型定义。<xref:System.Type></span><span class="sxs-lookup"><span data-stu-id="d6f12-1129">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="d6f12-1130">如果两种构造类型是使用相同的类型参数从同一泛型类型定义创建的, 则<xref:System.Type.GetGenericTypeDefinition%2A>该方法将为<xref:System.Type>这两种类型返回相同的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1130">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="d6f12-1131">如果在已表示<xref:System.Type.GetGenericTypeDefinition%2A>泛型类型定义<xref:System.Type>的对象上调用方法, 则它将返回当前<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1131">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d6f12-1132">泛型类型的数组本身不是泛型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1132">An array of generic types is not itself generic.</span></span> <span data-ttu-id="d6f12-1133">在C#代码`A<int>[] v;`或 Visual Basic 代码`Dim v() As A(Of Integer)`中, 变量`v`的类型不是泛型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1133">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="d6f12-1134">用于<xref:System.Type.IsGenericType%2A>在调用<xref:System.Type.GetGenericTypeDefinition%2A>之前确定类型是否为泛型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1134">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-1135">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1135">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1136">下面的代码示例使用普通实例创建创建构造类型的实例, 然后使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法检索构造类型和泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1136">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="d6f12-1137">此示例使用泛型<xref:System.Collections.Generic.Dictionary%602>类型; 构造类型<xref:System.Collections.Generic.Dictionary%602>表示具有字符串键的`Test`对象的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1137">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-1138">当前类型不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1138">The current type is not a generic type.</span></span>  <span data-ttu-id="d6f12-1139">也就是说，<see cref="P:System.Type.IsGenericType" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1139">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-1140">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1140">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="d6f12-1141">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1141">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-1142">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1142">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-1143">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1143">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1144">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1144">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1145">此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1145">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1146">此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1146">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1147">下面的示例显示`System.Windows.Forms.Button`类的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1147">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1148">获取由当前 <see cref="T:System.Type" /> 实现或继承的特定接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1148">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1149">包含要获取的接口名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1149">The string containing the name of the interface to get.</span></span> <span data-ttu-id="d6f12-1150">对于泛型接口，这是重整名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1150">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="d6f12-1151">搜索具有指定名称的接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1151">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1152">表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1152">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1153">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1153">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="d6f12-1154">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Type>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1154">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1155">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1155">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1156">对于泛型接口, `name`参数为错位名称, 以抑音符 (\`) 和类型参数的数目结尾。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1156">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="d6f12-1157">这对于泛型接口定义和构造泛型接口都是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1157">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="d6f12-1158">例如, 若要查找`IExample<T>` (`IExample(Of T)`在 Visual Basic 中) `IExample<string>`或`IExample(Of String)` (在 Visual Basic 中), ``"IExample`1"``请搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1158">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1159">下面的代码示例使用<xref:System.Type.GetInterface%28System.String%29>方法在<xref:System.Collections.Hashtable>类<xref:System.Runtime.Serialization.IDeserializationCallback>中搜索接口, 并列出接口的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1159">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="d6f12-1160">此代码示例还演示了<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法重载<xref:System.Type.GetInterfaceMap%2A>和方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1160">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1161"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1161"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1162">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1162">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1163">包含要获取的接口名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1163">The string containing the name of the interface to get.</span></span> <span data-ttu-id="d6f12-1164">对于泛型接口，这是重整名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1164">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="d6f12-1165"><see langword="true" /> 表示对于用来指定简单接口名称的 <paramref name="name" /> 部分（该部分指定命名空间大小写必须正确）忽略其大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1165"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="d6f12-1166">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1166">-or-</span></span> 
 <span data-ttu-id="d6f12-1167"><see langword="false" /> 表示对 <paramref name="name" /> 的所有部分执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1167"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-1168">当在派生类中重写时，搜索指定的接口，指定是否要对接口名称执行不区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1168">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1169">表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1169">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1170">此`ignoreCase`参数仅适用于简单接口名称, 而不适用于命名空间。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1170">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="d6f12-1171">指定命名空间`name`的部分必须具有正确的大小写, 否则将找不到该接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1171">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="d6f12-1172">例如, 字符串 "system.icomparable" 查找<xref:System.IComparable>接口, 但字符串 "system.icomparable" 不会。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1172">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="d6f12-1173">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Type>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1173">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1174">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1174">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1175">对于泛型接口, `name`参数为错位名称, 以抑音符 (\`) 和类型参数的数目结尾。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1175">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="d6f12-1176">这对于泛型接口定义和构造泛型接口都是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1176">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="d6f12-1177">例如, 若要查找`IExample<T>` (`IExample(Of T)`在 Visual Basic 中) `IExample<string>`或`IExample(Of String)` (在 Visual Basic 中), `"IExample`请搜索 "1"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1177">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1178">下面的代码示例使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法为<xref:System.Collections.IEnumerable>接口执行不区分大小写的<xref:System.Collections.Hashtable>类搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1178">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="d6f12-1179">此代码示例还演示了<xref:System.Type.GetInterface%28System.String%29>方法重载<xref:System.Type.GetInterfaceMap%2A>和方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1179">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1180"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1180"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1181">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1181">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="d6f12-1182">要检索其映射的接口类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1182">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="d6f12-1183">返回指定接口类型的接口映射。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1183">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1184">表示 <paramref name="interfaceType" /> 的接口映射的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1184">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1185">接口映射表示接口如何映射到实现该接口的类上的实际成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1185">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="d6f12-1186">如果当前<xref:System.Type>表示构造泛型类型, 则在此方法返回的的<xref:System.Reflection.InterfaceMapping>元素中, 类型参数将替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1186">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1187">下面的<xref:System.Type.GetInterfaceMap%2A>示例调用方法来确定<xref:System.IFormatProvider>接口如何映射到<xref:System.Globalization.CultureInfo>方法, 以及<xref:System.IAppDomainSetup>接口如何映射到<xref:System.AppDomainSetup>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1187">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="d6f12-1188">请注意, 由于<xref:System.IAppDomainSetup>接口定义了一组属性, 因此, 返回<xref:System.Reflection.InterfaceMapping>的对象为属性的 get 和 set 访问器包含单独<xref:System.Reflection.MethodInfo>的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1188">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1189">当前类型未实现 <paramref name="interfaceType" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1189"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="d6f12-1190">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1190">-or-</span></span> 
<span data-ttu-id="d6f12-1191"><paramref name="interfaceType" /> 参数未引用接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1191">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="d6f12-1192">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1192">-or-</span></span>

<span data-ttu-id="d6f12-1193">当前实例或 <paramref name="interfaceType" /> 参数是开放式泛型类型；即，<see cref="P:System.Type.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1193">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="d6f12-1194">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1194">-or-</span></span>


 <span data-ttu-id="d6f12-1195"><paramref name="interfaceType" /> 是一个泛型接口，而当前类型是一个数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1195"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1196"><paramref name="interfaceType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1196"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-1197">当前 <see cref="T:System.Type" /> 表示泛型类型参数；即， <see cref="P:System.Type.IsGenericParameter" /> 为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1197">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-1198">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1198">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="d6f12-1199">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1199">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1200">当在派生类中重写时，获取由当前 <see cref="T:System.Type" /> 实现或继承的所有接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1200">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1201">表示由当前 <see cref="T:System.Type" /> 实现或继承的所有接口的 <see cref="T:System.Type" />对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1201">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-1202">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1202">-or-</span></span> 
<span data-ttu-id="d6f12-1203">如果没有由当前 <see cref="T:System.Type" /> 实现或继承的接口，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1203">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1204"><xref:System.Type.GetInterfaces%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1204">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1205">你的代码不能依赖于接口的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1205">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1206">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Type>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1207">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1208">下面的示例获取指定类的类型并显示该类型实现或继承的所有接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1208">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="d6f12-1209">若要编译 Visual Basic 示例, 请使用以下编译器命令:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1209">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-1210">调用静态初始值设定项时引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1210">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1211">获取当前 <see cref="T:System.Type" /> 的指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1211">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1212">包含要获取的公共成员名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1212">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-1213">搜索具有指定名称的公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1213">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1214">一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1214">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1215">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1215">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-1216">搜索包括公共静态和公共实例成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1216">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="d6f12-1217">成员包括属性、方法、字段、事件等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1217">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-1218"><xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1218">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1219">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1219">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1220">此方法重载将找不到类初始值设定项 (静态构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1220">This method overload will not find class initializers (static constructor).</span></span> <span data-ttu-id="d6f12-1221">若要查找类初始值设定项, 请使用<xref:System.Reflection.BindingFlags>采用的重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1221">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-1222">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1222">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1223">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1223">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1224">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1224">Member Type</span></span>|<span data-ttu-id="d6f12-1225">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1225">Static</span></span>|<span data-ttu-id="d6f12-1226">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1226">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1227">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1227">Constructor</span></span>|<span data-ttu-id="d6f12-1228">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1228">No</span></span>|<span data-ttu-id="d6f12-1229">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1229">No</span></span>|  
|<span data-ttu-id="d6f12-1230">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1230">Field</span></span>|<span data-ttu-id="d6f12-1231">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1231">No</span></span>|<span data-ttu-id="d6f12-1232">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1232">Yes.</span></span> <span data-ttu-id="d6f12-1233">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1233">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1234">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1234">Event</span></span>|<span data-ttu-id="d6f12-1235">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1235">Not applicable</span></span>|<span data-ttu-id="d6f12-1236">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1236">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1237">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1237">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1238">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1238">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1239">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1239">Method</span></span>|<span data-ttu-id="d6f12-1240">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1240">No</span></span>|<span data-ttu-id="d6f12-1241">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1241">Yes.</span></span> <span data-ttu-id="d6f12-1242">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1242">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1243">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1243">Nested Type</span></span>|<span data-ttu-id="d6f12-1244">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1244">No</span></span>|<span data-ttu-id="d6f12-1245">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1245">No</span></span>|  
|<span data-ttu-id="d6f12-1246">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1246">Property</span></span>|<span data-ttu-id="d6f12-1247">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1247">Not applicable</span></span>|<span data-ttu-id="d6f12-1248">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1248">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1249">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1249">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1250">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1250">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1251">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1251">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1252">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1252">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1253">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1253">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1254">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1254">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1255">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1255">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1256">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1256">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1257">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1257">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1258">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1258">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1259">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1259">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1260">下面的示例显示以字母 C 开头的`String`类的所有成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1260">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1261"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1261"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1262">包含要获取的成员的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1262">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1263">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1263">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1264">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1264">-or-</span></span> 
 <span data-ttu-id="d6f12-1265">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1265"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1266">使用指定绑定约束搜索指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1266">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1267">一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1267">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1268">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1268">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="d6f12-1269">成员包括属性、方法、字段、事件等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1269">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-1270"><xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1270">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1271">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1271">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1272">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1272">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1273">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1273">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1274">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1274">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1275">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1275">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1276">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1276">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1277">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1277">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1278">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1278">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1279">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1279">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1280">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1280">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1281">若要使用此方法重载获取类初始值设定项 (静态构造函数), 必须为指定 "static `name`构造函数<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> "<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> , Visual Basic &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>并为`bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="d6f12-1281">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="d6f12-1282">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1282">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1283">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1283">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1284">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1284">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1285">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1285">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1286">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1286">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1287">下面的示例显示以字母 C 开头的`myString`类的所有公共静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1287">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1288"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1289">包含要获取的成员的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1289">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="d6f12-1290">要搜索的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1290">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1291">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1291">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1292">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1292">-or-</span></span> 
 <span data-ttu-id="d6f12-1293">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1293"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1294">使用指定绑定约束搜索指定成员类型的指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1294">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1295">一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1295">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1296">成员包括属性、方法、字段、事件等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1296">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-1297"><xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1297">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1298">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1298">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1299">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1299">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1300">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1300">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1301">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1301">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1302">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1302">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1303">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1303">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1304">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1304">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1305">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1305">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1306">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1306">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1307">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1307">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1308">若要使用此方法重载获取类初始值设定项 (静态构造函数`name`), 必须为`type`、和&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`指定"静态构造函数"。对于为VisualBasic`bindingAttr`)。 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-1308">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="d6f12-1309">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1309">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1310">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1310">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1311">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1311">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1312">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1312">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1313">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1313">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1314">下面的示例显示以字母 C 开头的`myString`类的所有方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1314">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1315"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1315"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-1316">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1316">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1317">获取当前 <see cref="T:System.Type" /> 的成员（包括属性、方法、字段、事件等）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1317">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1318">返回为当前 <see cref="T:System.Type" /> 的所有公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1318">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1319">表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有公共成员的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1319">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-1320">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1320">-or-</span></span> 
<span data-ttu-id="d6f12-1321">如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有公共成员，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1321">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d6f12-1322">成员包括属性、方法、构造函数、字段、事件和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1322">Members include properties, methods, constructors, fields, events, and nested types.</span></span>
  
 <span data-ttu-id="d6f12-1323"><xref:System.Type.GetMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1323">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1324">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1324">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1325"><xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>此方法重载调用方法重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在 Visual Basic 中)。<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; `Or` `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-1325">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-1326">它将找不到类初始值设定项 (静态构造函数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1326">It will not find class initializers (static constructors).</span></span> <span data-ttu-id="d6f12-1327">若要查找类初始值设定项<xref:System.Type.GetMembers(System.Reflection.BindingFlags)> , 请调用重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1327">To find class initializers, call the <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> overload, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-1328">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1328">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1329">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1329">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1330">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1330">Member Type</span></span>|<span data-ttu-id="d6f12-1331">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1331">Static</span></span>|<span data-ttu-id="d6f12-1332">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1332">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1333">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1333">Constructor</span></span>|<span data-ttu-id="d6f12-1334">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1334">No</span></span>|<span data-ttu-id="d6f12-1335">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1335">No</span></span>|  
|<span data-ttu-id="d6f12-1336">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1336">Field</span></span>|<span data-ttu-id="d6f12-1337">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1337">No</span></span>|<span data-ttu-id="d6f12-1338">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1338">Yes.</span></span> <span data-ttu-id="d6f12-1339">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1339">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1340">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1340">Event</span></span>|<span data-ttu-id="d6f12-1341">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1341">Not applicable</span></span>|<span data-ttu-id="d6f12-1342">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1342">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1343">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1343">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1344">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1344">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1345">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1345">Method</span></span>|<span data-ttu-id="d6f12-1346">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1346">No</span></span>|<span data-ttu-id="d6f12-1347">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1347">Yes.</span></span> <span data-ttu-id="d6f12-1348">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1348">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1349">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1349">Nested Type</span></span>|<span data-ttu-id="d6f12-1350">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1350">No</span></span>|<span data-ttu-id="d6f12-1351">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1351">No</span></span>|  
|<span data-ttu-id="d6f12-1352">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1352">Property</span></span>|<span data-ttu-id="d6f12-1353">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1353">Not applicable</span></span>|<span data-ttu-id="d6f12-1354">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1354">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1355">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1355">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1356">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1356">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1357">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1357">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1358">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1358">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1359">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1359">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1360">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1360">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1361">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1361">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1362">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1362">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1363">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1363">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="d6f12-1364">下面的代码示例演示如何使用<xref:System.Type.GetMembers>方法重载来收集有关指定类的所有公共成员的信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1364">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1365">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1365">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1366">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1366">-or-</span></span> 
 <span data-ttu-id="d6f12-1367">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1367"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1368">当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1368">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1369">表示为当前 <see cref="T:System.Reflection.MemberInfo" /> 定义的匹配指定绑定约束的所有成员的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1369">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="d6f12-1370">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1370">-or-</span></span> 
<span data-ttu-id="d6f12-1371">如果没有为当前 <see cref="T:System.Type" /> 定义成员，或者定义的成员均与绑定约束不匹配，则为空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1371">An empty array if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d6f12-1372">成员包括属性、方法、构造函数、字段、事件和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1372">Members include properties, methods, constructors, fields, events, and nested types.</span></span>

<span data-ttu-id="d6f12-1373"><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索方法信息, 参数必须包含至少一个和中的至少一个和和。 `GetMethods(BindingFlags)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1373">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-1374">唯一的例外是使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>的方法调用, 它返回有关嵌套类型的成员信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1374">The sole exception is a method call with <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, which returns member information about nested types.</span></span>

<span data-ttu-id="d6f12-1375">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1375">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span> 

- <span data-ttu-id="d6f12-1376">指定`BindingFlags.Instance`以包括实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1376">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="d6f12-1377">指定`BindingFlags.Static`以包括静态方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1377">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="d6f12-1378">指定`BindingFlags.Public`在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1378">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="d6f12-1379">指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1379">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="d6f12-1380">仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1380">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="d6f12-1381">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="d6f12-1382">单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.MethodInfo>数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1382">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>

<span data-ttu-id="d6f12-1383">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="d6f12-1384">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
<span data-ttu-id="d6f12-1385">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="d6f12-1386"><xref:System.Type.GetMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1386">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1387">你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1387">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  

 <span data-ttu-id="d6f12-1388">若要使用此方法重载获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1388">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="d6f12-1389">还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1389">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-1390">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1390">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1391">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1391">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  

## Examples  
 <span data-ttu-id="d6f12-1392">下面的代码示例演示如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法重载来收集有关指定类的所有公共实例成员的信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1392">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1393">获取当前 <see cref="T:System.Type" /> 的特定方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1393">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1394">包含要获取的公共方法的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1394">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-1395">搜索具有指定名称的公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1395">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1396">表示具有指定名称的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1396">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1397">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1397">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-1398">搜索包括公共静态和公共实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1398">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="d6f12-1399">如果重载了方法并且有多个公共方法, 该<xref:System.Type.GetMethod%28System.String%29>方法将<xref:System.Reflection.AmbiguousMatchException>引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1399">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="d6f12-1400">在下面的示例中, 引发了异常, 因为有多个<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法的公共重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1400">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="d6f12-1401">另一方面, 因为`Person.ToString`方法会重写<xref:System.Object.ToString%2A?displayProperty=nameWithType> , 因此不<xref:System.Type.GetMethod%28System.String%29>会重载, 所以方法可以检索<xref:System.Reflection.MethodInfo>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1401">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="d6f12-1402">可以执行以下操作之一来检索特定方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1402">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="d6f12-1403">调用方法, 并指定唯一`bindingAttr`标识该方法的参数。 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29></span><span class="sxs-lookup"><span data-stu-id="d6f12-1403">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="d6f12-1404">例如, 如果由于类型具有静态和实例重载而引发异常, 则可以`bindingAttr`指定的<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1404">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="d6f12-1405"><xref:System.Type.GetMethod%2A> 调用`types`包含参数的方法的重载, 该参数定义方法的参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1405">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="d6f12-1406"><xref:System.Type.GetMethods>调用方法以检索包含属于某个类型的所有公共方法的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1406">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="d6f12-1407">然后, 你可以对其进行循环访问以识别`name`名为的重复方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1407">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="d6f12-1408">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1408">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1409">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1409">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1410">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1410">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1411">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1411">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1412">下面的示例获取名为`MethodA`的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1412">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1413">找到了多个具有指定名称的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1413">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1414"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1414"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1415">包含要获取的方法名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1415">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1416">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1416">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1417">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1417">-or-</span></span> 
 <span data-ttu-id="d6f12-1418">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1418"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-1419">使用指定绑定约束搜索指定方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1419">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1420">表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1420">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1421">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1421">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1422">必须指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1422">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1423">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1423">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1424">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共方法 (即私有、内部和保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1424">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1425">指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1425">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1426">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1426">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1429">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1430">如果重载方法, 并且多个重载满足`bindingAttr`参数所指定的约束, 则该方法将<xref:System.Reflection.AmbiguousMatchException>引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1430">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="d6f12-1431">在下面的示例中, 引发了异常, 因为:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1431">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="d6f12-1432">该`TestClass`类型具有两个`DisplayValue`方法的公共实例重载: `DisplayValue(String)`和`DisplayValue(String, Object[])`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1432">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="d6f12-1433">此`TestClass`类型具有`Equals`方法的两个公共实例重载, 其中一个派生自<xref:System.Object>: `Equals(TestClass)`和`Equals(Object)`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1433">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="d6f12-1434">可以执行以下操作之一来检索特定方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1434">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="d6f12-1435">更改绑定约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1435">Change the binding constraints.</span></span> <span data-ttu-id="d6f12-1436">在前面的示例中, 尝试检索由类型声明`Equals`的公共实例方法, 而不是成功检索。 `Equals(TestClass)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1436">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="d6f12-1437"><xref:System.Type.GetMethod%2A> 调用`types`包含参数的方法的重载, 该参数定义方法的参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1437">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="d6f12-1438"><xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>调用方法以检索一个数组, 该数组包含属于具有指定绑定特性的类型的所有方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1438">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="d6f12-1439">然后, 你可以对其进行循环访问以识别`name`名为的重复方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1439">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="d6f12-1440">此方法在上一个示例的<xref:System.Reflection.AmbiguousMatchException>异常处理程序中进行了说明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1440">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="d6f12-1441">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1441">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1442">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1442">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1443">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1443">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1444">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1444">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1445">下面的示例获取与指定的绑定标志匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1445">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1446">找到多个具有指定名称且与指定绑定约束匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1446">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1447"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1447"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1448">包含要获取的公共方法的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1448">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-1449">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1449">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="d6f12-1450">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1450">-or-</span></span> 
<span data-ttu-id="d6f12-1451">空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1451">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="d6f12-1452">搜索其参数与指定参数类型匹配的指定公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1452">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1453">表示其参数与指定参数类型匹配的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1453">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1454">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1454">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-1455">搜索包括公共静态和公共实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1455">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1456">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1456">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-1457">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1457">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-1458">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1458">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1459">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1459">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1460">`name`参数不能包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1460">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="d6f12-1461">例如, C#代码`GetMethod("MyGenericMethod<int>")`搜索文本名称为 "`MyGenericMethod<int>`" 的方法, 而不是使用一个类型`int`的泛型参数的`MyGenericMethod`名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1461">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="d6f12-1462">应将与`GetMethod("MyGenericMethod")` `types`数组中的相应参数一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1462">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1463">下面的示例查找的`MethodA`特定重载, 并指定各种参数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1463">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1464">该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1464">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="d6f12-1465">下面的示例检索<xref:System.Reflection.MethodInfo> `Add`表示非泛型类型 ( <xref:System.Collections.ArrayList>类<xref:System.Collections.Generic.List%601> )、开放式泛型类型 (类) 和封闭式泛型类型 ( `List(Of String)`类型) 的方法的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1465">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="d6f12-1466">该示例定义了`GetAddMethod`一个检索相应<xref:System.Reflection.MethodInfo>对象的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1466">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="d6f12-1467">为了提供开放式`types`泛型类型的参数, 它将<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>调用方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1467">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d6f12-1468">为提供封闭式`types`泛型类型的参数, 它将检索<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1468">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1469">找到了多个具有指定名称和指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1469">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1470"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1470"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1471">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1471">-or-</span></span> 
 <span data-ttu-id="d6f12-1472"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1472"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1473">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1473">-or-</span></span> 
<span data-ttu-id="d6f12-1474"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1474">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1475"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1475"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1476">包含要获取的公共方法的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1476">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-1477">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1477">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="d6f12-1478">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1478">-or-</span></span> 
<span data-ttu-id="d6f12-1479">空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1479">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-1480"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1480">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-1481">仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1481">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="d6f12-1482">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1482">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-1483">搜索其参数与指定参数类型及修饰符匹配的指定公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1483">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1484">表示符合指定要求的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1484">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1485">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1485">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-1486">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1486">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-1487">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1487">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-1488">搜索包括公共静态和公共实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1488">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1489">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1489">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-1490">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1490">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-1491">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1491">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1492">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1492">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1493">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1493">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1494">例如, C#代码`GetMethod("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1494">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="d6f12-1495">应将与`GetMethod("MyMethod")` `types`数组中的相应参数一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1495">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1496">找到了多个具有指定名称和指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1496">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1497"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1497"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1498">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1498">-or-</span></span> 
 <span data-ttu-id="d6f12-1499"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1499"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1500">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1500">-or-</span></span> 
<span data-ttu-id="d6f12-1501"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1501">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1502"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1502"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-1503">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1503">-or-</span></span> 
 <span data-ttu-id="d6f12-1504"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1504"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1505">包含要获取的方法名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1505">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1506">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1506">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1507">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1507">-or-</span></span> 
 <span data-ttu-id="d6f12-1508">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1508"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-1509">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1509">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-1510">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1510">-or-</span></span> 
<span data-ttu-id="d6f12-1511">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1511">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-1512">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1512">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="d6f12-1513">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1513">-or-</span></span> 
<span data-ttu-id="d6f12-1514">空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1514">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-1515"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1515">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-1516">仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1516">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="d6f12-1517">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1517">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-1518">使用指定绑定约束，搜索其参数与指定参数类型及修饰符匹配的指定方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1518">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1519">表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1519">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1520">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1520">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-1521">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1521">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-1522">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1522">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1523">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1523">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1524">指定`BindingFlags.Public`在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1524">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1525">指定`BindingFlags.NonPublic`在搜索中包含非公共方法 (即私有方法、内部方法和受保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1525">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1526">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1526">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1527">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1527">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1528">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1528">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1529">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1529">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1530">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1530">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1531">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1531">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-1532">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1532">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-1533">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1533">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1534">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1534">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1535">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1535">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1536">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1536">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1537">下面的示例查找的`MethodA`特定重载, 并指定绑定约束和各种参数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1537">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1538">该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1538">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1539">找到多个具有指定名称且与指定绑定约束匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1539">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1540"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1540"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1541">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1541">-or-</span></span> 
 <span data-ttu-id="d6f12-1542"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1542"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1543">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1543">-or-</span></span> 
<span data-ttu-id="d6f12-1544"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1544">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1545"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1545"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-1546">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1546">-or-</span></span> 
 <span data-ttu-id="d6f12-1547"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1547"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1548">包含要获取的方法名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1548">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1549">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1549">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1550">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1550">-or-</span></span> 
 <span data-ttu-id="d6f12-1551">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1551"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-1552">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1552">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-1553">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1553">-or-</span></span> 
<span data-ttu-id="d6f12-1554">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1554">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="d6f12-1555">该对象用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1555">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-1556">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1556">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="d6f12-1557">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1557">-or-</span></span> 
<span data-ttu-id="d6f12-1558">空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1558">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-1559"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1559">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-1560">仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1560">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="d6f12-1561">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1561">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-1562">用指定的绑定约束和指定的调用约定，搜索参数与指定的参数类型及修饰符相匹配的指定方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1562">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1563">表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1563">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1564">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1564">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-1565">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1565">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-1566">下表显示了在类型上反射时`GetXXX`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1566">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1567">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1567">Member Type</span></span>|<span data-ttu-id="d6f12-1568">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1568">Static</span></span>|<span data-ttu-id="d6f12-1569">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1569">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1570">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1570">Constructor</span></span>|<span data-ttu-id="d6f12-1571">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1571">No</span></span>|<span data-ttu-id="d6f12-1572">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1572">No</span></span>|  
|<span data-ttu-id="d6f12-1573">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1573">Field</span></span>|<span data-ttu-id="d6f12-1574">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1574">No</span></span>|<span data-ttu-id="d6f12-1575">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1575">Yes.</span></span> <span data-ttu-id="d6f12-1576">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1576">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1577">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1577">Event</span></span>|<span data-ttu-id="d6f12-1578">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1578">Not applicable</span></span>|<span data-ttu-id="d6f12-1579">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1579">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1580">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1580">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1581">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1581">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1582">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1582">Method</span></span>|<span data-ttu-id="d6f12-1583">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1583">No</span></span>|<span data-ttu-id="d6f12-1584">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1584">Yes.</span></span> <span data-ttu-id="d6f12-1585">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1585">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1586">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1586">Nested Type</span></span>|<span data-ttu-id="d6f12-1587">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1587">No</span></span>|<span data-ttu-id="d6f12-1588">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1588">No</span></span>|  
|<span data-ttu-id="d6f12-1589">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1589">Property</span></span>|<span data-ttu-id="d6f12-1590">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1590">Not applicable</span></span>|<span data-ttu-id="d6f12-1591">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1591">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1592">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1592">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1593">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1593">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1594">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1594">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1595">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1595">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1596">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1596">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1597">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1597">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1598">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1598">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1599">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1599">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1600">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1600">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1601">指定`BindingFlags.Public`在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1601">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1602">指定`BindingFlags.NonPublic`在搜索中包含非公共方法 (即私有方法、内部方法和受保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1602">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1603">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1603">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1604">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1604">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1605">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1605">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1606">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1606">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1607">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1607">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1608">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1608">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-1609">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1609">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-1610">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1610">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1611">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1612">对于泛型方法, 请不要在中`name`包括类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1612">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="d6f12-1613">例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1613">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1614">下面的示例查找的`MethodA`特定重载, 指定绑定约束、调用约定和各种参数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1614">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1615">该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1615">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1616">找到多个具有指定名称且与指定绑定约束匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1616">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1617"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1617"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1618">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1618">-or-</span></span> 
 <span data-ttu-id="d6f12-1619"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1619"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-1620">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1620">-or-</span></span> 
<span data-ttu-id="d6f12-1621"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1622"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1622"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-1623">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1623">-or-</span></span> 
 <span data-ttu-id="d6f12-1624"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1624"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1625">包含要获取的方法名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1625">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1626">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1626">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1627">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1627">-or-</span></span> 
 <span data-ttu-id="d6f12-1628">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1628"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-1629">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1629">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-1630">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1630">-or-</span></span> 
<span data-ttu-id="d6f12-1631">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1631">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="d6f12-1632">该对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器以及哪个进程清理堆栈。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1632">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-1633">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1633">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="d6f12-1634">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1634">-or-</span></span> 
<span data-ttu-id="d6f12-1635">一个类型为 <see cref="T:System.Type" /> （即 Type[] types = new Type[0]）的空数组，用于获取一个不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1635">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="d6f12-1636">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1636">-or-</span></span> 
 <span data-ttu-id="d6f12-1637"><see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1637"><see langword="null" />.</span></span> <span data-ttu-id="d6f12-1638">如果 <paramref name="types" /> 为 <see langword="null" />，则参数不匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1638">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-1639"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1639">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-1640">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1640">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-1641">当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的指定方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1641">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1642">表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1642">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1643">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1643">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-1644">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1644">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-1645">如果 `types` 为 `null`，则参数不匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1645">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="d6f12-1646">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1646">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1647">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1647">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1648">指定`BindingFlags.Public`在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1648">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1649">指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1649">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1650">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1650">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1651">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1651">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-1652">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1652">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-1653">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1653">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1654">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1654">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1655">找到多个具有指定名称且与指定绑定约束匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1655">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1656"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1656"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-1657"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1657"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-1658">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1658">-or-</span></span> 
 <span data-ttu-id="d6f12-1659"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1659"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-1660">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1660">-or-</span></span> 
 <span data-ttu-id="d6f12-1661"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1661"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-1662">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1662">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1663">获取当前 <see cref="T:System.Type" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1663">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1664">返回为当前 <see cref="T:System.Type" /> 的所有公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1664">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1665">表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的所有公共方法的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1665">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-1666">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1666">-or-</span></span> 
<span data-ttu-id="d6f12-1667">如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的公共方法，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1667">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d6f12-1668"><xref:System.Type.GetMethods%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1668">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1669">你的代码不能依赖于方法的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1669">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1670">构造函数不包含在此调用所返回的方法的数组中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1670">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="d6f12-1671">单独调用`GetConstructors()`以获取构造函数方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1671">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="d6f12-1672">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1672">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1673">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1673">Member Type</span></span>|<span data-ttu-id="d6f12-1674">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1674">Static</span></span>|<span data-ttu-id="d6f12-1675">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1675">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1676">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1676">Constructor</span></span>|<span data-ttu-id="d6f12-1677">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1677">No</span></span>|<span data-ttu-id="d6f12-1678">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1678">No</span></span>|  
|<span data-ttu-id="d6f12-1679">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1679">Field</span></span>|<span data-ttu-id="d6f12-1680">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1680">No</span></span>|<span data-ttu-id="d6f12-1681">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1681">Yes.</span></span> <span data-ttu-id="d6f12-1682">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1682">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1683">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1683">Event</span></span>|<span data-ttu-id="d6f12-1684">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1684">Not applicable</span></span>|<span data-ttu-id="d6f12-1685">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1685">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1686">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1686">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1687">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1687">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1688">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1688">Method</span></span>|<span data-ttu-id="d6f12-1689">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1689">No</span></span>|<span data-ttu-id="d6f12-1690">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1690">Yes.</span></span> <span data-ttu-id="d6f12-1691">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1691">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1692">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1692">Nested Type</span></span>|<span data-ttu-id="d6f12-1693">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1693">No</span></span>|<span data-ttu-id="d6f12-1694">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1694">No</span></span>|  
|<span data-ttu-id="d6f12-1695">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1695">Property</span></span>|<span data-ttu-id="d6f12-1696">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1696">Not applicable</span></span>|<span data-ttu-id="d6f12-1697">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1697">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1698">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1698">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1699">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1699">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1700">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1700">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1701">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1701">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1702">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1702">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1703">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1703">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1704">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1704">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1705">在查找构造函数和方法时, 不能忽略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1705">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="d6f12-1706">在调用时, 只能省略参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1706">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="d6f12-1707">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MethodInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1707">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1708">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1708">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1709">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1709">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="d6f12-1710">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1710">-or-</span></span>

 <span data-ttu-id="d6f12-1711">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1711"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1712">当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1712">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1713">表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的匹配指定绑定约束的所有方法的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1713">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="d6f12-1714">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1714">-or-</span></span> 
<span data-ttu-id="d6f12-1715">如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的方法，或者如果没有一个定义的方法匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1715">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="d6f12-1716"><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索方法信息, 参数必须包含至少一个和中的至少一个和和。 `GetMethods(BindingFlags)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1716">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 
  
 <span data-ttu-id="d6f12-1717">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
- <span data-ttu-id="d6f12-1718">指定`BindingFlags.Instance`以包括实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1718">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="d6f12-1719">指定`BindingFlags.Static`以包括静态方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1719">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="d6f12-1720">指定`BindingFlags.Public`在搜索中包含公共方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1720">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="d6f12-1721">指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1721">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="d6f12-1722">仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1722">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="d6f12-1723">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1723">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="d6f12-1724">单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.MethodInfo>数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1724">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>
  
 <span data-ttu-id="d6f12-1725">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1725">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="d6f12-1726">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1726">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1727">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1727">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="d6f12-1728"><xref:System.Type.GetMethods%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1728">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1729">你的代码不能依赖于方法的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1729">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  

<span data-ttu-id="d6f12-1730">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MethodInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1730">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
<span data-ttu-id="d6f12-1731">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1731">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="d6f12-1732">下面的示例创建一个具有两个公共方法和一个受保护方法的类`Type` , 创建与`MyTypeClass`对应的对象, 获取所有公共和非公共方法, 并显示它们的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1732">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1733">获取嵌套在当前 <see cref="T:System.Type" /> 中的特定类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1733">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1734">包含要获取的嵌套类型的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1734">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-1735">搜索具有指定名称的公共嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1735">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1736">如找到，则为表示具有指定名称的公共嵌套类型的对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1736">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1737">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1737">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="d6f12-1738">使用嵌套类`name`的简单名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1738">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="d6f12-1739">不要将其与外部类的名称限定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1739">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="d6f12-1740">对于泛型嵌套类, 请使用错位的名称-即, 追加一个重音符和泛型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1740">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="d6f12-1741">例如, 使用字符串 "Inner\`1" 获取泛型嵌套类`Inner<T>` (`Inner(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1741">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="d6f12-1742">不要包含类型参数的特定于语言的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1742">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="d6f12-1743">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1743">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1744">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1744">Member Type</span></span>|<span data-ttu-id="d6f12-1745">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1745">Static</span></span>|<span data-ttu-id="d6f12-1746">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1746">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1747">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1747">Constructor</span></span>|<span data-ttu-id="d6f12-1748">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1748">No</span></span>|<span data-ttu-id="d6f12-1749">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1749">No</span></span>|  
|<span data-ttu-id="d6f12-1750">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1750">Field</span></span>|<span data-ttu-id="d6f12-1751">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1751">No</span></span>|<span data-ttu-id="d6f12-1752">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1752">Yes.</span></span> <span data-ttu-id="d6f12-1753">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1753">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1754">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1754">Event</span></span>|<span data-ttu-id="d6f12-1755">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1755">Not applicable</span></span>|<span data-ttu-id="d6f12-1756">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1756">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1757">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1757">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1758">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1758">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1759">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1759">Method</span></span>|<span data-ttu-id="d6f12-1760">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1760">No</span></span>|<span data-ttu-id="d6f12-1761">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1761">Yes.</span></span> <span data-ttu-id="d6f12-1762">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1762">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1763">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1763">Nested Type</span></span>|<span data-ttu-id="d6f12-1764">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1764">No</span></span>|<span data-ttu-id="d6f12-1765">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1765">No</span></span>|  
|<span data-ttu-id="d6f12-1766">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1766">Property</span></span>|<span data-ttu-id="d6f12-1767">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1767">Not applicable</span></span>|<span data-ttu-id="d6f12-1768">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1768">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1769">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1769">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1770">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1770">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1771">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1771">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1772">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1772">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1773">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1773">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1774">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1774">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1775">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1775">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1776">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1776">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-1777">如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1777">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="d6f12-1778">即使封闭泛型类型是封闭式构造类型, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1778">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1779">如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1779">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="d6f12-1780">这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1780">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="d6f12-1781">有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1781">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1782"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1782"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1783">包含要获取的嵌套类型的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1783">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1784">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1784">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1785">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1785">-or-</span></span> 
 <span data-ttu-id="d6f12-1786">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1786"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-1787">当在派生类中重写时，使用指定绑定约束搜索指定嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1787">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1788">表示符合指定要求的嵌套类型的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1788">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1789">使用嵌套类`name`的简单名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1789">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="d6f12-1790">不要将其与外部类的名称限定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1790">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="d6f12-1791">对于泛型嵌套类, 请使用错位的名称-即, 追加一个重音符和泛型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1791">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="d6f12-1792">例如, 使用字符串 "Inner\`1" 获取泛型嵌套类`Inner<T>` (`Inner(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1792">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="d6f12-1793">不要包含类型参数的特定于语言的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1793">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="d6f12-1794">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的嵌套类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1794">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1795">必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1795">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1796">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包括公共嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1796">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1797">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共嵌套类型 (即私有、内部和受保护的嵌套类型)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1797">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-1798">此方法只返回当前类型的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1798">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="d6f12-1799">它不会搜索当前类型的基类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1799">It does not search the base classes of the current type.</span></span> <span data-ttu-id="d6f12-1800">若要查找嵌套在基类中的类型, 必须遍历继承层次结构, 并在<xref:System.Type.GetNestedType%2A>每个级别调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1800">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="d6f12-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-1802">仅<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>用标志或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志调用此方法将返回指定的嵌套类型, 并且不需要任何其他标志。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1802">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="d6f12-1803">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1803">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1804">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1804">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-1805">如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1805">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="d6f12-1806">即使封闭泛型类型是封闭式构造类型, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1806">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1807">如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1807">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="d6f12-1808">这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1808">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="d6f12-1809">有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1809">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1810"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1810"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1811">获取嵌套在当前 <see cref="T:System.Type" /> 中的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1811">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1812">返回嵌套在当前的 <see cref="T:System.Type" /> 中的公共类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1812">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1813"><see cref="T:System.Type" /> 对象的数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的公共类型（搜索是非递归的）；如果当前的 <see cref="T:System.Type" /> 中没有嵌套公共类型，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1813">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1814"><xref:System.Type.GetNestedTypes%2A>方法不按特定顺序返回类型, 如字母或声明顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1814">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1815">你的代码不能依赖于类型的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1815">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1816">仅返回立即嵌套在当前类型中的公共类型;搜索不是递归的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1816">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="d6f12-1817">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1817">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1818">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1818">Member Type</span></span>|<span data-ttu-id="d6f12-1819">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1819">Static</span></span>|<span data-ttu-id="d6f12-1820">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1820">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1821">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1821">Constructor</span></span>|<span data-ttu-id="d6f12-1822">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1822">No</span></span>|<span data-ttu-id="d6f12-1823">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1823">No</span></span>|  
|<span data-ttu-id="d6f12-1824">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1824">Field</span></span>|<span data-ttu-id="d6f12-1825">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1825">No</span></span>|<span data-ttu-id="d6f12-1826">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1826">Yes.</span></span> <span data-ttu-id="d6f12-1827">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1827">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1828">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1828">Event</span></span>|<span data-ttu-id="d6f12-1829">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1829">Not applicable</span></span>|<span data-ttu-id="d6f12-1830">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1830">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1831">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1831">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1832">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1832">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1833">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1833">Method</span></span>|<span data-ttu-id="d6f12-1834">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1834">No</span></span>|<span data-ttu-id="d6f12-1835">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1835">Yes.</span></span> <span data-ttu-id="d6f12-1836">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1836">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1837">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1837">Nested Type</span></span>|<span data-ttu-id="d6f12-1838">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1838">No</span></span>|<span data-ttu-id="d6f12-1839">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1839">No</span></span>|  
|<span data-ttu-id="d6f12-1840">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1840">Property</span></span>|<span data-ttu-id="d6f12-1841">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1841">Not applicable</span></span>|<span data-ttu-id="d6f12-1842">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1842">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1843">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1843">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1844">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1844">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1845">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1845">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1846">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1846">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1847">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1847">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1848">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1848">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1849">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1849">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1850">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1850">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-1851">如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1851">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="d6f12-1852">即使封闭泛型类型是封闭式构造类型, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1852">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1853">如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1853">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="d6f12-1854">这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1854">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="d6f12-1855">有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1855">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1856">下面的示例在中`struct` `MyClass`定义一个嵌套类和一个, 然后使用类型获取嵌套`MyClass`类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1856">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1857">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1857">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1858">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1858">-or-</span></span> 
 <span data-ttu-id="d6f12-1859">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1859"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-1860">当在派生类中重写时，使用指定绑定约束搜索嵌套在当前 <see cref="T:System.Type" /> 中的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1860">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1861"><see cref="T:System.Type" /> 对象数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的所有与指定的绑定约束匹配的类型（搜索是非递归的）；如果没有找到与绑定约束匹配的嵌套类型，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1861">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1862">嵌套类型的搜索不是递归的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1862">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="d6f12-1863"><xref:System.Type.GetNestedTypes%2A>方法不按特定顺序返回类型, 如字母或声明顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1863">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1864">你的代码不能依赖于类型的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1864">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1865">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的嵌套类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1865">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1866">必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1866">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1867">指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包括公共嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1867">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1868">指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共嵌套类型 (即私有、内部和受保护的嵌套类型)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1868">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="d6f12-1869">此方法只返回当前类型的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1869">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="d6f12-1870">它不会搜索当前类型的基类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1870">It does not search the base classes of the current type.</span></span> <span data-ttu-id="d6f12-1871">若要查找嵌套在基类中的类型, 必须遍历继承层次结构, 并在<xref:System.Type.GetNestedTypes%2A>每个级别调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1871">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="d6f12-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-1873">仅<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>用标志或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志调用此方法将返回指定的嵌套类型, 并且不需要任何其他标志。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1873">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="d6f12-1874">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1874">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-1875">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1875">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-1876">如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1876">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="d6f12-1877">即使封闭泛型类型是封闭式构造类型, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1877">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-1878">如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1878">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="d6f12-1879">这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1879">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="d6f12-1880">有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1880">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1881">下面的示例创建两个嵌套公共类和两个嵌套的受保护类, 并显示与指定绑定约束匹配的类的信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1881">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1882">获取当前 <see cref="T:System.Type" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1882">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-1883">返回为当前 <see cref="T:System.Type" /> 的所有公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1883">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1884">表示当前 <see cref="T:System.Reflection.PropertyInfo" /> 的所有公共属性的 <see cref="T:System.Type" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1884">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="d6f12-1885">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1885">-or-</span></span> 
<span data-ttu-id="d6f12-1886">如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有公共属性，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1886">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1887">调用此重载<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>等效于`bindingAttr`使用与 Visual Basic `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`中C# `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`的相同的参数调用重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1887">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="d6f12-1888">它将返回所有公共实例和静态属性, 这两个属性都由当前<xref:System.Type>对象所表示的类型以及从其基类型继承的类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1888">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="d6f12-1889">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1889">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-1890">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1890">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-1891"><xref:System.Type.GetProperties%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1891">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1892">你的代码不能依赖属性的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1892">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="d6f12-1893">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1893">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-1894">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1894">Member Type</span></span>|<span data-ttu-id="d6f12-1895">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-1895">Static</span></span>|<span data-ttu-id="d6f12-1896">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-1896">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-1897">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-1897">Constructor</span></span>|<span data-ttu-id="d6f12-1898">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1898">No</span></span>|<span data-ttu-id="d6f12-1899">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1899">No</span></span>|  
|<span data-ttu-id="d6f12-1900">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-1900">Field</span></span>|<span data-ttu-id="d6f12-1901">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1901">No</span></span>|<span data-ttu-id="d6f12-1902">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1902">Yes.</span></span> <span data-ttu-id="d6f12-1903">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1903">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1904">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-1904">Event</span></span>|<span data-ttu-id="d6f12-1905">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1905">Not applicable</span></span>|<span data-ttu-id="d6f12-1906">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1906">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1907">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1907">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1908">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1908">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-1909">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-1909">Method</span></span>|<span data-ttu-id="d6f12-1910">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1910">No</span></span>|<span data-ttu-id="d6f12-1911">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1911">Yes.</span></span> <span data-ttu-id="d6f12-1912">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1912">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-1913">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-1913">Nested Type</span></span>|<span data-ttu-id="d6f12-1914">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1914">No</span></span>|<span data-ttu-id="d6f12-1915">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-1915">No</span></span>|  
|<span data-ttu-id="d6f12-1916">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-1916">Property</span></span>|<span data-ttu-id="d6f12-1917">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-1917">Not applicable</span></span>|<span data-ttu-id="d6f12-1918">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1918">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-1919">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1919">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1920">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1920">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-1921">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1921">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-1922">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1922">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-1923">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1923">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-1924">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1924">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-1925">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1925">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-1926">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.PropertyInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1926">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1927">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1927">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1928">下面的示例演示 `GetProperties` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1928">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1929">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1929">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="d6f12-1930">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1930">-or-</span></span>

 <span data-ttu-id="d6f12-1931">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1931"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="d6f12-1932">当在派生类中重写时，使用指定绑定约束，搜索当前 <see cref="T:System.Type" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1932">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1933">一个对象数组，它表示当前 <see cref="T:System.Type" /> 中与指定的绑定约束匹配的所有属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1933">An array of objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="d6f12-1934">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-1934">-or-</span></span> 
<span data-ttu-id="d6f12-1935">如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有属性，或者如果没有一个属性匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1935">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="d6f12-1936"><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索属性信息, 参数必须包含至少一个和, 以及至少一个和中的一个。 `GetProperties(BindingFlags)`</span><span class="sxs-lookup"><span data-stu-id="d6f12-1936">For the `GetProperties(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="d6f12-1937">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1937">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
- <span data-ttu-id="d6f12-1938">指定`BindingFlags.Instance`以包括实例方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1938">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="d6f12-1939">指定`BindingFlags.Static`以包括静态方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1939">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="d6f12-1940">指定`BindingFlags.Public`在搜索中包括公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span> <span data-ttu-id="d6f12-1941">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> 
  
- <span data-ttu-id="d6f12-1942">指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1942">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="d6f12-1943">仅返回基类的受保护的和内部属性;不返回基类上的私有属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1943">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
- <span data-ttu-id="d6f12-1944">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1944">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="d6f12-1945">单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.PropertyInfo>数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1945">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

 <span data-ttu-id="d6f12-1946">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1946">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="d6f12-1947">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1947">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-1948">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1948">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="d6f12-1949"><xref:System.Type.GetProperties%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1949">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="d6f12-1950">你的代码不能依赖属性的返回顺序, 因为该顺序会有所不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1950">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  

 <span data-ttu-id="d6f12-1951">如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.PropertyInfo>返回类型参数替换为相应类型参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1951">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1952">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1952">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1953">下面的示例定义了一个名`PropertyClass`为的类, 其中包含六个属性: 两个是公共的, 一个是专用的,`Friend`一个是专用的, 一个是内部的 (`Protected Friend`在 Visual Basic 中), 一个受保护 (在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1953">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="d6f12-1954">然后, 它会显示与指定绑定约束匹配的属性的一些基本属性信息 (属性名称和类型, 无论它是`get`读`set`写, 还是其和访问器的可见性)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1954">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-1955">获取当前 <see cref="T:System.Type" /> 的特定属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1955">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1956">包含要获取的公共属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1956">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-1957">搜索具有指定名称的公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1957">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1958">表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1958">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1959">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1959">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-1960">搜索包括公共静态和公共实例属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1960">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="d6f12-1961">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1961">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-1962">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1962">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-1963">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-1964">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-1965">出现这<xref:System.Reflection.AmbiguousMatchException>种情况的情况如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1965">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="d6f12-1966">类型包含两个具有相同名称但参数数目不同的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1966">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="d6f12-1967">若要解决多义性, 请使用<xref:System.Type.GetProperty%2A>方法的重载, 该重载指定参数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1967">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="d6f12-1968">派生的类型声明一个属性, 该属性通过使用`new`修饰符 (`Shadows`在 Visual Basic 中) 隐藏同名的继承属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1968">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="d6f12-1969">若要解决多义性问题, 请<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>使用方法重载并<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>添加标志, 以将搜索限制为未继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1969">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-1970">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-1970">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-1971">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1971">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-1972">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1972">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-1973">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1973">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-1974">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1974">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-1975">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1975">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-1976">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1976">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-1977">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1977">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-1978">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1978">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-1979">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1979">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-1980">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1980">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-1981">下面的示例检索`Type`用户定义的类的对象, 检索该类的属性, 并显示属性名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1981">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="d6f12-1982">在内部, 在元数据中, 名称为 "Item"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1982">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="d6f12-1983">尝试`PropertyInfo`使用反射必须指定此内部名称, 才能正确`PropertyInfo`返回属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1983">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-1984">找到了多个具有指定名称的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1984">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-1985"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1985"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-1986">包含要获取的属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1986">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-1987">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1987">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-1988">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-1988">-or-</span></span> 
<span data-ttu-id="d6f12-1989">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1989"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-1990">使用指定的绑定约束搜索指定属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1990">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-1991">表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1991">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-1992">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1992">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-1993">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1993">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-1994">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1994">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-1995">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1995">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-1996">指定`BindingFlags.Public`在搜索中包括公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1996">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1997">指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1997">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-1998">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-1998">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-1999">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-1999">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-2000">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2000">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-2001">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2001">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-2002">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2002">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-2003">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2003">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2004">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2004">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="d6f12-2005">出现这<xref:System.Reflection.AmbiguousMatchException>种情况的情况如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2005">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="d6f12-2006">类型包含两个具有相同名称但参数数目不同的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2006">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="d6f12-2007">若要解决多义性, 请使用<xref:System.Type.GetProperty%2A>方法的重载, 该重载指定参数类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2007">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="d6f12-2008">派生的类型声明一个属性, 该属性使用`new`修饰符 (`Shadows`在 Visual Basic 中) 隐藏同名的继承属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2008">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="d6f12-2009">若要解决多义性, 请<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>包含以将搜索限制为未继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2009">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2010">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2010">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2011">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2011">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2012">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2012">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2013">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2013">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2014">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2014">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2015">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2015">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2016">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2016">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2017">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2017">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2018">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2018">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2019">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2019">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2020">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2020">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2021">下面的示例检索用户定义的类的类型, 检索该类的属性, 并根据指定的绑定约束显示属性名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2021">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2022">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2022">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2023"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2023"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2024">包含要获取的公共属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2024">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="d6f12-2025">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2025">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="d6f12-2026">搜索具有指定名称和返回类型的公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2026">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2027">表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2027">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2028">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2028">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-2029">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2029">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-2030">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2030">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-2031">搜索包括公共静态和公共实例属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2031">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="d6f12-2032">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2032">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2033">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2033">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2034">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2034">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2035">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2035">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2036">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2036">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2037">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2037">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2038">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2038">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2039">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2039">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2040">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2040">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2041">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2041">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2042">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2042">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2043">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2043">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2044">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2044">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2045">下面的示例定义一个具有一个属性的类, 并检索属性的名称和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2045">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2046">找到了多个具有指定名称的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2046">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2047"><paramref name="name" /> 是 <see langword="null" />，或 <paramref name="returnType" /> 是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2047"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2048">包含要获取的公共属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2048">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-2049">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2049">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="d6f12-2050">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2050">-or-</span></span> 
<span data-ttu-id="d6f12-2051">获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2051">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="d6f12-2052">搜索其参数与指定自变量类型匹配的指定公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2052">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2053">表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2053">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2054">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2054">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-2055">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2055">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-2056">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2056">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-2057">搜索包括公共静态和公共实例属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2057">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="d6f12-2058">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2058">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2059">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2059">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2060">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2060">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2061">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2061">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2062">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2062">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2063">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2063">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2064">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2064">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2065">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2065">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2066">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2066">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2067">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2067">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2068">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2068">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2069">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2069">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2070">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2070">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2071">下面的示例检索`Type`用户定义的类的对象, 检索该类的属性, 并显示由传递给`GetProperty`的参数指定的属性名称和属性类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2071">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2072">找到多个具有指定名称且与指定自变量类型匹配的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2072">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2073"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2073"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2074">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2074">-or-</span></span> 
 <span data-ttu-id="d6f12-2075"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2075"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2076"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2076"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="d6f12-2077"><paramref name="types" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2077">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2078">包含要获取的公共属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2078">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="d6f12-2079">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2079">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-2080">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2080">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="d6f12-2081">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2081">-or-</span></span> 
<span data-ttu-id="d6f12-2082">获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2082">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="d6f12-2083">搜索其参数与指定自变量类型匹配的指定公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2083">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2084">表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2084">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2085">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2085">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-2086">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2086">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-2087">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2087">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-2088">搜索包括公共静态和公共实例属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2088">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="d6f12-2089">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2089">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2090">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2090">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2091">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2091">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2092">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2092">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2093">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2093">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2094">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2094">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2095">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2095">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2096">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2096">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2097">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2097">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2098">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2098">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2099">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2099">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2100">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2100">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2101">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2101">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2102">找到多个具有指定名称且与指定自变量类型匹配的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2102">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2103"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2103"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2104">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2104">-or-</span></span> 
 <span data-ttu-id="d6f12-2105"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2105"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2106"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2106"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="d6f12-2107"><paramref name="types" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2107">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2108">包含要获取的公共属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2108">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="d6f12-2109">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2109">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-2110">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2110">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="d6f12-2111">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2111">-or-</span></span> 
<span data-ttu-id="d6f12-2112">获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2112">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-2113"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2113">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-2114">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2114">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-2115">搜索其参数与指定自变量类型及修饰符匹配的指定公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2115">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2116">表示符合指定要求的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2116">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2117">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2117">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-2118">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2118">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-2119">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2119">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-2120">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2120">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-2121">的搜索`name`区分大小写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2121">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="d6f12-2122">搜索包括公共静态和公共实例属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2122">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="d6f12-2123">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2123">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2124">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2124">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2125">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2125">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2126">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2126">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2127">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2127">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2128">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2128">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2129">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2129">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2130">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2130">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2131">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2131">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2132">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2132">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2133">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2133">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2134">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2134">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2135">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2135">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2136">下面的示例获取`Type`对应于`MyPropertyClass`的对象, 并且使用传递给`GetProperty`方法的参数检索此类的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2136">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2137">找到多个具有指定名称且与指定参数类型和修饰符匹配的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2137">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2138"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2138"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2139">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2139">-or-</span></span> 
 <span data-ttu-id="d6f12-2140"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2140"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2141"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2141"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2142">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2142">-or-</span></span> 
 <span data-ttu-id="d6f12-2143"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2143"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2144">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2144">-or-</span></span> 
 <span data-ttu-id="d6f12-2145"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2145"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="d6f12-2146"><paramref name="types" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2146">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2147">包含要获取的属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2147">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-2148">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2148">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-2149">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2149">-or-</span></span> 
 <span data-ttu-id="d6f12-2150">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2150"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-2151">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2151">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-2152">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2152">-or-</span></span> 
<span data-ttu-id="d6f12-2153">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2153">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="d6f12-2154">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2154">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-2155">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2155">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="d6f12-2156">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2156">-or-</span></span> 
<span data-ttu-id="d6f12-2157">获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2157">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-2158"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2158">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-2159">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2159">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-2160">使用指定的绑定约束，搜索参数与指定的自变量类型及修饰符匹配的指定属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2160">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2161">表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2161">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2162">如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2162">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="d6f12-2163">否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2163">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="d6f12-2164">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2164">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-2165">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2165">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-2166">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2166">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-2167">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2167">Member Type</span></span>|<span data-ttu-id="d6f12-2168">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-2168">Static</span></span>|<span data-ttu-id="d6f12-2169">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-2169">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-2170">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-2170">Constructor</span></span>|<span data-ttu-id="d6f12-2171">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2171">No</span></span>|<span data-ttu-id="d6f12-2172">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2172">No</span></span>|  
|<span data-ttu-id="d6f12-2173">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-2173">Field</span></span>|<span data-ttu-id="d6f12-2174">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2174">No</span></span>|<span data-ttu-id="d6f12-2175">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2175">Yes.</span></span> <span data-ttu-id="d6f12-2176">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2176">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2177">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-2177">Event</span></span>|<span data-ttu-id="d6f12-2178">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2178">Not applicable</span></span>|<span data-ttu-id="d6f12-2179">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2179">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2180">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2180">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2181">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2181">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-2182">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2182">Method</span></span>|<span data-ttu-id="d6f12-2183">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2183">No</span></span>|<span data-ttu-id="d6f12-2184">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2184">Yes.</span></span> <span data-ttu-id="d6f12-2185">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2185">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2186">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2186">Nested Type</span></span>|<span data-ttu-id="d6f12-2187">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2187">No</span></span>|<span data-ttu-id="d6f12-2188">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2188">No</span></span>|  
|<span data-ttu-id="d6f12-2189">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-2189">Property</span></span>|<span data-ttu-id="d6f12-2190">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2190">Not applicable</span></span>|<span data-ttu-id="d6f12-2191">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2191">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2192">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2192">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2193">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2193">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-2194">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2194">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-2195">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2195">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-2196">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2196">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2197">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2197">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-2198">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2198">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-2199">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2199">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-2200">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2200">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-2201">指定`BindingFlags.Public`在搜索中包括公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2201">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-2202">指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2202">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-2203">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2203">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-2204">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2204">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-2205">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2205">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-2206">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2206">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-2207">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2207">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-2208">如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-2209">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="d6f12-2210">索引器和默认属性</span><span class="sxs-lookup"><span data-stu-id="d6f12-2210">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="d6f12-2211">、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2211">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="d6f12-2212">例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2212">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="d6f12-2213">可以重载属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2213">You can overload the property.</span></span>  
  
 <span data-ttu-id="d6f12-2214">在C#中, 此功能称为索引器, 不能按名称引用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2214">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="d6f12-2215">默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2215">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="d6f12-2216">但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2216">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="d6f12-2217">例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2217">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="d6f12-2218">使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2218">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="d6f12-2219">若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2219">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="d6f12-2220">如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2220">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2221">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2221">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2222"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2222"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2223">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2223">-or-</span></span> 
 <span data-ttu-id="d6f12-2224"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2224"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2225"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2225"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2226">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2226">-or-</span></span> 
 <span data-ttu-id="d6f12-2227"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2227"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2228">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2228">-or-</span></span> 
 <span data-ttu-id="d6f12-2229"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2229"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="d6f12-2230"><paramref name="types" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2230">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-2231">包含要获取的属性名的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2231">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="d6f12-2232">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2232">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="d6f12-2233">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2233">-or-</span></span> 
 <span data-ttu-id="d6f12-2234">若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2234"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-2235">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载成员、强制自变量类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2235">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-2236">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2236">-or-</span></span> 
<span data-ttu-id="d6f12-2237">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2237">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="d6f12-2238">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2238">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="d6f12-2239">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2239">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="d6f12-2240">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2240">-or-</span></span> 
<span data-ttu-id="d6f12-2241">获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2241">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-2242"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2242">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="d6f12-2243">默认的联编程序不处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2243">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="d6f12-2244">当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的参数类型和修饰符匹配的指定属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2244">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2245">表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2245">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2246">尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2246">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="d6f12-2247">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2247">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-2248">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2248">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-2249">必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2249">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="d6f12-2250">指定`BindingFlags.Public`在搜索中包括公共属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2250">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-2251">指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2251">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-2252">指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2252">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="d6f12-2253">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2253">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-2254">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2254">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-2255">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2255">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-2256">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2256">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-2257">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2257">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2258"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2258"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2259">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2259">-or-</span></span> 
 <span data-ttu-id="d6f12-2260"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2260"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-2261">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2261">-or-</span></span> 
<span data-ttu-id="d6f12-2262"><paramref name="types" /> 的其中一个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2262">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2263"><paramref name="types" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2263"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2264">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2264">-or-</span></span> 
 <span data-ttu-id="d6f12-2265"><paramref name="modifiers" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2265"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="d6f12-2266">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2266">-or-</span></span> 
 <span data-ttu-id="d6f12-2267"><paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2267"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-2268">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2268">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-2269">获取表示指定类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2269">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-2270">获取当前 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2270">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2271">当前的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2271">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2272">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2272">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-2273">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-2273">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2274">要获取的类型的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2274">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="d6f12-2275">请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2275">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="d6f12-2276">如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2276">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="d6f12-2277">获取具有指定名称的 <see cref="T:System.Type" />，执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2277">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2278">具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2278">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2279">如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2279">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="d6f12-2280"><xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2280"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="d6f12-2281"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2281">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="d6f12-2282">如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2282">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2283">如果`typeName`找不<xref:System.Type.GetType%28System.String%29>到, 则对方法的调用将`null`返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2283">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="d6f12-2284">它不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2284">It does not throw an exception.</span></span> <span data-ttu-id="d6f12-2285">若要控制是否引发异常, 请调用<xref:System.Type.GetType%2A> `throwOnError`具有参数的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2285">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="d6f12-2286"><xref:System.Type.GetType%2A>仅适用于从磁盘加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2286"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="d6f12-2287">如果调用<xref:System.Type.GetType%2A>查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2287">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="d6f12-2288">此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2288">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="d6f12-2289">如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2289">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="d6f12-2290">如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2290">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="d6f12-2291">`GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2291">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="d6f12-2292">若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2292">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="d6f12-2293">否则, 将在内存中获取程序集的两个副本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2293">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="d6f12-2294">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2294">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-2295">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2295">Member Type</span></span>|<span data-ttu-id="d6f12-2296">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-2296">Static</span></span>|<span data-ttu-id="d6f12-2297">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-2297">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-2298">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-2298">Constructor</span></span>|<span data-ttu-id="d6f12-2299">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2299">No</span></span>|<span data-ttu-id="d6f12-2300">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2300">No</span></span>|  
|<span data-ttu-id="d6f12-2301">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-2301">Field</span></span>|<span data-ttu-id="d6f12-2302">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2302">No</span></span>|<span data-ttu-id="d6f12-2303">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2303">Yes.</span></span> <span data-ttu-id="d6f12-2304">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2304">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2305">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-2305">Event</span></span>|<span data-ttu-id="d6f12-2306">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2306">Not applicable</span></span>|<span data-ttu-id="d6f12-2307">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2307">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2308">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2308">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2309">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2309">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-2310">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2310">Method</span></span>|<span data-ttu-id="d6f12-2311">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2311">No</span></span>|<span data-ttu-id="d6f12-2312">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2312">Yes.</span></span> <span data-ttu-id="d6f12-2313">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2313">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2314">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2314">Nested Type</span></span>|<span data-ttu-id="d6f12-2315">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2315">No</span></span>|<span data-ttu-id="d6f12-2316">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2316">No</span></span>|  
|<span data-ttu-id="d6f12-2317">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-2317">Property</span></span>|<span data-ttu-id="d6f12-2318">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2318">Not applicable</span></span>|<span data-ttu-id="d6f12-2319">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2319">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2320">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2320">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2321">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2321">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-2322">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2322">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-2323">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2323">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-2324">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2324">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2325">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2325">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-2326">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2326">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-2327">不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2327">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="d6f12-2328">`typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2328">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="d6f12-2329">请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2329">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-2330">如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2330">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="d6f12-2331">如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2331">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="d6f12-2332">如果程序集具有强名称, 则需要完整的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2332">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="d6f12-2333"><xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2333">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="d6f12-2334">所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2334">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2335">在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2335">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="d6f12-2336">例如, "ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2336">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="d6f12-2337">不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2337">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="d6f12-2338">还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2338">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="d6f12-2339">然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2339">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="d6f12-2340">另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2340">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="d6f12-2341">后面</span><span class="sxs-lookup"><span data-stu-id="d6f12-2341">Delimiter</span></span>|<span data-ttu-id="d6f12-2342">含义</span><span class="sxs-lookup"><span data-stu-id="d6f12-2342">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d6f12-2343">反斜杠 (\\)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2343">Backslash (\\)</span></span>|<span data-ttu-id="d6f12-2344">转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2344">Escape character.</span></span>|  
|<span data-ttu-id="d6f12-2345">反撇号 (')</span><span class="sxs-lookup"><span data-stu-id="d6f12-2345">Backtick (\`)</span></span>|<span data-ttu-id="d6f12-2346">在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2346">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="d6f12-2347">方括号 ([])</span><span class="sxs-lookup"><span data-stu-id="d6f12-2347">Brackets ([])</span></span>|<span data-ttu-id="d6f12-2348">为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2348">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="d6f12-2349">逗号 (,)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2349">Comma (,)</span></span>|<span data-ttu-id="d6f12-2350">在程序集名称之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2350">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="d6f12-2351">Period (.)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2351">Period (.)</span></span>|<span data-ttu-id="d6f12-2352">表示命名空间标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2352">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="d6f12-2353">加号 (+)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2353">Plus sign (+)</span></span>|<span data-ttu-id="d6f12-2354">在嵌套类之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2354">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="d6f12-2355">例如, 类的完全限定名称可能如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2355">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2356">如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2356">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="d6f12-2357">反射发出此字符串, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2357">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2358">"+ +"\\变成 "\\++\\\\",而""\\变成 ""。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2358">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="d6f12-2359">此限定名称可以保留, 以后用于加载<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2359">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="d6f12-2360">若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2360">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="d6f12-2361"><xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2361"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="d6f12-2362"><xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2362"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="d6f12-2363">类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2363">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="d6f12-2364">若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2364">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="d6f12-2365">空格在除程序集名称之外的所有类型名称组件中都是相关的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2365">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="d6f12-2366">在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2366">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-2367">泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2367">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="d6f12-2368">此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2368">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="d6f12-2369">例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2369">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="d6f12-2370">对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2370">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="d6f12-2371">例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2371">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="d6f12-2372">具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2372">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="d6f12-2373">若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2373">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="d6f12-2374">否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2374">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="d6f12-2375">例如, 可以按<xref:System.Collections.Generic.Dictionary%602>如下`MyType`所示指定一个 fromMyAssembly 的, 其中<xref:System.String>包含类型为的键:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2375">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2376">仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2376">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="d6f12-2377">用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2377">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="d6f12-2378">可以为 null 的类型是泛型类型的特例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2378">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="d6f12-2379">例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2379">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2380">在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2380">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="d6f12-2381">例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2381">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="d6f12-2382">下表显示了`GetType`用于各种类型的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2382">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="d6f12-2383">获取</span><span class="sxs-lookup"><span data-stu-id="d6f12-2383">To Get</span></span>|<span data-ttu-id="d6f12-2384">使用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2384">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="d6f12-2385">可以为 null<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="d6f12-2385">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="d6f12-2386">指向的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2386">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="d6f12-2387">指向指向的指针的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2387">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="d6f12-2388">托管指针或对的引用`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2388">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="d6f12-2389">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2389">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="d6f12-2390">请注意，与指针不同，引用仅限于一个级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2390">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="d6f12-2391">父类和嵌套类</span><span class="sxs-lookup"><span data-stu-id="d6f12-2391">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="d6f12-2392">下限为0的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2392">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="d6f12-2393">下限未知的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2393">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="d6f12-2394">一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2394">An n-dimensional array</span></span>|<span data-ttu-id="d6f12-2395">括号中的逗号 (,) 的总计 n-1 次。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2395">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="d6f12-2396">例如, `System.Object[,,]`表示一个`Object`三维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2396">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="d6f12-2397">一维数组的数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2397">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="d6f12-2398">下限未知的矩形二维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2398">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="d6f12-2399">具有一个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2399">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="d6f12-2400">具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2400">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="d6f12-2401">具有两个程序集限定类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2401">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="d6f12-2402">具有程序集限定类型参数的程序集限定的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2402">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="d6f12-2403">一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2403">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2404">下面的示例检索的类型`System.Int32` , 并使用该类型对象<xref:System.Type.FullName%2A>显示的属性`System.Int32`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2404">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2405"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2405"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2406">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2406">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2407"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2407"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2408">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2408">-or-</span></span> 
 <span data-ttu-id="d6f12-2409"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2409"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2410">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2410">-or-</span></span> 
 <span data-ttu-id="d6f12-2411"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2411"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-2412"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2412"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d6f12-2413">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2413">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d6f12-2414">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2414">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-2415">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2415">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-2416">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2416">-or-</span></span>  
  
 <span data-ttu-id="d6f12-2417">当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2417">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-2418">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-2418">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2419">要获取的类型的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2419">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="d6f12-2420">请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2420">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="d6f12-2421">如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2421">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-2422">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2422"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="d6f12-2423">指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2423">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="d6f12-2424">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2424">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="d6f12-2425">获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2425">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2426">具有指定名称的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2426">The type with the specified name.</span></span> <span data-ttu-id="d6f12-2427">如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2427">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="d6f12-2428">在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2428">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="d6f12-2429">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2429">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2430">如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2430">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="d6f12-2431"><xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2431"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="d6f12-2432"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2432">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="d6f12-2433">如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2433">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="d6f12-2434">`GetType`仅适用于从磁盘加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2434">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="d6f12-2435">如果调用`GetType`查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2435">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="d6f12-2436">此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2436">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="d6f12-2437">如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2437">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="d6f12-2438">如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2438">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="d6f12-2439">`GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2439">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="d6f12-2440">若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2440">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="d6f12-2441">否则, 将在内存中获取程序集的两个副本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2441">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="d6f12-2442">`throwOnError`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2442">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="d6f12-2443">引发一些异常, 而不考虑的值`throwOnError`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2443">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="d6f12-2444">例如, 如果找到类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也会引发。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2444">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="d6f12-2445">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2445">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-2446">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2446">Member Type</span></span>|<span data-ttu-id="d6f12-2447">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-2447">Static</span></span>|<span data-ttu-id="d6f12-2448">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-2448">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-2449">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-2449">Constructor</span></span>|<span data-ttu-id="d6f12-2450">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2450">No</span></span>|<span data-ttu-id="d6f12-2451">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2451">No</span></span>|  
|<span data-ttu-id="d6f12-2452">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-2452">Field</span></span>|<span data-ttu-id="d6f12-2453">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2453">No</span></span>|<span data-ttu-id="d6f12-2454">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2454">Yes.</span></span> <span data-ttu-id="d6f12-2455">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2455">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2456">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-2456">Event</span></span>|<span data-ttu-id="d6f12-2457">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2457">Not applicable</span></span>|<span data-ttu-id="d6f12-2458">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2458">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2459">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2459">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2460">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2460">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-2461">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2461">Method</span></span>|<span data-ttu-id="d6f12-2462">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2462">No</span></span>|<span data-ttu-id="d6f12-2463">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2463">Yes.</span></span> <span data-ttu-id="d6f12-2464">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2464">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2465">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2465">Nested Type</span></span>|<span data-ttu-id="d6f12-2466">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2466">No</span></span>|<span data-ttu-id="d6f12-2467">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2467">No</span></span>|  
|<span data-ttu-id="d6f12-2468">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-2468">Property</span></span>|<span data-ttu-id="d6f12-2469">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2469">Not applicable</span></span>|<span data-ttu-id="d6f12-2470">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2470">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2471">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2471">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2472">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2472">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-2473">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2473">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-2474">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2474">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-2475">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2475">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2476">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2476">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-2477">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2477">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-2478">不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2478">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="d6f12-2479">`typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2479">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="d6f12-2480">请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2480">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-2481">如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2481">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="d6f12-2482">如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2482">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="d6f12-2483">如果程序集具有强名称, 则需要完整的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2483">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="d6f12-2484"><xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和泛型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2484">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="d6f12-2485">所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2485">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2486">在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2486">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="d6f12-2487">例如, "ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2487">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="d6f12-2488">不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2488">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="d6f12-2489">还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2489">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="d6f12-2490">然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2490">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="d6f12-2491">另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2491">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="d6f12-2492">后面</span><span class="sxs-lookup"><span data-stu-id="d6f12-2492">Delimiter</span></span>|<span data-ttu-id="d6f12-2493">含义</span><span class="sxs-lookup"><span data-stu-id="d6f12-2493">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d6f12-2494">反斜杠 (\\)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2494">Backslash (\\)</span></span>|<span data-ttu-id="d6f12-2495">转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2495">Escape character.</span></span>|  
|<span data-ttu-id="d6f12-2496">反撇号 (')</span><span class="sxs-lookup"><span data-stu-id="d6f12-2496">Backtick (\`)</span></span>|<span data-ttu-id="d6f12-2497">在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2497">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="d6f12-2498">方括号 ([])</span><span class="sxs-lookup"><span data-stu-id="d6f12-2498">Brackets ([])</span></span>|<span data-ttu-id="d6f12-2499">为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2499">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="d6f12-2500">逗号 (,)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2500">Comma (,)</span></span>|<span data-ttu-id="d6f12-2501">在程序集名称之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2501">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="d6f12-2502">Period (.)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2502">Period (.)</span></span>|<span data-ttu-id="d6f12-2503">表示命名空间标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2503">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="d6f12-2504">加号 (+)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2504">Plus sign (+)</span></span>|<span data-ttu-id="d6f12-2505">在嵌套类之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2505">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="d6f12-2506">例如, 类的完全限定名称可能如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2506">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2507">如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2507">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="d6f12-2508">反射发出此字符串, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2508">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2509">"+ +"\\变成 "\\++\\\\",而""\\变成 ""。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2509">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="d6f12-2510">此限定名称可以保留, 以后用于加载<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2510">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="d6f12-2511">若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2511">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="d6f12-2512"><xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2512"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="d6f12-2513"><xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2513"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="d6f12-2514">类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2514">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="d6f12-2515">若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2515">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="d6f12-2516">空格在除程序集名称之外的所有类型名称组件中都是相关的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2516">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="d6f12-2517">在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2517">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-2518">泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2518">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="d6f12-2519">此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2519">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="d6f12-2520">例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2520">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="d6f12-2521">对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2521">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="d6f12-2522">例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2522">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="d6f12-2523">具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2523">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="d6f12-2524">若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2524">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="d6f12-2525">否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2525">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="d6f12-2526">例如, <xref:System.Collections.Generic.Dictionary%602>可以按如下`MyType`所示指定的 MyAssembly 中的, 其<xref:System.String>键类型为, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2526">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2527">仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2527">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="d6f12-2528">用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2528">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="d6f12-2529">可以为 null 的类型是泛型类型的特例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2529">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="d6f12-2530">例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2530">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2531">在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2531">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="d6f12-2532">例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2532">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="d6f12-2533">下表显示了`GetType`用于各种类型的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2533">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="d6f12-2534">获取</span><span class="sxs-lookup"><span data-stu-id="d6f12-2534">To Get</span></span>|<span data-ttu-id="d6f12-2535">使用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2535">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="d6f12-2536">可以为 null<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="d6f12-2536">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="d6f12-2537">指向的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2537">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="d6f12-2538">指向指向的指针的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2538">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="d6f12-2539">托管指针或对的引用`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2539">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="d6f12-2540">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2540">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="d6f12-2541">请注意，与指针不同，引用仅限于一个级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2541">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="d6f12-2542">父类和嵌套类</span><span class="sxs-lookup"><span data-stu-id="d6f12-2542">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="d6f12-2543">下限为0的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2543">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="d6f12-2544">下限未知的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2544">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="d6f12-2545">一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2545">An n-dimensional array</span></span>|<span data-ttu-id="d6f12-2546">括号中的逗号 (,) 的总计 n-1 次。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2546">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="d6f12-2547">例如, `System.Object[,,]`表示一个`Object`三维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2547">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="d6f12-2548">二维数组的数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2548">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="d6f12-2549">下限未知的矩形二维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2549">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="d6f12-2550">具有一个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2550">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="d6f12-2551">具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2551">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="d6f12-2552">具有两个程序集限定类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2552">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="d6f12-2553">具有程序集限定类型参数的程序集限定的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2553">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="d6f12-2554">一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2554">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-2555">下面的示例检索的类型`System.Int32` , 并使用该类型对象<xref:System.Type.FullName%2A>显示的属性`System.Int32`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2555">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="d6f12-2556">如果类型对象引用不存在的程序集, 则此示例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2556">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2557"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2557"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2558">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2558">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-2559"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2559"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="d6f12-2560">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2560">-or-</span></span> 
 <span data-ttu-id="d6f12-2561"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="d6f12-2562">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2562">-or-</span></span> 
 <span data-ttu-id="d6f12-2563"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2563"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="d6f12-2564">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2564">-or-</span></span> 
 <span data-ttu-id="d6f12-2565"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2565"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="d6f12-2566">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2566">-or-</span></span> 
 <span data-ttu-id="d6f12-2567"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2567"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2568"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2568"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="d6f12-2569">例如："MyType[,\*,]"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2569">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="d6f12-2570">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2570">-or-</span></span> 
 <span data-ttu-id="d6f12-2571"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2571"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2572">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2572">-or-</span></span> 
 <span data-ttu-id="d6f12-2573"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2573"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2574">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2574">-or-</span></span> 
 <span data-ttu-id="d6f12-2575"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2575"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d6f12-2576"><paramref name="throwOnError" /> 是 <see langword="true" /> 并且未找到程序集或其依赖项之一。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2576"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d6f12-2577">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2577">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d6f12-2578">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2578">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-2579">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2579">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-2580">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2580">-or-</span></span>  
  
 <span data-ttu-id="d6f12-2581">当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2581">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-2582">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-2582">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2583">要获取的类型的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2583">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="d6f12-2584">请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2584">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="d6f12-2585">如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2585">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-2586">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2586"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="d6f12-2587">指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2587">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="d6f12-2588">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2588">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="d6f12-2589">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2589"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-2590">获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2590">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2591">具有指定名称的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2591">The type with the specified name.</span></span> <span data-ttu-id="d6f12-2592">如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2592">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="d6f12-2593">在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2593">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="d6f12-2594">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2594">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2595">如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2595">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="d6f12-2596"><xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2596"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="d6f12-2597"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2597">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="d6f12-2598">如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2598">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="d6f12-2599">`GetType`仅适用于从磁盘加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2599">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="d6f12-2600">如果调用`GetType`查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2600">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="d6f12-2601">此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2601">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="d6f12-2602">如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2602">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="d6f12-2603">如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2603">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="d6f12-2604">`GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2604">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="d6f12-2605">若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2605">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="d6f12-2606">否则, 将在内存中获取程序集的两个副本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2606">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="d6f12-2607">`throwOnError`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2607">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="d6f12-2608">引发一些异常, 而不考虑的值`throwOnError`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2608">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="d6f12-2609">例如, 如果找到类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也会引发。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2609">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="d6f12-2610">下表显示了在类型上反射时`Get`方法返回的基类成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2610">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="d6f12-2611">成员类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2611">Member Type</span></span>|<span data-ttu-id="d6f12-2612">Static</span><span class="sxs-lookup"><span data-stu-id="d6f12-2612">Static</span></span>|<span data-ttu-id="d6f12-2613">非静态</span><span class="sxs-lookup"><span data-stu-id="d6f12-2613">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="d6f12-2614">构造函数</span><span class="sxs-lookup"><span data-stu-id="d6f12-2614">Constructor</span></span>|<span data-ttu-id="d6f12-2615">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2615">No</span></span>|<span data-ttu-id="d6f12-2616">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2616">No</span></span>|  
|<span data-ttu-id="d6f12-2617">字段</span><span class="sxs-lookup"><span data-stu-id="d6f12-2617">Field</span></span>|<span data-ttu-id="d6f12-2618">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2618">No</span></span>|<span data-ttu-id="d6f12-2619">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2619">Yes.</span></span> <span data-ttu-id="d6f12-2620">字段始终按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2620">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2621">事件</span><span class="sxs-lookup"><span data-stu-id="d6f12-2621">Event</span></span>|<span data-ttu-id="d6f12-2622">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2622">Not applicable</span></span>|<span data-ttu-id="d6f12-2623">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2624">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2625">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2625">See note 2 below.</span></span>|  
|<span data-ttu-id="d6f12-2626">方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2626">Method</span></span>|<span data-ttu-id="d6f12-2627">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2627">No</span></span>|<span data-ttu-id="d6f12-2628">可以。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2628">Yes.</span></span> <span data-ttu-id="d6f12-2629">方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2629">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="d6f12-2630">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2630">Nested Type</span></span>|<span data-ttu-id="d6f12-2631">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2631">No</span></span>|<span data-ttu-id="d6f12-2632">No</span><span class="sxs-lookup"><span data-stu-id="d6f12-2632">No</span></span>|  
|<span data-ttu-id="d6f12-2633">Property</span><span class="sxs-lookup"><span data-stu-id="d6f12-2633">Property</span></span>|<span data-ttu-id="d6f12-2634">不适用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2634">Not applicable</span></span>|<span data-ttu-id="d6f12-2635">通用类型系统规则是指继承与实现属性的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2635">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="d6f12-2636">反射将属性视为隐藏的名称和签名。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2636">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2637">请参阅下面的注释2。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2637">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="d6f12-2638">按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2638">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="d6f12-2639">这是二进制比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2639">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="d6f12-2640">对于反射, 属性和事件是按名称和签名隐藏的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2640">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="d6f12-2641">如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2641">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="d6f12-2642">自定义属性不属于通用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2642">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="d6f12-2643">不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2643">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="d6f12-2644">`typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2644">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="d6f12-2645">请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2645">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-2646">如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2646">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="d6f12-2647">如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2647">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="d6f12-2648">如果程序集具有强名称, 则需要完整的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2648">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="d6f12-2649"><xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2649">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="d6f12-2650">所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2650">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2651">在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2651">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="d6f12-2652">例如, "ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2652">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="d6f12-2653">不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2653">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="d6f12-2654">还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2654">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="d6f12-2655">然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2655">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="d6f12-2656">另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2656">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="d6f12-2657">后面</span><span class="sxs-lookup"><span data-stu-id="d6f12-2657">Delimiter</span></span>|<span data-ttu-id="d6f12-2658">含义</span><span class="sxs-lookup"><span data-stu-id="d6f12-2658">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d6f12-2659">反斜杠 (\\)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2659">Backslash (\\)</span></span>|<span data-ttu-id="d6f12-2660">转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2660">Escape character.</span></span>|  
|<span data-ttu-id="d6f12-2661">反撇号 (')</span><span class="sxs-lookup"><span data-stu-id="d6f12-2661">Backtick (\`)</span></span>|<span data-ttu-id="d6f12-2662">在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2662">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="d6f12-2663">方括号 ([])</span><span class="sxs-lookup"><span data-stu-id="d6f12-2663">Brackets ([])</span></span>|<span data-ttu-id="d6f12-2664">为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2664">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="d6f12-2665">逗号 (,)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2665">Comma (,)</span></span>|<span data-ttu-id="d6f12-2666">在程序集名称之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2666">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="d6f12-2667">Period (.)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2667">Period (.)</span></span>|<span data-ttu-id="d6f12-2668">表示命名空间标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2668">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="d6f12-2669">加号 (+)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2669">Plus sign (+)</span></span>|<span data-ttu-id="d6f12-2670">在嵌套类之前。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2670">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="d6f12-2671">例如, 类的完全限定名称可能如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2671">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2672">如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2672">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="d6f12-2673">反射发出此字符串, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2673">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="d6f12-2674">"+ +"\\变成 "\\++\\\\",而""\\变成 ""。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2674">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="d6f12-2675">此限定名称可以保留, 以后用于加载<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2675">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="d6f12-2676">若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2676">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="d6f12-2677"><xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2677"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="d6f12-2678"><xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2678"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="d6f12-2679">类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2679">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="d6f12-2680">若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2680">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="d6f12-2681">空格在除程序集名称之外的所有类型名称组件中都是相关的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2681">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="d6f12-2682">在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2682">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="d6f12-2683">泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2683">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="d6f12-2684">此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2684">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="d6f12-2685">例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2685">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="d6f12-2686">对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2686">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="d6f12-2687">例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2687">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="d6f12-2688">具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2688">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="d6f12-2689">若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2689">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="d6f12-2690">否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2690">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="d6f12-2691">例如, <xref:System.Collections.Generic.Dictionary%602>可以按如下`MyType`所示指定的 MyAssembly 中的, 其<xref:System.String>键类型为, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2691">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2692">仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2692">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="d6f12-2693">用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2693">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="d6f12-2694">可以为 null 的类型是泛型类型的特例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2694">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="d6f12-2695">例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2695">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2696">在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2696">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="d6f12-2697">例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2697">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="d6f12-2698">下表显示了`GetType`用于各种类型的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2698">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="d6f12-2699">获取</span><span class="sxs-lookup"><span data-stu-id="d6f12-2699">To Get</span></span>|<span data-ttu-id="d6f12-2700">使用</span><span class="sxs-lookup"><span data-stu-id="d6f12-2700">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="d6f12-2701">可以为 null<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="d6f12-2701">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="d6f12-2702">指向的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2702">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="d6f12-2703">指向指向的指针的非托管指针`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2703">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="d6f12-2704">托管指针或对的引用`MyType`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2704">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="d6f12-2705">`Type.GetType("MyType&")`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2705">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="d6f12-2706">请注意，与指针不同，引用仅限于一个级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2706">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="d6f12-2707">父类和嵌套类</span><span class="sxs-lookup"><span data-stu-id="d6f12-2707">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="d6f12-2708">下限为0的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2708">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="d6f12-2709">下限未知的一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2709">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="d6f12-2710">一维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2710">An n-dimensional array</span></span>|<span data-ttu-id="d6f12-2711">括号中的逗号 (,) 的总计 n-1 次。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2711">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="d6f12-2712">例如, `System.Object[,,]`表示一个`Object`三维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2712">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="d6f12-2713">二维数组的数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2713">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="d6f12-2714">下限未知的矩形二维数组</span><span class="sxs-lookup"><span data-stu-id="d6f12-2714">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="d6f12-2715">具有一个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2715">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="d6f12-2716">具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2716">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="d6f12-2717">具有两个程序集限定类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2717">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="d6f12-2718">具有程序集限定类型参数的程序集限定的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2718">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="d6f12-2719">一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2719">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2720"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2720"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2721">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2721">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-2722"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2722"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="d6f12-2723">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2723">-or-</span></span> 
 <span data-ttu-id="d6f12-2724"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2724"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="d6f12-2725">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2725">-or-</span></span> 
 <span data-ttu-id="d6f12-2726"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2726"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="d6f12-2727">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2727">-or-</span></span> 
 <span data-ttu-id="d6f12-2728"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2728"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="d6f12-2729">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2729">-or-</span></span> 
 <span data-ttu-id="d6f12-2730"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2730"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2731"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2731"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="d6f12-2732">例如："MyType[,\*,]"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2732">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="d6f12-2733">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2733">-or-</span></span> 
 <span data-ttu-id="d6f12-2734"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2734"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2735">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2735">-or-</span></span> 
 <span data-ttu-id="d6f12-2736"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2736"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2737">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2737">-or-</span></span> 
 <span data-ttu-id="d6f12-2738"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2738"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d6f12-2739"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2739"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d6f12-2740">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2740">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-2741">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2741">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-2742">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2742">-or-</span></span>  
  
 <span data-ttu-id="d6f12-2743">当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2743">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-2744">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-2744">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2745">要获取的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2745">The name of the type to get.</span></span> <span data-ttu-id="d6f12-2746">如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2746">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="d6f12-2747">如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2747">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="d6f12-2748">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2748">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="d6f12-2749">以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2749">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="d6f12-2750">如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2750">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="d6f12-2751">如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2751">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="d6f12-2752">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2752">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="d6f12-2753">此操作可能会导致恶意代码特权提升。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2753">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="d6f12-2754">仅使用你提供或者熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2754">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="d6f12-2755">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2755">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="d6f12-2756">如果未提供任何程序集，则 <paramref name="typeResolver" /> 方法可以提供一个程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2756">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="d6f12-2757">该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2757">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="d6f12-2758">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2758">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="d6f12-2759">获取具有指定名称的类型，（可选）提供自定义方法以解析程序集和该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2759">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2760">具有指定名称的类型，如果未找到该类型，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2760">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2761">此方法的使用方案以及有关`assemblyResolver`和`typeResolver`参数的详细信息<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>可在方法重载中找到。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2761">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2762">如果`typeName`找不<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>到, 则对方法的调用将`null`返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2762">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="d6f12-2763">它不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2763">It does not throw an exception.</span></span> <span data-ttu-id="d6f12-2764">若要控制是否引发异常, 请调用<xref:System.Type.GetType%2A> `throwOnError`具有参数的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2764">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="d6f12-2765">调用此方法重载<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>与调用方法重载和为`throwOnError`和`ignoreCase`参数指定`false`的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2765">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2766"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2766"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2767">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2767">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2768">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2768">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="d6f12-2769">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2769">-or-</span></span> 
 <span data-ttu-id="d6f12-2770"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2770"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2771">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2771">-or-</span></span> 
 <span data-ttu-id="d6f12-2772"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2772"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2773">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2773">-or-</span></span> 
 <span data-ttu-id="d6f12-2774"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2774"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-2775"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2775"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d6f12-2776">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2776">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="d6f12-2777">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2777">-or-</span></span> 
 <span data-ttu-id="d6f12-2778"><paramref name="typeName" /> 包含无效的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2778"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="d6f12-2779">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2779">-or-</span></span> 
 <span data-ttu-id="d6f12-2780"><paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2780"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-2781">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2781">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-2782">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2782">-or-</span></span>  
  
 <span data-ttu-id="d6f12-2783">此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2783">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2784">要获取的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2784">The name of the type to get.</span></span> <span data-ttu-id="d6f12-2785">如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2785">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="d6f12-2786">如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2786">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="d6f12-2787">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2787">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="d6f12-2788">以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2788">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="d6f12-2789">如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2789">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="d6f12-2790">如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2790">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="d6f12-2791">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2791">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="d6f12-2792">此操作可能会导致恶意代码特权提升。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2792">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="d6f12-2793">仅使用你提供或者熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2793">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="d6f12-2794">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2794">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="d6f12-2795">如果未提供任何程序集，则该方法可以提供一个程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2795">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="d6f12-2796">该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2796">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="d6f12-2797">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2797">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-2798">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2798"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="d6f12-2799">指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2799">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="d6f12-2800">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2800">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="d6f12-2801">获取具有指定名称的类型，指定在找不到该类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2801">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2802">具有指定名称的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2802">The type with the specified name.</span></span> <span data-ttu-id="d6f12-2803">如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2803">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="d6f12-2804">在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2804">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="d6f12-2805">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2805">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2806">此方法的使用方案以及有关`assemblyResolver`和`typeResolver`参数的详细信息<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>可在方法重载中找到。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2806">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="d6f12-2807">调用此方法重载与调用<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载和为`ignoreCase`参数指定`false`的方法相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2807">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2808"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2808"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-2809">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2809">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-2810"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2810"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="d6f12-2811">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2811">-or-</span></span> 
 <span data-ttu-id="d6f12-2812"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2812"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="d6f12-2813">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2813">-or-</span></span> 
 <span data-ttu-id="d6f12-2814"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2814"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="d6f12-2815">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2815">-or-</span></span> 
 <span data-ttu-id="d6f12-2816"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2816"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="d6f12-2817">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2817">-or-</span></span> 
 <span data-ttu-id="d6f12-2818"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2818"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-2819">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2819">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="d6f12-2820">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2820">-or-</span></span> 
 <span data-ttu-id="d6f12-2821"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,\*,]"）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2821"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="d6f12-2822">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2822">-or-</span></span> 
 <span data-ttu-id="d6f12-2823"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2823"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2824">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2824">-or-</span></span> 
 <span data-ttu-id="d6f12-2825"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2825"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-2826">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2826">-or-</span></span> 
 <span data-ttu-id="d6f12-2827"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2827"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d6f12-2828"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2828"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="d6f12-2829">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-2829">-or-</span></span> 
 <span data-ttu-id="d6f12-2830"><paramref name="typeName" /> 包含无效的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2830"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="d6f12-2831">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2831">-or-</span></span> 
 <span data-ttu-id="d6f12-2832"><paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2832"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d6f12-2833">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2833">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-2834">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2834">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-2835">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-2835">-or-</span></span>  
  
 <span data-ttu-id="d6f12-2836">此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2836">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-2837">要获取的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2837">The name of the type to get.</span></span> <span data-ttu-id="d6f12-2838">如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2838">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="d6f12-2839">如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2839">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="d6f12-2840">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2840">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="d6f12-2841">以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2841">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="d6f12-2842">如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2842">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="d6f12-2843">如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2843">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="d6f12-2844">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2844">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="d6f12-2845">此操作可能会导致恶意代码特权提升。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2845">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="d6f12-2846">仅使用你提供或者熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2846">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="d6f12-2847">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2847">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="d6f12-2848">如果未提供任何程序集，则该方法可以提供一个程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2848">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="d6f12-2849">该方法还采用一个参数以指定是否执行不区分大小写的搜索；<paramref name="ignoreCase" /> 的值传递给该参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2849">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="d6f12-2850">警告   不要通过未知的或不受信任的调用方传递方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2850">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-2851">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2851"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="d6f12-2852">指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2852">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="d6f12-2853">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2853">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="d6f12-2854">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2854"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-2855">获取具有指定名称的类型，指定是否执行区分大小写的搜索，在找不到类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2855">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-2856">具有指定名称的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2856">The type with the specified name.</span></span> <span data-ttu-id="d6f12-2857">如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2857">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="d6f12-2858">在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2858">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="d6f12-2859">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2859">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-2860">使用此方法重载及其关联的重载 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>和<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 将<xref:System.Type.GetType%2A>方法的默认实现替换为更灵活的实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2860">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="d6f12-2861">通过提供自己的方法来解析类型名称以及包含它们的程序集的名称, 您可以执行以下操作:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2861">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="d6f12-2862">控制从其加载类型的程序集的版本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2862">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="d6f12-2863">提供另一个查找不包括程序集名称的类型名称的位置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2863">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="d6f12-2864">使用部分程序集名称加载程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2864">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="d6f12-2865">返回不是<xref:System.Type?displayProperty=nameWithType>由公共语言运行时 (CLR) 创建的子类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2865">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="d6f12-2866">例如, 在版本容错序列化中, 此方法使你能够使用部分名称搜索 "最适合" 程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2866">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="d6f12-2867">此<xref:System.Type.GetType%2A>方法的其他重载需要程序集限定的类型名称, 包括版本号。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2867">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="d6f12-2868">类型系统的其他实现可能需要返回不是由 CLR <xref:System.Type?displayProperty=nameWithType>创建的的子类; 该<xref:System.Type.GetType%2A>方法的其他重载返回的所有类型都是运行时类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2868">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="d6f12-2869">使用说明</span><span class="sxs-lookup"><span data-stu-id="d6f12-2869">Usage Notes</span></span>  
 <span data-ttu-id="d6f12-2870">此方法重载及其关联重载分析`typeName`为类型名称和程序集名称, 然后解析名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2870">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="d6f12-2871">程序集名称的解析出现在类型名称解析之前, 因为类型名称必须在程序集的上下文中解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2871">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2872">如果不熟悉程序集限定类型名称的概念, 请参见<xref:System.Type.AssemblyQualifiedName%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2872">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="d6f12-2873">如果`typeName`不是程序集限定名称, 则跳过程序集解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2873">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="d6f12-2874">可在 mscorlib.dll 或当前正在执行的程序集的上下文中解析不合格的类型名称, 也可以选择在`typeResolver`参数中提供程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2874">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="d6f12-2875">包括或省略不同类型名称解析的程序集名称的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2875">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="d6f12-2876">一般使用说明:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2876">General usage notes:</span></span>  
  
-   <span data-ttu-id="d6f12-2877">如果方法来自未知或`assemblyResolver`不`typeResolver`受信任的调用方, 请不要将方法传递给或。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2877">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="d6f12-2878">仅使用你提供或者熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2878">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="d6f12-2879">使用来自未知或不受信任调用方的方法可能会导致恶意代码特权提升。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2879">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="d6f12-2880">如果省略了`assemblyResolver`和/或`typeResolver`参数`throwOnError` , 则参数的值将传递给执行默认解析的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2880">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="d6f12-2881">如果`throwOnError`为`typeResolver` <xref:System.IO.FileNotFoundException> `assemblyResolver` , 则此方法`null`在返回时引发, 而在返回`null`时引发。 <xref:System.TypeLoadException> `true`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2881">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="d6f12-2882">此方法不会捕获和`assemblyResolver` `typeResolver`引发的异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2882">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="d6f12-2883">你负责解析程序方法引发的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2883">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="d6f12-2884">解析程序集</span><span class="sxs-lookup"><span data-stu-id="d6f12-2884">Resolving Assemblies</span></span>  
 <span data-ttu-id="d6f12-2885">方法接收一个<xref:System.Reflection.AssemblyName>对象, 该对象是通过分析中`typeName`包含的字符串程序集名称生成的。 `assemblyResolver`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2885">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="d6f12-2886">如果`typeName`不包含程序集名称, `assemblyResolver`则不会`typeResolver`调用并`null`将传递给。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2886">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="d6f12-2887">如果`assemblyResolver`未提供, 则使用标准程序集探测来定位程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2887">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="d6f12-2888">如果`assemblyResolver`提供了, 则<xref:System.Type.GetType%2A>方法不执行标准探测; 在这种情况下, 您必须确保`assemblyResolver`您可以处理您传递给它的所有程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2888">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="d6f12-2889">如果`assemblyResolver`无法解析程序`null`集, 则该方法应返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2889">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="d6f12-2890">如果`assemblyResolver`返回`throwOnError` `true`, 则不<xref:System.IO.FileNotFoundException>会调用, 也不会进行进一步的处理; 此外, 如果为, 则引发。 `null` `typeResolver`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2890">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d6f12-2891">如果传递到`assemblyResolver`的是部分名称, 则其一个或`null`多个部分为。 <xref:System.Reflection.AssemblyName></span><span class="sxs-lookup"><span data-stu-id="d6f12-2891">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="d6f12-2892">例如, 如果它没有版本, <xref:System.Reflection.AssemblyName.Version%2A>则属性为。 `null`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2892">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="d6f12-2893">如果属性、属性和<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法全部返回`null`, 则仅提供程序集的简单名称。 <xref:System.Reflection.AssemblyName.CultureInfo%2A> <xref:System.Reflection.AssemblyName.Version%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-2893">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="d6f12-2894">`assemblyResolver`方法可以使用或忽略程序集名称的所有部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2894">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="d6f12-2895">对于简单的和程序集限定的类型名称, 不同的程序集解析选项的作用在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2895">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="d6f12-2896">解析类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2896">Resolving Types</span></span>  
 <span data-ttu-id="d6f12-2897">如果`typeName`未指定程序集名称, `typeResolver`则始终调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2897">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="d6f12-2898">如果`typeName`指定程序集名称, `typeResolver`则只有在成功解析程序集名称时才会调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2898">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="d6f12-2899">如果`assemblyResolver`或标准程序集探测`null`返回`typeResolver` , 则不会调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2899">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="d6f12-2900">`typeResolver`方法收到三个参数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2900">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="d6f12-2901">要搜索`null`的程序集, `typeName`如果不包含程序集名称, 则为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2901">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="d6f12-2902">类型的简单名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2902">The simple name of the type.</span></span> <span data-ttu-id="d6f12-2903">对于嵌套类型, 这是最外层的包含类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2903">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="d6f12-2904">对于泛型类型, 这是泛型类型的简单名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2904">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="d6f12-2905">一个布尔值, 如果`true`要忽略类型名称的大小写, 则为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2905">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="d6f12-2906">实现确定使用这些参数的方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2906">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="d6f12-2907">如果方法无法解析类型, 则应返回`null`。 `typeResolver`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2907">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="d6f12-2908">如果`typeResolver`返回`true` <xref:System.TypeLoadException>且为, 则的<xref:System.Type.GetType%2A>此重载将引发。 `throwOnError` `null`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2908">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="d6f12-2909">对于简单的和程序集限定的类型名称, 不同类型解析选项的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2909">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="d6f12-2910">解析嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2910">Resolving Nested Types</span></span>  
 <span data-ttu-id="d6f12-2911">如果`typeName`是嵌套类型, 则仅将包含类型的最外面的名称`typeResolver`传递给。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2911">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="d6f12-2912">当`typeResolver`返回此类型时<xref:System.Type.GetNestedType%2A> , 将以递归方式调用方法, 直到解析最内层的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2912">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="d6f12-2913">解析泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-2913">Resolving Generic Types</span></span>  
 <span data-ttu-id="d6f12-2914"><xref:System.Type.GetType%2A>递归调用以解析泛型类型:首先解析泛型类型本身, 然后解析其类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2914">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="d6f12-2915">如果类型参数是泛型, <xref:System.Type.GetType%2A>则会以递归方式调用以解析其类型参数, 依此类推。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2915">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="d6f12-2916">您提供的`assemblyResolver`和`typeResolver`的组合必须能够解析此递归的所有级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2916">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="d6f12-2917">例如, 假设您提供了一个`assemblyResolver` , 用于控制的`MyAssembly`加载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2917">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="d6f12-2918">假设要解析泛型类型`Dictionary<string, MyType>` (`Dictionary(Of String, MyType)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2918">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="d6f12-2919">你可能会传递以下泛型类型名称:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2919">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="d6f12-2920">请注意`MyType` , 是唯一的程序集限定类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2920">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="d6f12-2921"><xref:System.Collections.Generic.Dictionary%602> 和<xref:System.String>类的名称不是程序集限定的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2921">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="d6f12-2922">`null` <xref:System.Collections.Generic.Dictionary%602> <xref:System.String>必须能够处理程序集或`null`, 因为它将接收和。 `typeResolver`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2922">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="d6f12-2923">它可以通过调用采用字符串的<xref:System.Type.GetType%2A>方法重载来处理这种情况, 因为两个非限定类型名称都在 mscorlib.dll 中:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2923">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="d6f12-2924">不会为字典类型和字符串类型调用方法,因为这些类型名称不是程序集限定名称。`assemblyResolver`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2924">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="d6f12-2925">现在, 假设第一个`System.String`泛型参数类型为, `YourAssembly`而不`YourType`是:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2925">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="d6f12-2926">由于此程序集既不是 Mscorlib .dll, 也不是当前正在执行的`YourType`程序集, 因此无法在没有程序集限定名称的情况下解析。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2926">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="d6f12-2927">`assemblyResolve`由于将以递归方式调用, 因此它必须能够处理这种情况。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2927">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="d6f12-2928">它现在会`null`使用提供<xref:System.Reflection.AssemblyName>的对象`MyAssembly`执行程序集加载, 而不是为之外的程序集进行返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2928">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="d6f12-2929">返回到[使用说明](#usage_notes)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2929">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="d6f12-2930">解析包含特殊字符的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-2930">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="d6f12-2931">某些字符在程序集限定名称中具有特殊含义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2931">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="d6f12-2932">如果简单的类型名称包含这些字符, 则当简单名称是程序集限定名称的一部分时, 这些字符将导致分析错误。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2932">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="d6f12-2933">若要避免分析错误, 必须使用反斜杠对特殊字符进行转义, 然后才能将程序集限定名称传递给<xref:System.Type.GetType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2933">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="d6f12-2934">例如, 如果类型`Strange]Type`为, 则必须将转义符添加到方括号的前面, 如下所示:。 `Strange\]Type`</span><span class="sxs-lookup"><span data-stu-id="d6f12-2934">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-2935">不能在 Visual Basic 或C#中创建具有此类特殊字符的名称, 但可以使用 Microsoft 中间语言 (MSIL) 或发出动态程序集来创建它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2935">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="d6f12-2936">下表显示了类型名称的特殊字符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2936">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="d6f12-2937">字符</span><span class="sxs-lookup"><span data-stu-id="d6f12-2937">Character</span></span>|<span data-ttu-id="d6f12-2938">含义</span><span class="sxs-lookup"><span data-stu-id="d6f12-2938">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d6f12-2939">`,`跟</span><span class="sxs-lookup"><span data-stu-id="d6f12-2939">`,` (comma)</span></span>|<span data-ttu-id="d6f12-2940">程序集限定名称的分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2940">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="d6f12-2941">`[]`(方括号)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2941">`[]` (square brackets)</span></span>|<span data-ttu-id="d6f12-2942">作为后缀对, 指示数组类型;作为分隔符对, 包含泛型参数列表和程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2942">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="d6f12-2943">`&`前面</span><span class="sxs-lookup"><span data-stu-id="d6f12-2943">`&` (ampersand)</span></span>|<span data-ttu-id="d6f12-2944">作为后缀, 指示类型是引用类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2944">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="d6f12-2945">`*`红星</span><span class="sxs-lookup"><span data-stu-id="d6f12-2945">`*` (asterisk)</span></span>|<span data-ttu-id="d6f12-2946">作为后缀, 指示类型是指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2946">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="d6f12-2947">`+`加大</span><span class="sxs-lookup"><span data-stu-id="d6f12-2947">`+` (plus)</span></span>|<span data-ttu-id="d6f12-2948">嵌套类型的分隔符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2948">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="d6f12-2949">`\`符号</span><span class="sxs-lookup"><span data-stu-id="d6f12-2949">`\` (backslash)</span></span>|<span data-ttu-id="d6f12-2950">转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2950">Escape character.</span></span>|  
  
 <span data-ttu-id="d6f12-2951">诸如返回正确<xref:System.Type.AssemblyQualifiedName%2A>转义的字符串之类的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2951">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="d6f12-2952">必须将正确转义的<xref:System.Type.GetType%2A>字符串传递给方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2952">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="d6f12-2953">相反, 该<xref:System.Type.GetType%2A>方法将正确的转义名称传递`typeResolver`给和的默认类型解析方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2953">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="d6f12-2954">如果需要将名称与中`typeResolver`的非转义名称进行比较, 则必须删除转义符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2954">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="d6f12-2955">返回到[使用说明](#usage_notes)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2955">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="d6f12-2956">混合名称解析</span><span class="sxs-lookup"><span data-stu-id="d6f12-2956">Mixed Name Resolution</span></span>  
 <span data-ttu-id="d6f12-2957">下表总结了、 `assemblyResolver` `typeResolver`和默认名称解析之间的交互, 适用于中`typeName`的类型名称和程序集名称的所有组合:</span><span class="sxs-lookup"><span data-stu-id="d6f12-2957">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="d6f12-2958">类型名称的内容</span><span class="sxs-lookup"><span data-stu-id="d6f12-2958">Contents of type name</span></span>|<span data-ttu-id="d6f12-2959">程序集解析程序方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2959">Assembly resolver method</span></span>|<span data-ttu-id="d6f12-2960">类型解析程序方法</span><span class="sxs-lookup"><span data-stu-id="d6f12-2960">Type resolver method</span></span>|<span data-ttu-id="d6f12-2961">结果</span><span class="sxs-lookup"><span data-stu-id="d6f12-2961">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="d6f12-2962">类型、程序集</span><span class="sxs-lookup"><span data-stu-id="d6f12-2962">type, assembly</span></span>|<span data-ttu-id="d6f12-2963">null</span><span class="sxs-lookup"><span data-stu-id="d6f12-2963">null</span></span>|<span data-ttu-id="d6f12-2964">null</span><span class="sxs-lookup"><span data-stu-id="d6f12-2964">null</span></span>|<span data-ttu-id="d6f12-2965">等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2965">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="d6f12-2966">类型、程序集</span><span class="sxs-lookup"><span data-stu-id="d6f12-2966">type, assembly</span></span>|<span data-ttu-id="d6f12-2967">规定</span><span class="sxs-lookup"><span data-stu-id="d6f12-2967">provided</span></span>|<span data-ttu-id="d6f12-2968">null</span><span class="sxs-lookup"><span data-stu-id="d6f12-2968">null</span></span>|<span data-ttu-id="d6f12-2969">`assemblyResolver`返回程序集, 如果`null`无法解析程序集, 则返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2969">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="d6f12-2970">如果对程序集进行解析, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>则使用方法重载从程序集加载类型; 否则, 将不会尝试解析该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2970">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="d6f12-2971">类型、程序集</span><span class="sxs-lookup"><span data-stu-id="d6f12-2971">type, assembly</span></span>|<span data-ttu-id="d6f12-2972">null</span><span class="sxs-lookup"><span data-stu-id="d6f12-2972">null</span></span>|<span data-ttu-id="d6f12-2973">规定</span><span class="sxs-lookup"><span data-stu-id="d6f12-2973">provided</span></span>|<span data-ttu-id="d6f12-2974">等效于将程序集名称转换为<xref:System.Reflection.AssemblyName>对象, 并<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>调用方法重载以获取程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2974">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="d6f12-2975">如果对程序集进行解析, 则将其`typeResolver`传递到; `typeResolver`否则, 将不会调用, 也不会再尝试解析该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2975">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="d6f12-2976">类型、程序集</span><span class="sxs-lookup"><span data-stu-id="d6f12-2976">type, assembly</span></span>|<span data-ttu-id="d6f12-2977">规定</span><span class="sxs-lookup"><span data-stu-id="d6f12-2977">provided</span></span>|<span data-ttu-id="d6f12-2978">规定</span><span class="sxs-lookup"><span data-stu-id="d6f12-2978">provided</span></span>|<span data-ttu-id="d6f12-2979">`assemblyResolver`返回程序集, 如果`null`无法解析程序集, 则返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2979">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="d6f12-2980">如果对程序集进行解析, 则将其`typeResolver`传递到; `typeResolver`否则, 将不会调用, 也不会再尝试解析该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2980">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="d6f12-2981">type</span><span class="sxs-lookup"><span data-stu-id="d6f12-2981">type</span></span>|<span data-ttu-id="d6f12-2982">提供空值</span><span class="sxs-lookup"><span data-stu-id="d6f12-2982">null, provided</span></span>|<span data-ttu-id="d6f12-2983">null</span><span class="sxs-lookup"><span data-stu-id="d6f12-2983">null</span></span>|<span data-ttu-id="d6f12-2984">等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2984">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="d6f12-2985">由于未提供程序集名称, 因此只会搜索 Mscorlib.dll 和当前正在执行的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2985">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="d6f12-2986">如果`assemblyResolver`提供了, 则将其忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2986">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="d6f12-2987">type</span><span class="sxs-lookup"><span data-stu-id="d6f12-2987">type</span></span>|<span data-ttu-id="d6f12-2988">提供空值</span><span class="sxs-lookup"><span data-stu-id="d6f12-2988">null, provided</span></span>|<span data-ttu-id="d6f12-2989">规定</span><span class="sxs-lookup"><span data-stu-id="d6f12-2989">provided</span></span>|<span data-ttu-id="d6f12-2990">`typeResolver`为程序集调用`null`并传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2990">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="d6f12-2991">`typeResolver`可以提供任何程序集中的类型, 包括为此目的而加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2991">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="d6f12-2992">如果`assemblyResolver`提供了, 则将其忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2992">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="d6f12-2993">程序集 (assembly)</span><span class="sxs-lookup"><span data-stu-id="d6f12-2993">assembly</span></span>|<span data-ttu-id="d6f12-2994">提供空值</span><span class="sxs-lookup"><span data-stu-id="d6f12-2994">null, provided</span></span>|<span data-ttu-id="d6f12-2995">提供空值</span><span class="sxs-lookup"><span data-stu-id="d6f12-2995">null, provided</span></span>|<span data-ttu-id="d6f12-2996"><xref:System.IO.FileLoadException>引发, 因为程序集名称被分析为程序集限定的类型名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2996">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="d6f12-2997">这会导致无效的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2997">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="d6f12-2998">返回到:[使用说明](#usage_notes),[解析程序集](#resolving_assemblies),[解析类型](#resolving_types)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2998">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-2999"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-2999"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-3000">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3000">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-3001"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3001"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="d6f12-3002">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3002">-or-</span></span> 
 <span data-ttu-id="d6f12-3003"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3003"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="d6f12-3004">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3004">-or-</span></span> 
 <span data-ttu-id="d6f12-3005"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3005"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="d6f12-3006">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3006">-or-</span></span> 
 <span data-ttu-id="d6f12-3007"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3007"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="d6f12-3008">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3008">-or-</span></span> 
 <span data-ttu-id="d6f12-3009"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3009"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3010">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3010">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="d6f12-3011">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3011">-or-</span></span> 
 <span data-ttu-id="d6f12-3012"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,\*,]"）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3012"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="d6f12-3013">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3013">-or-</span></span> 
 <span data-ttu-id="d6f12-3014"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3014"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-3015">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3015">-or-</span></span> 
 <span data-ttu-id="d6f12-3016"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3016"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-3017">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3017">-or-</span></span> 
 <span data-ttu-id="d6f12-3018"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3018"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d6f12-3019"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3019"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d6f12-3020">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3020">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="d6f12-3021">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3021">-or-</span></span> 
 <span data-ttu-id="d6f12-3022"><paramref name="typeName" /> 包含无效的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3022"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="d6f12-3023">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3023">-or-</span></span> 
 <span data-ttu-id="d6f12-3024"><paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3024"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-3025">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3025">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-3026">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3026">-or-</span></span>  
  
 <span data-ttu-id="d6f12-3027">此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3027">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="d6f12-3028">要确定其类型的对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3028">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="d6f12-3029">获取指定数组中对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3029">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3030">表示 <see cref="T:System.Type" /> 中相应元素的类型的 <paramref name="args" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3030">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d6f12-3031">下面的代码示例演示如何使用<xref:System.Type.GetTypeArray%2A>方法列出数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3031">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3032"><paramref name="args" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3032"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-3033">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3033">-or-</span></span> 
<span data-ttu-id="d6f12-3034"><paramref name="args" /> 的其中一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3034">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-3035">调用类初始值设定项，并且至少一个引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3035">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="d6f12-3036">要获取其基础代码的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3036">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-3037">获取指定 <see cref="T:System.Type" /> 的基础类型代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3037">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3038">如果 <see cref="F:System.TypeCode.Empty" /> 为 <paramref name="type" />，则为基础类型代码或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3038">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3039">当从<xref:System.Type>继承时, 可以通过<xref:System.Type.GetTypeCodeImpl%2A>重写方法来更改此方法的行为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3039">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3040">下面的代码示例演示如何<xref:System.TypeCode>使用枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3040">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="d6f12-3041">在`WriteObjectInfo`方法内的决策块中<xref:System.TypeCode> , 将检查<xref:System.Object>参数的, 并将相应的消息写入控制台。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3041">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3042">返回此 <see cref="T:System.Type" /> 实例的基础类型代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3042">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3043">基础类型的类型代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3043">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3044">此方法`static`提供 (在中C#) 或`Shared` (在 Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29>方法的实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3044">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="d6f12-3045">当从<xref:System.Type>继承时, 您可以重写此方法以提供您自己的<xref:System.Type.GetTypeCode%2A>实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3045">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-3046">获取与指定类标识符 (CLSID) 关联的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3046">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="d6f12-3047">要获取的类型的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3047">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-3048">获取与指定类标识符 (CLSID) 关联的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3048">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="d6f12-3049"><see langword="System.__ComObject" />，无论 CLSID 是否有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3049"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3050">当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3050">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="d6f12-3051">COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3051">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="d6f12-3052">可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3052">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="d6f12-3053">您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3053">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="d6f12-3054">从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3054">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="d6f12-3055">通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3055">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="d6f12-3056"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3056">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="d6f12-3057">有关说明, 请参阅示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3057">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="d6f12-3058">重载<xref:System.Type.GetTypeFromCLSID%28System.Guid%29>将忽略<xref:System.Type> 在`clsid`基于参数实例化对象时可能发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3058">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="d6f12-3059">请注意, 如果`clsid`在注册表中找不到, 则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3059">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3060">下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3060">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="d6f12-3061">然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3061">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="d6f12-3062">此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3062">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="d6f12-3063">所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3063">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="d6f12-3064">尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3064">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="d6f12-3065">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="d6f12-3065">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="d6f12-3066">相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3066">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="d6f12-3067">要获取的类型的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3067">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-3068"><see langword="true" /> 将引发所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3068"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="d6f12-3069">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3069">-or-</span></span> 
 <span data-ttu-id="d6f12-3070"><see langword="false" /> 将忽略所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3070"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="d6f12-3071">获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3071">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3072"><see langword="System.__ComObject" />，无论 CLSID 是否有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3072"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3073">当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3073">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="d6f12-3074">COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3074">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="d6f12-3075">可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3075">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="d6f12-3076">您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3076">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="d6f12-3077">从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3077">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="d6f12-3078">通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3078">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="d6f12-3079"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3079">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="d6f12-3080">有关说明, 请参阅示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3080">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="d6f12-3081">当指定<xref:System.OutOfMemoryException> `true`时, 将引发诸如之类的`throwOnError`异常, 但未注册的 clsid 将不会失败。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3081">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3082">下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3082">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="d6f12-3083">然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3083">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="d6f12-3084">如果在加载该类型时发生错误, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3084">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="d6f12-3085">此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3085">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="d6f12-3086">所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3086">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="d6f12-3087">尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3087">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="d6f12-3088">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="d6f12-3088">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="d6f12-3089">相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3089">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="d6f12-3090">要获取的类型的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3090">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="d6f12-3091">用于从中加载该类型的服务器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3091">The server from which to load the type.</span></span> <span data-ttu-id="d6f12-3092">如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3092">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="d6f12-3093">从指定服务器获取与指定类标识符 (CLSID) 关联的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3093">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3094"><see langword="System.__ComObject" />，无论 CLSID 是否有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3094"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3095">当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3095">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="d6f12-3096">COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3096">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="d6f12-3097">可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3097">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="d6f12-3098">您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3098">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="d6f12-3099">从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3099">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="d6f12-3100">通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3100">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="d6f12-3101"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3101">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3102">下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3102">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="d6f12-3103">然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3103">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="d6f12-3104">此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3104">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="d6f12-3105">所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3105">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="d6f12-3106">尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3106">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="d6f12-3107">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="d6f12-3107">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="d6f12-3108">相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3108">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="d6f12-3109">要获取的类型的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3109">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="d6f12-3110">用于从中加载该类型的服务器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3110">The server from which to load the type.</span></span> <span data-ttu-id="d6f12-3111">如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3111">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-3112"><see langword="true" /> 将引发所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3112"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="d6f12-3113">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3113">-or-</span></span> 
 <span data-ttu-id="d6f12-3114"><see langword="false" /> 将忽略所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3114"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="d6f12-3115">从指定服务器获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3115">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3116"><see langword="System.__ComObject" />，无论 CLSID 是否有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3116"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3117">当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3117">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="d6f12-3118">COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3118">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="d6f12-3119">可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3119">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="d6f12-3120">您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3120">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="d6f12-3121">从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3121">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="d6f12-3122">通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3122">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="d6f12-3123"><xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3123">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="d6f12-3124">当指定<xref:System.OutOfMemoryException> `true`时, 将引发诸如之类的`throwOnError`异常, 但未注册的 clsid 将不会失败。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3124">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3125">下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3125">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="d6f12-3126">然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3126">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="d6f12-3127">如果在加载该类型时发生错误, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3127">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="d6f12-3128">此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3128">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="d6f12-3129">所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3129">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="d6f12-3130">尽管方法返回对应于特定托管对象的 GUID <see cref="M:System.Activator.CreateInstance(System.Type)" />的<see cref="T:System.Type" /> 对象,但你不能使用该对象通过调用方法来创建类型实例,如<see cref="T:System.Type" />以下 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />示例所示展示.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3130">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="d6f12-3131">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="d6f12-3131">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="d6f12-3132">相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3132">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="d6f12-3133">引用类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3133">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="d6f12-3134">获取由指定类型句柄引用的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3134">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3135">如果 <see cref="T:System.RuntimeTypeHandle" /> 的 <see langword="null" /> 属性为 <see cref="P:System.RuntimeTypeHandle.Value" />，则为由指定的 <paramref name="handle" /> 引用的类型，或者为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3135">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3136">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3136">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3137">下面的示例<xref:System.Type.GetTypeFromHandle%2A>使用方法<xref:System.Type> <xref:System.RuntimeTypeHandle>从方法提供的中获取一个对象。<xref:System.Type.GetTypeHandle%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3137">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-3138">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3138">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-3139">获取与指定程序标识符 (ProgID) 关联的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3139">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="d6f12-3140">要获取的类型的 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3140">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="d6f12-3141">获取与指定程序标识符 (ProgID) 关联的类型，如果在加载 <see cref="T:System.Type" /> 时遇到错误，则返回空值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3141">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3142">如果 <paramref name="progID" /> 是注册表中的有效项，并且有与之关联的类型，则为与指定 ProgID 关联的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3142">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3143">提供此方法是为了支持 COM。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3143">This method is provided for COM support.</span></span> <span data-ttu-id="d6f12-3144">Progid 不在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3144">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3145"><paramref name="progID" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3145"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d6f12-3146">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d6f12-3147">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="d6f12-3148">要获取的类型的 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3148">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-3149"><see langword="true" /> 将引发所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3149"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="d6f12-3150">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3150">-or-</span></span> 
 <span data-ttu-id="d6f12-3151"><see langword="false" /> 将忽略所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3151"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="d6f12-3152">获取与指定程序标识符 (ProgID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3152">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3153">如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3153">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3154">提供此方法是为了支持 COM。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3154">This method is provided for COM support.</span></span> <span data-ttu-id="d6f12-3155">程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3156">下面的示例通过传递 ProgID 来检索一个类型, 并指定当 ProgID 无效时是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3156">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="d6f12-3157">然后, 该示例显示与 ProgID 相关的 ClassID 以及任何适用的异常消息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3157">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3158"><paramref name="progID" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3158"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="d6f12-3159">未注册指定的 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3159">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d6f12-3160">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3160">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d6f12-3161">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="d6f12-3162">要获取的类型的 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3162">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="d6f12-3163">用于从中加载该类型的服务器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3163">The server from which to load the type.</span></span> <span data-ttu-id="d6f12-3164">如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3164">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="d6f12-3165">从指定服务器获取与指定程序标识符 (progID) 关联的类型，如果在加载该类型时遇到错误则返回空值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3165">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3166">如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3166">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3167">提供此方法是为了支持 COM。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3167">This method is provided for COM support.</span></span> <span data-ttu-id="d6f12-3168">程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3168">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3169">下面的示例通过传递 ProgID 和服务器名称来检索类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3169">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="d6f12-3170">然后, 该示例显示与 ProgID 相关的 ClassID, 或如果 ProgID 或服务器名称无效, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3170">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3171"><paramref name="prodID" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3171"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d6f12-3172">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3172">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d6f12-3173">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3173">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="d6f12-3174">要获取的 <see cref="T:System.Type" /> 的 progID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3174">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="d6f12-3175">用于从中加载该类型的服务器。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3175">The server from which to load the type.</span></span> <span data-ttu-id="d6f12-3176">如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3176">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="d6f12-3177"><see langword="true" /> 将引发所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3177"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="d6f12-3178">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3178">-or-</span></span> 
 <span data-ttu-id="d6f12-3179"><see langword="false" /> 将忽略所发生的任何异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3179"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="d6f12-3180">从指定服务器获取与指定程序标识符 (progID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3180">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3181">如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3181">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3182">提供此方法是为了支持 COM。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3182">This method is provided for COM support.</span></span> <span data-ttu-id="d6f12-3183">程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3183">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3184">下面的示例通过传递 ProgID 和服务器名称来检索类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3184">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="d6f12-3185">然后, 该示例显示与 ProgID 相关的 ClassID, 并指定当 ProgID 或服务器名称无效时是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3185">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3186"><paramref name="progID" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3186"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="d6f12-3187">未注册指定的 progID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3187">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d6f12-3188">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d6f12-3189">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d6f12-3190">要获取类型句柄的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3190">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="d6f12-3191">获取指定对象的 <see cref="T:System.Type" /> 的句柄。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3191">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3192">指定 <see cref="T:System.Type" /> 的 <see cref="T:System.Object" /> 的句柄。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3192">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3193">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3193">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3194">下面的示例定义类`MyClass1`, 获取其实例, 并检索对象的运行时句柄。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3194">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3195"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3195"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3196">获取与 <see cref="T:System.Type" />关联的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3196">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-3197">获取与 <see cref="T:System.Type" /> 关联的 GUID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3197">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3198">GUID 与使用<xref:System.Runtime.InteropServices.GuidAttribute>特性的类型相关联。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3198">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3199">下面的示例使用公共方法`MyClass1`创建类, `Type`创建与对应`MyClass1`的对象, 并使用`GUID` `Type`类的属性<xref:System.Guid>获取结构。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3199">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3200">获取一个值，通过该值指示当前 <see cref="T:System.Type" /> 是包含还是引用另一类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3200">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="d6f12-3201">如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3201"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3202">例如, 键入 GetType ("Int32 []")。HasElementType 返回`true`, 但键入 GetType ("Int32")。HasElementType 返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3202">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="d6f12-3203">HasElementType 还返回`true` "int32 \*" 和 "int32 &"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3203">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="d6f12-3204">如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3204">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3205">下面的示例返回`true`或`false` , 具体取决于对象是数组、引用类型还是指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3205">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3206">当在派生类中重写时，实现 <see cref="P:System.Type.HasElementType" /> 属性，确定当前 <see cref="T:System.Type" /> 是否包含另一类型或对其引用；即，当前 <see cref="T:System.Type" /> 是否是数组、指针或由引用传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3206">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3207">如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3207"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3208">例如, 键入 GetType ("Int32 []")。HasElementTypeImpl 返回`true`, 但键入 GetType ("Int32")。HasElementTypeImpl 返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3208">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="d6f12-3209">HasElementTypeImpl 还返回`true` "int32 \*" 和 "int32 &"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3209">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3210">下面的示例定义类, `MyTypeDelegator`该类`HasElementTypeImpl`重写方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3210">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="d6f12-3211">主类检查`HasElementType`属性, 并显示元素类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3211">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-3212">调用当前 <see cref="T:System.Type" /> 的特定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3212">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-3213">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3213">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="d6f12-3214">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3214">-or-</span></span> 
<span data-ttu-id="d6f12-3215">空字符串 ("")，表示调用默认成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3215">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="d6f12-3216">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3216">-or-</span></span> 
<span data-ttu-id="d6f12-3217">对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3217">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="d6f12-3218">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3218">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="d6f12-3219">访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3219">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="d6f12-3220">查找类型无需指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3220">The type of lookup need not be specified.</span></span> <span data-ttu-id="d6f12-3221">如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3221">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-3222">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3222">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-3223">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3223">-or-</span></span> 
<span data-ttu-id="d6f12-3224">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3224">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="d6f12-3225">请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3225">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="d6f12-3226">对其调用指定成员的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3226">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="d6f12-3227">包含传递给要调用的成员的参数的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3227">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="d6f12-3228">使用指定的绑定约束并匹配指定的参数列表，调用指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3228">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3229">一个对象，表示被调用成员的返回值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3229">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3230">不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3230">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="d6f12-3231">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3231">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-3232">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3232">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3233">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有和受保护的成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3233">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3234">指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3234">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="d6f12-3235">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3235">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-3236">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3236">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-3237">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3237">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-3238">以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3238">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="d6f12-3239">`CreateInstance`调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3239">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="d6f12-3240">`name`将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3240">`name` is ignored.</span></span> <span data-ttu-id="d6f12-3241">与其他调用标志无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3241">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="d6f12-3242">`InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3242">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="d6f12-3243">对于`SetField` 或`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3243">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="d6f12-3244">如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3244">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="d6f12-3245">`GetField`获取字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3245">`GetField` to get the value of a field.</span></span> <span data-ttu-id="d6f12-3246">对`SetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3246">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3247">`SetField`设置字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3247">`SetField` to set the value of a field.</span></span> <span data-ttu-id="d6f12-3248">对`GetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3248">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3249">`GetProperty`获取属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3249">`GetProperty` to get a property.</span></span> <span data-ttu-id="d6f12-3250">对`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3250">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="d6f12-3251">`SetProperty`设置属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3251">`SetProperty` to set a property.</span></span> <span data-ttu-id="d6f12-3252">对`GetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3252">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="d6f12-3253">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-3254">如果以下两个条件均为 true, 则将调用方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3254">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="d6f12-3255">方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3255">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="d6f12-3256">联编程序可以将每个参数的类型转换为参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3256">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="d6f12-3257">此联编程序将查找所有匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3257">The binder will find all of the matching methods.</span></span> <span data-ttu-id="d6f12-3258">这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3258">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="d6f12-3259">方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3259">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="d6f12-3260">选择方法后, 将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3260">After the method is selected, it is invoked.</span></span> <span data-ttu-id="d6f12-3261">此时将检查可访问性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3261">Accessibility is checked at that point.</span></span> <span data-ttu-id="d6f12-3262">搜索可根据与方法关联的可访问性属性控制要搜索的方法集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3262">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="d6f12-3263"><xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3263">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="d6f12-3264">默认联编程序将选择最特定的匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3264">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="d6f12-3265">完全受信任的代码将忽略访问限制;也就是说, <xref:System.Reflection>只要代码完全受信任, 就可以访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3265">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="d6f12-3266">通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3266">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-3267">例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String`, 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3267">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="d6f12-3268">如果 F 是`String[]`, 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3268">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="d6f12-3269">这会将 F 字段初始化为这个新的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3269">which will initialize the field F to this new array.</span></span> <span data-ttu-id="d6f12-3270">你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3270">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="d6f12-3271">这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3271">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="d6f12-3272">调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3272">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="d6f12-3273">例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3273">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="d6f12-3274">DispID 调用成员比按名称查找成员的速度更快。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3274">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="d6f12-3275">在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3275">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3276">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3276">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="d6f12-3277">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="d6f12-3277">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="d6f12-3278">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3278">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3279">下面的示例使用`InvokeMember`来访问类型的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3279">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3280"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3280"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3281"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3281"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="d6f12-3282">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3282">-or-</span></span> 
 <span data-ttu-id="d6f12-3283"><paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3283"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3284">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3284">-or-</span></span> 
 <span data-ttu-id="d6f12-3285"><paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3285"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3286">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3286">-or-</span></span> 
 <span data-ttu-id="d6f12-3287"><paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3287"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="d6f12-3288">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3288">-or-</span></span> 
 <span data-ttu-id="d6f12-3289"><paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3289"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3290">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3290">-or-</span></span> 
 <span data-ttu-id="d6f12-3291"><paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3291"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3292">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3292">-or-</span></span> 
 <span data-ttu-id="d6f12-3293"><paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3293"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="d6f12-3294">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3294">-or-</span></span> 
<span data-ttu-id="d6f12-3295">对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3295">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3296">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3296">-or-</span></span> 
<span data-ttu-id="d6f12-3297">其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3297">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="d6f12-3298">指定的成员是类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3298">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="d6f12-3299">找不到此字段或属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3299">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="d6f12-3300">找不到与 <paramref name="args" /> 中的参数匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3300">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="d6f12-3301">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3301">-or-</span></span> 
<span data-ttu-id="d6f12-3302">当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3302">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="d6f12-3303">不能在 <paramref name="target" /> 上调用指定的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3303">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-3304">多个方法与绑定条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3304">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-3305">.NET Compact Framework 当前不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3305">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-3306">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3306">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="d6f12-3307">也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3307">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d6f12-3308">用于访问非公共成员, 而不考虑其授予集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3308">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="d6f12-3309">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3309">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="d6f12-3310">调用非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3310">to call unmanaged code.</span></span> <span data-ttu-id="d6f12-3311">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3311">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-3312">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3312">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="d6f12-3313">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3313">-or-</span></span> 
<span data-ttu-id="d6f12-3314">空字符串 ("")，表示调用默认成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3314">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="d6f12-3315">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3315">-or-</span></span> 
<span data-ttu-id="d6f12-3316">对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3316">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="d6f12-3317">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3317">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="d6f12-3318">访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3318">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="d6f12-3319">查找类型无需指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3319">The type of lookup need not be specified.</span></span> <span data-ttu-id="d6f12-3320">如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3320">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-3321">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3321">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-3322">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3322">-or-</span></span> 
<span data-ttu-id="d6f12-3323">要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3323">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="d6f12-3324">请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3324">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="d6f12-3325">对其调用指定成员的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3325">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="d6f12-3326">包含传递给要调用的成员的参数的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3326">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="d6f12-3327">表示要使用的全局化区域设置的对象，它对区域设置特定的转换可能是必需的，比如将数字 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3327">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="d6f12-3328">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3328">-or-</span></span> 
<span data-ttu-id="d6f12-3329">要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3329">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-3330">使用指定的绑定约束和匹配的指定参数列表及区域性来调用指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3330">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3331">一个对象，表示被调用成员的返回值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3331">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3332">尽管默认的联编程序不处理<xref:System.Globalization.CultureInfo> `culture` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`culture`的自定义联编程序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3332">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3333">不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3333">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="d6f12-3334">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3334">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-3335">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3335">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3336">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3336">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3337">指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3337">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="d6f12-3338">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3338">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-3339">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3339">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-3340">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3340">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-3341">以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3341">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="d6f12-3342">`CreateInstance`调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3342">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="d6f12-3343">`name`将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3343">`name` is ignored.</span></span> <span data-ttu-id="d6f12-3344">与其他调用标志无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3344">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="d6f12-3345">`InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3345">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="d6f12-3346">对于`SetField` 或`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3346">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="d6f12-3347">如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3347">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="d6f12-3348">`GetField`获取字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3348">`GetField` to get the value of a field.</span></span> <span data-ttu-id="d6f12-3349">对`SetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3349">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3350">`SetField`设置字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3350">`SetField` to set the value of a field.</span></span> <span data-ttu-id="d6f12-3351">对`GetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3351">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3352">`GetProperty`获取属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3352">`GetProperty` to get a property.</span></span> <span data-ttu-id="d6f12-3353">对`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3353">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="d6f12-3354">`SetProperty`设置属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3354">`SetProperty` to set a property.</span></span> <span data-ttu-id="d6f12-3355">对`GetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3355">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="d6f12-3356">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3356">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-3357">如果以下两个条件均为 true, 则将调用方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3357">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="d6f12-3358">方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3358">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="d6f12-3359">联编程序可以将每个参数的类型转换为参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3359">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="d6f12-3360">此联编程序将查找所有匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3360">The binder will find all of the matching methods.</span></span> <span data-ttu-id="d6f12-3361">这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3361">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="d6f12-3362">方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3362">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="d6f12-3363">选择方法后, 将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3363">After the method is selected, it is invoked.</span></span> <span data-ttu-id="d6f12-3364">此时将检查可访问性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3364">Accessibility is checked at that point.</span></span> <span data-ttu-id="d6f12-3365">搜索可根据与方法关联的可访问性属性控制要搜索的方法集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3365">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="d6f12-3366"><xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3366">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="d6f12-3367">默认联编程序将选择最特定的匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3367">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="d6f12-3368">完全受信任的代码将忽略访问限制;也就是说, 只要代码完全受信任, 就可以通过反射访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3368">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="d6f12-3369">通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3369">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-3370">例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String` , 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3370">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="d6f12-3371">如果 F 是`String[]`, 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3371">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="d6f12-3372">这会将 F 字段初始化为这个新的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3372">which will initialize the field F to this new array.</span></span> <span data-ttu-id="d6f12-3373">你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3373">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="d6f12-3374">这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3374">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="d6f12-3375">调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3375">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="d6f12-3376">例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3376">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="d6f12-3377">DispID 调用成员比按名称查找成员的速度更快。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3377">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="d6f12-3378">在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3378">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3379">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3379">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="d6f12-3380">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="d6f12-3380">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="d6f12-3381">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3381">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3382"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3382"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3383"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3383"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="d6f12-3384">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3384">-or-</span></span> 
 <span data-ttu-id="d6f12-3385"><paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3385"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3386">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3386">-or-</span></span> 
 <span data-ttu-id="d6f12-3387"><paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3387"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3388">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3388">-or-</span></span> 
 <span data-ttu-id="d6f12-3389"><paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3389"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="d6f12-3390">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3390">-or-</span></span> 
 <span data-ttu-id="d6f12-3391"><paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3391"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3392">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3392">-or-</span></span> 
 <span data-ttu-id="d6f12-3393"><paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3393"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3394">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3394">-or-</span></span> 
 <span data-ttu-id="d6f12-3395"><paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3395"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="d6f12-3396">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3396">-or-</span></span> 
<span data-ttu-id="d6f12-3397">对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3397">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3398">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3398">-or-</span></span> 
<span data-ttu-id="d6f12-3399">其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3399">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="d6f12-3400">指定的成员是类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3400">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="d6f12-3401">找不到此字段或属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3401">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="d6f12-3402">找不到与 <paramref name="args" /> 中的参数匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3402">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="d6f12-3403">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3403">-or-</span></span> 
<span data-ttu-id="d6f12-3404">当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3404">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="d6f12-3405">不能在 <paramref name="target" /> 上调用指定的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3405">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-3406">多个方法与绑定条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3406">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-3407">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3407">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="d6f12-3408">也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3408">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d6f12-3409">用于访问非公共成员, 而不考虑其授予集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3409">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="d6f12-3410">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3410">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="d6f12-3411">调用非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3411">to call unmanaged code.</span></span> <span data-ttu-id="d6f12-3412">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3412">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d6f12-3413">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3413">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="d6f12-3414">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3414">-or-</span></span> 
<span data-ttu-id="d6f12-3415">空字符串 ("")，表示调用默认成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3415">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="d6f12-3416">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3416">-or-</span></span> 
<span data-ttu-id="d6f12-3417">对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3417">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="d6f12-3418">枚举值的按位组合，这些值指定如何进行搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3418">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="d6f12-3419">访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3419">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="d6f12-3420">查找类型无需指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3420">The type of lookup need not be specified.</span></span> <span data-ttu-id="d6f12-3421">如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3421">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="d6f12-3422">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3422">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="d6f12-3423">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3423">-or-</span></span> 
<span data-ttu-id="d6f12-3424">要使用 <see cref="P:System.Type.DefaultBinder" /> 的空引用（在 Visual Basic 中为 Nothing）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3424">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="d6f12-3425">请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3425">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="d6f12-3426">对其调用指定成员的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3426">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="d6f12-3427">包含传递给要调用的成员的参数的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3427">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="d6f12-3428"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="args" /> 数组中的相应元素关联的特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3428">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="d6f12-3429">参数的关联的属性存储在成员的签名中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3429">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="d6f12-3430">只有在调用 COM 组件时，默认联编程序才处理此参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3430">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="d6f12-3431">表示要使用的全局化区域设置的 <see cref="T:System.Globalization.CultureInfo" /> 对象，它对区域设置特定的转换可能是必需的，比如将数字 String 转换为 Double。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3431">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="d6f12-3432">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3432">-or-</span></span> 
<span data-ttu-id="d6f12-3433">要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3433">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="d6f12-3434">包含参数名称的数组，<paramref name="args" /> 数组中的值将传递给这些参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3434">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="d6f12-3435">当在派生类中重写时，使用指定的绑定约束并匹配指定的参数列表、修饰符和区域性，调用指定成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3435">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3436">一个对象，表示被调用成员的返回值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3436">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3437">`InvokeMember`调用构造函数成员或方法成员, 获取或设置属性成员, 获取或设置数据字段成员, 或者获取或设置数组成员的元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3437">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3438">不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3438">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="d6f12-3439">调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3439">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="d6f12-3440">例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3440">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="d6f12-3441">DispID 调用成员比按名称查找成员的速度更快。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3441">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="d6f12-3442">在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3442">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="d6f12-3443">尽管默认联编程序不处理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo> ( `modifiers`和`culture`参数), 但你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`和`culture`.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3443">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="d6f12-3444">`ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3444">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="d6f12-3445">`namedParameters` 数组中的每个参数对应 `args` 数组中的元素来获取值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3445">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="d6f12-3446">如果 `args` 的长度大于 `namedParameters` 的长度，则剩余的自变量值将按顺序传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3446">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="d6f12-3447">`namedParameters`数组可用于更改输入数组中参数的顺序。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3447">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="d6f12-3448">例如`M(string a, int b)` , `args`如果给定了方法 (`M(ByVal a As String, ByVal b As Integer)`在 Visual Basic 中) 和输入数组`{ 42, "x" }`, 则当为提供数组`{ "b", "a" }`时, 输入数组可以`namedParameters`保持不变。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3448">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="d6f12-3449">以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3449">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="d6f12-3450">指定`BindingFlags.Public`在搜索中包括公共成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3450">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3451">指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3451">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="d6f12-3452">指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3452">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="d6f12-3453">以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3453">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="d6f12-3454">`BindingFlags.IgnoreCase`如果忽略, 则为`name`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3454">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="d6f12-3455">`BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3455">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="d6f12-3456">以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3456">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="d6f12-3457">`CreateInstance`调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3457">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="d6f12-3458">`name`将被忽略。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3458">`name` is ignored.</span></span> <span data-ttu-id="d6f12-3459">与其他调用标志无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3459">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="d6f12-3460">`InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3460">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="d6f12-3461">对于`SetField` 或`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3461">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="d6f12-3462">如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3462">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="d6f12-3463">`GetField`获取字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3463">`GetField` to get the value of a field.</span></span> <span data-ttu-id="d6f12-3464">对`SetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3464">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3465">`SetField`设置字段的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3465">`SetField` to set the value of a field.</span></span> <span data-ttu-id="d6f12-3466">对`GetField`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3466">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="d6f12-3467">`GetProperty`获取属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3467">`GetProperty` to get a property.</span></span> <span data-ttu-id="d6f12-3468">对`SetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3468">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="d6f12-3469">`SetProperty`设置属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3469">`SetProperty` to set a property.</span></span> <span data-ttu-id="d6f12-3470">对`GetProperty`无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3470">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="d6f12-3471">有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3471">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="d6f12-3472">如果以下两个条件均为 true, 则将调用方法:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3472">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="d6f12-3473">方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3473">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="d6f12-3474">联编程序可以将每个参数的类型转换为参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3474">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="d6f12-3475">此联编程序将查找所有匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3475">The binder will find all of the matching methods.</span></span> <span data-ttu-id="d6f12-3476">这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3476">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="d6f12-3477">方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3477">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="d6f12-3478">选择方法后, 将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3478">After the method is selected, it is invoked.</span></span> <span data-ttu-id="d6f12-3479">此时将检查可访问性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3479">Accessibility is checked at that point.</span></span> <span data-ttu-id="d6f12-3480">搜索可根据与方法关联的可访问性属性控制要搜索的方法集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3480">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="d6f12-3481"><xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3481">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="d6f12-3482">默认联编程序将选择最特定的匹配项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3482">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="d6f12-3483">`InvokeMember`可用于调用带有具有默认值的参数的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3483">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="d6f12-3484">若要绑定到这些方法, 需要<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定反射。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3484">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="d6f12-3485">对于具有默认值的参数, 您可以提供不同的值, 也<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>可以使用默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3485">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="d6f12-3486">例如, 假设有一个方法, 如 MyMethod (int x, float y = 2.0)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3486">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="d6f12-3487">若要调用此方法并只将第一个参数作为 MyMethod (4), 请传递上述绑定标志之一, 并为第一个参数和`Missing.Value`第二个参数传递两个参数, 即4。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3487">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="d6f12-3488">除非你使用`Missing.Value`, 否则不能使用`Invoke`方法省略可选参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3488">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="d6f12-3489">如果必须这样做, 请`InvokeMember`改用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3489">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="d6f12-3490">完全受信任的代码将忽略访问限制;也就是说, <xref:System.Reflection>只要代码完全受信任, 就可以访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3490">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="d6f12-3491">通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3491">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-3492">例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String`, 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3492">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="d6f12-3493">如果 F 是`String[]`, 则可以使用以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3493">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="d6f12-3494">这会将 F 字段初始化为这个新的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3494">which will initialize the field F to this new array.</span></span> <span data-ttu-id="d6f12-3495">你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3495">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="d6f12-3496">这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3496">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3497">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3497">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="d6f12-3498">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="d6f12-3498">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="d6f12-3499">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3499">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3500"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3500"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3501"><paramref name="args" /> 和 <paramref name="modifiers" /> 的长度不相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3501"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="d6f12-3502">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3502">-or-</span></span> 
 <span data-ttu-id="d6f12-3503"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3503"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="d6f12-3504">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3504">-or-</span></span> 
 <span data-ttu-id="d6f12-3505"><paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3505"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3506">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3506">-or-</span></span> 
 <span data-ttu-id="d6f12-3507"><paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3507"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3508">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3508">-or-</span></span> 
 <span data-ttu-id="d6f12-3509"><paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3509"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="d6f12-3510">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3510">-or-</span></span> 
 <span data-ttu-id="d6f12-3511"><paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3511"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3512">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3512">-or-</span></span> 
 <span data-ttu-id="d6f12-3513"><paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3513"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3514">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3514">-or-</span></span> 
 <span data-ttu-id="d6f12-3515"><paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3515"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="d6f12-3516">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3516">-or-</span></span> 
<span data-ttu-id="d6f12-3517">命名的参数数组大于参数数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3517">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="d6f12-3518">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3518">-or-</span></span> 
<span data-ttu-id="d6f12-3519">对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3519">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="d6f12-3520">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3520">-or-</span></span> 
<span data-ttu-id="d6f12-3521">其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3521">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="d6f12-3522">指定的成员是类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3522">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="d6f12-3523">找不到此字段或属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3523">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="d6f12-3524">找不到与 <paramref name="args" /> 中的参数匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3524">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="d6f12-3525">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-3525">-or-</span></span> 
<span data-ttu-id="d6f12-3526">找不到具有 <paramref name="namedParameters" /> 中提供的参数名称的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3526">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="d6f12-3527">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-3527">-or-</span></span> 
<span data-ttu-id="d6f12-3528">当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3528">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="d6f12-3529">不能在 <paramref name="target" /> 上调用指定的成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3529">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="d6f12-3530">多个方法与绑定条件匹配。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3530">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-3531">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3531">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="d6f12-3532">也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3532">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d6f12-3533">用于访问非公共成员, 而不考虑其授予集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3533">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="d6f12-3534">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3534">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="d6f12-3535">调用非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3535">to call unmanaged code.</span></span> <span data-ttu-id="d6f12-3536">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="d6f12-3536">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3537">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为抽象的并且必须被重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3537">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="d6f12-3538">如果 <see cref="T:System.Type" /> 是抽象的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3538"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3539">在<xref:System.Type.IsAbstract%2A>以下情况`true`下, 属性将返回:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3539">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="d6f12-3540">当前类型是抽象的;也就是说, 它不能进行实例化, 但只能充当派生类的基类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3540">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="d6f12-3541">在C#中, 抽象类标有[abstract](~/docs/csharp/language-reference/keywords/abstract.md)关键字;在 Visual Basic 中, 它们用[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)关键字进行标记。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3541">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="d6f12-3542">当前类型是接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3542">The current type is an interface.</span></span>  
  
 <span data-ttu-id="d6f12-3543">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3543">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3544">下面的<xref:System.Type>示例创建对象的数组, 这些对象表示以下类型: 如果指定的对象为`abstract`, 则包含类型返回`true` ; 否则返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3544">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="d6f12-3545">`AbstractClass`, 抽象类 (在`abstract` C#和`MustInherit`中标记为的类 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3545">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="d6f12-3546">`DerivedClass`, 是从`AbstractClass`继承的类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3546">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="d6f12-3547">`SingleClass`, 不可继承的类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3547">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="d6f12-3548">它在和`sealed` `NotInheritable` Visual Basic 中C#定义为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3548">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="d6f12-3549">`ITypeInfo`, 接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3549">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="d6f12-3550">`ImplementingClass`, 是实现`ITypeInfo`接口的类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3550">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="d6f12-3551">方法只为`true` `AbstractClass`、抽象类和`ITypeInfo`接口返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3551">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3552">获取一个值，该值指示是否为 <see langword="AnsiClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3552">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-3553">如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AnsiClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3553"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3554"><xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3554">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="d6f12-3555">字符串格式特性通过定义应如何解释字符串来增强互操作性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3555">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="d6f12-3556">如果当前<xref:System.Type>表示泛型类型, 则此属性适用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3556">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3557">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3557">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3558">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3558">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3559">下面的示例获取字段信息并检查`AnsiClass`特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3559">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3560">获取一个值，该值指示类型是否为数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3560">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="d6f12-3561">如果当前类型是数组，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3561"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3562"><xref:System.Type.IsArray%2A>属性`false`为类<xref:System.Array>返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3562">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="d6f12-3563">如果当前实例`false` <xref:System.Type>是表示集合类型的对象或用于处理集合的接口 (如<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>), 则此方法也会返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3563">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="d6f12-3564">若要检查数组, 请使用如下所示的代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3564">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="d6f12-3565">如果当前类型表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3565">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3566">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3566">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3567">下面的示例演示如何使用<xref:System.Type.IsArray%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3567">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3568">在派生类中重写时，实现 <see cref="P:System.Type.IsArray" /> 属性并确定 <see cref="T:System.Type" /> 是否为数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3568">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3569">如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3569"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3570"><xref:System.Array>类的实例必须返回`false` , 因为它是一个对象, 而不是一个数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3570">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3571">下面的示例重写`IsArrayImpl` `MyTypeDelegator`类中的方法, 检查变量是否为数组, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3571">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="d6f12-3572">要与当前类型进行比较的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3572">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="d6f12-3573">确定指定类型的实例是否能分配给当前类型的变量。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3573">Determines whether an instance of a specified type can be assigned to a variable of the current type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3574">如果满足下列任一条件，则为 <see langword="true" />：</span><span class="sxs-lookup"><span data-stu-id="d6f12-3574"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="d6f12-3575">
-   <paramref name="c" /> 和当前实例表示相同类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3575">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="d6f12-3576">
-   <paramref name="c" /> 是从当前实例直接或间接派生的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3576">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="d6f12-3577">如果继承于当前实例，则 <paramref name="c" /> 是从当前实例直接派生的；如果继承于从当前实例继承的接连一个或多个类，则 <paramref name="c" /> 是从当前实例间接派生的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3577"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="d6f12-3578">-   当前实例是 <paramref name="c" /> 实现的一个接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3578">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="d6f12-3579">
-   <paramref name="c" /> 是一个泛型类型参数，并且当前实例表示 <paramref name="c" /> 的约束之一。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3579">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="d6f12-3580">在以下示例中，当前实例是表示 <see cref="T:System.IO.Stream" /> 类的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3580">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="d6f12-3581"><c>GenericWithConstraint</c> 是一种泛型类型，其泛型类型参数必须为 <see cref="T:System.IO.Stream" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3581"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="d6f12-3582">将其泛型类型参数传递到 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示可以将泛型类型参数的实例分配给 <see cref="T:System.IO.Stream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3582">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="d6f12-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="d6f12-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="d6f12-3584">
-   <paramref name="c" /> 表示一个值类型，并且当前实例表示 <c>Nullable&lt;c&gt;</c>（在 Visual Basic 中为 <c>Nullable(Of c)</c>）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3584">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="d6f12-3585">如果不满足上述任何一个条件或者 <paramref name="c" /> 为 <see langword="false" />，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3585"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3586">方法可用于确定是否可将的`c`实例分配给当前类型的实例, 当你处理的对象的类型在设计时是未知的并且允许有条件时, 该方法最有用<xref:System.Type.IsAssignableFrom%2A>赋值, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3586">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="d6f12-3587">因此, 此方法可确保在运行时执行类似于下面的代码行, 而不<xref:System.InvalidCastException>会引发异常或类似的异常:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3587">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="d6f12-3588">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3588">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3589">泛型类型定义不可从封闭式构造类型赋值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3589">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="d6f12-3590">也就是说, 不能将封闭式构造类型`MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic 中) 分配给类型`MyGenericList<T>`的变量。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3590">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3591">如果参数的类型<xref:System.Reflection.Emit.TypeBuilder>为, 则结果基于要生成的类型。 `c`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3591">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="d6f12-3592">下面的代码示例使用名为`B`的生成类型对此进行演示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3592">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3593">下面的示例演示了`IsAssignableFrom`使用定义的类、整数数组和泛型的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3593">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3594">获取一个值，该值指示是否为 <see langword="AutoClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3594">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-3595">如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AutoClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3595"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3596"><xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3596">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="d6f12-3597">字符串格式特性通过定义应如何解释字符串来增强互操作性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3597">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="d6f12-3598">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3598">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3599">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3599">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3600">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3600">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3601">获取指示当前类型的字段是否由公共语言运行时自动放置的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3601">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="d6f12-3602">如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3602"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3603">提供此属性是为了方便。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3603">This property is provided as a convenience.</span></span> <span data-ttu-id="d6f12-3604">或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>已设置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3604">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="d6f12-3605"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3605">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="d6f12-3606">对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>类型时指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3606">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="d6f12-3607">在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以使运行时确定对类进行布局的适当方式。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3607">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3608">不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3608">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="d6f12-3609">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3609">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3610">例如, 如果当前<xref:System.Type>表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由`MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3610">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="d6f12-3611">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3612">下面的示例创建类型的实例并显示<xref:System.Type.IsAutoLayout%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3612">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="d6f12-3613">元数据和自描述组件</span><span class="sxs-lookup"><span data-stu-id="d6f12-3613">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3614">获取一个值，该值指示 <see cref="T:System.Type" /> 是否由引用传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3614">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="d6f12-3615">如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3615"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3616">若要获取实际类型, 请取消引用通过引用传递的类型, 然后对该类型<xref:System.Type.GetElementType%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3616">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3617">下面的示例演示如何使用`IsByRef`属性来检查指定类型是否由引用传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3617">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="d6f12-3618">该示例定义了类`MyTypeDelegator`, 该类会`HasElementTypeImpl`重写方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3618">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="d6f12-3619">主类检查`HasElementType`属性, 并显示元素类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3619">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3620">在派生类中重写时，实现 <see cref="P:System.Type.IsByRef" /> 属性并确定<see cref="T:System.Type" /> 是否通过引用传递。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3620">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3621">如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3621"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3622">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个类或委托；即，不是值类型或接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3622">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="d6f12-3623">如果 <see cref="T:System.Type" /> 是类，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3623"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3624">此属性返回`true`类和委托的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3624">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="d6f12-3625">它会`false`返回值类型 (对于结构和枚举), 即使它们已装箱也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3625">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="d6f12-3626">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`true`。如果当前<xref:System.Type>表示构造泛型类型, 则当泛型类型定义`true`是类定义时, 此属性将返回; 也就是说, 它不定义接口或值类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3626">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3627">此属性为`true` `Type`表示<xref:System.Enum> 和<xref:System.ValueType>类的实例返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3627">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="d6f12-3628">这两个类分别是枚举和值类型的基类型, 但它们不是枚举或值类型本身。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3628">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="d6f12-3629">有关详细信息, 请参阅<xref:System.Type.IsValueType%2A>和<xref:System.Type.IsEnum%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3629">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="d6f12-3630"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>枚举值将类型声明分为类或接口。但是, 类和值类型都是用<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>特性标记的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3630">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="d6f12-3631">如果检索类型属性的值, 并使用<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>该值来确定类型是否是类而不是值类型, 则还必须<xref:System.Type.IsValueType%2A>调用属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3631">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="d6f12-3632"><xref:System.Reflection.TypeAttributes>枚举的示例包含附加信息以及 anexample。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3632">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="d6f12-3633">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3633">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3634">下面的示例创建一个类型的实例, 并指示该类型是否为类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3634">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3635">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3635">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="d6f12-3636">如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3636"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3637">此方法对于`false` COM 接口返回, 因为它们不是对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3637">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="d6f12-3638">COM 接口可由 Microsoft .NET Framework 对象实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3638">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="d6f12-3639">还可以通过使用`Type` [tlbimp.exe (类型库导入程序)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具加载 com 类并获取该 com 类的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3639">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="d6f12-3640">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3640">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3641">例如, 如果<xref:System.Type>当前表示`MyGenericType<int`> (`MyGenericType(Of Integer)` Visual Basic), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3641">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3642">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3643">当在派生类中重写时，实现 <see cref="P:System.Type.IsCOMObject" /> 属性并确定 <see cref="T:System.Type" /> 是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3643">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3644">如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3644"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3645">此方法对于`false` COM 接口返回, 因为它们不是对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3645">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="d6f12-3646">COM 接口可由 Microsoft .NET Framework 对象实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3646">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3647">获取指示此对象是否表示构造的泛型类型的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3647">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="d6f12-3648">你可以创建构造型泛型类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3648">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="d6f12-3649">如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3649"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3650">构造的泛型类型已为其所有泛型类型参数提供显式类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3650">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="d6f12-3651">它也称为封闭式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3651">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="d6f12-3652">当此属性为`true`时, 可以创建当前类型的实例; 如果是`false`, 则不能。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3652">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3653">获取一个值，通过该值指示 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3653">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="d6f12-3654">如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3654"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3655">上下文会截获对类成员的调用, 并强制实施应用于类的策略, 如同步。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3655">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="d6f12-3656">有关远程处理上下文的更多详细信息<xref:System.Runtime.Remoting.Contexts.Context>, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3656">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="d6f12-3657">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3657">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3658">下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3658">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="d6f12-3659">它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3659">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3660">实现 <see cref="P:System.Type.IsContextful" /> 属性并确定 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3660">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3661">如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3661"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3662">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3662">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="d6f12-3663">上下文会截获对类成员的调用, 并强制实施应用于类的策略, 如同步。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3663">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3664">下面的示例演示`IsContextfulImpl`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3664">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3665">获取一个值，该值指示当前的 <see cref="T:System.Type" /> 是否表示枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3665">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="d6f12-3666">如果当前 <see langword="true" /> 表示枚举，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3666"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3667">此属性为`true`枚举返回, 但不<xref:System.Enum>返回类型本身。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3667">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="d6f12-3668">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3668">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3669">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3669">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3670">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3670">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3671">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3671">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3672">下面的示例演示如何使用`IsEnum`属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3672">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d6f12-3673">要测试的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3673">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="d6f12-3674">返回一个值，该值指示当前的枚举类型中是否存在指定的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3674">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3675">如果指定的值是当前枚举类型的成员，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3675"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-3676">当前类型不是一个枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3676">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-3677"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3677"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-3678"><paramref name="value" /> 类型不能为枚举的基础类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3678"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d6f12-3679">要测试是否与当前类型等效的 COM 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3679">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="d6f12-3680">确定两个 COM 类型是否具有相同的标识，以及是否符合类型等效的条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3680">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3681">如果 COM 类型等效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3681"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d6f12-3682">如果一个类型位于为执行加载的程序集中，而另一个类型位于已加载到仅限反射上下文的程序集中，则此方法也返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3682">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3683">从开始, 公共语言运行时支持直接将 com 类型的类型信息嵌入到托管程序集中, 而不需要托管程序集从互操作获取 com 类型的类型信息[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]程序.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3683">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="d6f12-3684">由于嵌入式类型信息仅包含托管程序集实际使用的类型和成员，因此两个托管程序集可能具有相同 COM 类型的不同视图。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3684">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="d6f12-3685">每个托管程序集都有不同的 <xref:System.Type> 对象来表示其 COM 类型视图。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3685">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="d6f12-3686">公共语言运行时支持接口、结构、枚举和委托等不同视图之间的类型等效性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3686">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="d6f12-3687">类型等效性意味着从一个托管程序集传递到另一个托管程序集的 COM 对象可以转换为接收程序集中适当的托管类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3687">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="d6f12-3688"><xref:System.Type.IsEquivalentTo%2A>方法使程序集能够确定从另一个程序集获取的 com 对象与第一个程序集自己的嵌入互操作类型之一具有相同的 com 标识, 因此可以强制转换为该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3688">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="d6f12-3689">有关详细信息, 请参阅[类型等效性和嵌入的互操作类型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3689">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3690">获取指示当前类型的字段是否放置在显式指定的偏移量处的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3690">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="d6f12-3691">如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3691"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3692">提供此属性是为了方便。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3692">This property is provided as a convenience.</span></span> <span data-ttu-id="d6f12-3693">或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>已设置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3693">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="d6f12-3694"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3694">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="d6f12-3695">对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>类型时指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3695">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="d6f12-3696">在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以指定显式指定字段开始的偏移量。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3696">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3697">不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3697">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="d6f12-3698">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3698">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3699">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3699">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3700">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3700">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3701">下面的示例创建一个类型的实例, 并显示其<xref:System.Type.IsExplicitLayout%2A>属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3701">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="d6f12-3702">它使用`MySystemTime`类, 该类也在的代码<xref:System.Runtime.InteropServices.StructLayoutAttribute>示例中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3702">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="d6f12-3703">元数据和自描述组件</span><span class="sxs-lookup"><span data-stu-id="d6f12-3703">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3704">获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示泛型类型或方法的定义中的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3704">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="d6f12-3705">如果 <see cref="T:System.Type" /> 对象表示泛型类型定义或泛型方法定义的类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3705"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3706"><xref:System.Type>可以通过调用<xref:System.Type.GetGenericArguments%2A>表示<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>泛型类型定义的<xref:System.Type>对象的方法<xref:System.Reflection.MethodInfo>或表示泛型方法的对象的方法来获取表示泛型类型参数的对象。定义.</span><span class="sxs-lookup"><span data-stu-id="d6f12-3706"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="d6f12-3707">对于泛型类型或方法定义, <xref:System.Type.IsGenericParameter%2A>属性为所得数组的每个元素返回。 `true`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3707">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="d6f12-3708">对于封闭式构造类型或方法, <xref:System.Type.IsGenericParameter%2A>属性为该<xref:System.Type.GetGenericArguments%2A>方法`false`返回的数组的每个元素返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3708">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="d6f12-3709">对于开放构造的类型或方法, 数组的某些元素可能是特定类型, 而其他元素可能为类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3709">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="d6f12-3710"><xref:System.Type.IsGenericParameter%2A>为`false`类型参数和`true`类型参数返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3710"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="d6f12-3711"><xref:System.Type.ContainsGenericParameters%2A>属性的代码示例演示了混合类型和类型参数的泛型类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3711">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="d6f12-3712">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3712">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3713">下面的示例使用<xref:System.Type.IsGenericParameter%2A>属性测试泛型类型中的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3713">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-3714">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3714">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-3715">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3715">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3716">获取一个值，该值指示当前类型是否是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3716">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="d6f12-3717"><see langword="true" />如果当前类型是泛型类型, 则为; 否则为。否则为<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3717"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3718">使用属性来确定<xref:System.Type>对象是否表示泛型类型。 <xref:System.Type.IsGenericType%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3718">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="d6f12-3719">使用属性可确定<xref:System.Type>对象表示开放构造类型还是封闭式构造类型。 <xref:System.Type.ContainsGenericParameters%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3719">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3720">如果<xref:System.Type.IsGenericType%2A>直接类型`false`不是泛型, 则属性返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3720">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="d6f12-3721">例如, 其元素属于类型`A<int>` (`A(Of Integer)`在 Visual Basic 中) 的数组本身不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3721">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="d6f12-3722">下表总结了泛型反射中使用的常用术语的固定条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3722">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="d6f12-3723">术语</span><span class="sxs-lookup"><span data-stu-id="d6f12-3723">Term</span></span>|<span data-ttu-id="d6f12-3724">固定条件</span><span class="sxs-lookup"><span data-stu-id="d6f12-3724">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="d6f12-3725">Generic Type Definition — 泛型类型定义</span><span class="sxs-lookup"><span data-stu-id="d6f12-3725">generic type definition</span></span>|<span data-ttu-id="d6f12-3726"><xref:System.Type.IsGenericTypeDefinition%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3726">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3727">定义泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3727">Defines a generic type.</span></span> <span data-ttu-id="d6f12-3728">构造类型是通过<xref:System.Type.MakeGenericType%2A> <xref:System.Type>对表示泛型类型定义并指定类型参数数组的对象调用方法创建的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3728">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="d6f12-3729"><xref:System.Type.MakeGenericType%2A>只能对泛型类型定义调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3729"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="d6f12-3730">任何泛型类型定义都是泛型类型 ( <xref:System.Type.IsGenericType%2A>属性为`true`), 但反之不成立。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3730">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="d6f12-3731">Generic Type — 泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3731">generic type</span></span>|<span data-ttu-id="d6f12-3732"><xref:System.Type.IsGenericType%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3732">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3733">可以是泛型类型定义、开放式构造类型或封闭式构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3733">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="d6f12-3734">请注意, 其元素类型为泛型的数组类型本身不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3734">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="d6f12-3735">表示指向泛型类型的指针<xref:System.Type>的对象也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3735">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="d6f12-3736">开放式构造类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3736">open constructed type</span></span>|<span data-ttu-id="d6f12-3737"><xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3737">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3738">例如, 具有未分配的类型参数的泛型类型、嵌套在泛型类型定义中的类型或开放构造类型中的泛型类型, 或者具有<xref:System.Type.ContainsGenericParameters%2A> `true`属性所属的类型参数的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3738">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3739">不能创建开放式构造类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3739">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="d6f12-3740">请注意, 并非所有开放式构造类型都是泛型的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3740">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="d6f12-3741">例如, 其元素类型为泛型类型定义的数组不是泛型类型, 而指向开放式构造类型的指针不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3741">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="d6f12-3742">封闭式构造类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3742">closed constructed type</span></span>|<span data-ttu-id="d6f12-3743"><xref:System.Type.ContainsGenericParameters%2A> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3743">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="d6f12-3744">递归检查时, 类型没有未分配的泛型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3744">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="d6f12-3745">Generic Type Parameter — 泛型类型参数</span><span class="sxs-lookup"><span data-stu-id="d6f12-3745">generic type parameter</span></span>|<span data-ttu-id="d6f12-3746"><xref:System.Type.IsGenericParameter%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3746">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3747"><xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3747">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3748">在泛型类型定义中, 将在稍后赋值的类型的占位符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3748">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="d6f12-3749">Generic Type Argument — 泛型类型参数</span><span class="sxs-lookup"><span data-stu-id="d6f12-3749">generic type argument</span></span>|<span data-ttu-id="d6f12-3750">可以是任何类型, 包括泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3750">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="d6f12-3751">类型参数指定为在创建构造的<xref:System.Type>泛型类型时传递<xref:System.Type.MakeGenericType%2A>给方法的对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3751">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="d6f12-3752">如果要创建结果类型的实例, 则<xref:System.Type.ContainsGenericParameters%2A>该属性`false`必须为所有类型自变量。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3752">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="d6f12-3753">下面的代码示例和表说明了其中一些术语和固定条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3753">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="d6f12-3754">`Derived`类特别感兴趣, 因为其基类型是一个构造类型, 该类型在其类型参数列表中混合了类型和类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3754">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="d6f12-3755">下表显示在类`Base`、 `Derived`和`G`上使用和生成的示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3755">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="d6f12-3756">当C++和C#代码相同时, 只显示一个条目。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3756">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="d6f12-3757">示例</span><span class="sxs-lookup"><span data-stu-id="d6f12-3757">Example</span></span>|<span data-ttu-id="d6f12-3758">固定协定</span><span class="sxs-lookup"><span data-stu-id="d6f12-3758">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="d6f12-3759">对于此类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3759">For this type:</span></span><br /><br /> <span data-ttu-id="d6f12-3760"><xref:System.Type.IsGenericType%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3761"><xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3762"><xref:System.Type.ContainsGenericParameters%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3762"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="d6f12-3763">对于此类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3763">For this type:</span></span><br /><br /> <span data-ttu-id="d6f12-3764"><xref:System.Type.IsGenericType%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3764"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3765"><xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3765"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="d6f12-3766"><xref:System.Type.ContainsGenericParameters%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3766"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="d6f12-3767">对于变量`d`类型:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3767">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="d6f12-3768"><xref:System.Type.IsGenericType%2A>为`false` , `d`因为是一个数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3768"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="d6f12-3769"><xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3769"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="d6f12-3770"><xref:System.Type.ContainsGenericParameters%2A> 为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3770"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="d6f12-3771">`T`、 `U`和`V` (显示在任何位置)</span><span class="sxs-lookup"><span data-stu-id="d6f12-3771">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="d6f12-3772"><xref:System.Type.IsGenericParameter%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3772"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3773"><xref:System.Type.IsGenericType%2A>是`false`因为没有办法将类型形参约束为泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3773"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="d6f12-3774"><xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3774"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="d6f12-3775"><xref:System.Type.ContainsGenericParameters%2A>是`true`因为`T`、 `U`和是本身的泛型类型参数。`V`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3775"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="d6f12-3776">这并不意味着有关稍后分配给它们的类型参数的任何信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3776">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="d6f12-3777">字段的类型`F`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3777">The type of field `F`</span></span>|<span data-ttu-id="d6f12-3778"><xref:System.Type.IsGenericType%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="d6f12-3779"><xref:System.Type.IsGenericTypeDefinition%2A>是`false`因为类型已分配给的`G`类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="d6f12-3780">请注意, 这等效于调用<xref:System.Type.MakeGenericType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3780">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="d6f12-3781"><xref:System.Type.ContainsGenericParameters%2A>是`true`因为字段`F`的类型具有一个类型参数, 该类型参数是一个开放式构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3781"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="d6f12-3782">构造类型是开放式的, 因为其类型参数 ( `Base`即) 为泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3782">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="d6f12-3783">这说明了<xref:System.Type.IsGenericType%2A>属性的递归特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3783">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="d6f12-3784">嵌套类`Nested`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3784">The nested class `Nested`</span></span>|<span data-ttu-id="d6f12-3785"><xref:System.Type.IsGenericType%2A>为`true`, 即使`Nested`类没有自己的泛型类型参数, 因为它嵌套在泛型类型中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3785"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="d6f12-3786"><xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3786"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="d6f12-3787">也就是说, 您可以调用<xref:System.Type.MakeGenericType%2A>方法并提供封闭`Derived`类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3787">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="d6f12-3788"><xref:System.Type.ContainsGenericParameters%2A>是`true`因为封闭`Derived`类型具有泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3788"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="d6f12-3789">这说明了<xref:System.Type.ContainsGenericParameters%2A>属性的递归特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3789">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3790">下面的代码示例显示了 "备注" <xref:System.Type.IsGenericType%2A>部分中<xref:System.Type.IsGenericParameter%2A>描述的<xref:System.Type.ContainsGenericParameters%2A>类型的、 <xref:System.Type.IsGenericTypeDefinition%2A>、和属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3790">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="d6f12-3791">有关属性值的说明, 请参阅 "备注" 中附带的表。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3791">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-3792">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3792">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-3793">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3793">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3794">获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3794">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="d6f12-3795">如果此 <see langword="true" /> 对象表示泛型类型定义，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3795"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3796">泛型类型定义是可以从中构造其他类型的模板。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3796">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="d6f12-3797">例如, 从泛型类型定义`G<T>` (用C#语法表示),`G(Of Integer)` `G<int>` <xref:System.Type.MakeGenericType%2A>在 Visual Basic 或`generic <typename T> ref class G`中C++), 可以通过调用方法和包含的泛型参数列表 (在 Visual Basic 中) 构造和实例化类型。 `G(Of T)` <xref:System.Int32>键入。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3797">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="d6f12-3798">给定表示此构造类型的<xref:System.Type.GetGenericTypeDefinition%2A> 对象后,方法将再次获取该泛型类型定义。<xref:System.Type></span><span class="sxs-lookup"><span data-stu-id="d6f12-3798">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="d6f12-3799"><xref:System.Type.IsGenericTypeDefinition%2A>使用属性可确定是否可以从当前类型创建新类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3799">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="d6f12-3800">如果属性返回`true`, 则可以调用方法来创建新的泛型类型。<xref:System.Type.MakeGenericType%2A> <xref:System.Type.IsGenericTypeDefinition%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3800">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="d6f12-3801">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3801">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3802">下面的示例显示有关类型的信息, 包括该类型是否为泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3802">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="d6f12-3803">为构造类型、泛型类型定义和普通类型显示信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3803">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-3804">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3804">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-3805">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-3805">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3806">获取一个值，该值指示 <see cref="T:System.Type" /> 是否应用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性，如果应用了该属性，则表示它是从 COM 类型库导入的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3806">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="d6f12-3807">如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，则为 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3807"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3808">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3808">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3809">例如, 如果当前<xref:System.Type>表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由`MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="d6f12-3809">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="d6f12-3810">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3810">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d6f12-3811">要与当前类型进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3811">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="d6f12-3812">确定指定的对象是否是当前 <see cref="T:System.Type" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3812">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3813">如果满足下列任一条件，则为 <see langword="true" />：当前 <see langword="Type" /> 位于由 <paramref name="o" /> 表示的对象的继承层次结构中；当前 <see langword="Type" /> 是 <paramref name="o" /> 实现的接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3813"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="d6f12-3814">如果不属于其中任一种情况，<paramref name="o" /> 为 <see langword="null" />，或者当前 <see langword="Type" /> 为开放式泛型类型（即 <see cref="P:System.Type.ContainsGenericParameters" /> 返回 <see langword="true" />），则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3814"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3815">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3815">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3816">构造类型不是其泛型类型定义的实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3816">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="d6f12-3817">也就是说, `MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic) 不是的`MyGenericList<T>`实例 (`MyGenericList(Of T)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3817">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3818">下面的示例演示 `IsInstanceOfType` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3818">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3819">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个接口；即，不是类或值类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3819">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="d6f12-3820">如果 <see langword="true" /> 是接口，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3820"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3821">将<xref:System.Reflection.TypeAttributes.ClassSemanticsMask>类型声明与类、接口或值类型区分开来。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3821">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="d6f12-3822">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3822">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3823">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3823">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3824">下面的示例创建一个接口, 检查接口类型, 并指示类`IsInterface`是否设置了属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3824">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3825">获取指示当前类型的字段是否按顺序（定义顺序或发送到元数据的顺序）放置的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3825">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="d6f12-3826">如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3826"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3827">提供此属性是为了方便。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3827">This property is provided as a convenience.</span></span> <span data-ttu-id="d6f12-3828">或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>已设置。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3828">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="d6f12-3829"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d6f12-3829">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="d6f12-3830">对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>类型时指定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3830">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="d6f12-3831">在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以指定布局是连续的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3831">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3832">不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3832">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="d6f12-3833">有关详细信息, 请参阅公共语言基础结构 (CLI) 文档规范的9.1.2 部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3833">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="d6f12-3834">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3834">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="d6f12-3835">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3835">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-3836">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3836">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-3837">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3837">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3838">下面的示例创建类的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>一个实例, 该类的枚举值<xref:System.Runtime.InteropServices.StructLayoutAttribute>已<xref:System.Type.IsLayoutSequential%2A>设置, 并检查属性, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3838">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="d6f12-3839">元数据和自描述组件</span><span class="sxs-lookup"><span data-stu-id="d6f12-3839">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3840">获取一个值，该值指示 <see cref="T:System.Type" /> 是否按引用进行封送。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3840">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="d6f12-3841">如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3841"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d6f12-3842">下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3842">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="d6f12-3843">它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3843">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3844">实现 <see cref="P:System.Type.IsMarshalByRef" /> 属性并确定 <see cref="T:System.Type" /> 是否按引用来进行封送。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3844">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3845">如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3845"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3846">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3846">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3847">下面的示例确定给定类型是否按引用进行封送并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3847">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3848">获取一个指示当前 <see cref="T:System.Type" /> 对象是否表示其定义嵌套在另一个类型的定义之内的类型的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3848">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="d6f12-3849">如果 <see langword="true" /> 嵌套在另一个类型内，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3849"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3850">属性为所有`true`嵌套类型返回, 而不考虑可见性。 <xref:System.Type.IsNested%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3850">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="d6f12-3851">若要同时测试嵌套和可见性, 请使用相关的属性<xref:System.Type.IsNestedAssembly%2A> <xref:System.Type.IsNestedFamANDAssem%2A>、 <xref:System.Type.IsNestedPrivate%2A> <xref:System.Type.IsNestedFamily%2A> <xref:System.Type.IsNestedFamORAssem%2A>、、、或<xref:System.Type.IsNestedPublic%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3851">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3852"><xref:System.Reflection.TypeAttributes.VisibilityMask>枚举成员选择类型的可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3852">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3853">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3853">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3854">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3854">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3855">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的程序集内可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3855">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="d6f12-3856">如果 <see langword="true" /> 是嵌套的并且仅在它自己的程序集中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3856"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3857">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3859">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3859">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3860">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3860">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3861">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对同时属于自己家族和自己程序集的类可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3861">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="d6f12-3862">如果 <see cref="T:System.Type" /> 是嵌套的并且只对同时属于它自己的家族和它自己的程序集的类可见，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3862"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3863">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3863">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-3865">C#和 Visual Basic 语言不包括允许您定义嵌套类型的语义, 此嵌套类型仅在其自己的程序集中受保护的类型可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3865">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="d6f12-3866">`protected internal`Visual Basic 中C#的`Protected Friend`可见性和可见性定义了对受保护类型和同一程序集中的类型可见的嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3866">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="d6f12-3867">对象的系列定义为与其子类型相同<xref:System.Type>的所有对象。 <xref:System.Type></span><span class="sxs-lookup"><span data-stu-id="d6f12-3867">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3868">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3868">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3869">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3869">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3870">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的家族内可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3870">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="d6f12-3871">如果 <see langword="true" /> 是嵌套的并且仅在它自己的家族中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3871"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3872">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3872">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="d6f12-3874">对象的系列定义为完全相同<xref:System.Type>的所有对象及其子类型。 <xref:System.Type></span><span class="sxs-lookup"><span data-stu-id="d6f12-3874">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3875">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3875">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3876">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3876">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3877">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3877">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="d6f12-3878">如果 <see langword="true" /> 是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3878"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3879">`protected internal`如果类型的可见性`Protected Friend`在 Visual Basic 中C# , <xref:System.Type.IsNestedFamORAssem%2A>则属性返回`true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3879">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="d6f12-3880">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3880">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="d6f12-3882">对象的系列定义为完全相同<xref:System.Type>的所有对象及其子类型。 <xref:System.Type></span><span class="sxs-lookup"><span data-stu-id="d6f12-3882">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3883">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3883">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3884">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3884">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3885">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并声明为私有。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3885">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="d6f12-3886">如果 <see langword="true" /> 是嵌套的并声明为私有，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3886"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3887">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3887">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3889">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3890">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3891">获取一个值，通过该值指示类是否是嵌套的并且声明为公共的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3891">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="d6f12-3892">如果类是嵌套的并且声明为公共的，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3892"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3893">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3893">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3895">下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3895">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="d6f12-3896">然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3896">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3897">获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3897">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="d6f12-3898">如果 <see langword="true" /> 未声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3898"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3899">不要将此属性与嵌套类型一起使用;请改用<xref:System.Type.IsNestedPublic%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3899">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="d6f12-3900">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3900">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3901">此示例使用`IsNotPublic`属性获取类型的可见性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3901">This example uses the `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="d6f12-3902">下面的代码示例演示了为何不能`IsPublic`将`IsNotPublic`和用于嵌套类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3902">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="d6f12-3903">对于嵌套类, `IsPublic`忽略和`IsNotPublic`的结果, 并`IsNestedPublic`只注意和`IsNestedPrivate`的结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3903">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="d6f12-3904">此代码片段的反射输出如下所示:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3904">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="d6f12-3905">类</span><span class="sxs-lookup"><span data-stu-id="d6f12-3905">Class</span></span>|<span data-ttu-id="d6f12-3906">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="d6f12-3906">IsNotPublic</span></span>|<span data-ttu-id="d6f12-3907">IsPublic</span><span class="sxs-lookup"><span data-stu-id="d6f12-3907">IsPublic</span></span>|<span data-ttu-id="d6f12-3908">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="d6f12-3908">IsNestedPublic</span></span>|<span data-ttu-id="d6f12-3909">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="d6f12-3909">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="d6f12-3910">包含当前请求的 URL 的</span><span class="sxs-lookup"><span data-stu-id="d6f12-3910">A</span></span>|<span data-ttu-id="d6f12-3911">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3911">FALSE</span></span>|<span data-ttu-id="d6f12-3912">true</span><span class="sxs-lookup"><span data-stu-id="d6f12-3912">TRUE</span></span>|<span data-ttu-id="d6f12-3913">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3913">FALSE</span></span>|<span data-ttu-id="d6f12-3914">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3914">FALSE</span></span>|  
|<span data-ttu-id="d6f12-3915">B</span><span class="sxs-lookup"><span data-stu-id="d6f12-3915">B</span></span>|<span data-ttu-id="d6f12-3916">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3916">FALSE</span></span>|<span data-ttu-id="d6f12-3917">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3917">FALSE</span></span>|<span data-ttu-id="d6f12-3918">true</span><span class="sxs-lookup"><span data-stu-id="d6f12-3918">TRUE</span></span>|<span data-ttu-id="d6f12-3919">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3919">FALSE</span></span>|  
|<span data-ttu-id="d6f12-3920">C</span><span class="sxs-lookup"><span data-stu-id="d6f12-3920">C</span></span>|<span data-ttu-id="d6f12-3921">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3921">FALSE</span></span>|<span data-ttu-id="d6f12-3922">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3922">FALSE</span></span>|<span data-ttu-id="d6f12-3923">false</span><span class="sxs-lookup"><span data-stu-id="d6f12-3923">FALSE</span></span>|<span data-ttu-id="d6f12-3924">true</span><span class="sxs-lookup"><span data-stu-id="d6f12-3924">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3925">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3925">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="d6f12-3926">如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3926"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3927">如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3927">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="d6f12-3928">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3928">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3929">下面的示例演示`IsPointer`属性的用法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3929">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3930">在派生类中重写时，实现 <see cref="P:System.Type.IsPointer" /> 属性并确定 <see cref="T:System.Type" /> 是否为指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3930">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3931">如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3931"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3932">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3932">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="d6f12-3933">如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3933"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3934">基元类型<xref:System.Boolean>为、 <xref:System.Int16> <xref:System.UInt16> 、<xref:System.Int64>、、、 、<xref:System.UInt32>、 、、<xref:System.UInt64>、 、、<xref:System.IntPtr> <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UIntPtr> <xref:System.Char><xref:System.Double>、和<xref:System.Single>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3934">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="d6f12-3935">如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3935">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3936">下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3936">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="d6f12-3937">它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3937">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-3938">在派生类中重写时，实现 <see cref="P:System.Type.IsPrimitive" /> 属性并确定 <see cref="T:System.Type" /> 是否为基元类型之一。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3938">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="d6f12-3939">如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3939"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3940">基元<xref:System.Boolean>类型为<xref:System.Int16> 、<xref:System.Int32> 、、、<xref:System.Single>、、 、、<xref:System.UInt32>、、和。 <xref:System.Int64> <xref:System.UInt64> <xref:System.UInt16> <xref:System.Byte> <xref:System.SByte> <xref:System.Char> <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="d6f12-3940">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3941">下面的示例确定给定的类型是否为基元类型并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3941">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3942">获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3942">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="d6f12-3943">如果 <see langword="true" /> 声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3943"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3944">不要将与嵌套类型一起使用;改<xref:System.Type.IsNestedPublic%2A>为使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3944">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="d6f12-3945">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性返回`true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3945">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="d6f12-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3947">下面的示例创建一个实例`MyTestClass`, 检查`IsPublic`属性, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3947">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="d6f12-3948">对于嵌套类, `IsPublic`忽略和`IsNotPublic`的结果, 并<xref:System.Type.IsNestedPublic%2A>只注意和<xref:System.Type.IsNestedPrivate%2A>的结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3948">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3949">获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为密封的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3949">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="d6f12-3950">如果 <see langword="true" /> 被声明为密封的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3950"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3951">如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`true`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3951">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-3952">下面的示例创建`sealed`类的实例, 检查`IsSealed`属性, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3952">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3953">获取一个值，该值指示当前的类型在当前信任级别上是安全关键的还是安全可靠关键的，并因此可以执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3953">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="d6f12-3954">如果当前类型在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3954"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3955"><xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3955">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d6f12-3956">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3956">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="d6f12-3957">安全级别</span><span class="sxs-lookup"><span data-stu-id="d6f12-3957">Security level</span></span>|<span data-ttu-id="d6f12-3958">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d6f12-3958">IsSecurityCritical</span></span>|<span data-ttu-id="d6f12-3959">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d6f12-3959">IsSecuritySafeCritical</span></span>|<span data-ttu-id="d6f12-3960">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="d6f12-3960">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="d6f12-3961">严重</span><span class="sxs-lookup"><span data-stu-id="d6f12-3961">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="d6f12-3962">安全关键</span><span class="sxs-lookup"><span data-stu-id="d6f12-3962">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="d6f12-3963">透明</span><span class="sxs-lookup"><span data-stu-id="d6f12-3963">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="d6f12-3964">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3964">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d6f12-3965">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3965">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d6f12-3966">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3966">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d6f12-3967">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3967">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d6f12-3968">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3968">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d6f12-3969">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3969">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d6f12-3970">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3970">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d6f12-3971">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3971">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d6f12-3972">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3972">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="d6f12-3973">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="d6f12-3973">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="d6f12-3974">.NET Framework 中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="d6f12-3974">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3975">获取一个值，该值指示当前类型在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3975">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="d6f12-3976">如果当前类型在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3976"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3977"><xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-3977">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d6f12-3978">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="d6f12-3978">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="d6f12-3979">安全级别</span><span class="sxs-lookup"><span data-stu-id="d6f12-3979">Security level</span></span>|<span data-ttu-id="d6f12-3980">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d6f12-3980">IsSecurityCritical</span></span>|<span data-ttu-id="d6f12-3981">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d6f12-3981">IsSecuritySafeCritical</span></span>|<span data-ttu-id="d6f12-3982">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="d6f12-3982">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="d6f12-3983">严重</span><span class="sxs-lookup"><span data-stu-id="d6f12-3983">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="d6f12-3984">安全关键</span><span class="sxs-lookup"><span data-stu-id="d6f12-3984">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="d6f12-3985">透明</span><span class="sxs-lookup"><span data-stu-id="d6f12-3985">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="d6f12-3986">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3986">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d6f12-3987">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3987">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d6f12-3988">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3988">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d6f12-3989">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3989">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d6f12-3990">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3990">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d6f12-3991">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3991">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d6f12-3992">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3992">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d6f12-3993">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3993">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d6f12-3994">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3994">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="d6f12-3995">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="d6f12-3995">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="d6f12-3996">.NET Framework 中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="d6f12-3996">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-3997">获取一个值，该值指示当前类型在当前信任级别上是否是透明的而无法执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3997">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="d6f12-3998">如果该类型在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3998"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-3999">如果此属性返回`true`, 则<xref:System.Type.IsSecurityCritical%2A>和<xref:System.Type.IsSecuritySafeCritical%2A>属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-3999">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="d6f12-4000"><xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-4000">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d6f12-4001">使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4001">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d6f12-4002">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4002">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d6f12-4003">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4003">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d6f12-4004">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4004">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d6f12-4005">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4005">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d6f12-4006">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4006">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d6f12-4007">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4007">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d6f12-4008">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4008">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d6f12-4009">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4009">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="d6f12-4010">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="d6f12-4010">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="d6f12-4011">.NET Framework 中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="d6f12-4011">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4012">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为可序列化的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4012">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="d6f12-4013">如果 <see cref="T:System.Type" /> 是可序列化的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4013"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="d6f12-4014">在 .NET Standard 中定义的类型未标记<xref:System.SerializableAttribute>为。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4014">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="d6f12-4015">相反, 每个 .NET 实现确定类型是否可序列化。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4015">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="d6f12-4016">在运行时, 可以使用<xref:System.Type.IsSerializable%2A>属性来确定该实现是否支持对该类型的实例进行序列化。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4016">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="d6f12-4017">有关详细信息和示例, 请参阅[如何确定 .NET Standard 对象是否可以序列化](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4017">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="d6f12-4018">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4018">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-4019">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4019">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-4020">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4020">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4021">`MyTestClass`下面的示例创建类的一个实例, 设置 [Serializable] 特性, 并`IsSerializable`检查`true`或`false`的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4021">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4022">获取一个值，该值指示该类型是否具有需要特殊处理的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4022">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="d6f12-4023">如果该类型具有需要特殊处理的名称，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4023"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4024">以或开头的名称包含下划线字符 (_)、属性访问器和运算符重载方法是可能需要某些编译器特殊处理的类型的示例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4024">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="d6f12-4025">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4025">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-4026">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4026">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-4027">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="d6f12-4028">要与当前类型进行比较的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4028">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="d6f12-4029">确定当前 <see cref="T:System.Type" /> 是否派生自指定的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4029">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4030">如果当前 <see langword="true" /> 派生于 <see langword="Type" />，则为 <paramref name="c" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4030"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d6f12-4031">如果 <see langword="false" /> 和当前 <paramref name="c" /> 相等，此方法也返回 <see langword="Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4031">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4032">可以调用<xref:System.Type.IsSubclassOf%2A>方法来确定以下任何内容:</span><span class="sxs-lookup"><span data-stu-id="d6f12-4032">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="d6f12-4033">一个类是否派生自另一个类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4033">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="d6f12-4034">类型是否派生自<xref:System.ValueType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4034">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="d6f12-4035">不过, <xref:System.Type.IsValueType%2A>是一种更有效的方法来确定类型是否为值类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4035">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="d6f12-4036">类型是否派生自<xref:System.Enum>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4036">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="d6f12-4037">不过, <xref:System.Type.IsEnum%2A>方法是一种更有效的方法来确定类型是否为枚举。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4037">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="d6f12-4038">类型是否为委托, 即是否从<xref:System.Delegate>或<xref:System.MulticastDelegate>派生。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4038">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="d6f12-4039"><xref:System.Type.IsSubclassOf%2A>方法不能用于确定接口是派生自另一个接口, 还是类实现接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4039">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="d6f12-4040"><xref:System.Type.IsAssignableFrom%2A>使用方法实现此目的, 如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4040">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="d6f12-4041">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则它从其类约束派生或从中<xref:System.Object?displayProperty=nameWithType>派生 (如果它没有类约束)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-4042">除了与接口一起使用时<xref:System.Type.IsSubclassOf%2A> , 与<xref:System.Type.IsAssignableFrom%2A>相反。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4042">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="d6f12-4043">也就是说, 如果`t1.IsSubclassOf(t2)`为`true`, 则`t2.IsAssignableFrom(t1)`也`true`是。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4043">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="d6f12-4044">此方法可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4044">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4045">下面的示例创建一个名为`Class1`的类和一个名`DerivedC1`为的派生类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4045">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="d6f12-4046">它调用<xref:System.Type.IsSubclassOf%2A>方法以`DerivedC1`显示是的子类`Class1`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4046">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-4047"><paramref name="c" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4047"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4048">获取一个值，该值指示是否为 <see langword="UnicodeClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4048">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-4049">如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="UnicodeClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4049"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4050"><xref:System.Reflection.TypeAttributes.StringFormatMask>用于选择字符串格式特性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4050">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="d6f12-4051">字符串格式特性通过定义应如何解释字符串来增强互操作性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4051">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="d6f12-4052">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4052">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-4053">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4053">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-4054">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4054">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4055">获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为值类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4055">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4056">如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4056"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4057">值类型是表示为位序列的类型;值类型不是类或接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4057">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="d6f12-4058">在某些编程语言中, 值类型称为 "结构"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4058">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="d6f12-4059">枚举是值类型的一种特殊情况。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4059">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="d6f12-4060">此属性`false` <xref:System.ValueType>为类返回, 因为<xref:System.ValueType>不是值类型本身。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4060">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="d6f12-4061">它是所有值类型的基类, 因此可以为其分配任何值类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4061">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="d6f12-4062">如果<xref:System.ValueType>自身是值类型, 则不可能。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4062">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="d6f12-4063">将值类型分配给类型<xref:System.ValueType>的字段时, 这些值类型将装箱。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4063">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="d6f12-4064">此属性为`true`枚举返回, 但不<xref:System.Enum>返回类型本身。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4064">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="d6f12-4065">有关演示此行为的示例, 请参见<xref:System.Type.IsEnum%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4065">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="d6f12-4066">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4066">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4067">下面的示例创建一个类型`MyEnum`为的变量, 检查`IsValueType`属性, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4067">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-4068">实现 <see cref="P:System.Type.IsValueType" /> 属性并确定 <see cref="T:System.Type" /> 是否是值类型；即，它不是值类或接口。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4068">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4069">如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4069"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4070">提供此方法是为了实现备用类型系统。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4070">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="d6f12-4071">它通常不在应用程序代码中使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4071">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4072">获取一个指示 <see cref="T:System.Type" /> 是否可由程序集之外的代码访问的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4072">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="d6f12-4073">如果当前 <see langword="true" /> 是公共类型或公共嵌套类型从而使所有封闭类型都是公共类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4073"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4074">使用此属性确定类型是否为组件程序集的公共接口的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4074">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4075">下面的代码示例测试两个类, 其中只有一个类在程序集外可见。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4075">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d6f12-4076">返回表示当前类型的数组的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4076">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-4077">返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4077">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4078">返回一个表示当前类型的一维数组（下限为零）的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4078">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4079"><xref:System.Type.MakeArrayType%2A>方法提供了一种方法, 用于生成在运行时计算其元素类型的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4079">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="d6f12-4080">**注意**公共语言运行时区分向量 (即, 始终从零开始的一维数组) 和多维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4080">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="d6f12-4081">向量 (始终只有一个维度) 不同于只具有一个维度的多维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4081">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="d6f12-4082">此方法重载仅可用于创建矢量类型, 并且是创建矢量类型的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4082">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="d6f12-4083"><xref:System.Type.MakeArrayType%28System.Int32%29>使用方法重载创建多维数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4083">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4084">下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4084">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4085">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4085">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="d6f12-4086">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4086">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-4087">当前的类型是 <see cref="T:System.TypedReference" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4087">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="d6f12-4088">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4088">-or-</span></span> 
<span data-ttu-id="d6f12-4089">当前的类型是 <see langword="ByRef" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4089">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="d6f12-4090">也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="d6f12-4091">数组的维数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4091">The number of dimensions for the array.</span></span> <span data-ttu-id="d6f12-4092">此数字必须小于或等于 32。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4092">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="d6f12-4093">返回 <see cref="T:System.Type" /> 对象，该对象表示一个具有指定维数的当前类型的数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4093">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4094">表示当前类型的指定维数的数组的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4094">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4095"><xref:System.Type.MakeArrayType%2A>方法提供了一种方法, 用于生成在运行时计算其元素类型的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4095">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-4096">公共语言运行时区分向量 (即, 始终从零开始的一维数组) 和多维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4096">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="d6f12-4097">向量 (始终只有一个维度) 不同于只具有一个维度的多维数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4097">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="d6f12-4098">不能使用此方法重载来创建矢量类型;如果`rank`为 1, 则此方法重载返回有一个维度的多维数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4098">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="d6f12-4099"><xref:System.Type.MakeArrayType>使用方法重载来创建矢量类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4099">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4100">下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4100">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="d6f12-4101"><paramref name="rank" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4101"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="d6f12-4102">例如，0 或负数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4102">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4103">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4103">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-4104">当前的类型是 <see cref="T:System.TypedReference" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4104">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="d6f12-4105">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4105">-or-</span></span> 
<span data-ttu-id="d6f12-4106">当前的类型是 <see langword="ByRef" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4106">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="d6f12-4107">也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4107">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="d6f12-4108">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4108">-or-</span></span> 
 <span data-ttu-id="d6f12-4109"><paramref name="rank" /> 大于 32。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4109"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-4110">返回表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4110">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="d6f12-4111">表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4111">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4112">方法提供了一种方法, `ref`用于生成`ByRef`参数列表的类型 (在 Visual Basic 中)。 <xref:System.Type.MakeByRefType%2A></span><span class="sxs-lookup"><span data-stu-id="d6f12-4112">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="d6f12-4113">如果当前<xref:System.Type>对象表示<xref:System.Int32>, 则使用 Microsoft 中间语言 (MSIL) 的语法, 此方法返回表示`Int32&`的<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4113">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4114">下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4115">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4115">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-4116">当前的类型是 <see cref="T:System.TypedReference" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4116">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="d6f12-4117">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4117">-or-</span></span> 
<span data-ttu-id="d6f12-4118">当前的类型是 <see langword="ByRef" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4118">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="d6f12-4119">也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4119">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition"><span data-ttu-id="d6f12-4120">泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4120">The generic type definition.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="d6f12-4121">类型参数数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4121">An array of type arguments.</span></span></param>
        <summary><span data-ttu-id="d6f12-4122">创建一个泛型签名类型，该类型允许第三方重新实现反射，从而完全支持在查询类型成员时使用签名类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4122">Creates a generic signature type, which allows third party reimplementations of Reflection to fully support the use of signature types in querying type members.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4123">泛型签名类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4123">A generic signature type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="d6f12-4124">将代替当前泛型类型的类型参数的类型数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4124">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="d6f12-4125">替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4125">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4126"><see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4126">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4127">使用<xref:System.Type.MakeGenericType%2A>方法, 可以编写将特定类型分配给泛型类型定义的类型参数的代码, 从而<xref:System.Type>创建表示特定构造类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4127">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="d6f12-4128">您可以使用此<xref:System.Type>对象创建构造类型的运行时实例。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4128">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="d6f12-4129">用<xref:System.Type.MakeGenericType%2A>构造的类型可以是开放的, 也就是说, 它们的某些类型参数可以是封闭泛型方法或类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4129">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="d6f12-4130">发出动态程序集时, 可以使用此类开放式构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4130">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="d6f12-4131">例如, 请考虑以下代码`Base`中`Derived`的类和。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4131">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="d6f12-4132">若要`Derived`在动态程序集中生成, 需要构造其基类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4132">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="d6f12-4133">为此, 请使用泛型<xref:System.Type.MakeGenericType%2A>类型参数<xref:System.Int32>和<xref:System.Type>中`V` `Derived`的类型参数`Base`对表示类的对象调用方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4133">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="d6f12-4134">因为类型和泛型类型参数均由<xref:System.Type>对象表示, 所以, 同时包含这两个参数的数组可传递<xref:System.Type.MakeGenericType%2A>给方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4134">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-4135">发出代码时, 构造`Base<int, V>`类型 (如) 非常有用, 但不能对<xref:System.Type.MakeGenericType%2A>此类型调用方法, 因为它不是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4135">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="d6f12-4136">若要创建可以实例化的封闭式构造类型, 请首先调用<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>获取表示泛型类型定义的对象, 然后使用所需<xref:System.Type.MakeGenericType%2A>的类型参数调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4136">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="d6f12-4137"><xref:System.Object.GetType%2A> <xref:System.Object.GetType%2A> <xref:System.Type>返回的对象与通过调用生成的构造类型的方法获得的相同, 或从相同泛型创建的任何构造类型的方法相同。 <xref:System.Type> <xref:System.Type.MakeGenericType%2A>类型定义使用相同的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4137">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d6f12-4138">泛型类型的数组本身不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4138">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="d6f12-4139">不能对<xref:System.Type.MakeGenericType%2A>数组类型`C<T>[]` (`Dim ac() As C(Of T)`如 Visual Basic) 调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4139">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="d6f12-4140">若`C<T>[]`要从构造封闭式泛型类型, 请<xref:System.Type.GetElementType%2A>调用以获取泛型类型定义`C<T>`; 对<xref:System.Type.MakeGenericType%2A>泛型类型<xref:System.Type.MakeArrayType%2A>定义调用以创建构造类型; 最后调用方法用于创建数组类型的构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4140">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="d6f12-4141">指针类型和`ref`类型 (`ByRef`在 Visual Basic) 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4141">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="d6f12-4142">有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4142">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="d6f12-4143">嵌套类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-4143">Nested Types</span></span>  
 <span data-ttu-id="d6f12-4144">如果使用C#、 C++或 Visual Basic 定义泛型类型, 则其嵌套类型都是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4144">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="d6f12-4145">即使嵌套类型没有自己的类型参数, 也是如此, 因为所有这三种语言都包括嵌套类型的类型参数列表中的封闭类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4145">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="d6f12-4146">请考虑以下类:</span><span class="sxs-lookup"><span data-stu-id="d6f12-4146">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="d6f12-4147">嵌套类`Inner`的类型参数列表具有两个类型参数`U`, `T`第一个参数是其封闭类的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4147">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="d6f12-4148">同样, 嵌套类`Innermost1`的类型参数列表具有三个类型参数`U`: `T`、和`V`, `T` `U`它们来自其封闭类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4148">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="d6f12-4149">嵌套类`Innermost2`有两个类型参数: `T`和`U`, 它们来自其封闭类。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4149">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="d6f12-4150">如果封闭类型的参数列表具有多个类型参数, 则按顺序列出的所有类型参数都包含在嵌套类型的类型参数列表中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4150">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="d6f12-4151">若要从嵌套类型的泛型类型定义构造泛型类型, 请通过连接<xref:System.Type.MakeGenericType%2A>所有封闭类型的类型参数数组 (从最外面的泛型类型开始, 以嵌套类型本身的类型参数数组 (如果它具有其自己的类型参数)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4151">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="d6f12-4152">若要创建的`Innermost1`实例, 请使用包含三种类型的数组<xref:System.Type.MakeGenericType%2A>调用方法, 将其分配给 T、U 和 V。若要创建的`Innermost2`实例, 请使用包含两个类型的数组<xref:System.Type.MakeGenericType%2A>调用方法, 将其分配给 T 和 U。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4152">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="d6f12-4153">语言以这种方式传播封闭类型的类型参数, 因此可以使用封闭类型的类型参数来定义嵌套类型的字段。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4153">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="d6f12-4154">否则, 类型参数将不会位于嵌套类型体内的范围内。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4154">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="d6f12-4155">通过在动态程序集中发出代码或使用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md), 可以定义嵌套类型而无需传播封闭类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4155">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="d6f12-4156">对于 MSIL 组装器, 请考虑以下代码:</span><span class="sxs-lookup"><span data-stu-id="d6f12-4156">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="d6f12-4157">在此示例中, 不能在类`T` `Innermost`中定义类型为或`U`的字段, 因为这些类型参数不在范围内。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4157">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="d6f12-4158">以下汇编程序代码定义了嵌套类, 它们的行为方式与它们在、 C++Visual Basic 和C#中定义的方式相同:</span><span class="sxs-lookup"><span data-stu-id="d6f12-4158">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="d6f12-4159">可以使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查在高级语言中定义的嵌套类, 并观察此命名方案。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4159">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4160">下面的示例使用<xref:System.Type.MakeGenericType%2A>方法从<xref:System.Collections.Generic.Dictionary%602>类型的泛型类型定义中创建构造类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4160">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="d6f12-4161">构造类型表示<xref:System.Collections.Generic.Dictionary%602>具有字符串键`Test`的对象的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4161">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d6f12-4162">当前的类型不表示泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4162">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="d6f12-4163">也就是说，<see cref="P:System.Type.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4163">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-4164"><paramref name="typeArguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4164"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d6f12-4165">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4165">-or-</span></span> 
<span data-ttu-id="d6f12-4166"><paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4166">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-4167"><paramref name="typeArguments" /> 中的元素数与当前泛型类型定义中的类型参数数不同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4167">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="d6f12-4168">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4168">-or-</span></span> 
<span data-ttu-id="d6f12-4169"><paramref name="typeArguments" /> 的所有元素都不满足为当前泛型类型的相应类型参数指定的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4169">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="d6f12-4170">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4170">-or-</span></span> 
 <span data-ttu-id="d6f12-4171"><paramref name="typeArguments" /> 包含一个元素，该元素是一个指针类型（<see cref="P:System.Type.IsPointer" /> 返回 <see langword="true" />）、by-ref 类型（<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />）或 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4171"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4172">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4172">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="d6f12-4173">派生类必须提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4173">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="d6f12-4174">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-4174">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="d6f12-4175">如何：使用反射检查和实例化泛型类型</span><span class="sxs-lookup"><span data-stu-id="d6f12-4175">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-4176">返回表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4176">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4177">表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4177">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4178"><xref:System.Type.MakePointerType%2A>方法提供了一种方法来生成参数列表的指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4178">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="d6f12-4179">如果当前<xref:System.Type>对象表示<xref:System.Int32>, 则使用 Microsoft 中间语言 (MSIL) 的语法, 此方法返回表示`Int32*`的<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4179">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4180">下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4180">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4181">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4181">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-4182">当前的类型是 <see cref="T:System.TypedReference" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4182">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="d6f12-4183">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4183">-or-</span></span> 
<span data-ttu-id="d6f12-4184">当前的类型是 <see langword="ByRef" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4184">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="d6f12-4185">也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4185">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4186">获取一个指示此成员是类型还是嵌套类型的 <see cref="T:System.Reflection.MemberTypes" /> 值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4186">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4187">一个 <see cref="T:System.Reflection.MemberTypes" /> 值，指示此成员是类型还是嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4187">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4188">此属性将<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>重写。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4188">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6f12-4189">因此, 在检查一<xref:System.Reflection.MemberInfo>组对象 (例如, <xref:System.Type.GetMembers%2A>返回<xref:System.Reflection.MemberInfo.MemberType%2A>的数组) 时, 当给定成员是嵌套<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>类型时, 属性将返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4189">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="d6f12-4190">如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4190">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="d6f12-4191">例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4191">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="d6f12-4192">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4192">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4193">下面的代码示例将该`MemberType`字段显示为`GetMember`方法的参数:</span><span class="sxs-lookup"><span data-stu-id="d6f12-4193">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4194">表示 <see cref="T:System.Type" /> 信息中的缺少值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4194">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="d6f12-4195">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4195">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4196">`Missing`使用字段通过反射调用以获取参数的默认值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4196">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="d6f12-4197">如果为参数值传入了<xref:System.ArgumentException> 字段,并且该参数没有默认值,则会引发。`Missing`</span><span class="sxs-lookup"><span data-stu-id="d6f12-4197">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4198">下面的代码示例演示如何使用`Missing`字段来调用方法及其默认参数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4198">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="d6f12-4199">此代码生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="d6f12-4199">This code produces the following output:</span></span>  
  
 <span data-ttu-id="d6f12-4200">a = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="d6f12-4200">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="d6f12-4201">a = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="d6f12-4201">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="d6f12-4202">a = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="d6f12-4202">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4203">获取在其中定义当前 <see cref="T:System.Type" /> 的模块 (DLL)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4203">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="d6f12-4204">在其中定义当前 <see cref="T:System.Type" /> 的模块。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4204">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4205">如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回定义了泛型类型定义的模块。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4205">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="d6f12-4206">例如, 如果您创建了一个实例`MyGenericStack<int>`, 则构造的类型的属性将<xref:System.Type.Module%2A> `MyGenericStack<T>`返回定义的模块。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4206">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="d6f12-4207">同样, 如果当前<xref:System.Type>表示泛型参数`T`, 则此属性返回包含定义`T`的泛型类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4207">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4208">下面的示例演示如何<xref:System.Type.Namespace%2A>使用和`Module` <xref:System.Type>属性以及<xref:System.Type.ToString%2A>的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4208">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4209">在派生类中覆盖时，获取当前类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4209">When overridden in a derived class, gets the name of the current type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4210">当前类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4210">The name of the current type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4211">获取 <see cref="T:System.Type" /> 的命名空间。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4211">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-4212"><see cref="T:System.Type" /> 的命名空间；如果当前实例没有命名空间或表示泛型参数，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4212">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4213">命名空间是逻辑设计时命名方便, 主要用于在应用程序中定义作用域, 并在单个层次结构中组织类和其他类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4213">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="d6f12-4214">从运行时的角度来看, 没有任何命名空间。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4214">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="d6f12-4215">如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回包含泛型类型定义的命名空间。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4215">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="d6f12-4216">同样, 如果当前<xref:System.Type>表示泛型参数`T`, 则此属性返回包含定义`T`的泛型类型定义的命名空间。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4216">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="d6f12-4217">如果当前<xref:System.Type>对象表示泛型参数, 则此属性返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4217">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4218">下面的示例演示如何`Namespace`使用和<xref:System.Type.Module%2A> <xref:System.Type>属性以及<xref:System.Type.ToString%2A>的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4218">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-4219">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-4219">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d6f12-4220">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4220">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d6f12-4221">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4221">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="d6f12-4222">指示两个 <see cref="T:System.Type" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4222">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4223">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4223"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d6f12-4224">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4224">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d6f12-4225">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4225">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="d6f12-4226">指示两个 <see cref="T:System.Type" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4226">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4227">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4227"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4228">获取用于获取该成员的类对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4228">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="d6f12-4229"><see langword="Type" /> 对象，通过它获取了此 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4229">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4230">对于<xref:System.Type>对象, 此属性的值始终与<xref:System.Type.DeclaringType%2A>属性的值相同。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4230">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4231">此示例显示嵌套类的反射类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4231">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="d6f12-4232">要获取的 <see cref="T:System.Type" /> 的程序集限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4232">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="d6f12-4233">如果为 <see langword="true" />，则会在找不到该类型时引发 <see cref="T:System.TypeLoadException" />；如果为 <see langword="false" />，则在找不到该类型时返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4233"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="d6f12-4234">指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4234">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="d6f12-4235">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4235">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="d6f12-4236">如果为 <see langword="true" />，则执行不区分大小写的 <paramref name="typeName" /> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <paramref name="typeName" /> 搜索。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4236"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="d6f12-4237">获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4237">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="d6f12-4238">该类型只为反射加载，而不为执行加载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4238">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4239">具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4239">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="d6f12-4240">如果找不到该类型，则 <paramref name="throwIfNotFound" /> 参数指定是返回 <see langword="null" /> 还是引发异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4240">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="d6f12-4241">在某些情况下，将引发异常，而不考虑 <paramref name="throwIfNotFound" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4241">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="d6f12-4242">请参见“异常”部分。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4242">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4243">如果包含该类型的程序集尚未加载到仅反射上下文中, 则使用<xref:System.Type.ReflectionOnlyGetType%2A>方法等效于首先加载仅用于反射的程序集, 然后<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>使用方法, 然后通过调用程序集<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4243">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d6f12-4244">有关程序集限定名称的信息, 请参见<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4244">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d6f12-4245">有关指定类型名称的更多详细信息, <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>请参阅方法重载。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4245">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="d6f12-4246">如果程序集已加载以便执行, 则将另一个副本加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4246">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="d6f12-4247">`throwIfNotFound`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4247">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="d6f12-4248">引发一些异常, 而不考虑的值`throwIfNotFound`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4248">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="d6f12-4249">例如, 如果程序集无效, <xref:System.BadImageFormatException> `throwIfNotFound`即使为`false`, 也会引发。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4249">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="d6f12-4250">有关使用仅反射上下文的详细信息, 请参阅[如何:将程序集加载到仅反射上下文中](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4250">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d6f12-4251"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4251"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d6f12-4252">调用了类初始值设定项，且该项引发了异常。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4252">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d6f12-4253"><paramref name="throwIfNotFound" /> 是 <see langword="true" />，且找不到该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4253"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="d6f12-4254">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4254">-or-</span></span> 
 <span data-ttu-id="d6f12-4255"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4255"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="d6f12-4256">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4256">-or-</span></span> 
 <span data-ttu-id="d6f12-4257"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4257"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="d6f12-4258">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4258">-or-</span></span> 
 <span data-ttu-id="d6f12-4259"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4259"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="d6f12-4260">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4260">-or-</span></span> 
 <span data-ttu-id="d6f12-4261"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4261"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d6f12-4262"><paramref name="typeName" /> 不包括程序集名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4262"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="d6f12-4263">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4263">-or-</span></span> 
 <span data-ttu-id="d6f12-4264"><paramref name="throwIfNotFound" /> 为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,\*,]"）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4264"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="d6f12-4265">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4265">-or-</span></span> 
 <span data-ttu-id="d6f12-4266"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4266"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="d6f12-4267">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4267">-or-</span></span> 
 <span data-ttu-id="d6f12-4268"><paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4268"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="d6f12-4269">或</span><span class="sxs-lookup"><span data-stu-id="d6f12-4269">-or-</span></span> 
 <span data-ttu-id="d6f12-4270"><paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4270"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d6f12-4271"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4271"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d6f12-4272">找到了程序集或其依赖项之一，但无法加载它们。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4272">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d6f12-4273">程序集或其依赖项之一无效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4273">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="d6f12-4274">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d6f12-4274">-or-</span></span>  
  
 <span data-ttu-id="d6f12-4275">此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4275">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="d6f12-4276">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="d6f12-4276">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="d6f12-4277">如何：将程序集加载到仅反射上下文中</span><span class="sxs-lookup"><span data-stu-id="d6f12-4277">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4278">获取一个描述当前类型的布局的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4278">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4279">获取一个描述当前类型的大致布局特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4279">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4280"><xref:System.Runtime.InteropServices.StructLayoutAttribute><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法未返回。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4280"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="d6f12-4281">而是使用此属性获取它。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4281">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4282">下面的代码示例首先使用特殊的布局特性 (结构嵌套在类中) 来定义类、结构和结构。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4282">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="d6f12-4283">然后, 该示例使用<xref:System.Type.StructLayoutAttribute%2A>属性<xref:System.Runtime.InteropServices.StructLayoutAttribute>获取每个类型的, 并显示特性的属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4283">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4284">基类不支持调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4284">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="d6f12-4285">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4285">Reserved for future use.</span></span> <span data-ttu-id="d6f12-4286">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4286">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="d6f12-4287">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4287">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="d6f12-4288">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4288">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="d6f12-4289">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4289">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="d6f12-4290">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4290">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="d6f12-4291">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4291">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4292">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4292">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d6f12-4293">有关`IDispatch::GetIDsOfNames`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4293">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d6f12-4294">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4294">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="d6f12-4295">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4295">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="d6f12-4296">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4296">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="d6f12-4297">指向请求的类型信息对象的指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4297">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="d6f12-4298">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4298">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4299">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4299">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d6f12-4300">有关`IDispatch::GetTypeInfo`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4300">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d6f12-4301">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4301">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="d6f12-4302">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4302">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="d6f12-4303">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4303">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4304">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4304">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d6f12-4305">有关`IDispatch::GetTypeInfoCount`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4305">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d6f12-4306">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4306">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="d6f12-4307">标识成员。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4307">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="d6f12-4308">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4308">Reserved for future use.</span></span> <span data-ttu-id="d6f12-4309">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4309">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="d6f12-4310">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4310">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="d6f12-4311">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4311">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="d6f12-4312">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4312">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="d6f12-4313">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4313">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="d6f12-4314">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4314">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="d6f12-4315">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4315">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="d6f12-4316">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4316">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4317">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4317">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d6f12-4318">有关`IDispatch::Invoke`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4318">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d6f12-4319">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4319">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d6f12-4320">返回表示当前 <see langword="String" /> 的名称的 <see langword="Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4320">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="d6f12-4321">表示当前 <see cref="T:System.String" /> 的名称的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4321">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4322">此方法为所有基元类型返回完全限定的公共语言运行时命名空间和名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4322">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="d6f12-4323">例如, C#指令`(long)0.Type().ToString()`返回 "system.string" 而不只是 "Int64"。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4323">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="d6f12-4324">如果当前<xref:System.Type>表示泛型类型, 则类型及其类型参数由命名空间和嵌套类型限定, 而不是由程序集限定。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4324">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="d6f12-4325">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法返回类型参数的非限定名称。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4325">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4326">下面的示例演示如何<xref:System.Type.Namespace%2A>使用和<xref:System.Type.Module%2A> <xref:System.Type>属性以及`ToString`的方法。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4326">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="d6f12-4327">下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4327">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4328">获取当前 <see cref="T:System.Type" /> 的句柄。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4328">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="d6f12-4329">当前 <see cref="T:System.Type" /> 的句柄。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4329">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4330">`TypeHandle`封装指向表示类型的内部数据结构的指针。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4330">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="d6f12-4331">此句柄在进程生存期内是唯一的。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4331">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="d6f12-4332">该句柄仅在获取该句柄的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4332">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d6f12-4333">下面的示例返回相应类型的句柄, 并将该句柄传递给一个方法, 该方法从句柄获取类型并显示该类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4333">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d6f12-4334">.NET Compact Framework 当前不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4334">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4335">获取该类型的初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4335">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4336">包含 <see cref="T:System.Type" /> 的类构造函数的名称的对象。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4336">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d6f12-4337"><xref:System.Type.FindMembers%2A>还可以通过方法或使用<xref:System.Reflection.BindingFlags>作为参数的、 <xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetConstructor%2A>和<xref:System.Type.GetConstructors%2A>方法的<xref:System.Type.GetMember%2A>重载来使用类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4337">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="d6f12-4338">如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性返回`null`。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4338">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d6f12-4339">指示表示该类型的公共语言运行时提供的类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4339">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="d6f12-4340"><see cref="T:System.Type" /> 的基础系统类型。</span><span class="sxs-lookup"><span data-stu-id="d6f12-4340">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
