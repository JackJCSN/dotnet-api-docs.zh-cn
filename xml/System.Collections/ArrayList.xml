<Type Name="ArrayList" FullName="System.Collections.ArrayList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="928d8d72e6df9a907d147f3aa2f7dda7c3b3cfe9" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63907032" /></Metadata><TypeSignature Language="C#" Value="public class ArrayList : ICloneable, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ArrayList extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ArrayList" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayList&#xA;Implements ICloneable, IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class ArrayList : ICloneable, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ArrayList = class&#xA;    interface IList&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>使用大小会根据需要动态增加的数组来实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

> [!IMPORTANT]
>  我们不建议你使用`ArrayList`类的新的开发。 相反，我们建议使用泛型<xref:System.Collections.Generic.List%601>类。
> <xref:System.Collections.ArrayList>类专门用于存储异类对象的集合。 但是，它不会始终提供最佳性能。 相反，我们的建议如下：  
> - 对于异类对象的集合，使用`List<Object>`（在 C# 中) 或`List(Of Object)`（在 Visual Basic 中) 中，键入。  
> - 对于同类对象的集合，使用<xref:System.Collections.Generic.List%601>类。  
> 请参阅[的性能注意事项](xref:System.Collections.Generic.List%601#performance-considerations)中<xref:System.Collections.Generic.List%601>这些类的相对性能的讨论的参考主题。  请参阅[不应使用非泛型集合](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md)在 GitHub 上使用的泛型而不要使用非泛型集合类型的一般信息。 
  
 <xref:System.Collections.ArrayList>不保证排序。  您必须进行排序<xref:System.Collections.ArrayList>通过调用其<xref:System.Collections.ArrayList.Sort%2A>方法，然后执行操作 (如<xref:System.Collections.ArrayList.BinarySearch%2A>) 需要<xref:System.Collections.ArrayList>进行排序。 若要维护一个集合，其中添加新元素时自动进行排序，可以使用<xref:System.Collections.Generic.SortedSet%601>类。  
  
 容量<xref:System.Collections.ArrayList>是元素数目<xref:System.Collections.ArrayList>可以容纳。 元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配所需的方式。 可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过设置<xref:System.Collections.ArrayList.Capacity%2A>属性显式。  
  
 **仅限.NET framework:** 对于非常大<xref:System.Collections.ArrayList>对象，可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`的属性[ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration 元素`true`中运行时环境。  
  
 可以使用整数索引访问此集合中的元素。  在此集合中的索引都是从零开始的。  
  
 <xref:System.Collections.ArrayList>集合接受`null`为有效的值。 它还允许重复元素。  
  
 将多维数组中的元素用作<xref:System.Collections.ArrayList>不支持的集合。  
  
   
  
## Examples  
 下面的示例演示如何创建和初始化<xref:System.Collections.ArrayList>以及如何显示它的值。  
  
 [!code-cpp[Classic ArrayList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员是线程安全。 但不保证所有实例成员都是线程安全的。  
  
<see cref="T:System.Collections.ArrayList" /> ，只要不修改该集合可以同时支持多个读取器。 若要保证的线程安全<see cref="T:System.Collections.ArrayList" />，必须通过返回的包装器完成所有操作<see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />方法。  
  
枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Generic.List`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该实例为空并且具有默认初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素数目的<xref:System.Collections.ArrayList>可以容纳。 元素添加到<xref:System.Collections.ArrayList>，自动增加容量所要求的重新分配内部数组。  
  
 如果可以估计集合的大小，指定的初始容量，则无需要执行多个大小调整操作，同时将元素添加到<xref:System.Collections.ArrayList>。  
  
 此构造函数是 o （1） 操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : System.Collections.ICollection -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList c" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">其元素已复制到新列表的 <see cref="T:System.Collections.ICollection" />。</param>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素数目的<xref:System.Collections.ArrayList>可以容纳。 元素添加到<xref:System.Collections.ArrayList>，自动增加容量所要求的重新分配内部数组。  
  
 如果可以估计集合的大小，指定的初始容量，则无需要执行多个大小调整操作，同时将元素添加到<xref:System.Collections.ArrayList>。  
  
 将元素复制到<xref:System.Collections.ArrayList>读取的相同顺序<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。  
  
 此构造函数是 O (`n`) 操作，其中`n`是中的元素数`c`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.ArrayList : int -&gt; System.Collections.ArrayList" Usage="new System.Collections.ArrayList capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新列表最初可以存储的元素数。</param>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该实例为空并且具有指定的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素数目的<xref:System.Collections.ArrayList>可以容纳。 元素添加到<xref:System.Collections.ArrayList>，自动增加容量所要求的重新分配内部数组。  
  
 如果可以估计集合的大小，指定的初始容量，则无需要执行多个大小调整操作，同时将元素添加到<xref:System.Collections.ArrayList>。  
  
 此构造函数是 O (`n`) 操作，其中`n`是`capacity`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Adapter (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Adapter(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Adapter(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Adapter (list As IList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Adapter(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Adapter : System.Collections.IList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Adapter list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>为特定 <see cref="T:System.Collections.IList" /> 创建 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns><see cref="T:System.Collections.IList" /> 的 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Adapter%2A> 不会复制的内容<xref:System.Collections.IList>。 相反，而只会创建<xref:System.Collections.ArrayList>周围的包装器<xref:System.Collections.IList>; 因此，将更改为<xref:System.Collections.IList>也会影响<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList>类提供了泛型<xref:System.Collections.ArrayList.Reverse%2A>，<xref:System.Collections.ArrayList.BinarySearch%2A>和<xref:System.Collections.ArrayList.Sort%2A>方法。 此包装器可以是一种方法来使用这些方法<xref:System.Collections.IList>; 但是，执行通过包装这些泛型操作可能会比直接应用于操作的效率较低<xref:System.Collections.IList>。  
  
 此方法为 o （1） 运算。  
  
## <a name="version-compatibility"></a>版本兼容性  
 在.NET Framework 版本 1.0 和 1.1 中，调用<xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29>方法重载上的<xref:System.Collections.ArrayList>包装返回的枚举数上限为而不是计数处理第二个参数。 在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]作为计数正确处理第二个参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
        <altmember cref="M:System.Collections.ArrayList.Reverse" />
        <altmember cref="M:System.Collections.ArrayList.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="arrayList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:System.Object" /> 的结尾处的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>将对象添加到 <see cref="T:System.Collections.ArrayList" /> 的结尾处。</summary>
        <returns>已添加 <paramref name="value" /> 的 <see cref="T:System.Collections.ArrayList" /> 索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>已等于<xref:System.Collections.ArrayList.Capacity%2A>，则容量的<xref:System.Collections.ArrayList>自动重新分配内部数组中，增加和现有元素之前添加新元素将复制到新数组。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>是小于<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 o （1） 运算。 如果需要增加以容纳新元素的容量，此方法将成为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素添加到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddRange(System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : System.Collections.ICollection -&gt; unit&#xA;override this.AddRange : System.Collections.ICollection -&gt; unit" Usage="arrayList.AddRange c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Collections.ICollection" />，其元素应添加到 <see cref="T:System.Collections.ArrayList" /> 的末尾。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>将 <see cref="T:System.Collections.ICollection" /> 的元素添加到 <see cref="T:System.Collections.ArrayList" /> 的末尾。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 中的元素的顺序<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>。  
  
 如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>，则容量的<xref:System.Collections.ArrayList>增加通过自动重新分配要容纳新元素的内部数组和之前添加新元素，现有元素将复制到新数组。  
  
 如果<xref:System.Collections.ArrayList>可以容纳新元素而不增加<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 O (`n`) 操作，其中`n`是要添加的元素数。 如果需要增加以容纳新元素的容量，此方法将成为 O (`n` + `m`) 操作，其中`n`是要添加的元素数并`m`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素添加到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用对分检索算法在已排序的 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中查找特定元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj -&gt; int&#xA;override this.BinarySearch : obj -&gt; int" Usage="arrayList.BinarySearch value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <summary>使用默认的比较器在整个已排序的 <see cref="T:System.Collections.ArrayList" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数和每个元素<xref:System.Collections.ArrayList>必须实现<xref:System.IComparable>接口，用于比较。 元素<xref:System.Collections.ArrayList>必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许使用任何类型和使用时不会生成异常<xref:System.IComparable>。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.ArrayList>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Collections.ArrayList.BinarySearch%2A>来查找中的特定对象<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不是同一类型。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 如果为 <see langword="null" />，则使用默认比较器，即每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器在整个已排序的 <see cref="T:System.Collections.ArrayList" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer>作为要执行不区分大小写的字符串搜索的比较器的实例。  
  
 如果`comparer`提供的元素<xref:System.Collections.ArrayList>为指定的值使用指定比较<xref:System.Collections.IComparer>实现。 元素<xref:System.Collections.ArrayList>必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>元素本身或指定的值提供的实现。 元素<xref:System.Collections.ArrayList>必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许使用任何类型和使用时不会生成异常<xref:System.IComparable>。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.ArrayList>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Collections.ArrayList>彩色动画。 提供<xref:System.Collections.IComparer>执行二进制搜索的字符串比较。 显示迭代搜索和二进制搜索的结果。  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不属于同一类型。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(int32 index, int32 count, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (index As Integer, count As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(int index, int count, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int&#xA;override this.BinarySearch : int * int * obj * System.Collections.IComparer -&gt; int" Usage="arrayList.BinarySearch (index, count, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">要搜索范围的从零开始的起始索引。</param>
        <param name="count">要搜索的范围的长度。</param>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 如果为 <see langword="null" />，则使用默认比较器，即每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器在已排序 <see cref="T:System.Collections.ArrayList" /> 的某个元素范围中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer>作为要执行不区分大小写的字符串搜索的比较器的实例。  
  
 如果`comparer`提供的元素<xref:System.Collections.ArrayList>为指定的值使用指定比较<xref:System.Collections.IComparer>实现。 元素<xref:System.Collections.ArrayList>必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>元素本身或指定的值提供的实现。 元素<xref:System.Collections.ArrayList>必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许使用任何类型和使用时不会生成异常<xref:System.IComparable>。 排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法将返回只包含其中一个匹配项，并且它可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回一个负整数。 您可以应用于此负整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 当将值插入到<xref:System.Collections.ArrayList>，此索引应使用作为插入点，以保持排序顺序。  
  
 此方法为 O (log `n`) 操作，其中`n`是`count`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中的有效范围。  
  
- 或 - 
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不属于同一类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.ArrayList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Collections.ArrayList" /> 可包含的元素数。</summary>
        <value><see cref="T:System.Collections.ArrayList" /> 可包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> 是的元素数的<xref:System.Collections.ArrayList>可以存储。 <xref:System.Collections.ArrayList.Count%2A> 是中的实际的元素数目<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 始终是大于或等于<xref:System.Collections.ArrayList.Count%2A>。 如果<xref:System.Collections.ArrayList.Count%2A>超出了<xref:System.Collections.ArrayList.Capacity%2A>时添加元素，则自动通过增大容量在复制旧元素和添加新元素之前重新分配内部数组。  
  
 可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过设置<xref:System.Collections.ArrayList.Capacity%2A>属性显式。 时的值<xref:System.Collections.ArrayList.Capacity%2A>设置了显式，内部数组还重新分配以适应指定的容量。  
  
 检索此属性的值是 o （1） 的操作;将属性设置为 O (`n`) 操作，其中`n`新容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.ArrayList.Capacity" /> 已设置为一个小于 <see cref="P:System.Collections.ArrayList.Count" /> 的值。</exception>
        <exception cref="T:System.OutOfMemoryException">系统上没有足够的可用内存。</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="arrayList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Count%2A> 已设置为零，并且对其他对象的集合的元素也被释放。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 保持不变。  若要重置的容量<xref:System.Collections.ArrayList>，调用<xref:System.Collections.ArrayList.TrimToSize%2A>，或者设置<xref:System.Collections.ArrayList.Capacity%2A>直接属性。 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认容量。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何剪裁的未使用的部分<xref:System.Collections.ArrayList>以及如何清除的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.TrimToSize" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="arrayList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Collections.ArrayList" /> 的浅表副本。</summary>
        <returns><see cref="T:System.Collections.ArrayList" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合的浅表副本仅复制元素的集合，无论它们是引用类型还是值类型，但它不会复制所引用的对象。 新集合中的引用都指向相同原始集合中的引用指向的对象。  
  
 与此相反，集合的深层副本复制这些元素以及由这些元素直接或间接引用的所有内容。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="arrayList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.ArrayList" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 或它的一部分复制到一维数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array -&gt; unit&#xA;override this.CopyTo : Array -&gt; unit" Usage="arrayList.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <summary>从目标数组的开头开始，将整个 <see cref="T:System.Collections.ArrayList" /> 复制到兼容的一维 <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
源 <see cref="T:System.Collections.ArrayList" /> 中的元素个数大于目标 <paramref name="array" /> 可以包含的元素个数。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="arrayList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <summary>从目标数组的指定索引处开始将整个 <see cref="T:System.Collections.ArrayList" /> 复制到兼容的一维 <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
源 <see cref="T:System.Collections.ArrayList" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (int index, Array array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int32 index, class System.Array array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(int index, Array ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int * Array * int * int -&gt; unit&#xA;override this.CopyTo : int * Array * int * int -&gt; unit" Usage="arrayList.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">复制即从源 <see cref="T:System.Collections.ArrayList" /> 中从零开始的索引开始。</param>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <param name="count">要复制的元素数。</param>
        <summary>从目标数组的指定索引处开始，将 <see cref="T:System.Collections.ArrayList" /> 中某个范围的元素复制到兼容的一维数组  <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>元素将复制到。  
  
 将元素复制到<xref:System.Array>枚举器循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="arrayIndex" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
 <paramref name="index" /> 等于或大于源 <see cref="T:System.Collections.ArrayList" /> 的 <see cref="P:System.Collections.ArrayList.Count" />。  
  
- 或 - 
从 <paramref name="index" /> 到源 <see cref="T:System.Collections.ArrayList" /> 的末尾的元素数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 的末尾的可用空间。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ArrayList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.ArrayList" /> 中实际包含的元素数。</summary>
        <value><see cref="T:System.Collections.ArrayList" /> 中实际包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> 是的元素数的<xref:System.Collections.ArrayList>可以存储。 <xref:System.Collections.ArrayList.Count%2A> 是中的实际的元素数目<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 始终是大于或等于<xref:System.Collections.ArrayList.Count%2A>。 如果<xref:System.Collections.ArrayList.Count%2A>超出了<xref:System.Collections.ArrayList.Capacity%2A>时添加元素，则自动通过增大容量在复制旧元素和添加新元素之前重新分配内部数组。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FixedSize">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList FixedSize(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ FixedSize(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回具有固定大小的 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns>具有固定大小的 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此包装器可用于防止原始<xref:System.Collections.ArrayList>。 元素仍然可以修改或替换。  
  
 具有固定大小的集合只是一个集合与防止添加和移除元素; 的包装器因此，如果在更改基础集合，包括添加或删除的元素，大小固定集合反映了这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何创建固定大小周围的包装器<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.IList FixedSize (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList FixedSize(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ FixedSize(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member FixedSize : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.FixedSize list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回具有固定大小的 <see cref="T:System.Collections.IList" /> 包装。</summary>
        <returns>具有固定大小的 <see cref="T:System.Collections.IList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此包装器可用于防止原始<xref:System.Collections.IList>。 元素仍然可以修改或替换。  
  
 具有固定大小的集合只是一个集合与防止添加和移除元素; 的包装器因此，如果在更改基础集合，包括添加或删除的元素，大小固定集合反映了这些更改。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回循环访问 <see cref="T:System.Collections.ArrayList" /> 的枚举数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回用于整个 <see cref="T:System.Collections.ArrayList" /> 的枚举数。</summary>
        <returns>用于整个 <see cref="T:System.Collections.ArrayList" /> 的 <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 语言的 `foreach` 语句（在 Visual Basic 中为 `for each`）隐藏了枚举数的复杂性。  因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例获取的枚举数<xref:System.Collections.ArrayList>，和一系列中的元素的枚举器<xref:System.Collections.ArrayList>。  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator (index As Integer, count As Integer) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : int * int -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : int * int -&gt; System.Collections.IEnumerator" Usage="arrayList.GetEnumerator (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">枚举器应引用的 <see cref="T:System.Collections.ArrayList" /> 部分从零开始的起始索引。</param>
        <param name="count">枚举器应引用的 <see cref="T:System.Collections.ArrayList" /> 部分中的元素数。</param>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 中元素范围的枚举器。</summary>
        <returns><see cref="T:System.Collections.ArrayList" /> 中指定的元素范围的 <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach`语句的C#语言 (`for each`视觉对象中C++， `For Each` Visual Basic) 隐藏了枚举器的复杂性。  因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
## <a name="version-compatibility"></a>版本兼容性  
 有关.NET Framework 版本 1.0 和 1.1 中，枚举器中<xref:System.Collections.ArrayList>返回的包装器<xref:System.Collections.ArrayList.Adapter%2A>方法处理第二个参数为上限而不是计数。 在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]作为计数正确处理第二个参数。  
  
   
  
## Examples  
 下面的示例获取的枚举数<xref:System.Collections.ArrayList>，和一系列中的元素的枚举器<xref:System.Collections.ArrayList>。  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效范围。</exception>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ArrayList GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ArrayList GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRange (index As Integer, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ArrayList ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetRange : int * int -&gt; System.Collections.ArrayList&#xA;override this.GetRange : int * int -&gt; System.Collections.ArrayList" Usage="arrayList.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">范围开始处的从零开始的 <see cref="T:System.Collections.ArrayList" /> 索引。</param>
        <param name="count">范围中的元素数。</param>
        <summary>返回一个 <see cref="T:System.Collections.ArrayList" />，它表示源 <see cref="T:System.Collections.ArrayList" /> 中的元素子集。</summary>
        <returns>一个 <see cref="T:System.Collections.ArrayList" />，它表示源 <see cref="T:System.Collections.ArrayList" /> 中的元素子集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会创建元素的副本。 新<xref:System.Collections.ArrayList>是一个视图窗口将源<xref:System.Collections.ArrayList>。 但是，对源的所有后续更改<xref:System.Collections.ArrayList>必须通过此视图窗口<xref:System.Collections.ArrayList>。 如果直接对源进行更改<xref:System.Collections.ArrayList>，视图窗口<xref:System.Collections.ArrayList>失效，并对它的任何操作将返回<xref:System.InvalidOperationException>。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一系列元素中<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中某个值的第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="arrayList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回整个 <see cref="T:System.Collections.ArrayList" /> 中第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为整个 <paramref name="value" /> 中 <see cref="T:System.Collections.ArrayList" /> 第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>向前的第一个元素开始和结束时间的最后一个元素搜索。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int -&gt; int&#xA;override this.IndexOf : obj * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从指定索引到最后一个元素的元素范围中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中从 <paramref name="startIndex" /> 到最后一个元素的元素范围内找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是中的元素数目`startIndex`到末尾<xref:System.Collections.ArrayList>。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj * int * int -&gt; int&#xA;override this.IndexOf : obj * int * int -&gt; int" Usage="arrayList.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从指定索引开始，并包含指定元素数的元素范围中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中从 <paramref name="startIndex" /> 开始并包含 <paramref name="count" /> 个元素的元素范围内找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>处开始向前搜索`startIndex`结束时间`startIndex`plus`count`减 1，如果`count`大于 0。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="arrayList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="value" /> 的从零开始的索引。</param>
        <param name="value">要插入的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <summary>将元素插入 <see cref="T:System.Collections.ArrayList" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>已等于<xref:System.Collections.ArrayList.Capacity%2A>，则容量的<xref:System.Collections.ArrayList>自动重新分配内部数组中，增加和现有元素之前添加新元素将复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.ArrayList.Count%2A>，`value`添加到末尾<xref:System.Collections.ArrayList>。  
  
 在由连续的元素组成的集合（如列表）中，插入点下面的元素将下移以容纳新的元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素插入<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public virtual void InsertRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InsertRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InsertRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member InsertRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.InsertRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.InsertRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">应在此处插入新元素的从零开始的索引。</param>
        <param name="c"><see cref="T:System.Collections.ICollection" />，应将其元素插入到 <see cref="T:System.Collections.ArrayList" /> 中。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>将集合中的元素插入 <see cref="T:System.Collections.ArrayList" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>，则容量的<xref:System.Collections.ArrayList>增加通过自动重新分配要容纳新元素的内部数组和之前添加新元素，现有元素将复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.ArrayList.Count%2A>，元素将被添加到末尾<xref:System.Collections.ArrayList>。  
  
 中的元素的顺序<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>。  
  
 在由连续的元素组成的集合（如列表）中，插入点下面的元素将下移以容纳新的元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n` + `m`) 操作，其中`n`是要添加的元素数并`m`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素插入<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.ArrayList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.ArrayList" /> 是否具有固定大小。</summary>
        <value>如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合在创建之后不能再添加或移除元素，但是允许修改现有元素。  
  
 具有固定大小的集合只是一个集合与防止添加和移除元素; 的包装器因此，如果在更改基础集合，包括添加或删除的元素，大小固定集合反映了这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建固定大小周围的包装器<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.ArrayList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.ArrayList" /> 是否为只读。</summary>
        <value>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的只是一个集合与可防止修改集合; 的包装器因此，如果对基础集合进行更改，只读集合反映了这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建周围的只读包装<xref:System.Collections.ArrayList>以及如何确定如果<xref:System.Collections.ArrayList>是只读的。  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.ArrayList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ArrayList" /> 的访问（线程安全）。</summary>
        <value>如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要保证的线程安全<xref:System.Collections.ArrayList>，必须通过返回的包装器完成所有操作<xref:System.Collections.ArrayList.Synchronized%2A>方法。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 下面的代码示例显示了如何同步<xref:System.Collections.ArrayList>，确定是否<xref:System.Collections.ArrayList>同步以及如何使用同步<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Collections.ArrayList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Item%2A> 返回 <xref:System.Object>，因此，您可能需要将返回的值强制转换为原始类型以便对其进行操作。 请务必注意，<xref:System.Collections.ArrayList> 不是个强类型集合。 有关强类型替代项，请参见 <xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 可以使用下面的语法通过此属性访问集合中的特定元素：`myCollection[index]`。  
  
 C#语言中使用[ `this` ](~/docs/csharp/language-reference/keywords/this.md)关键字来定义而不是实现索引器<xref:System.Collections.ArrayList.Item%2A>属性。 Visual Basic 将 <xref:System.Collections.ArrayList.Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 检索此属性的值是 o （1） 的操作;将属性设置也是 o （1） 操作。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Collections.ArrayList>，并将添加多个项。 该示例演示具有访问元素<xref:System.Collections.ArrayList.Item%2A>属性 （索引器在 C# 中），并通过将分配到一个新值更改元素<xref:System.Collections.ArrayList.Item%2A>指定索引的属性。 该示例还表明，<xref:System.Collections.ArrayList.Item%2A>属性不能用于访问或添加外部列表的当前大小的元素。  
  
 [!code-cpp[System.Collections.ArrayList.Item#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source.cs#1)]
 [!code-vb[System.Collections.ArrayList.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source.vb#1)]  
  
 下面的示例使用<xref:System.Collections.ArrayList.Item%2A>属性显式将值分配给列表中的项。 该示例定义继承的类<xref:System.Collections.ArrayList>并添加一个方法要混排列表项。  
  
 [!code-cpp[System.Collections.ArrayList.Item#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source2.cpp#2)]
 [!code-csharp[System.Collections.ArrayList.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source2.cs#2)]
 [!code-vb[System.Collections.ArrayList.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中某个值的最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj -&gt; int&#xA;override this.LastIndexOf : obj -&gt; int" Usage="arrayList.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>在整个 <see cref="T:System.Collections.ArrayList" /> 中搜索指定的 <see cref="T:System.Object" />，并返回最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在整个 <see cref="T:System.Collections.ArrayList" /> 中找到 <paramref name="value" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int -&gt; int&#xA;override this.LastIndexOf : obj * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的从零开始索引。</summary>
        <returns>如果找到，则返回在 <see cref="T:System.Collections.ArrayList" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围内找到 <paramref name="value" /> 的最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>是搜索处开始向后`startIndex`和结束时间的第一个元素。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是从开头的元素数目<xref:System.Collections.ArrayList>到`startIndex`。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : obj * int * int -&gt; int&#xA;override this.LastIndexOf : obj * int * int -&gt; int" Usage="arrayList.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中到指定索引为止包含指定元素数的这部分元素中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中到 <paramref name="startIndex" /> 为止包含 <paramref name="count" /> 个元素的这部分元素中找到 <paramref name="value" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>是搜索处开始向后`startIndex`结束时间`startIndex`减去`count`加上 1，如果`count`大于 0。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>上的方法`item`以确定是否存在项。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。 请注意，`LastIndexOf`是向后搜索; 因此，`count`必须小于或等于`startIndex`+ 1。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadOnly">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回只读的列表包装。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList ReadOnly(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ ReadOnly(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回只读的 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns><paramref name="list" /> 周围的只读 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对进行任何修改`list`，公开`list`只能通过此包装器。  
  
 集合是只读的只是一个集合与可防止对集合进行修改的包装器。 如果对基础集合进行更改，只读集合反映了这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何创建周围的只读包装<xref:System.Collections.ArrayList>以及如何确定如果<xref:System.Collections.ArrayList>是只读的。  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.IList ReadOnly (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList ReadOnly(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ ReadOnly(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.ReadOnly list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回只读的 <see cref="T:System.Collections.IList" /> 包装。</summary>
        <returns><paramref name="list" /> 周围的只读 <see cref="T:System.Collections.IList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对进行任何修改`list`，公开`list`只能通过此包装器。  
  
 集合是只读的只是一个集合与可防止对集合进行修改的包装器。 如果对基础集合进行更改，只读集合反映了这些更改。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="arrayList.Remove obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要从 <see cref="T:System.Object" /> 移除的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Collections.ArrayList>不包含指定的对象，<xref:System.Collections.ArrayList>保持不变。 不引发异常。  
  
 此方法执行线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用来确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
   
  
## Examples  
 下面的代码示例演示如何从元素移除<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="arrayList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的从零开始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.ArrayList" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移除该元素后，调整集合的大小和的值<xref:System.Collections.ArrayList.Count%2A>属性减少 1。  
  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何从元素移除<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : int * int -&gt; unit&#xA;override this.RemoveRange : int * int -&gt; unit" Usage="arrayList.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素范围的从零开始的起始索引。</param>
        <param name="count">要移除的元素数。</param>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除一定范围的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何从元素移除<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <Member MemberName="Repeat">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Repeat (object value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Repeat(object value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Repeat (value As Object, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Repeat(System::Object ^ value, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : obj * int -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Repeat (value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在新的 <see cref="T:System.Collections.ArrayList" /> 中对其进行多次复制的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <param name="count"><paramref name="value" /> 应复制的次数。</param>
        <summary>返回 <see cref="T:System.Collections.ArrayList" />，其元素是指定值的副本。</summary>
        <returns>具有 <paramref name="count" /> 个元素数的 <see cref="T:System.Collections.ArrayList" />，所有元素都是 <paramref name="value" /> 的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一个新<xref:System.Collections.ArrayList>具有相同值。  
  
 [!code-cpp[Classic ArrayList.Repeat Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Repeat Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Repeat Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中元素的顺序反转。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse();" />
      <MemberSignature Language="F#" Value="abstract member Reverse : unit -&gt; unit&#xA;override this.Reverse : unit -&gt; unit" Usage="arrayList.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将整个 <see cref="T:System.Collections.ArrayList" /> 中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序，以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示该范围内的任何索引移动到<xref:System.Collections.ArrayList>[j]，其中 j 等于`index`  +  `index`  +  `count` -i-1。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何反转排序顺序中的值的<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Reverse : int * int -&gt; unit&#xA;override this.Reverse : int * int -&gt; unit" Usage="arrayList.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要反转的范围的从零开始的起始索引。</param>
        <param name="count">要反转的范围内的元素数。</param>
        <summary>将指定范围中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序，以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示该范围内的任何索引移动到<xref:System.Collections.ArrayList>[j]，其中 j 等于`index`  +  `index`  +  `count` -i-1。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何反转排序顺序中的元素范围内的值的<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetRange">
      <MemberSignature Language="C#" Value="public virtual void SetRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetRange(int index, System::Collections::ICollection ^ c);" />
      <MemberSignature Language="F#" Value="abstract member SetRange : int * System.Collections.ICollection -&gt; unit&#xA;override this.SetRange : int * System.Collections.ICollection -&gt; unit" Usage="arrayList.SetRange (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的 <see cref="T:System.Collections.ArrayList" /> 索引，从此索引处开始复制 <paramref name="c" /> 的元素。</param>
        <param name="c"><see cref="T:System.Collections.ICollection" />，它的元素要复制到 <see cref="T:System.Collections.ArrayList" />。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>复制 <see cref="T:System.Collections.ArrayList" /> 中一个子集合的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`为有效的值，并允许重复元素。  
  
 中的元素的顺序<xref:System.Collections.ICollection>保留在<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n` + 1) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一系列元素中<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 加上 <paramref name="c" /> 中的元素数大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中的元素进行排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="arrayList.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>对整个 <see cref="T:System.Collections.ArrayList" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，它使用快速排序算法。 快速排序算法进行了比较排序 （也称为不稳定排序），这意味着，一个"小于或等于"比较操作将确定这两个元素应首先出现在最后一个已排序的列表。 但是，如果两个元素相等，则可能不会保留其原始顺序。 与此相反，一个稳定排序保留相等元素的顺序。 若要执行一个稳定排序，必须实现一个自定义<xref:System.Collections.IComparer>接口，以便使用与此方法的其他重载。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏的情况是 O (`n`^2) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何对中的值进行排序<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Sort Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Sort Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Sort Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : System.Collections.IComparer -&gt; unit&#xA;override this.Sort : System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
一个空引用（在 Visual Basic 中为 <see langword="Nothing" />），将使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器对整个 <see cref="T:System.Collections.ArrayList" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Collections.ArrayList.Sort%2A> 方法通过实现 <xref:System.Collections.IComparer> 接口的自定义比较器对对象的列表进行排序。 如果为 `null` 传递 `comparer`，则此方法将使用每个元素的 <xref:System.IComparable> 实现。 在此情况下，您必须确保列表中包含的对象实现 <xref:System.Collections.IComparer> 接口，否则将发生异常。  
  
 此外，使用 <xref:System.IComparable> 实现意味着此列表将执行比较排序（也称为“不稳定排序”）；也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。 若要执行一个稳定排序，必须实现一个自定义<xref:System.Collections.IComparer>接口。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏的情况是 O (`n`^2) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何对中的值进行排序<xref:System.Collections.ArrayList>使用默认比较器和将反转排序顺序的自定义比较器。  
  
 [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CPP/arraylist_sort2.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CS/arraylist_sort2.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/VB/arraylist_sort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <exception cref="T:System.InvalidOperationException">比较两个元素时出错。</exception>
        <exception cref="T:System.ArgumentException">将为 <see langword="null" /> 传递 <paramref name="comparer" />，并且列表中的元素不实现 <see cref="T:System.IComparable" />。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (int index, int count, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(int32 index, int32 count, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (index As Integer, count As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(int index, int count, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="abstract member Sort : int * int * System.Collections.IComparer -&gt; unit&#xA;override this.Sort : int * int * System.Collections.IComparer -&gt; unit" Usage="arrayList.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">要排序范围的从零开始的起始索引。</param>
        <param name="count">要排序的范围的长度。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
一个空引用（在 Visual Basic 中为 <see langword="Nothing" />），将使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器对 <see cref="T:System.Collections.ArrayList" /> 中某个范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`设置为`null`，此方法将执行比较排序 （也称为不稳定排序）; 也就是说，如果两个元素相等，其顺序可能不会保留。 与此相反，一个稳定排序保留相等元素的顺序。 若要执行一个稳定排序，必须实现一个自定义<xref:System.Collections.IComparer>接口。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是`count`; 最坏的情况是 O(n^2) 的操作。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序的元素范围中的值<xref:System.Collections.ArrayList>使用默认比较器和将反转排序顺序的自定义比较器。  
  
 [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CPP/arraylist_sort3.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CS/arraylist_sort3.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/VB/arraylist_sort3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效范围。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <exception cref="T:System.InvalidOperationException">比较两个元素时出错。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Synchronized">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回同步的（线程安全）列表包装。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Synchronized(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Synchronized(System::Collections::ArrayList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.ArrayList -&gt; System.Collections.ArrayList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要同步的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回同步的（线程安全）<see cref="T:System.Collections.ArrayList" /> 包装器。</summary>
        <returns>同步的（线程安全）<see cref="T:System.Collections.ArrayList" /> 包装器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要保证的线程安全<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 此方法为 o （1） 运算。  
  
 下面的代码示例显示了如何同步<xref:System.Collections.ArrayList>，确定是否<xref:System.Collections.ArrayList>同步以及如何使用同步<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.IList Synchronized (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList Synchronized(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ Synchronized(System::Collections::IList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.IList -&gt; System.Collections.IList" Usage="System.Collections.ArrayList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要同步的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回同步的（线程安全）<see cref="T:System.Collections.IList" /> 包装器。</summary>
        <returns>同步的（线程安全）<see cref="T:System.Collections.IList" /> 包装器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要保证的线程安全<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.ArrayList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Collections.ArrayList" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Collections.ArrayList" /> 的访问的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建的同步的版本<xref:System.Collections.ArrayList>，使用<xref:System.Collections.ArrayList.Synchronized%2A>方法。 但是，派生的类可以提供其自己的同步的版本<xref:System.Collections.ArrayList>使用<xref:System.Collections.ArrayList.SyncRoot%2A>属性。 同步代码必须在执行操作<xref:System.Collections.ArrayList.SyncRoot%2A>的<xref:System.Collections.ArrayList>，而不是直接在<xref:System.Collections.ArrayList>。 这样可确保对从其他对象派生的集合正确地执行操作。 具体而言，它维护与其他线程可能同时对修改的正确同步<xref:System.Collections.ArrayList>对象。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToArray">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到新数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="arrayList.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到新 <see cref="T:System.Object" /> 数组中。</summary>
        <returns>一个包含 <see cref="T:System.Collections.ArrayList" /> 的元素副本的 <see cref="T:System.Object" /> 数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual Array ToArray (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array ToArray(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ ToArray(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ToArray : Type -&gt; Array&#xA;override this.ToArray : Type -&gt; Array" Usage="arrayList.ToArray type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要创建和复制元素的目标数组的元素 <see cref="T:System.Type" />。</param>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到新的指定元素类型数组中。</summary>
        <returns>包含 <see cref="T:System.Collections.ArrayList" /> 的元素副本的指定元素类型数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的对象的所有<xref:System.Collections.ArrayList>对象强制转换为<xref:System.Type>中指定`type`参数。  
  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 以下复制示例演示如何将复制的元素<xref:System.Collections.ArrayList>为字符串数组。  
  
 [!code-cpp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CPP/arraylist_toarray.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CS/arraylist_toarray.cs#1)]
 [!code-vb[System.Collections.ArrayList.ToArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/VB/arraylist_toarray.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Collections.ArrayList" /> 的类型无法自动转换为指定类型。</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="arrayList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将容量设置为 <see cref="T:System.Collections.ArrayList" /> 中元素的实际数目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于最小化集合的内存开销如果任何新元素将不添加到集合。  
  
 若要重置<xref:System.Collections.ArrayList>为其初始状态，请在调用<xref:System.Collections.ArrayList.Clear%2A>方法之前调用<xref:System.Collections.ArrayList.TrimToSize%2A>。 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认容量。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何剪裁的未使用的部分<xref:System.Collections.ArrayList>以及如何清除的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.ArrayList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Clear" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
  </Members>
</Type>