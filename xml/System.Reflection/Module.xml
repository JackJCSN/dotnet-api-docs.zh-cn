<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ed76cedd2d6d731739b8397e573e226ea679dd6c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69107906" /></Metadata><TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Module = class&#xA;    interface ISerializable&#xA;    interface ICustomAttributeProvider&#xA;    interface _Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="efc82-101">在模块上执行反射。</span><span class="sxs-lookup"><span data-stu-id="efc82-101">Performs reflection on a module.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-102">模块是可移植的可执行文件, 例如类型 .dll 或 setup.exe, 其中包含一个或多个类和接口。</span><span class="sxs-lookup"><span data-stu-id="efc82-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="efc82-103">单个模块可包含多个命名空间，而一个命名空间可跨越多个模块。</span><span class="sxs-lookup"><span data-stu-id="efc82-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="efc82-104">作为一个单元部署的一个或多个模块组成一个程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="efc82-105">有关创建包含多个模块的程序集的信息, 请参阅多[文件程序集](~/docs/framework/app-domains/multifile-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="efc82-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="efc82-106">请注意, .NET Framework 模块与 Visual Basic 中的模块不同, 程序员使用它在应用程序中组织函数和子例程。</span><span class="sxs-lookup"><span data-stu-id="efc82-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-107">下面的代码示例演示如何使用反射来获取有关模块的信息:</span><span class="sxs-lookup"><span data-stu-id="efc82-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="efc82-108">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="efc82-108">for full trust for inheritors.</span></span> <span data-ttu-id="efc82-109">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="efc82-109">This class cannot be inherited by partially trusted code.</span></span></permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-110">初始化 <see cref="T:System.Reflection.Module" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="efc82-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-111">此构造函数在<xref:System.Reflection.Module>对象的构造过程中由派生类调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-112">为此 <see cref="T:System.Reflection.Module" /> 实例获取适当的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span></span></summary>
        <value><span data-ttu-id="efc82-113"><see langword="Assembly" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-113">An <see langword="Assembly" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-114">下面的示例显示指定模块中指定程序集的全名。</span><span class="sxs-lookup"><span data-stu-id="efc82-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-115">获取包含此模型自定义属性的集合。</span><span class="sxs-lookup"><span data-stu-id="efc82-115">Gets a collection that contains this module's custom attributes.</span></span></summary>
        <value><span data-ttu-id="efc82-116">包含此模块的自定义特性的集合。</span><span class="sxs-lookup"><span data-stu-id="efc82-116">A collection that contains this module's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="module.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="efc82-117">与该实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-117">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="efc82-118">确定此模块和指定的对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="efc82-118">Determines whether this module and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="efc82-119">如果 <see langword="true" /> 与此实例相等，则为 <paramref name="o" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-119"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeName : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-120">一个 <see langword="TypeFilter" /> 对象，该对象根据名称筛选在此模块中定义的类型列表。</span><span class="sxs-lookup"><span data-stu-id="efc82-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="efc82-121">此字段区分大小写且为只读。</span><span class="sxs-lookup"><span data-stu-id="efc82-121">This field is case-sensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-122">筛选器支持后缀 "\*" 通配符。</span><span class="sxs-lookup"><span data-stu-id="efc82-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-123">下面的示例显示与指定搜索条件相匹配的模块名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeNameIgnoreCase : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-124">一个 <see langword="TypeFilter" /> 对象，该对象根据名称筛选在此模块中定义的类型列表。</span><span class="sxs-lookup"><span data-stu-id="efc82-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="efc82-125">此字段不区分大小写且为只读。</span><span class="sxs-lookup"><span data-stu-id="efc82-125">This field is case-insensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-126">筛选器支持后缀 "\*" 通配符。</span><span class="sxs-lookup"><span data-stu-id="efc82-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-127">下面的示例显示与指定的搜索条件匹配的模块名称 (忽略大小写)。</span><span class="sxs-lookup"><span data-stu-id="efc82-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="module.FindTypes (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="efc82-128">用于筛选类的委托。</span><span class="sxs-lookup"><span data-stu-id="efc82-128">The delegate used to filter the classes.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="efc82-129">用于筛选类的对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-129">An Object used to filter the classes.</span></span></param>
        <summary><span data-ttu-id="efc82-130">返回给定筛选器和筛选条件接受的类数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-130">Returns an array of classes accepted by the given filter and filter criteria.</span></span></summary>
        <returns><span data-ttu-id="efc82-131">类型 <see langword="Type" /> 的数组，包含已被筛选器接受的类。</span><span class="sxs-lookup"><span data-stu-id="efc82-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-132"><xref:System.Reflection.ReflectionTypeLoadException>是一个特殊的类加载异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="efc82-133">`ReflectionTypeLoadException.Types`属性包含已在模块中定义并加载的类的数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="efc82-134">此数组可能包含一些 null 值。</span><span class="sxs-lookup"><span data-stu-id="efc82-134">This array may contain some null values.</span></span> <span data-ttu-id="efc82-135">`ReflectionTypeLoadException.LoaderExceptions`属性是一个异常数组, 表示由类加载程序引发的异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="efc82-136">类数组中的孔与异常一起排列。</span><span class="sxs-lookup"><span data-stu-id="efc82-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="efc82-137">给定`filter`的委托针对模块中的每个类进行调用, `Type`同时传递表示类的对象以及给定`filterCriteria`的。</span><span class="sxs-lookup"><span data-stu-id="efc82-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="efc82-138">如果`filter`返回特定类, 则该类将包含在返回的数组中。</span><span class="sxs-lookup"><span data-stu-id="efc82-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="efc82-139">如果`filter` `filterCriteria`返回`null`, 则返回并忽略所有类。</span><span class="sxs-lookup"><span data-stu-id="efc82-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="efc82-140">`FindTypes`不能用于查找参数化类型 (如数组)。</span><span class="sxs-lookup"><span data-stu-id="efc82-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-141">下面的示例演示`FindTypes`方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="efc82-142">无法加载模块中的一个或多个类。</span><span class="sxs-lookup"><span data-stu-id="efc82-142">One or more classes in a module could not be loaded.</span></span></exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-143">获取表示此模块的完全限定名和路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-143">Gets a string representing the fully qualified name and path to this module.</span></span></summary>
        <value><span data-ttu-id="efc82-144">完全限定的模块名。</span><span class="sxs-lookup"><span data-stu-id="efc82-144">The fully qualified module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-145">若要获取名称而不使用路径, <xref:System.Reflection.Module.Name%2A>请使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="efc82-146">如果此模块的程序集是从字节数组加载的, 则`FullyQualifiedName`该模块的将为:\<未知的 >。</span><span class="sxs-lookup"><span data-stu-id="efc82-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-147">模块名称的大小写与平台相关。</span><span class="sxs-lookup"><span data-stu-id="efc82-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-148">下面的示例显示指定模块的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="efc82-149">调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="efc82-149">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="efc82-150">用于访问路径中的信息。</span><span class="sxs-lookup"><span data-stu-id="efc82-150">for access to information in the path.</span></span> <span data-ttu-id="efc82-151">关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-152">返回自定义属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-152">Returns custom attributes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="module.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="efc82-153">对于该类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-153">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="efc82-154">返回所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-154">Returns all custom attributes.</span></span></summary>
        <returns><span data-ttu-id="efc82-155">包含所有自定义属性的 <see langword="Object" /> 类型的数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-155">An array of type <see langword="Object" /> containing all custom attributes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-156">下面的示例显示与指定搜索条件相匹配的模块名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="module.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="efc82-157">要获取的特性的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-157">The type of attribute to get.</span></span></param>
        <param name="inherit"><span data-ttu-id="efc82-158">对于该类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-158">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="efc82-159">获取指定类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-159">Gets custom attributes of the specified type.</span></span></summary>
        <returns><span data-ttu-id="efc82-160"><see langword="Object" /> 类型的数组，包含指定类型的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-161">下面的示例显示与指定的搜索条件匹配的指定类型的模块名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-162"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-162"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-163"><paramref name="attributeType" /> 不是由运行时提供的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-163"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="efc82-164">例如，<paramref name="attributeType" /> 是一个 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="module.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-165">返回当前模块的 <see cref="T:System.Reflection.CustomAttributeData" /> 对象列表，这些对象可以在只反射上下文中使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span></span></summary>
        <returns><span data-ttu-id="efc82-166"><see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，表示已应用到当前模块的特性的相关数据。</span><span class="sxs-lookup"><span data-stu-id="efc82-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-167">如果自定义属性本身是在加载到仅反射上下文中的代码中定义的, 则使用此方法在仅反射上下文中检查代码的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="efc82-168">此类情况下<xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType>不能使用和等方法,因为它们会创建属性的实例。<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="efc82-169">仅反射上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="efc82-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="efc82-170">有关详细信息和示例代码, 请参阅<xref:System.Reflection.CustomAttributeData>类。</span><span class="sxs-lookup"><span data-stu-id="efc82-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-171">返回指定的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-171">Returns a specified field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="module.GetField name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-172">字段名。</span><span class="sxs-lookup"><span data-stu-id="efc82-172">The field name.</span></span></param>
        <summary><span data-ttu-id="efc82-173">返回具有指定名称的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-173">Returns a field having the specified name.</span></span></summary>
        <returns><span data-ttu-id="efc82-174">具有指定名称的 <see langword="FieldInfo" /> 对象，如果该字段不存在则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-175"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-175">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="module.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-176">字段名。</span><span class="sxs-lookup"><span data-stu-id="efc82-176">The field name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="efc82-177">用来控制搜索的其中一个 <see langword="BindingFlags" /> 位标志。</span><span class="sxs-lookup"><span data-stu-id="efc82-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <summary><span data-ttu-id="efc82-178">返回具有指定名称和绑定特性的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-178">Returns a field having the specified name and binding attributes.</span></span></summary>
        <returns><span data-ttu-id="efc82-179">具有指定名称和绑定特性的 <see langword="FieldInfo" /> 对象，如果该字段不存在则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-180"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-180">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-181">返回在模块上定义的全局字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-181">Returns the global fields defined on the module.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-182">返回在模块上定义的全局字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-182">Returns the global fields defined on the module.</span></span></summary>
        <returns><span data-ttu-id="efc82-183">表示在模块上定义的全局字段的 <see cref="T:System.Reflection.FieldInfo" /> 对象数组；如果没有全局字段，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-184"><xref:System.Reflection.Module.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="efc82-185">你的代码不能依赖于字段的返回顺序, 因为该顺序可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="efc82-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="efc82-186">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="efc82-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="efc82-187">返回在与指定绑定标志匹配的模块上定义的全局字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-187">Returns the global fields defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="efc82-188">类型 <see cref="T:System.Reflection.FieldInfo" /> 的数组，表示在与指定的绑定标志匹配的模块上定义的全局字段；如果没有全局字段匹配绑定标志，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-189"><xref:System.Reflection.Module.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="efc82-190">你的代码不能依赖于字段的返回顺序, 因为该顺序可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="efc82-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="module.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-191">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="efc82-191">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="efc82-192">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="efc82-192">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-193">返回具有指定条件的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-193">Returns a method having the specified criteria.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-194">方法名。</span><span class="sxs-lookup"><span data-stu-id="efc82-194">The method name.</span></span></param>
        <summary><span data-ttu-id="efc82-195">返回具有指定名称的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-195">Returns a method having the specified name.</span></span></summary>
        <returns><span data-ttu-id="efc82-196">具有指定名称的 <see langword="MethodInfo" /> 对象，如果该方法不存在则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-197"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-197"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-198">方法名。</span><span class="sxs-lookup"><span data-stu-id="efc82-198">The method name.</span></span></param>
        <param name="types"><span data-ttu-id="efc82-199">要搜索的参数类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-199">The parameter types to search for.</span></span></param>
        <summary><span data-ttu-id="efc82-200">返回具有指定名称和参数类型的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-200">Returns a method having the specified name and parameter types.</span></span></summary>
        <returns><span data-ttu-id="efc82-201">一个符合指定条件的 <see langword="MethodInfo" /> 对象，如果方法不存在则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-202"><paramref name="name" /> 为 <see langword="null" />，<paramref name="types" /> 为 <see langword="null" />，或 <paramref name="types" /> (i) 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-202"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-203">方法名。</span><span class="sxs-lookup"><span data-stu-id="efc82-203">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="efc82-204">用来控制搜索的其中一个 <see langword="BindingFlags" /> 位标志。</span><span class="sxs-lookup"><span data-stu-id="efc82-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="efc82-205">一个实现 <see langword="Binder" /> 的对象，包含与此方法相关的属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="efc82-206">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="efc82-206">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="efc82-207">要搜索的参数类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-207">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="efc82-208">参数修饰符的数组，用于使绑定可与在其中修改了类型的参数签名一起使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="efc82-209">返回具有指定名称、绑定信息、调用约定和参数类型及修饰符的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="efc82-210">一个符合指定条件的 <see langword="MethodInfo" /> 对象，如果方法不存在则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-211"><paramref name="name" /> 为 <see langword="null" />，<paramref name="types" /> 为 <see langword="null" />，或 <paramref name="types" /> (i) 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-211"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="efc82-212">方法名。</span><span class="sxs-lookup"><span data-stu-id="efc82-212">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="efc82-213">用来控制搜索的其中一个 <see langword="BindingFlags" /> 位标志。</span><span class="sxs-lookup"><span data-stu-id="efc82-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="efc82-214">一个实现 <see langword="Binder" /> 的对象，包含与此方法相关的属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="efc82-215">方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="efc82-215">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="efc82-216">要搜索的参数类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-216">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="efc82-217">参数修饰符的数组，用于使绑定可与在其中修改了类型的参数签名一起使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="efc82-218">返回符合指定条件的方法实现。</span><span class="sxs-lookup"><span data-stu-id="efc82-218">Returns the method implementation in accordance with the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="efc82-219">包含指定的实现信息的 <see langword="MethodInfo" /> 对象；如果该方法不存在，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="efc82-220"><paramref name="types" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-220"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-221">返回在模块中定义的全局方法</span><span class="sxs-lookup"><span data-stu-id="efc82-221">Returns the global methods defined on the module</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-222">返回在模块中定义的全局方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-222">Returns the global methods defined on the module.</span></span></summary>
        <returns><span data-ttu-id="efc82-223">一个表示模块中定义的所有全局方法的 <see cref="T:System.Reflection.MethodInfo" /> 对象数组；如果没有全局方法，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="efc82-224">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="efc82-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="efc82-225">返回在与指定的绑定标志匹配的模块上定义的全局方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-225">Returns the global methods defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="efc82-226">类型 <see cref="T:System.Reflection.MethodInfo" /> 的数组，表示在与指定的绑定标志匹配的模块上定义的全局方法；如果没有全局方法匹配绑定标志，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="module.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="efc82-227">序列化或反序列化对象所需的信息和数据。</span><span class="sxs-lookup"><span data-stu-id="efc82-227">The information and data needed to serialize or deserialize an object.</span></span></param>
        <param name="context"><span data-ttu-id="efc82-228">序列化的上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-228">The context for the serialization.</span></span></param>
        <summary><span data-ttu-id="efc82-229">提供序列化对象的 <see cref="T:System.Runtime.Serialization.ISerializable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="efc82-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-230"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="efc82-231">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="efc82-231">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="efc82-232">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="abstract member GetPEKind :  *  -&gt; unit&#xA;override this.GetPEKind :  *  -&gt; unit" Usage="module.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="peKind"><span data-ttu-id="efc82-233">当此方法返回时，为 <see cref="T:System.Reflection.PortableExecutableKinds" /> 值的组合，用于指示模块中代码的性质。</span><span class="sxs-lookup"><span data-stu-id="efc82-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span></span></param>
        <param name="machine"><span data-ttu-id="efc82-234">当此方法返回时，为 <see cref="T:System.Reflection.ImageFileMachine" /> 值中的一个，用于指示模块的目标平台。</span><span class="sxs-lookup"><span data-stu-id="efc82-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span></span></param>
        <summary><span data-ttu-id="efc82-235">获取一对值，这一对值指示某个模块中代码的性质和该模块的目标平台。</span><span class="sxs-lookup"><span data-stu-id="efc82-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="abstract member GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate&#xA;override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="module.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-236">返回与证书（包括在此模块所属的程序集的验证码签名中）对应的 <see langword="X509Certificate" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span></span> <span data-ttu-id="efc82-237">如果此程序集没有进行验证码签名，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span></span></summary>
        <returns><span data-ttu-id="efc82-238"><see langword="X509Certificate" /> 对象；如果此模块所属的程序集没有进行验证码签名，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-239">返回指定的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-239">Returns the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="module.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="efc82-240">要查找的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-240">The name of the type to locate.</span></span> <span data-ttu-id="efc82-241">名称必须用命名空间加以完全限定。</span><span class="sxs-lookup"><span data-stu-id="efc82-241">The name must be fully qualified with the namespace.</span></span></param>
        <summary><span data-ttu-id="efc82-242">返回指定的类型，执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="efc82-242">Returns the specified type, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="efc82-243">表示给定类型的 <see langword="Type" /> 对象（如果类型位于此模块中）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="efc82-244">如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="efc82-245">有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="efc82-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="efc82-246">可以使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>从特定模块中检索类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="efc82-247">对<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>包含清单的模块调用将不会搜索整个程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="efc82-248">若要从程序集中检索某一类型, 而不考虑它所在的模块, 则<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>必须调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-249">下面的示例显示指定模块中的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-250"><paramref name="className" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-250"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="efc82-251">调用类初始值设定项，并且引发异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-251">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-252"><paramref name="className" /> 是一个长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-252"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="efc82-253"><paramref name="className" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="efc82-253"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="efc82-254"><paramref name="className" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-254"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="efc82-255">或</span><span class="sxs-lookup"><span data-stu-id="efc82-255">-or-</span></span> 
<span data-ttu-id="efc82-256">当前程序集被加载到仅反射上下文中，并且 <paramref name="className" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="efc82-257"><paramref name="className" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-257"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="efc82-258">或</span><span class="sxs-lookup"><span data-stu-id="efc82-258">-or-</span></span> 
 <span data-ttu-id="efc82-259"><paramref name="className" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="efc82-259"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="module.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="efc82-260">要查找的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-260">The name of the type to locate.</span></span> <span data-ttu-id="efc82-261">名称必须用命名空间加以完全限定。</span><span class="sxs-lookup"><span data-stu-id="efc82-261">The name must be fully qualified with the namespace.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="efc82-262">对于不区分大小写的搜索，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-262"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="efc82-263">返回指定的类型，通过指定的区分大小写搜索模块。</span><span class="sxs-lookup"><span data-stu-id="efc82-263">Returns the specified type, searching the module with the specified case sensitivity.</span></span></summary>
        <returns><span data-ttu-id="efc82-264">表示给定类型的 <see langword="Type" /> 对象（如果类型位于此模块中）；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="efc82-265">如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="efc82-266">有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="efc82-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="efc82-267">可以使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>从特定模块中检索类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="efc82-268">对<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>包含清单的模块调用将不会搜索整个程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="efc82-269">若要从程序集中检索某一类型, 而不考虑它所在的模块, 则<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>必须调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-270">下面的示例显示指定模块中的类型名称, 并`false` `ignoreCase`为参数指定, 以便不忽略此大小写。</span><span class="sxs-lookup"><span data-stu-id="efc82-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-271"><paramref name="className" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-271"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="efc82-272">调用类初始值设定项，并且引发异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-272">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-273"><paramref name="className" /> 是一个长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-273"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="efc82-274"><paramref name="className" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="efc82-274"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="efc82-275"><paramref name="className" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-275"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="efc82-276">或</span><span class="sxs-lookup"><span data-stu-id="efc82-276">-or-</span></span> 
<span data-ttu-id="efc82-277">当前程序集被加载到仅反射上下文中，并且 <paramref name="className" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="efc82-278"><paramref name="className" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-278"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="efc82-279">或</span><span class="sxs-lookup"><span data-stu-id="efc82-279">-or-</span></span> 
 <span data-ttu-id="efc82-280"><paramref name="className" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="efc82-280"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="module.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="efc82-281">要查找的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-281">The name of the type to locate.</span></span> <span data-ttu-id="efc82-282">名称必须用命名空间加以完全限定。</span><span class="sxs-lookup"><span data-stu-id="efc82-282">The name must be fully qualified with the namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="efc82-283">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-283"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="efc82-284">对于不区分大小写的搜索，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-284"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="efc82-285">返回指定的类型，指定是否对该模块进行区分大小写的搜索；如果找不到该类型，则指定是否引发异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span></span></summary>
        <returns><span data-ttu-id="efc82-286">如果已在此模块中声明指定类型，则为一个表示指定类型的 <see cref="T:System.Type" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-287">此`throwOnError`参数仅影响找不到该类型时所发生的情况。</span><span class="sxs-lookup"><span data-stu-id="efc82-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="efc82-288">它不会影响可能引发的任何其他异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="efc82-289">特别是, 如果找到该类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也可能引发该类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-290">如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="efc82-291">有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="efc82-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="efc82-292">可以使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>从特定模块中检索类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="efc82-293">对<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>包含清单的模块调用将不会搜索整个程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="efc82-294">若要从程序集中检索某一类型, 而不考虑它所在的模块, 则<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>必须调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-295">下面的示例显示指定模块中的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="efc82-296">和参数被指定为`false`。 `throwOnError` `ignoreCase`</span><span class="sxs-lookup"><span data-stu-id="efc82-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-297"><paramref name="className" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-297"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="efc82-298">调用类初始值设定项，并且引发异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-298">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-299"><paramref name="className" /> 是一个长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-299"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="efc82-300"><paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-300"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="efc82-301"><paramref name="className" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="efc82-301"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="efc82-302"><paramref name="className" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-302"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="efc82-303">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-303">-or-</span></span> 
<span data-ttu-id="efc82-304">当前程序集被加载到仅反射上下文中，并且 <paramref name="className" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="efc82-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="efc82-305"><paramref name="className" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-305"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="efc82-306">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-306">-or-</span></span> 
 <span data-ttu-id="efc82-307"><paramref name="className" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="efc82-307"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="module.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-308">返回在此模块中定义的所有类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-308">Returns all the types defined within this module.</span></span></summary>
        <returns><span data-ttu-id="efc82-309">一组 <see langword="Type" /> 类型，其中包含在此实例反映的模块中定义的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-310">`ReflectionTypeLoadException`是一个特殊的负载异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="efc82-311">`ReflectionTypeLoadException.Types`属性包含已在模块中定义并加载的类型的数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="efc82-312">此数组可能包含一些 null 值。</span><span class="sxs-lookup"><span data-stu-id="efc82-312">This array may contain some null values.</span></span> <span data-ttu-id="efc82-313">`ReflectionTypeLoadException.LoaderExceptions`属性是一个异常数组, 表示加载程序引发的异常。</span><span class="sxs-lookup"><span data-stu-id="efc82-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="efc82-314">类数组中的孔与异常一起排列。</span><span class="sxs-lookup"><span data-stu-id="efc82-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="efc82-315">例如, 如果某个类的类初始值设定项在加载时引发了异常, `TargetInvocationException`则会将其存储在`LoaderExceptions`数组的相应元素中。</span><span class="sxs-lookup"><span data-stu-id="efc82-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-316">如果类型已转发给另一个程序集, 则它不会包含在返回的数组中。</span><span class="sxs-lookup"><span data-stu-id="efc82-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="efc82-317">有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="efc82-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="efc82-318">无法加载模块中的一个或多个类。</span><span class="sxs-lookup"><span data-stu-id="efc82-318">One or more classes in a module could not be loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="efc82-319">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="efc82-319">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="efc82-320">当前模块的反射权限。</span><span class="sxs-lookup"><span data-stu-id="efc82-320">Reflection permission for the current module.</span></span></permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="module.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="efc82-321">要测试的自定义属性的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-321">The type of custom attribute to test for.</span></span></param>
        <param name="inherit"><span data-ttu-id="efc82-322">对于该类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-322">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="efc82-323">返回一个值，该值指示是否已将指定的特性类型应用于此模块。</span><span class="sxs-lookup"><span data-stu-id="efc82-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span></span></summary>
        <returns><span data-ttu-id="efc82-324">如果一个或多个 <paramref name="attributeType" /> 实例已应用于此模块，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-324"><see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-325">下面的示例演示`IsDefined`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="efc82-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="efc82-326"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-326"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-327"><paramref name="attributeType" /> 不是由运行时提供的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-327"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="efc82-328">例如，<paramref name="attributeType" /> 是一个 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberSignature Language="F#" Value="abstract member IsResource : unit -&gt; bool&#xA;override this.IsResource : unit -&gt; bool" Usage="module.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-329">获取一个值，该值指示此对象是否是资源。</span><span class="sxs-lookup"><span data-stu-id="efc82-329">Gets a value indicating whether the object is a resource.</span></span></summary>
        <returns><span data-ttu-id="efc82-330">如果此对象是资源，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-330"><see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-331">下面的示例演示`IsResource`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="efc82-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-332">获取元数据流版本。</span><span class="sxs-lookup"><span data-stu-id="efc82-332">Gets the metadata stream version.</span></span></summary>
        <value><span data-ttu-id="efc82-333">表示元数据流版本的 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="efc82-333">A 32-bit integer representing the metadata stream version.</span></span> <span data-ttu-id="efc82-334">高序位的两个字节表示主版本号，低序位的两个字节表示次版本号。</span><span class="sxs-lookup"><span data-stu-id="efc82-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="efc82-335">有关元数据标头的详细信息, 请参阅 "Partition II:公共语言基础结构 (CLI) 文档中的元数据定义和语义。</span><span class="sxs-lookup"><span data-stu-id="efc82-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="efc82-336">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-337">获取一个令牌，该令牌用于标识元数据中的模块。</span><span class="sxs-lookup"><span data-stu-id="efc82-337">Gets a token that identifies the module in metadata.</span></span></summary>
        <value><span data-ttu-id="efc82-338">一个整数标记，用于标识元数据中的当前模块。</span><span class="sxs-lookup"><span data-stu-id="efc82-338">An integer token that identifies the current module in metadata.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-339">使用此属性获取的令牌可传递给非托管反射 API。</span><span class="sxs-lookup"><span data-stu-id="efc82-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="efc82-340">有关详细信息, 请参阅[非托管反射 API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。</span><span class="sxs-lookup"><span data-stu-id="efc82-340">For more information, see [Unmanaged Reflection API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-341">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-342">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleHandle : ModuleHandle" Usage="System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-343">获取模块的图柄。</span><span class="sxs-lookup"><span data-stu-id="efc82-343">Gets a handle for the module.</span></span></summary>
        <value><span data-ttu-id="efc82-344">当前模块的 <see cref="T:System.ModuleHandle" /> 结构。</span><span class="sxs-lookup"><span data-stu-id="efc82-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-345">获取可用于区分模块的两个版本的全局唯一标识符 (UUID)。</span><span class="sxs-lookup"><span data-stu-id="efc82-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span></span></summary>
        <value><span data-ttu-id="efc82-346">可用于区分模块的两个版本的 <see cref="T:System.Guid" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-347">在非托管元数据中, <xref:System.Reflection.Module.ModuleVersionId%2A>属性返回的 GUID 称为`mvid`, 并存储在 GUID 堆中。</span><span class="sxs-lookup"><span data-stu-id="efc82-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-348">有关元数据的详细信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-349">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-350">获取 <see langword="String" />，它表示移除了路径的模块名。</span><span class="sxs-lookup"><span data-stu-id="efc82-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span></span></summary>
        <value><span data-ttu-id="efc82-351">不带路径的模块名。</span><span class="sxs-lookup"><span data-stu-id="efc82-351">The module name with no path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-352">`Name`是与平台相关的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="efc82-353">如果此模块的程序集是从字节数组加载的, 则`FullyQualifiedName`该模块的将为:\<未知的 >。</span><span class="sxs-lookup"><span data-stu-id="efc82-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="efc82-354">若要获取名称和路径, 请使用<xref:System.Reflection.Module.FullyQualifiedName%2A>。</span><span class="sxs-lookup"><span data-stu-id="efc82-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-355">此示例演示`ScopeName`、 `FullyQualifiedName`和`Name`属性的效果。</span><span class="sxs-lookup"><span data-stu-id="efc82-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Module" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="efc82-356">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-356">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="efc82-357">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-357">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="efc82-358">指示两个 <see cref="T:System.Reflection.Module" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="efc82-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="efc82-359">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-359"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="System.Reflection.Module.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Module" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="efc82-360">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-360">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="efc82-361">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-361">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="efc82-362">指示两个 <see cref="T:System.Reflection.Module" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="efc82-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="efc82-363">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-363"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-364">返回由元数据令牌标识的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-364">Returns the field identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveField : int -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-365">一个元数据令牌，用于标识模块中的一个字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-365">A metadata token that identifies a field in the module.</span></span></param>
        <summary><span data-ttu-id="efc82-366">返回由指定的元数据令牌标识的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-366">Returns the field identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-367">一个 <see cref="T:System.Reflection.FieldInfo" /> 对象，表示由指定元数据令牌标识的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-368">若要解析标识`TypeSpec`其父级具有包含元素`ELEMENT_TYPE_MVAR`类型`ELEMENT_TYPE_VAR`的签名的字段的元数据标记, 请使用<xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法重载, 这允许你提供必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="efc82-369">也就是说, 当你为依赖于泛型类型的泛型类型参数和/或嵌入了标记的泛型方法的字段的元数据标记进行解析时, 必须使用允许提供这些类型参数的重载。</span><span class="sxs-lookup"><span data-stu-id="efc82-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-370">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-371">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="efc82-372">有关使用一般上下文 (即, 泛型类型的泛型类型参数和/或泛型方法的泛型类型参数, 其中嵌入了标记) 的代码, 请参阅<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-373"><paramref name="metadataToken" /> 不是当前模块范围内的字段的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-373"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-374">或</span><span class="sxs-lookup"><span data-stu-id="efc82-374">-or-</span></span> 
 <span data-ttu-id="efc82-375"><paramref name="metadataToken" /> 标识一个字段，该字段的父级 <see langword="TypeSpec" /> 具有一个包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）的签名。</span><span class="sxs-lookup"><span data-stu-id="efc82-375"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-376"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-376"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo&#xA;override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-377">一个元数据令牌，用于标识模块中的一个字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-377">A metadata token that identifies a field in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="efc82-378">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="efc82-379">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="efc82-380">在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="efc82-381">一个 <see cref="T:System.Reflection.FieldInfo" /> 对象，表示由指定元数据令牌标识的字段。</span><span class="sxs-lookup"><span data-stu-id="efc82-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-382">在类型中对类型使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-383">对方法使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-384">提供这些参数始终是安全的, 即使不需要它们也是如此。</span><span class="sxs-lookup"><span data-stu-id="efc82-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-385">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-386">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="efc82-387">有关使用一般上下文 (即, 泛型类型的泛型类型参数和/或泛型方法的泛型类型参数, 其中嵌入了标记) 的代码, 请参阅<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-388"><paramref name="metadataToken" /> 不是当前模块范围内的字段的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-388"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-389">或</span><span class="sxs-lookup"><span data-stu-id="efc82-389">-or-</span></span> 
 <span data-ttu-id="efc82-390"><paramref name="metadataToken" /> 标识一个字段，该字段的父级 <see langword="TypeSpec" /> 具有一个包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）的签名，并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-390"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-391"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-391"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-392">返回由元数据令牌标识的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-392">Returns the type or member identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMember : int -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-393">一个元数据令牌，用于标识模块中的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-393">A metadata token that identifies a type or member in the module.</span></span></param>
        <summary><span data-ttu-id="efc82-394">返回由指定的元数据令牌标识的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-394">Returns the type or member identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-395">一个 <see cref="T:System.Reflection.MemberInfo" /> 对象，表示由指定的元数据令牌标识的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-396">若要解析的元数据标记`MethodSpec`或`TypeSpec`其签名包含元素<xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>类型`ELEMENT_TYPE_VAR`或`ELEMENT_TYPE_MVAR`的元数据标记, 请使用方法重载, 这允许你提供必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="efc82-397">也就是说, 当你为依赖于泛型类型的泛型类型参数和/或嵌入了标记的泛型方法的成员的元数据标记进行解析时, 必须使用允许提供这些类型参数的重载。</span><span class="sxs-lookup"><span data-stu-id="efc82-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-398">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-399">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="efc82-400">有关使用一般上下文 (即, 泛型类型的泛型类型参数和/或泛型方法的泛型类型参数, 其中嵌入了标记) 的代码, 请参阅<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-401"><paramref name="metadataToken" /> 不是当前模块范围内的类型或成员的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-401"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-402">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-402">-or-</span></span> 
 <span data-ttu-id="efc82-403"><paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）。</span><span class="sxs-lookup"><span data-stu-id="efc82-403"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span>  
  
<span data-ttu-id="efc82-404">或</span><span class="sxs-lookup"><span data-stu-id="efc82-404">-or-</span></span> 
 <span data-ttu-id="efc82-405"><paramref name="metadataToken" /> 标识一个属性或事件。</span><span class="sxs-lookup"><span data-stu-id="efc82-405"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-406"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-406"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo&#xA;override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-407">一个元数据令牌，用于标识模块中的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-407">A metadata token that identifies a type or member in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="efc82-408">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="efc82-409">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="efc82-410">在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="efc82-411">一个 <see cref="T:System.Reflection.MemberInfo" /> 对象，表示由指定的元数据令牌标识的类型或成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-412">在类型中对类型使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-413">对方法使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-414">提供这些参数始终是安全的, 即使不需要它们也是如此。</span><span class="sxs-lookup"><span data-stu-id="efc82-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-415">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-416">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="efc82-417">有关使用一般上下文 (即, 泛型类型的泛型类型参数和/或泛型方法的泛型类型参数, 其中嵌入了标记) 的代码, 请参阅<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-418"><paramref name="metadataToken" /> 不是当前模块范围内的类型或成员的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-418"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-419">或</span><span class="sxs-lookup"><span data-stu-id="efc82-419">-or-</span></span> 
 <span data-ttu-id="efc82-420"><paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-420"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span>  
  
<span data-ttu-id="efc82-421">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-421">-or-</span></span> 
 <span data-ttu-id="efc82-422"><paramref name="metadataToken" /> 标识一个属性或事件。</span><span class="sxs-lookup"><span data-stu-id="efc82-422"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-423"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-423"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-424">返回由元数据令牌标识的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-424">Returns the method identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMethod : int -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-425">一个元数据令牌，用于标识模块中的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="efc82-425">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <summary><span data-ttu-id="efc82-426">返回由指定的元数据令牌标识的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="efc82-426">Returns the method or constructor identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-427">一个 <see cref="T:System.Reflection.MethodBase" /> 对象，表示由指定的元数据令牌标识的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="efc82-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-428">若要解析其签名包含元素`MethodSpec`类型`ELEMENT_TYPE_VAR`或`ELEMENT_TYPE_MVAR`的元数据标记, 请使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法重载, 这允许你提供必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="efc82-429">也就是说, 当你为依赖泛型类型的泛型类型参数和/或嵌入了标记的泛型方法的方法解析元数据标记时, 必须使用允许提供这些类型参数的重载。</span><span class="sxs-lookup"><span data-stu-id="efc82-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-430">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-431">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-432">下面的示例演示如何使用<xref:System.Reflection.Module.ResolveMethod%2A>方法的两个重载来解析泛型和非泛型上下文中的调用站点的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="efc82-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="efc82-433">此代码示例定义了两个泛型`G1<Tg1>`类型`G2<Tg2>` ,`G1(Of Tg1)`并`G2(Of Tg2)`定义了 (在 Visual Basic 中), 其中每个类型都有一个泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="efc82-434">`G1<Tg1>`还具有一个使用类型参数`Tg1`作为参数的非泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="efc82-435">`GM2<Tgm2>` 类型`G2<Tg2>`中的泛型方法包含若干方法调用:</span><span class="sxs-lookup"><span data-stu-id="efc82-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="efc82-436">案例 1:调用泛型方法`GM1<Tgm1>` , `G2<Tg2>`并`GM2<Tgm2>`使用的类型参数作为类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="efc82-437">换言之, 被调用方法的参数类型将取决于用于从的类型定义`G2<Tg2>`构造封闭式泛型类型的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="efc82-438">案例 2:调用非泛型方法`M1` 。</span><span class="sxs-lookup"><span data-stu-id="efc82-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="efc82-439">此方法的参数使用定义类型`G1<Tg1>`的类型参数, 该类型参数将在此示例中由封闭`G2<Tg2>`类型的类型参数替换。</span><span class="sxs-lookup"><span data-stu-id="efc82-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="efc82-440">案例 3:调用泛型方法`GM1<Tgm1>` , 并分别为<xref:System.Int32>泛型<xref:System.Object>类型和泛型方法的类型参数指定和。</span><span class="sxs-lookup"><span data-stu-id="efc82-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="efc82-441">此方法调用不依赖于封闭类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="efc82-442">情况 4:调用`Example`类的非泛型`M1`方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="efc82-443">此方法调用不依赖于封闭类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="efc82-444">此外, 该示例还定义了非泛型`Example`类。</span><span class="sxs-lookup"><span data-stu-id="efc82-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="efc82-445">此类具有调用泛型`M`方法的方法:</span><span class="sxs-lookup"><span data-stu-id="efc82-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="efc82-446">情况 5:调用泛型方法`GM1` , 并分别为<xref:System.Int32>泛型<xref:System.Object>类型和泛型方法的类型参数指定和。</span><span class="sxs-lookup"><span data-stu-id="efc82-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="efc82-447">此方法的上下文没有封闭泛型类型或泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="efc82-448">对于每种情况, 该示例首先构造<xref:System.Reflection.MethodInfo>一个表示所调用方法的, 然后<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法重载解析该标记, 方法是使用`genericTypeArguments`和<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法获取和的值`genericMethodArguments`参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="efc82-449">此方法适用于所有情况, 因为方法为非<xref:System.Type.EmptyTypes?displayProperty=nameWithType>泛型上下文返回。</span><span class="sxs-lookup"><span data-stu-id="efc82-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="efc82-450">该示例将解析<xref:System.Reflection.MethodInfo>的与构造<xref:System.Reflection.MethodInfo>的进行比较。</span><span class="sxs-lookup"><span data-stu-id="efc82-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="efc82-451">然后, 该示例尝试使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>方法重载来解析令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="efc82-452">这适用于3、4和5情况, 因为方法调用不依赖于一般上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="efc82-453">在案例1和2中, 引发异常, 因为没有足够的信息来解析令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="efc82-454">元数据标记值硬编码为枚举。</span><span class="sxs-lookup"><span data-stu-id="efc82-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="efc82-455">如果更改此代码示例, 则可能会更改标记值。</span><span class="sxs-lookup"><span data-stu-id="efc82-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="efc82-456">若要确定新的标记值, 请编译代码并使用 **/TOKENS**选项来检查程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="efc82-457">可以在调用点找到标记。</span><span class="sxs-lookup"><span data-stu-id="efc82-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="efc82-458">将新值插入到枚举中, 然后重新编译该示例。</span><span class="sxs-lookup"><span data-stu-id="efc82-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-459"><paramref name="metadataToken" /> 不是当前模块范围内的方法或构造函数的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-459"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-460">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-460">-or-</span></span> 
 <span data-ttu-id="efc82-461"><paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）。</span><span class="sxs-lookup"><span data-stu-id="efc82-461"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-462"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-462"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase&#xA;override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-463">一个元数据令牌，用于标识模块中的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="efc82-463">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="efc82-464">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="efc82-465">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="efc82-466">在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="efc82-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="efc82-467">一个 <see cref="T:System.Reflection.MethodBase" /> 对象，表示由指定的元数据令牌标识的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-468">在类型中对类型使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-469">对方法使用`metadataToken` `genericMethodArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="efc82-470">提供这些参数始终是安全的, 即使不需要它们也是如此。</span><span class="sxs-lookup"><span data-stu-id="efc82-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-471">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-472">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-473">下面的示例演示如何使用<xref:System.Reflection.Module.ResolveMethod%2A>方法的两个重载来解析泛型和非泛型上下文中的调用站点的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="efc82-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="efc82-474">此代码示例定义了两个泛型`G1<Tg1>`类型`G2<Tg2>`, 每个泛型类型都有一个泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="efc82-475">`G1<Tg1>`还具有一个使用类型参数`Tg1`作为参数的非泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="efc82-476">`GM2<Tgm2>` 类型`G2<Tg2>`中的泛型方法包含若干方法调用:</span><span class="sxs-lookup"><span data-stu-id="efc82-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="efc82-477">案例 1:调用泛型方法`GM1<Tgm1>` , `G2<Tg2>`并`GM2<Tgm2>`使用的类型参数作为类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="efc82-478">换言之, 被调用方法的参数类型将取决于用于从的类型定义`G2<Tg2>`构造封闭式泛型类型的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="efc82-479">案例 2:调用非泛型方法`M1` 。</span><span class="sxs-lookup"><span data-stu-id="efc82-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="efc82-480">此方法的参数使用定义类型`G1<Tg1>`的类型参数, 该类型参数将在此示例中由封闭`G2<Tg2>`类型的类型参数替换。</span><span class="sxs-lookup"><span data-stu-id="efc82-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="efc82-481">案例 3:调用泛型方法`GM1<Tgm1>` , 并分别为<xref:System.Int32>泛型<xref:System.Object>类型和泛型方法的类型参数指定和。</span><span class="sxs-lookup"><span data-stu-id="efc82-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="efc82-482">此方法调用不依赖于封闭类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="efc82-483">情况 4:调用`Example`类的非泛型`M1`方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="efc82-484">此方法调用不依赖于封闭类型或方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="efc82-485">此外, 该示例还定义了非泛型`Example`类。</span><span class="sxs-lookup"><span data-stu-id="efc82-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="efc82-486">此类具有对泛型`M`方法的调用的方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="efc82-487">情况 5:调用泛型方法`GM1<Tgm1>` , 并分别为<xref:System.Int32>泛型<xref:System.Object>类型和泛型方法的类型参数指定和。</span><span class="sxs-lookup"><span data-stu-id="efc82-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="efc82-488">此方法的上下文没有封闭泛型类型或泛型方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="efc82-489">对于每种情况, 该示例首先构造<xref:System.Reflection.MethodInfo>一个表示所调用方法的, 然后<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法重载解析该标记, 方法是使用`genericTypeArguments`和<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法获取和的值`genericMethodArguments`参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="efc82-490">此方法适用于所有情况, 因为方法为非<xref:System.Type.EmptyTypes?displayProperty=nameWithType>泛型上下文返回。</span><span class="sxs-lookup"><span data-stu-id="efc82-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="efc82-491">该示例将解析<xref:System.Reflection.MethodInfo>的与构造<xref:System.Reflection.MethodInfo>的进行比较。</span><span class="sxs-lookup"><span data-stu-id="efc82-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="efc82-492">然后, 该示例尝试使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>方法重载来解析令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="efc82-493">这适用于3、4和5情况, 因为方法调用不依赖于一般上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="efc82-494">在案例1和2中, 引发异常, 因为没有足够的信息来解析令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="efc82-495">元数据标记值硬编码为枚举。</span><span class="sxs-lookup"><span data-stu-id="efc82-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="efc82-496">如果更改此代码示例, 则可能会更改标记值。</span><span class="sxs-lookup"><span data-stu-id="efc82-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="efc82-497">若要确定新的标记值, 请编译代码并使用 **/TOKENS**选项来检查程序集。</span><span class="sxs-lookup"><span data-stu-id="efc82-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="efc82-498">可以在调用点找到标记。</span><span class="sxs-lookup"><span data-stu-id="efc82-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="efc82-499">将新值插入到枚举中, 然后重新编译该示例。</span><span class="sxs-lookup"><span data-stu-id="efc82-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-500"><paramref name="metadataToken" /> 不是当前模块范围内的方法或构造函数的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-500"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-501">或</span><span class="sxs-lookup"><span data-stu-id="efc82-501">-or-</span></span> 
 <span data-ttu-id="efc82-502"><paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-502"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-503"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-503"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveSignature : int -&gt; byte[]&#xA;override this.ResolveSignature : int -&gt; byte[]" Usage="module.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-504">一个元数据令牌，用于标识模块中的一个签名。</span><span class="sxs-lookup"><span data-stu-id="efc82-504">A metadata token that identifies a signature in the module.</span></span></param>
        <summary><span data-ttu-id="efc82-505">返回由元数据令牌标识的签名 Blob。</span><span class="sxs-lookup"><span data-stu-id="efc82-505">Returns the signature blob identified by a metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-506">一个字节数组，表示签名 Blob。</span><span class="sxs-lookup"><span data-stu-id="efc82-506">An array of bytes representing the signature blob.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="efc82-507">有关元数据标记和签名的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-508">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-509"><paramref name="metadataToken" /> 不是当前模块范围内的有效 <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、签名或 <see langword="FieldDef" /> 令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-509"><paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-510"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-510"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveString : int -&gt; string&#xA;override this.ResolveString : int -&gt; string" Usage="module.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-511">一个元数据令牌，用于标识模块的字符串堆中的一个字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-511">A metadata token that identifies a string in the string heap of the module.</span></span></param>
        <summary><span data-ttu-id="efc82-512">返回由指定元数据令牌标识的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-512">Returns the string identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-513">一个 <see cref="T:System.String" />，包含来自元数据字符串堆的一个字符串值。</span><span class="sxs-lookup"><span data-stu-id="efc82-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="efc82-514">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-515">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-516"><paramref name="metadataToken" /> 不是当前模块范围内的字符串的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-516"><paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-517"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-517"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="efc82-518">返回由元数据令牌标识的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-518">Returns the type identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveType : int -&gt; Type" Usage="module.ResolveType metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-519">一个元数据令牌，用于标识模块中的一个类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-519">A metadata token that identifies a type in the module.</span></span></param>
        <summary><span data-ttu-id="efc82-520">返回由指定的元数据令牌标识的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-520">Returns the type identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="efc82-521">一个 <see cref="T:System.Type" /> 对象，表示由指定的元数据令牌标识的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-522">若要解析的元数据标记`TypeSpec` (其签名`ELEMENT_TYPE_VAR`包含`ELEMENT_TYPE_MVAR`或), <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>请使用方法重载, 这允许你提供必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="efc82-523">也就是说, 当你为依赖于泛型类型的泛型类型参数和/或嵌入了标记的泛型方法的类型的元数据标记进行解析时, 必须使用允许提供这些类型参数的重载。</span><span class="sxs-lookup"><span data-stu-id="efc82-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-524">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-525">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-526"><paramref name="metadataToken" /> 不是当前模块范围内的类型的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-526"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-527">或</span><span class="sxs-lookup"><span data-stu-id="efc82-527">-or-</span></span> 
 <span data-ttu-id="efc82-528"><paramref name="metadataToken" /> 是一个 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）。</span><span class="sxs-lookup"><span data-stu-id="efc82-528"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-529"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-529"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : int * Type[] * Type[] -&gt; Type&#xA;override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="module.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="efc82-530">一个元数据令牌，用于标识模块中的一个类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-530">A metadata token that identifies a type in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="efc82-531">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="efc82-532">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="efc82-533">在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="efc82-534">一个 <see cref="T:System.Type" /> 对象，表示由指定的元数据令牌标识的类型。</span><span class="sxs-lookup"><span data-stu-id="efc82-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-535">在类型中对类型使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-536">对方法使用`metadataToken` `genericTypeArguments`方法, 其中在范围内可获取的泛型类型参数的数组。 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="efc82-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="efc82-537">提供这些参数始终是安全的, 即使不需要它们也是如此。</span><span class="sxs-lookup"><span data-stu-id="efc82-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="efc82-538">有关元数据令牌的信息, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第二部分:元数据定义和语义 "。</span><span class="sxs-lookup"><span data-stu-id="efc82-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="efc82-539">文档在线提供;请参阅在 ECMA 网站上的 MSDN 和[标准 ecma-335-公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)上的[ECMA C#和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)。</span><span class="sxs-lookup"><span data-stu-id="efc82-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="efc82-540">有关使用一般上下文 (即, 泛型类型的泛型类型参数和/或泛型方法的泛型类型参数, 其中嵌入了标记) 的代码, 请参阅<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="efc82-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="efc82-541"><paramref name="metadataToken" /> 不是当前模块范围内的类型的令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-541"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
<span data-ttu-id="efc82-542">- 或 -</span><span class="sxs-lookup"><span data-stu-id="efc82-542">-or-</span></span> 
 <span data-ttu-id="efc82-543"><paramref name="metadataToken" /> 是一个 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="efc82-543"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="efc82-544"><paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</span><span class="sxs-lookup"><span data-stu-id="efc82-544"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="efc82-545">获取表示模块名的字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-545">Gets a string representing the name of the module.</span></span></summary>
        <value><span data-ttu-id="efc82-546">模块名。</span><span class="sxs-lookup"><span data-stu-id="efc82-546">The module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-547">公共`ScopeName`语言运行时不使用此属性, 但在使用元数据 api 发出模块时, 可以使用它在属性中存储所需的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="efc82-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="efc82-548">反射本身不允许设置`ScopeName`属性。</span><span class="sxs-lookup"><span data-stu-id="efc82-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="efc82-549">此示例演示`ScopeName`、 `FullyQualifiedName`和`Name`属性的效果。</span><span class="sxs-lookup"><span data-stu-id="efc82-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="efc82-550">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-550">Reserved for future use.</span></span> <span data-ttu-id="efc82-551">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="efc82-551">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="efc82-552">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="efc82-552">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="efc82-553">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="efc82-553">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="efc82-554">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-554">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="efc82-555">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="efc82-555">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="efc82-556">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="efc82-556">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-557">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="efc82-558">有关`IDispatch::GetIDsOfNames`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="efc82-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="efc82-559">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="efc82-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="efc82-560">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="efc82-560">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="efc82-561">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="efc82-561">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="efc82-562">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="efc82-562">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="efc82-563">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="efc82-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-564">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="efc82-565">有关`IDispatch::GetTypeInfo`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="efc82-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="efc82-566">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="efc82-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="efc82-567">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="efc82-567">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="efc82-568">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="efc82-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-569">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="efc82-570">有关`IDispatch::GetTypeInfoCount`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="efc82-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="efc82-571">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="efc82-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="efc82-572">标识成员。</span><span class="sxs-lookup"><span data-stu-id="efc82-572">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="efc82-573">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="efc82-573">Reserved for future use.</span></span> <span data-ttu-id="efc82-574">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="efc82-574">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="efc82-575">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="efc82-575">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="efc82-576">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="efc82-576">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="efc82-577">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="efc82-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="efc82-578">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="efc82-578">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="efc82-579">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="efc82-579">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="efc82-580">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="efc82-580">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="efc82-581">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="efc82-581">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="efc82-582">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="efc82-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="efc82-583">有关`IDispatch::Invoke`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="efc82-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="efc82-584">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="efc82-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="module.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="efc82-585">返回模块的名称。</span><span class="sxs-lookup"><span data-stu-id="efc82-585">Returns the name of the module.</span></span></summary>
        <returns><span data-ttu-id="efc82-586">表示此模块的名称的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="efc82-586">A <see langword="String" /> representing the name of this module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="efc82-587">下面的示例演示`ToString`方法的用法。</span><span class="sxs-lookup"><span data-stu-id="efc82-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
