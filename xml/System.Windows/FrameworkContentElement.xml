<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a09a0bef3176e453d808d58d6e18c6b6bf05f74f" /><Meta Name="ms.sourcegitcommit" Value="bfce49b3a0c0685f994313d2e44a7c70def1694a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/05/2019" /><Meta Name="ms.locfileid" Value="66690853" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> 是 <see cref="T:System.Windows.ContentElement" /> 基类的 WPF 框架级别的实现和扩展。 <see cref="T:System.Windows.FrameworkContentElement" /> 增加了针对下列各项的支持：附加输入 API（包括工具提示和上下文菜单）、演示图板、用于数据绑定的数据上下文、格式支持和逻辑树帮助程序 API。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> 未定义其自己的呈现行为;实例化实际<xref:System.Windows.FrameworkContentElement>在代码或标记中的类实例是可能的但显示在中为 nothing[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 必须通过执行的类提供呈现逻辑<xref:System.Windows.FrameworkContentElement>子元素作为其内容模型的一部分或位于<xref:System.Windows.FrameworkContentElement>派生的类。  
  
 <xref:System.Windows.FrameworkContentElement> 有意与许多相同[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]作为<xref:System.Windows.FrameworkElement>。 请注意，某些[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>不会<xref:System.Windows.FrameworkContentElement>等效。 多个<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]是获取功能，如几何表示形式或布局，其中不相关的<xref:System.Windows.FrameworkContentElement>。  
  
 大多数现有<xref:System.Windows.FrameworkContentElement>将在派生的类中找到<xref:System.Windows.Documents>命名空间。 许多这些派生类实现用于流文档模型元素。 某些派生的类，如<xref:System.Windows.Documents.Hyperlink>具有一些类似控件的功能，但派生自<xref:System.Windows.FrameworkContentElement>以便类似控件的元素仍可以参与流文档模型。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkContentElement" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要添加的子元素。</param>
        <summary>将提供的元素添加为此元素的子元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在另一个进程循环访问逻辑树时调用此方法可以引发异常。  
  
 大多数<xref:System.Windows.FrameworkContentElement>派生的类公开的负责包含专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。 通常可以避免无需直接操作逻辑树，改为从这些类派生。 使用为内容元素的逻辑树是一个高级的方案，可能需要专用的分析器或专用<xref:System.Windows.FrameworkElement>，它作为父呈现元素 （内容主机）。  
  
 有关如何使用详细信息<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>已在初始化元素之前调用。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>重写此方法以提供您的元素在元素加载过程中在初始化之前应发生的特殊处理。  
  
您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。  
  
基实现将引发异常，如果<see cref="M:System.Windows.FrameworkContentElement.BeginInit" />称为不止一次在同一个元素之前到达<see cref="M:System.Windows.FrameworkContentElement.EndInit" />。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。 因此不能运行一次后重新启动动画。 请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <summary>开始所提供的演示图板中包含的操作序列，其中指定了在该属性经过动画处理后要发生的行为的选项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。 因此不能运行一次后重新启动动画。 请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用组合 HandoffBehavior  
 当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除时钟。  
  
 若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。 有几种方法来移除时钟：  
  
-   若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。 指定要进行动画处理的第一个参数的属性和`null`为第二个。 这将从属性中删除所有的动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  垃圾回收对象时，它的时钟也会断开连接和垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <param name="isControllable">声明在动画开始后是否仍可以对它进行控制（可以暂停）。</param>
        <summary>开始所提供的演示图板中包含的操作序列，其中指定了在动画开始之后动画控件的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。 因此不能运行一次后重新启动动画。 请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用组合 HandoffBehavior  
 当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除这些时钟。  
  
 若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。 有几种方法来移除时钟：  
  
-   若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。 指定要进行动画处理的第一个参数的属性和`null`为第二个。 这将从属性中删除所有的动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  垃圾回收对象时，它的时钟也会断开连接和垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.Data.BindingGroup>可用于验证对象的多个属性的值。 例如，假设应用程序提示用户输入地址，然后填充类型的对象`Address`，其中包含属性`Street`， `City`， `ZipCode`，和`Country`，使用值的用户提供。 应用程序必须包含四个面板<xref:System.Windows.Controls.TextBox>控件，其中每个绑定到对象的属性之一。 可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>验证`Address`对象。 例如，<xref:System.Windows.Controls.ValidationRule>可以确保 zip 代码是有效的国家/地区/区域的地址。  
  
 子元素继承<xref:System.Windows.Data.BindingGroup>从其父元素，就像使用任何其他可继承属性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，你有效地将调用<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>任何父可滚动区域中包含的元素 (很可能是父<xref:System.Windows.FrameworkElement>，而不<xref:System.Windows.FrameworkContentElement>)。 如果此元素不包含在可滚动区域中，仍引发该事件，但不会产生任何影响。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">如何：创建 ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置每当通过[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 从此元素中请求上下文菜单时应该显示的上下文菜单元素。</summary>
        <value>此元素使用的上下文菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 以下示例中位置<xref:System.Windows.Controls.ContextMenu>上<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭上下文菜单，该事件的处理程序应将其标记为已处理。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用基础服务的事件标识符：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件未正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuClosing>在触发器中使用的标识符)。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 下面的示例实现的处理程序上的命名区域更改光标`DisplayArea`（未显示）。 注释暗示<xref:System.Windows.UIElement>使用情况，实际上，此示例将是相同，但如果`DisplayArea`了<xref:System.Windows.FrameworkContentElement>。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开上下文菜单，事件的处理程序应将相关的事件标记为已处理。 否则为现有值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性将用于自动打开上下文菜单。 将标记处理的事件将有效地取消默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。 但是，是应注意的计时问题。 若要完全替换通过上下文菜单<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>处理程序中，初始上下文菜单不能为 null / 空。 或者，您可能需要处理的事件，然后手动打开新的上下文菜单。 有关详细信息，请参阅[如何：处理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用基础服务的事件标识符：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件未正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>在触发器中使用的标识符)。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在鼠标指针位于此元素上时显示的光标。</summary>
        <value>要显示的光标。 按此依赖属性，默认值定义为 <see langword="null" />。 但是，运行时的实际默认值将受到多种因素的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，则[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理器将依赖类型转换为<xref:System.Windows.Input.Cursor>类来计算该字符串。 所提供的字符串的计算结果应为<xref:System.Windows.Input.CursorType>值。 有关详细信息，请参阅<xref:System.Windows.Input.Cursor>。  
  
 此属性所建立的光标将还是将不会显示在鼠标指针位于此元素上时也是依赖于的值<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>属性。 此外，与事件相关的注意事项，如活动拖动、 鼠标捕获、 文本编辑模式中控件和等等，还将影响游标，并且其优先级高于此属性中指定的值。  
  
 若要还原的此属性设置为最终的默认行为，请将其设置为`null`试。  
  
 `null`默认值实际上意味着确定实际游标值的此处延迟，并且应从其他位置获取。 如果不存在以编程方式值来自任何源默认游标通过[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]应用程序将是一个箭头。  
  
 每个移动的鼠标悬停[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序将引发<xref:System.Windows.ContentElement.QueryCursor>事件。 该事件冒泡，并且路由中的任何元素都有机会处理事件并设置游标通过此事件的参数的值。 如果发生这种情况，则表明事件进行处理，并且 in 实参具有一个更改的值将优先于的值<xref:System.Windows.FrameworkContentElement.Cursor%2A>属性在任何级别，除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>设置。  
  
 如果不创建自定义光标，通常您将此属性设置的静态属性值<xref:System.Windows.Input.Cursors>类。  
  
 设置<xref:System.Windows.Input.Cursor>在部分信任环境中未启用为自定义值。 自定义光标的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例将光标设置为自定义值。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素参与数据绑定时的数据上下文。</summary>
        <value>要用作数据上下文的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *数据上下文*是允许将信息从其父元素继承有关用于绑定，以及其他特征等路径的绑定的绑定源元素的概念。  
  
 可以直接设置数据上下文[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]对象，并且将绑定到该对象的属性计算。 或者，可以将数据上下文设置为<xref:System.Windows.Data.DataSourceProvider>对象。  
  
 此依赖属性继承属性值。 如果没有与任何其他值的子元素<xref:System.Windows.FrameworkContentElement.DataContext%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkContentElement.DataContext%2A>分配有此值最接近的父元素的值。  
  
 或者，可以使用以下属性之一<xref:System.Windows.Data.Binding>类来显式指定绑定源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。 有关详细信息，请参阅[如何：指定绑定源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkContentElement.DataContext%2A>通常设置为<xref:System.Windows.Data.Binding>声明。 您可以使用属性元素语法或特性语法。 特性语法在此页上的示例所示。 您还可以设置<xref:System.Windows.FrameworkContentElement.DataContext%2A>在代码中。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 作为父元素中的任何绑定的数据上下文直接嵌入的对象。 通常情况下，此对象是<xref:System.Windows.Data.Binding>或另一个<xref:System.Windows.Data.BindingBase>子类。 或者，原始数据的任何[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]对象类型的目标的绑定可能会放在此处，定义更高版本的实际绑定。  
  
 *bindingUsage*  
 计算结果为相应的数据上下文绑定使用情况。 有关详细信息，请参阅 [Binding 标记扩展](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 以下项之一： `StaticResource`，或`DynamicResource`。 引用定义为资源中的对象的原始数据时，使用这种用法。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 正在请求中的对象的密钥标识符<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中，通过创建新的自定义数据对象，该对象作为建立<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素的数据上下文更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据上下文和数据绑定的说明，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  当元素的<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影响的更改，此元素上的所有数据绑定属性。 这适用于任何元素属于当前元素的子代元素继承数据上下文，以及当前元素本身。 所有此类绑定重新解释的新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映在绑定中的新值。 相对于引发这些更改的顺序不能保证<xref:System.Windows.FrameworkContentElement.DataContextChanged>事件。  事件后或在任意组合，可以在事件之前发生的更改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于在主题中查找此控件的样式模板的键。</summary>
        <value>样式键。 为了在主题样式查找中正确工作，此值应为样式化元素的 <see cref="T:System.Type" />。 <see langword="null" /> 是在某些情况下接受的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常通过其直接资源库的任何未设置此属性。 相反，每次创建新的子类覆盖此依赖项属性的特定于类型的元数据。 当在子类中，调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法针对<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>在控件子类的静态构造函数内的标识符。  
  
 例如，内联类，如<xref:System.Windows.Documents.Bold>实际上有很少之外重写实现<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>其静态构造函数，并公开多个实例构造函数中的元数据。 这一事实元素括<xref:System.Windows.Documents.Bold>标记提升<xref:System.Windows.Documents.TextElement.FontWeight%2A>的属性<xref:System.Windows.FontWeights.Bold%2A>内的默认值设置引用主题样式实现<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>到`typeof(Bold)`。  
  
 如果你希望元素或故意不使用主题样式的控件，设置<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>属性设置为`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>已在初始化元素后立即调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实现此方法以提供您的元素在元素加载过程中初始化时应发生的特殊处理。  
  
 您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。  
  
 如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>之前调用，基实现将引发<xref:System.Windows.FrameworkContentElement.Initialized>事件。 否则为如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>未调用或不能确定是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已调用，则不会引发该事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要搜索的元素的名称。</param>
        <summary>查找具有提供的标识符名的元素。</summary>
        <returns>请求的元素。 如果未找到匹配的元素，则可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素具有子元素，这些子元素将是所有以递归方式搜索请求的命名元素。  
  
   
  
## Examples  
 下面的示例内部引用通过名称找到的元素上设置属性<xref:System.Windows.Documents.FlowDocument>页面上。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找不到请求的资源，则会引发异常。</summary>
        <returns>找到的资源，如果找不到任何匹配资源，则为 <see langword="null" />（如果为 <see langword="null" />，则还会引发异常）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果找不到键调用此方法，将引发异常。 如果您不想要处理这种情况下的异常，应改为调用<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>。 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 返回`null`不到资源时找到，并且不会引发异常。  
  
 如果在调用元素上找不到资源，使用逻辑树搜索父树，树的方法相同的某个资源已请求搜索由在运行时参数。  
  
 通常，会立即强制转换为已尝试设置为返回的资源值的属性的类型的返回值。  
  
   
  
## Examples  
 下面的示例查找资源，在标记中定义并将其应用于路由事件的响应中的元素的某一属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到请求的资源键。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个对象，该对象允许自定义此元素在捕获到键盘焦点时要应用于此元素的外观、效果或其他样式特征。</summary>
        <value>要应用于焦点的所需样式。 该依赖属性中声明的默认值是一个空的静态 <see cref="T:System.Windows.Style" />。 但是，运行时的有效值通常是（但并非总是）控件的主题支持所提供的样式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、 样式几乎始终定义为资源，而不是作为一个元素，内联和资源，通常是作为引用<xref:System.Windows.StaticResourceExtension>。  
  
 请注意，此属性会影响视觉外观，但不会报告此元数据中。 这是因为可视外观更改是事件驱动和在任何时候，可能不适用，因此通常不应报告元数据中的任何视觉对象或布局信息。  
  
 从概念上讲，焦点应用于控件的可视行为应一致元素元素。 强制实施一致性的最合理方法是仅当您在创作整个主题更改焦点视觉样式。 在单个样式上而不是作为主题的一部分设置此属性不可此属性的预期的用法，因为它可能会导致混乱的用户体验与键盘焦点有关。 如果你想是故意不一致的整个主题的特定于元素的行为，更好的方法是使用触发器在样式中的个别输入的状态属性，如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，并为此，在没有一种方法以可视方式会影响任何现有的焦点视觉样式。 有关详细信息的设计意图<xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A>及替代焦点属性，请参阅[控件，以及 FocusVisualStyle 中的焦点设置样式](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:、 或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法就从技术上讲，但不是建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  绑定引用使用[TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 依赖属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Windows.FrameworkContentElement" /> 是否应该强制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 按照此实例的 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 属性所声明的方式呈现光标。</summary>
        <value>在光标位于此元素上时，强制光标呈现以将此实例的设置用于光标（包括在所有子元素上），则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`将覆盖由子元素的光标首选项。 这样做因此一般情况下应用程序[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能容易引起混淆的用户，尤其是如果子元素尝试指定游标。 设置<xref:System.Windows.FrameworkElement.ForceCursor%2A>控件子类化或组合的情况下方案中更合适。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例强制上元素的光标。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">从中获取绑定的目标 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>获取指定属性的绑定的 <see cref="T:System.Windows.Data.BindingExpression" />。</summary>
        <returns>如果目标为数据绑定，则返回 <see cref="T:System.Windows.Data.BindingExpression" />；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例通过查询属性来检索一个绑定。  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果没有视觉父级，则返回此元素的备用逻辑父级。 在这种情况下，<see cref="T:System.Windows.FrameworkContentElement" /> 父级始终与 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 属性具有相同值。</summary>
        <returns>当此方法的 WPF 框架级别实现具有非视觉父级连接时，即返回 <see langword="null" /> 之外的内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现返回预期的单个可视化父级。 自定义实现可能会返回备用的父关系。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化此 <see cref="T:System.Windows.FrameworkContentElement" /> 时发生。 这与 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 属性值从 <see langword="false" />（或未定义）更改为 <see langword="true" /> 的情况相符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此事件时引发<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>调用方法。 对这些方法的调用可能已进行了通过故意代码，或由[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]加载过程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Windows.FrameworkContentElement" /> 使用的输入的上下文。</summary>
        <value>解释输入范围，在该输入范围内修改从其他输入法输入的方式。 默认值为 <see langword="null" />（这将导致对命令的默认处理）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖属性继承属性值。 如果没有与任何其他值的子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.InputScope%2A>分配有此值最接近的父元素的值。  
  
 尽管[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法使用情况列出和语法上允许，则将此属性设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]并不常见。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已通过将此元素作为[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 加载或显式调用它的 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 方法初始化此元素。</summary>
        <value>如果已通过上述加载或方法调用初始化了此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性也可能`true`如果此元素被移动元素树中以便它有了新的父元素，并因此重新。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已加载此元素以供显示。</summary>
        <value>如果当前元素附加到元素树且已呈现，则为 <see langword="true" />；如果元素从未附加到加载的元素树中，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从新构造的实例，此属性以`false`，并保持`true`一旦设置为`true`，即使随后由代码中删除。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.FrameworkContentElement.IsLoaded%2A>作为条件检查，以确保函数`displayData`（未显示） 将具有有效的元素上加载页后，可以按需处理程序的一部分，针对工作。 作为事件处理程序运行时相同的逻辑<xref:System.Windows.FrameworkContentElement.Loaded>。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用于单个元素的本地化/全球化语言信息。</summary>
        <value>此元素的区域性信息。 默认值是一个 <see cref="T:System.Windows.Markup.XmlLanguage" /> 实例，它的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值设置为字符串“en-US”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串格式遵循 RFC 3066 标准。 例如，美国英语是"EN-US"。 请参阅<xref:System.Windows.Markup.XmlLanguage>的值和格式的详细信息。  
  
 此依赖属性继承属性值。 如果没有与任何其他值的子元素<xref:System.Windows.FrameworkElement.Language%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.Language%2A>分配有此值最接近的父元素的值。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Language" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当对元素进行布局、呈现，且可将其用于交互时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。 直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑子元素的一个枚举数。</summary>
        <value>此元素的逻辑子元素的一个枚举数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何使用的详细信息<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">焦点要移动的方向，作为一个枚举值。</param>
        <summary>将键盘焦点从此元素移到另一个元素。</summary>
        <returns>如果焦点成功移动，则返回 <see langword="true" />；如果指定方向上的目标元素不存在，则返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的标识名称。 该名称提供实例引用，以便编程代码隐藏（如事件处理程序代码）引用曾在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 的分析过程中构造的元素。</summary>
        <value>元素的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是指定时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]标记中的元素名称。  
  
 此属性实质上是提供一个 WPF 框架级便捷属性来设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 获取<xref:System.Windows.FrameworkContentElement.Name%2A>从代码并不常用，因为如果已在代码中具有适当的引用，只需调用方法和属性在元素上的引用且通常并不需要<xref:System.Windows.FrameworkContentElement.Name%2A>。 例外情况是字符串具有某些重载的含义，例如用于中显示该名称是否[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 设置<xref:System.Windows.FrameworkContentElement.Name%2A>从代码如果原始<xref:System.Windows.FrameworkContentElement.Name%2A>已从标记中的设置也不建议，并更改该属性不会更改的对象引用。 仅当过程中显式创建基础名称范围时，会创建此类对象引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]加载。  
  
 具体而言，必须调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>以进行有效的更改上<xref:System.Windows.FrameworkContentElement.Name%2A>已加载元素的属性。  
  
 一个值得一提设置情况<xref:System.Windows.FrameworkContentElement.Name%2A>从代码很重要是用于对运行演示图板将命名元素。 可以注册名称之前，可能还需要实例化并分配<xref:System.Windows.NameScope>实例。 请参阅示例部分中，或[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 设置<xref:System.Windows.FrameworkContentElement.Name%2A>从代码具有有限的应用程序，但按名称查找元素，则更容易，尤其是当采用一种导航模型的页面重新加载到应用程序和运行时代码不一定是的代码隐藏相应的页。 实用程序方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，这是可从任何<xref:System.Windows.FrameworkContentElement>，可以找到的任何元素<xref:System.Windows.FrameworkContentElement.Name%2A>中该元素的逻辑树以递归方式。 也可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>的静态方法<xref:System.Windows.LogicalTreeHelper>，其还会<xref:System.Windows.FrameworkContentElement.Name%2A>字符串作为参数。  
  
 常用根元素 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 实现该接口<xref:System.Windows.Markup.INameScope>。 此接口的实现需要强制实施的名称会明确其作用域内。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Name" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序的元素引发。 因此，您的实现必须考虑该事件参数的源属性 （并且不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要采取的事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary><see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的类处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该事件来源于此元素，此类处理程序在此元素上设置相应的焦点行为。 如果事件的源树中的另一个元素，该处理程序没有任何影响。  
  
 若要更改这些默认焦点行为在元素上重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary>引发 <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 事件。 只要将 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 设置为 <see langword="true" />，就可以调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题中前面所述，此虚拟方法的默认实现将引发事件。 重写应调用 base （） 以保留此行为。  
  
 请注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>属性是只读的。 因此，不能设置它以这种方式强制执行初始化行为。 初始化设置旨在只能由[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]框架。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">描述已更改的属性的事件数据，包括旧值和新值。</param>
        <summary>每当更新此 <see cref="T:System.Windows.FrameworkContentElement" /> 的任何依赖属性的有效值时调用。 将在实参形参中报告已更改的特定依赖属性。 重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不应以通常将检测到属性更改或失效。 它改为适用于修改常规失效模式如果特定的信息了解了宽分类的属性。  
  
 调用此方法可能很多时候一个对象的生命周期内。 因此，可以实现更好的性能，如果重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>各个属性的函数。 但是，应使用此方法，如果<xref:System.Windows.FrameworkContentElement>包括大量的值相关的依赖项属性，或如果它包含逻辑，例如呈现行为，必须重新运行多个相关的属性失效的情况。  
  
 请注意，没有具有相同名称`OnPropertyChanged`具有不同签名的方法 (参数类型是<xref:System.ComponentModel.PropertyChangedEventArgs>)，可能出现在多个类。 是否`OnPropertyChanged`用于数据对象通知，并且是为协定的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现中，您的实现中的第一个操作。 如果不这样做将大大禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，这会导致不正确的值报告。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">旧样式。</param>
        <param name="newStyle">新样式。</param>
        <summary>在此元素上使用的样式更改时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有一个默认实现，设置一个内部标志指明样式更改条件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现，否则不能应用样式。 如果派生的类具有专用的样式选择器，或缓存样式值，可能会包括重写此方法的方案。 主题更改可能会调用此方法。</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要采取的事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素是否合并了主题样式的样式属性。</summary>
        <value>如果此元素不使用主题样式属性，则为 <see langword="true" />；所有源于样式的属性均来自本地应用程序样式，不会应用主题样式属性。 如果首先应用了应用程序样式，然后将主题样式应用于未在应用程序样式中专门设置的属性，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是间接提供主题样式的样式资源库中使用。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑树中的父级。</summary>
        <value>此元素的逻辑父级。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，具体取决于应用程序的功能，可能发生更改的元素的逻辑父级保留此属性的值将不反映所做的更改。 需要它之前，通常应获取的值。  
  
 请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)有关遍历逻辑树和方案其中采用针对元素发现这种方法相应的详细信息。  
  
 属性系统将后可能重新计算所有属性值的元素父级，因为某些属性继承值到逻辑树。 <xref:System.Windows.FrameworkContentElement.DataContext%2A>适用于绑定可以还元素的父级更改。  
  
 更改元素的父级通常只能通过集合的操作，通过使用专用添加或删除方法，或通过设置内容属性的元素。  
  
 使用的最典型情形<xref:System.Windows.FrameworkContentElement.Parent%2A>属性将获取的引用，然后获取各种<xref:System.Windows.FrameworkContentElement>从父对象的属性值。 对于模板，<xref:System.Windows.FrameworkContentElement.Parent%2A>模板的最终将`null`。 若要忽略这一点并扩展到实际应用了模板的逻辑树，请使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>。  
  
   
  
## Examples  
 以下示例检查以查看是否<xref:System.Windows.FrameworkContentElement.Parent%2A>的<xref:System.Windows.Documents.TextPointer>的特定类型。  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">应确定其预期焦点更改的方向。</param>
        <summary>根据提供的焦点移动方向，确定在此元素之后接收焦点的下一个元素，但不实际移动焦点。 此方法是密封的，不能对其进行重写。</summary>
        <returns>如果实际遍历了焦点，则为焦点将要移到的下一个元素。 如果焦点不能按提供的方向相对于此元素移动，则可能返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 是实际移动焦点的相关的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定了以下方向之一：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 对于 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 来说，这些方向是非法的（但对于 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 来说是合法的）。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要在指定的名称-对象映射中使用的名称。</param>
        <param name="scopedElement">映射的对象。</param>
        <summary>提供一个可简化对 <see cref="T:System.Windows.NameScope" /> 注册方法访问的访问器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.NameScope.RegisterName%2A>。 该实现将检查后续父元素，直到它找到的适用<xref:System.Windows.NameScope>实现，它可以通过查找的元素，实现<xref:System.Windows.Markup.INameScope>。 有关名称范围的详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>为正确挂钩的应用程序时在代码中创建动画演示图板是必需的。 这是因为其中一个主要的演示图板属性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，使用运行时名称查找而不是要采用对目标元素的引用。 即使该元素是通过从代码引用可访问，这是如此。 为什么需要注册名称的情节提要目标的详细信息，请参阅[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。 为内容元素的动画是比动画在控件上，不太常见[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)重点介绍控制方案。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要移除的元素。</param>
        <summary>从该元素的逻辑树中移除指定的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]主要适用于派生的情况下，类时添加为子集合的支持。  
  
 大多数<xref:System.Windows.FrameworkContentElement>派生的类公开的负责包含专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。 派生自这些类通常可以避免无需直接操作逻辑树。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前本地定义的资源字典。</summary>
        <value>当前本地定义的资源。 这是一本资源字典，可通过键来访问字典中的资源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定义的资源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常创建为属性元素中，并且通常是针对任何单独的页面或应用程序的根元素上。 在此级别将资源字典可以更轻松地找到从页面中的各个子元素 （或从任何页上，在应用程序的情况下）。 在大多数应用程序方案中，我们建议样式定义为使用的资源字典中的对象元素或定义为外部资源中，以便整个样式资源可以是自包含 （此方法有助于单独设计器从开发人员的责任由分隔的物理文件，需要编辑职责）。  
  
 请注意，此属性返回该元素内直接声明仅的资源字典。 这是不同于实际资源查找过程，其中的子元素可以访问任何向上递归搜索每个父元素中定义的资源。  
  
 资源还可以通过从集合中的代码引用，但请注意在创建资源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]绝对不可访问，直到<xref:System.Windows.FrameworkContentElement.Loaded>引起声明该字典的元素。 实际上，资源以异步方式进行分析，甚至不能<xref:System.Windows.FrameworkContentElement.Loaded>事件是可以引用保障[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义资源。 出于此原因，通常只应访问[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义的资源作为的一部分运行时代码，或通过其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技术，如样式或特性值的资源扩展引用。 当通过代码访问资源时，它在实质上是等效于[DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)于从[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基础<xref:System.Windows.ResourceDictionary>支持添加、 删除，或通过使用代码查询从集合中的资源所需的方法。 <xref:System.Windows.FrameworkContentElement.Resources%2A>属性是可以设置以支持此方案的完全替换的元素是一个新的或不同的资源集合<xref:System.Windows.ResourceDictionary>。  
  
 请注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的语法不包含的元素<xref:System.Windows.ResourceDictionary>。 这是隐式集合语法; 的示例表示集合元素的标记，则可以省略。 改为指定作为项目添加到集合的元素。 有关隐式集合的详细信息和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，请参阅[XAML 语法详述](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 一种情况下，<xref:System.Windows.ResourceDictionary>元素是引入合并的字典，这种情况下是否存在通常没有子元素，如仍指定显式<xref:System.Windows.ResourceDictionary>。 有关详细信息，请参阅[合并资源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一个或多个对象元素，其中每个定义的资源。 在每个每个资源属性元素<xref:System.Windows.ResourceDictionary>必须具有唯一值[X:key 指令](~/docs/framework/xaml-services/x-key-directive.md)，从检索值时，它可作为唯一键<xref:System.Windows.ResourceDictionary>。  
  
   
  
## Examples  
 下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的收集<xref:System.Windows.Documents.FlowDocument>根元素。 <xref:System.Windows.Documents.FlowDocument> 是一个典型的选择，因为它是一个将少数<xref:System.Windows.FrameworkContentElement>作为根元素和资源有意义的类通常存储在页面根或更高级别的如在应用程序。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的依赖属性向此元素附加一个绑定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">标识绑定属性。</param>
        <param name="path">源属性名称或用于绑定的属性的路径。</param>
        <summary>将提供的源属性名作为数据源的路径限定，从而将绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>，并创建一个新<xref:System.Windows.Data.Binding>基于所提供`path`参数。 此签名是更方便，如果您要建立一个简单的默认绑定。 如果你需要指定任何绑定属性为非默认条件，或者想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，则应使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>签名。  
  
   
  
## Examples  
 下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中，通过创建新的自定义数据对象，该对象作为建立<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">标识绑定属性。</param>
        <param name="binding">表示数据绑定。</param>
        <summary>基于已提供的绑定对象将一个绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>。  
  
   
  
## Examples  
 下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中的，通过创建一个新<xref:System.Windows.Data.Binding>并将源设置为新生成`DateTime`对象。  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">资源绑定到的属性。</param>
        <param name="name">资源的名称。</param>
        <summary>搜索具有指定名称的资源，并且为指定的属性设置一个指向该资源的资源引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 资源引用是类似于使用[DynamicResource 标记扩展](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)标记中。 资源引用创建一个内部表达式，用于提供在运行时的延迟基础上的指定属性的值。 将重新计算表达式时资源字典指示更改的值通过内部事件，或者每当重新设定当前元素 （父级更改会更改字典查找路径）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`只要本地没有至少一个键控的资源<xref:System.Windows.FrameworkContentElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`如果<xref:System.Windows.Style>本地设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当参与此元素上的绑定的任意关联数据源更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件图面<xref:System.Windows.Data.Binding.SourceUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素要使用的样式。</summary>
        <value>若存在，则为此元素适用的非默认样式。 否则为 <see langword="null" />。 对于默认构造的 <see cref="T:System.Windows.FrameworkContentElement" />，其默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从主题设置，或从通常由资源在页面或应用程序级别 （隐式样式） 应用于该类型的对象的样式的默认样式通常提供当前样式。 此属性不会设置或返回默认 （主题） 样式，但它确实会隐式样式或显式样式。 如果存在隐式或显式样式，并不重要是否访问作为资源或本地定义的样式。  
  
 设置样式存在一些限制。 你可以重置整个<xref:System.Windows.FrameworkContentElement.Style%2A>属性设置为一个新<xref:System.Windows.Style>在任何时候，这将强制布局重新组合。 但是，一旦加载的元素，该样式放置在使用<xref:System.Windows.Style>应被视为密封。 尝试对正在使用样式的任何单个属性进行更改 (如的在集合中的任何内容<xref:System.Windows.Style.Setters%2A>) 会导致引发异常。 在标记中定义的样式被视为一旦加载从资源字典 （适用于资源），或包含在页面加载 （适用于内联样式），可使用。  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 是具有特殊的优先顺序的依赖项属性。 本地设置样式通常在进行操作的最高优先级属性系统中。 如果<xref:System.Windows.FrameworkContentElement.Style%2A>期间加载属性系统检查隐式样式定义指定该类型的资源作为在此情况下，为 null。 如果样式是完成此步骤后仍然为 null 则样式来自默认 （主题） 样式，但默认样式中不会返回<xref:System.Windows.FrameworkContentElement.Style%2A>属性值。 请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:、 或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法就从技术上讲，但不是建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  绑定引用使用[TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md)或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的收集<xref:System.Windows.Documents.FlowDocument>根元素，然后将其引用为特定样式的资源作为<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>如果 <paramref name="propertyName" /> 可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Windows.FrameworkContentElement> 实例强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置任意对象值，该值可用于存储关于此元素的自定义信息。</summary>
        <value>预期值。 此属性没有默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是类似于其他 Microsoft 编程模型，如 Visual Basic 应用程序或 Windows 窗体中的标记属性。 它旨在提供一个预先存在的空间来存储有关任何元素的一些基本的自定义信息，而不强制应用程序开发人员创建子类。  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML 值  
 由于此属性需要一个对象，需要设置以便使用属性元素用法<xref:System.Windows.FrameworkContentElement.Tag%2A>在 XAML 中为具有已知和内置类型转换器，如字符串的对象以外的任何属性。 这种方式中使用的对象通常不是标准的 WPF 命名空间内，因此可能需要以引入作为 XAML 元素的命名空间映射到外部命名空间。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 依赖属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当参与此元素上的绑定的任意关联目标属性更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件图面<xref:System.Windows.Data.Binding.TargetUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。 这通常意味着所讨论的绑定是双向绑定，且绑定的依赖属性确定每个任何验证或缓存的属性支持的方案的以前属性值无效。  
  
 此事件的事件参数会通知你绑定属性已更改。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此元素的模板父级的引用。 如果该元素不是通过模板创建的，则此属性无关。</summary>
        <value>元素的<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />导致要创建此元素。 此值通常为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 模板实际上是共享的对象，其中只有一次创建模板的内容。 因此，如果您获得来自模板的元素的对象引用，可能会发现明显的逻辑树不会访问到页面根。 若要连接到该页面的逻辑树这样的模板引用，应会看到<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>值并继续根据需要该元素树中导航。  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 通常会`null`对常见对象，因为如果您通过典型方式在应用程序中获取从页面外的对象引用，该元素可能不从创建模板。 事例<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>可能不是`null`将包括处理某些低级别的输入事件，或使用枚举器返回了来自模板的元素的命中测试的事件等操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中为此元素显示的工具提示对象。</summary>
        <value>工具提示对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值属于类型<xref:System.Windows.Controls.ToolTip>，则它就是将在中使用工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值为任何其他类型，则该值将用作*内容*为<xref:System.Windows.Controls.ToolTip>提供系统 （构造）。 有关详细信息，请参阅 <xref:System.Windows.Controls.ToolTipService>。 服务类提供了可用于进一步自定义工具提示的附加的属性。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 将成为显示的文本的字符串<xref:System.Windows.FrameworkContentElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 对象元素窗体，应使用的内容作为中提供某些对象<xref:System.Windows.FrameworkContentElement>。 通常，这是<xref:System.Windows.FrameworkElement>或创建布局的组合的情况下的某些其他元素<xref:System.Windows.FrameworkContentElement.ToolTip%2A>，最终包含在该组合中的文本内容。 在此使用情况<xref:System.Windows.Controls.ToolTip>元素创建隐式地从已分析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，并*经过*内容设置为其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>属性。  
  
 <`ToolTip` .../>  
 请参阅 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例设置的值<xref:System.Windows.FrameworkElement.ToolTip%2A>直接为字符串的属性。  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭工具提示，该事件的处理程序应将其标记为已处理。  
  
 此事件不能为<xref:System.Windows.EventTrigger>样式中。 这是因为此事件的标识符字段重新使用从一种服务，不会公开事件的添加/删除方法的实现。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开工具提示，事件的处理程序应将相关的事件标记为已处理。 否则为值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性将用于自动打开上下文菜单。 将标记处理的事件将有效地取消默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。 请注意，是否将不会引发此事件<xref:System.Windows.FrameworkContentElement.ToolTip%2A>为空引用或其他取消设置。  
  
 此事件不能为<xref:System.Windows.EventTrigger>样式中。 这是因为此事件的标识符字段重新使用从一种服务，不会公开事件的添加/删除方法的实现。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找到，则返回该资源。</summary>
        <returns>找到的资源。 如果找不到资源，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用元素上找不到资源，使用在树的方法相同的逻辑树中，搜索父树由在运行时参数请求动态资源引用时搜索。  
  
 通常，会立即强制转换为已尝试设置为返回的资源值的属性的类型的返回值。  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A>方法具有类似行为，不同之处在于它将在不使用提供的键查找资源的情况下发生异常。  
  
   
  
## Examples  
 下面的示例查找资源，在标记中定义并将其应用于路由事件的响应中的元素的某一属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从已加载元素的元素树中移除元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。 直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要从当前范围中移除的名称-对象对的名称。</param>
        <summary>简化对 <see cref="T:System.Windows.NameScope" /> 注销方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要重新注册该名称与另一个元素只需取消注册名称到系统。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认样式重新应用至当前 <see cref="T:System.Windows.FrameworkContentElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>