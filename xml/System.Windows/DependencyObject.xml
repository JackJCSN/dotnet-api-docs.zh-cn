<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9909bfd452bcd81963621d54c49b964f2e5e3ce1" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70594688" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个参与依赖项属性系统的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类可对[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]其许多派生类启用属性系统服务。 <xref:System.Windows.DependencyObject>  
  
 属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的其他键类为<xref:System.Windows.DependencyProperty>。 <xref:System.Windows.DependencyProperty>允许将依赖属性注册到属性系统，并提供有关每个依赖属性的标识和信息，而<xref:System.Windows.DependencyObject>作为基类使对象可以使用依赖项属性。  
  
 <xref:System.Windows.DependencyObject>服务和特征包括：  
  
-   依赖属性承载支持。 通过调用<xref:System.Windows.DependencyProperty.Register%2A>方法，并将该方法的返回值存储为类中的公共静态字段，来注册依赖属性。  
  
-   附加属性托管支持。 可以通过调用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法来注册附加属性，并将该方法的返回值存储为类中的公共静态只读字段。 （还有其他成员要求; 请注意，这表示[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加属性的特定实现。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。）然后，可以在派生自<xref:System.Windows.DependencyObject>的任何类上设置附加属性。  
  
-   获取、设置和清除中存在<xref:System.Windows.DependencyObject>的任何依赖项属性值的实用工具方法。  
  
-   元数据、强制值支持、属性更改通知和替代依赖属性或附加属性的回调。 此外， <xref:System.Windows.DependencyObject>类还有助于依赖项属性的每个所有者的属性元数据。  
  
-   派生自<xref:System.Windows.ContentElement>、 <xref:System.Windows.Freezable>或<xref:System.Windows.Media.Visual>的类的公共基类。 （<xref:System.Windows.UIElement>，另一个基元素类具有包含<xref:System.Windows.Media.Visual>的类层次结构。）  
  
   
  
## Examples  
 下面的示例从<xref:System.Windows.DependencyObject>派生，以创建一个新的抽象类。 然后，类将注册附加属性，并包含该附加属性的支持成员。  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.DependencyObject" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要清除的由 <see cref="T:System.Windows.DependencyProperty" /> 对象引用指定的依赖属性。</param>
        <summary>清除属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyProperty" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用<xref:System.Windows.DependencyObject.ClearValue%2A>来清除属性值并不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除属性仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后<xref:System.Windows.DependencyObject.ClearValue%2A>调用来清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">要清除的依赖属性的关键字。</param>
        <summary>清除只读属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyPropertyKey" /> 指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey>标识属性系统操作的只读依赖属性。 定义只读依赖项属性的类不应公开此密钥的公共访问权限。 公开密钥将提供一个非属性的只读字符的公共代码路径，前提是可以在类或程序集的外部<xref:System.Windows.DependencyObject.ClearValue%2A>调用<xref:System.Windows.DependencyObject.SetValue%2A>方法（如或），并引用密钥。  
  
 通过调用<xref:System.Windows.DependencyObject.ClearValue%2A>来清除属性值并不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除该值仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要强制转换的依赖项属性的标识符。</param>
        <summary>对指定依赖属性的值进行强制。 通过对调用方 <see cref="T:System.Windows.DependencyObject" /> 上存在的依赖属性的属性元数据中所指定的任何 <see cref="T:System.Windows.CoerceValueCallback" /> 函数进行调用来完成此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了通过调用<xref:System.Windows.DependencyObject.CoerceValue%2A>显式调用以外<xref:System.Windows.CoerceValueCallback> ，每当[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统重新计算依赖属性值时，也会在内部调用依赖属性的。  
  
 调用<xref:System.Windows.DependencyObject.CoerceValue%2A>方法时，最终将为指定的属性调用强制值回叫。 通常，仅当<xref:System.Windows.DependencyObject.CoerceValue%2A>知道强制值回调存在并且知道回调的强制条件时，才会调用。  
  
 调用<xref:System.Windows.DependencyObject.CoerceValue%2A>的最常见的情况是在类处理或属性更改回调的相关属性中，这些属性会以从属方式影响彼此的值。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
   
  
## Examples  
 下面的示例在<xref:System.Windows.DependencyObject.CoerceValue%2A>用作相同<xref:System.Windows.PropertyChangedCallback>类的不同依赖属性的<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>实现中调用。 这是在依赖属性之间引入 true 值依赖项的常见模式。  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效或不存在。</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</summary>
        <value>对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从方法返回的对象的返回值类型<xref:System.Windows.DependencyObject>为，并且你希望根据其类型对其执行特定于属性系统的操作，则此属性很有用。 例如， <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> <xref:System.Windows.DependencyObjectType>使用而不[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]是类型来调用更有效。 <xref:System.Windows.DependencyObjectType>有助于加快查找速度。  
  
   
  
## Examples  
 在下面的伪代码示例`MySubClass`中，预计其他派生类可能会更改`MyCustom`依赖属性的默认值。 类实现一个无参数的构造函数，该构造函数可以通过在<xref:System.Windows.DependencyObjectType>值上利用多态性，只要该构造函数用作派生类 instantiator。  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前实例进行比较的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>确定提供的 <see cref="T:System.Windows.DependencyObject" /> 是否等效于当前 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>如果两个实例相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现只是引用相等性，不会尝试计算所包含属性的值相等性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />重写然后密封两种<see cref="T:System.Object" />基本方法<see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> ： <see cref="M:System.Windows.DependencyObject.GetHashCode" />和。 重写调用<see cref="T:System.Object" />实现，从而导致对象相等行为。 这些有意的替代的目的是防止派生类尝试为指定值相等性<see cref="T:System.Windows.DependencyObject" />。 的值 equalities <see cref="T:System.Windows.DependencyObject" />将永远不准确<see cref="T:System.Windows.DependencyObject" /> ，这是因为原始属性值更改功能及其依赖属性。 这包括数据[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]绑定[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]和属性系统等基础功能。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此 <see cref="T:System.Windows.DependencyObject" /> 的哈希代码。</summary>
        <returns>带符号的 32 位整数哈希代码。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />重写然后密封两<see cref="T:System.Object" />种方法<see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> ： <see cref="M:System.Windows.DependencyObject.GetHashCode" />和。 重写调用<see cref="T:System.Object" />实现，从而导致对象相等行为。 这些有意的替代的目的是防止派生类尝试为指定值相等性<see cref="T:System.Windows.DependencyObject" />。 的值 equalities <see cref="T:System.Windows.DependencyObject" />将永远不准确<see cref="T:System.Windows.DependencyObject" /> ，这是因为原始属性值更改功能及其依赖属性。 这包括数据[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]绑定[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]和属性系统等基础功能。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个专用的枚举数，用于确定哪些依赖项属性在此 <see cref="T:System.Windows.DependencyObject" /> 上具有以本地方式设置的值。</summary>
        <returns>一个专用的本地值枚举数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *本地值*是由设置的<xref:System.Windows.DependencyObject.SetValue%2A>任何依赖属性值，而不是属性系统的其他方面。  
  
 通过<xref:System.Windows.LocalValueEnumerator>调用<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>获取的可用于枚举在<xref:System.Windows.DependencyObject>实例上具有本地设置的值的属性。 每个这样的属性都由一个<xref:System.Windows.LocalValueEntry>对象在枚举器中表示，该对象的属性引用特定<xref:System.Windows.DependencyProperty>的及其值。 这种枚举本地集值的方法可用于优化或用于本地值的其他处理，例如，确定的<xref:System.Windows.DependencyObject>哪些属性值会更改（如果它们已被清除）。  
  
> [!IMPORTANT]
>  返回<xref:System.Windows.LocalValueEnumerator>的可能包含<xref:System.Windows.LocalValueEntry>只读依赖项属性的记录或属性系统计算值的依赖项属性。 例如，具有通过布局建立的宽度的视觉框架元素将报告的本地值<xref:System.Windows.FrameworkElement.ActualWidth%2A>。 如果你正在获取本地值来重置它们，请检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>每个<xref:System.Windows.LocalValueEntry>的属性标识符上的值，以验证问题<xref:System.Windows.DependencyProperty>是否不是只读的。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后<xref:System.Windows.DependencyObject.ClearValue%2A>调用来清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要为其检索值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>对 <see cref="T:System.Windows.DependencyObject" /> 的此实例返回依赖属性的当前有效值。</summary>
        <returns>返回当前的有效值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *有效的值*是属性系统返回给请求该值的任何调用方的属性的值。 有效的值是属性系统计算所有可能的输入，这些输入都参与属性系统值的优先级。 这包括强制和动画。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 此方法将永远不<xref:System.Windows.DependencyProperty.UnsetValue>会返回。 <xref:System.Windows.DependencyProperty.UnsetValue>是属性系统的一个 sentinel 值，可在内部使用并偶尔通过强制回调公开。  
  
 如果不确定属性的类型，则可以查询请求的依赖项属性的标识符，以确定是否有更具体<xref:System.Windows.DependencyProperty.PropertyType%2A>的返回值可以转换为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效，或者指定的 <paramref name="dp" /> 不存在。</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要使其失效的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>重新计算指定依赖项属性的有效值</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>时，可能会调用为该<xref:System.Windows.CoerceValueCallback>依赖属性注册的任何关联的和适用的或<xref:System.Windows.PropertyChangedCallback>函数。  
  
 对<xref:System.Windows.DependencyObject.InvalidateProperty%2A>设置了本地值的属性调用将不起作用，因为本地值优先于其他属性系统输入，动画除外。 但是，您可以调用<xref:System.Windows.DependencyObject.ClearValue%2A>，然后调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>不一定适用于许多依赖属性方案。 如果因任何组成部分中的值发生更改而导致依赖属性无效，则属性系统将使该依赖属性自动失效并重新计算该属性。 但仍有一些适合的方案<xref:System.Windows.DependencyObject.InvalidateProperty%2A> 。 特别是，可以在其他<xref:System.Windows.DependencyObject.InvalidateProperty%2A>依赖属性的强制值或属性更改回调内使用。 你还可以使用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>来对无法实现建议<xref:System.ComponentModel.INotifyPropertyChanged>的通知机制的数据源（可能是如果使用无法从派生的数据类，或者数据为静态的数据源）强制重新计算绑定成员）。  
  
   
  
## Examples  
 下面的示例在<xref:System.Windows.DependencyObject.InvalidateProperty%2A>自定义属性上调用，而在属性的计算中涉及的属性发生变化时。 这是一种调用<xref:System.Windows.DependencyObject.CoerceValue%2A>方法的替代方法，因为使属性失效还会调用任何已注册<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>的。  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此实例当前是否为密封的（只读）。</summary>
        <value>如果此实例是密封的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值在内部设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">将包含相关依赖项属性标识符、类型的属性元数据以及旧值和新值的事件数据。</param>
        <summary>每当更新此 <see cref="T:System.Windows.DependencyObject" /> 的任何依赖属性的有效值时调用。 更改的特定依赖项属性将在事件数据中报告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常不用于检测单个属性更改，也不会对每个案例执行属性失效。 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>用于修改常规失效模式，前提是了解有关属性的广泛分类的信息。 例如，中的更改可能<xref:System.Windows.Freezable>是的值类型<xref:System.Windows.Freezable>发生更改，也可能是子属性，其中的更改在其他<xref:System.Windows.Freezable>引用内。 <xref:System.Windows.Freezable> 的 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 重写实现使用内部信息来确定属性是否为子属性，并为任意一种情况提供适当的基类逻辑。  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>在对象的整个生存期内，可能会多次调用。 因此，如果你重写特定属性的元数据，然后为单个属性附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>函数，则可以为整个属性系统获得更好的性能。 但是，如果<xref:System.Windows.DependencyObject>包含大量与值相关的依赖项属性，则可以使用此方法，或者，如果包含的逻辑（如呈现行为）必须针对属性失效的几个相关事例重新运行，则应使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现。 如果不这样做，将明显禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，从而导致报告错误的值。</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要为其检索值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>如果存在，则返回依赖属性的本地值。</summary>
        <returns>返回本地值，或在未设置本地值的情况下返回 sentinel 值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于依赖属性<xref:System.Windows.DependencyObject.GetValue%2A> ，您应使用最典型的 "get" 操作。 <xref:System.Windows.DependencyObject.ReadLocalValue%2A>如果值不是本地设置的，则不会返回有效的值。  
  
 由 "样式"、"主题"、"模板"、"元数据" 或 "属性值继承" 的默认值设置的值不被视为本地值。 但是，在计算绑定和其他表达式后，它们被视为本地值。  
  
 如果未设置本地值，则此方法返回<xref:System.Windows.DependencyProperty.UnsetValue>。  
  
 如果返回的值不是<xref:System.Windows.DependencyProperty.UnsetValue>，则可以查询请求的依赖项属性的元数据，以确定是否有更具体的类型可以将返回值转换为。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖项属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的值而不更改其值源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由组件使用，该组件以编程方式设置其自己的属性之一的值，而无需禁用应用程序声明的属性用法。 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>方法可更改属性的有效值，但现有触发器、数据绑定和样式将继续工作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖项属性，或尝试修改密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 的类型不是为 <paramref name="dp" /> 属性注册时使用的正确类型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置依赖属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖项属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的本地值，该值由其依赖属性标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 应始终将参数提供为适当的类型。 `value`  
  
 在所设置的依赖项属性的<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>依赖项属性标识符上存在回调时，异常情况可能会受到影响。 否则，提供的值可能会失败，一般类型检查条件（例如，在本机类型为 Double 时传递字符串）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖项属性，或尝试修改密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 的类型不是为 <paramref name="dp" /> 属性注册时使用的正确类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要设置的属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置一个只读依赖属性的本地值，该值由依赖属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你为自定义类定义的只读依赖项属性设置值时，通常使用此签名。 通常， <xref:System.Windows.DependencyObject.SetValue%2A>仅从注册该依赖项属性的类型调用，后者实现为依赖属性提供确定值的内部逻辑。 有关详细信息，请参阅[只读依赖属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 应始终将参数提供为适当的类型。 `value` 在所设置的依赖项属性的<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>依赖项属性标识符上存在回调时，异常情况可能会受到影响。  
  
   
  
## Examples  
 下面的示例定义了一个只读依赖项属性，以及一个`public static readonly` <xref:System.Windows.DependencyProperty>为属性使用者提供了必需的只读公开的，以及[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装的 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">应序列化的依赖项属性的标识符。</param>
        <summary>返回一个值，该值指示序列化进程是否应序列化所提供的依赖属性的值。</summary>
        <returns>如果应对提供的依赖项属性的值进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果依赖属性在`true` <xref:System.Windows.DependencyObject>上建立了一个本地值，则默认实现将返回。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的替代可能以不同方式处理特定依赖属性。</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
