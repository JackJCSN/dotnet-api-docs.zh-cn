<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8dbd7c54611eae4fc67bc3cfb380e97f4369f241" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63887934" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供与 Windows 事件日志的交互。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> 可访问或自定义 Windows 事件日志，记录有关软件或硬件的重要事件的信息。 使用<xref:System.Diagnostics.EventLog>，可以从现有的日志读取、 写入日志条目、 创建或删除事件源，删除日志，和响应的日志条目。 创建事件源时，还可以创建新的日志。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用对象实现 IDisposable"一节<xref:System.IDisposable>接口主题。  
  
 除了提供对单个事件日志和它们的项，访问<xref:System.Diagnostics.EventLog>类允许您访问所有事件日志的集合。 可以使用`static`的成员<xref:System.Diagnostics.EventLog>若要删除日志，获取日志列表、 创建或删除源，或确定计算机是否已包含一个特定的源。  
  
 有三个默认事件日志：应用程序、 系统和安全。 安全日志是只读的。 其他应用程序和服务安装，如 Active Directory，可能有其他事件日志。  
  
 使用的安全注意事项<xref:System.Diagnostics.EventLog>类。 <xref:System.Diagnostics.EventLog> 需要<xref:System.Diagnostics.EventLogPermission>的.NET Framework 2.0 和更高版本中的特定操作或.NET Framework 1.0 和 1.1 中的完全信任权限。 我们建议，<xref:System.Diagnostics.EventLogPermission>不授予给部分受信任的代码。  应永远不会传递事件日志的任何对象，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>对象，不太受信任的代码。 例如，创建<xref:System.Diagnostics.EventLog>对象，写入条目，并将传递<xref:System.Diagnostics.EventLog>对象与部分受信任代码可以创建安全问题，因为能够读取和写入事件日志允许代码执行操作，例如颁发另一个应用程序的名称的事件日志消息。  
  
 从 Windows Vista 开始，用户帐户控制 (UAC) 确定的用户的凭据。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要运行的代码访问安全日志，首先必须将你的凭据从标准用户提升至管理员。 通过打开该应用程序的快捷菜单中启动应用程序时可以执行此操作 （如果您使用鼠标，右键单击应用程序图标） 并指示你想要以管理员身份运行。  
  
 可以使用<xref:System.Diagnostics.EventLog>若要创建自定义事件日志，您可以通过服务器的事件查看器。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法，以便在事件查看器中显示的事件日志的本地化的名称。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法时它达到其最大日志大小配置行为的事件日志。  
  
 若要从事件日志中读取，指定日志名称 (<xref:System.Diagnostics.EventLog.Log%2A>属性) 和服务器计算机名称 (<xref:System.Diagnostics.EventLog.MachineName%2A>事件日志的属性。 如果未指定服务器的计算机名，本地计算机"。"，则假定。 不需要指定事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)，因为源是仅需要写入日志。 <xref:System.Diagnostics.EventLog.Entries%2A>属性会自动填充的条目的事件日志的列表。  
  
 若要写入事件日志，请指定或创建事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)。 若要创建新的事件源的计算机上，必须具有管理凭据。 事件源将注册你的应用程序与事件日志的有效源的条目。 可以使用事件源写入一次只有一个日志。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任何随机字符串，但该名称必须不同于计算机上的其他源。 事件源通常是应用程序或另一个标识字符串的名称。 尝试创建重复<xref:System.Diagnostics.EventLog.Source%2A>值将引发异常。 但是，单个事件日志可以与多个源相关联。  
  
 如果与关联事件日志的事件源<xref:System.Diagnostics.EventLog>实例不存在，则创建新的事件源。 若要创建的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理凭据。  
  
 此要求是因为必须搜索所有事件日志，包括安全日志，以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
  
> [!IMPORTANT]
>  创建或删除事件源需要使用已命名的互斥体的基础代码的同步。 如果高特权的应用程序锁定已命名的 mutex，尝试创建或删除事件源会导致应用程序停止响应，直到锁被释放。 若要帮助防止出现此问题，永远不会授予<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>到不受信任代码的权限。 此外，<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>权限可能允许绕过其他权限，并仅应授予高度受信任的代码。  
  
 应用程序和服务应编写应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。 如果未显式设置<xref:System.Diagnostics.EventLog.Log%2A>属性，默认为应用程序日志的事件日志。  
  
> [!NOTE]
>  没有要保护应用程序免受编写为任何已注册的源内容。  如果应用程序授予<xref:System.Diagnostics.EventLogPermissionAccess.Write>权限，它可以写入事件的任何有效的源计算机上注册。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将事件写入到事件日志。 必须指定事件源写入事件;必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统未常常刷新其事件源的列表，并且您尝试编写新的源的事件写入操作将失败。 可以使用配置新的源<xref:System.Diagnostics.EventLogInstaller>对象或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理凭据。  
  
 每个源可以一次; 写入一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要多个源配置为使用不同的事件日志或不同的资源文件。 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建它。 如果其他应用程序或组件使用现有的源，请使用更新的配置，而不是删除现有源创建新的源。  
  
 为事件类别和消息字符串，可以使用本地化的资源注册事件源。 你的应用程序可以通过使用资源标识符而不指定实际的字符串值写入事件日志项。 请参阅<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>有关的资源文件中配置你的源的详细信息的类。  
  
 如果你的应用程序直接将字符串值写入事件日志，您不需要设置源的文件属性的资源。 要写入本地化的项还是要直接写入字符串，必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
 写入事件时，必须至少指定一个消息字符串或将消息字符串的资源标识符。 其他事件属性是可选的。 可选事件设置的示例包括：  
  
-   可以设置<xref:System.Diagnostics.EventLogEntryType>以指定事件查看器显示的项的图标。  
  
-   如果你的应用程序使用类别进行筛选事件，可以指定事件的类别标识符。  
  
-   如果你想要将其他信息与给定的事件相关联，您可以将二进制数据附加到事件项。  
  
> [!IMPORTANT]
>  事件日志记录占用磁盘空间、 处理器时间和其他系统资源。 请务必只记录重要信息。 我们建议将事件日志的调用放在错误路径，而不是在主代码路径中，因此它们不性能产生负面影响。  
  
 有关实例的初始属性值的列表<xref:System.Diagnostics.EventLog>，请参阅<xref:System.Diagnostics.EventLog.%23ctor%2A>构造函数。  
  
   
  
## Examples  
 下面的示例创建事件源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
> [!NOTE]
>  从 Windows Vista 开始，你必须以管理员身份运行此应用程序。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 不将该实例与任何日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然后再调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性的<xref:System.Diagnostics.EventLog>实例。 如果仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，可选择指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本地计算机 ("。")。|  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">本地计算机上日志的名称。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与本地计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性设置为`logName`参数。 然后再调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性的<xref:System.Diagnostics.EventLog>实例。 如果仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，可选择指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。 此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>属性，但您可以更改此读取操作之前<xref:System.Diagnostics.EventLog.Entries%2A>属性。  
  
 如果你在中指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性从其他源的计算机上，后续调用都是唯一<xref:System.Diagnostics.EventLog.WriteEntry%2A>如果尚不存在具有指定名称创建一个日志。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本地计算机 ("。")。|  
  
   
  
## Examples  
 下面的示例读取事件日志，在本地计算机上"myNewLog"中的条目。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定算机上日志的名称。</param>
        <param name="machineName">日志所在的计算机。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与指定计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性设置为`logName`参数和<xref:System.Diagnostics.EventLog.MachineName%2A>属性设置为`machineName`参数。 然后再调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性的<xref:System.Diagnostics.EventLog>。 如果仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，可选择指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>并<xref:System.Diagnostics.EventLog.MachineName%2A>属性，但您可以更改之前读取<xref:System.Diagnostics.EventLog.Entries%2A>属性。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"myNewLog"计算机"myServer"上的条目。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 - 或 -  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定的计算机上日志的名称</param>
        <param name="machineName">日志所在的计算机。</param>
        <param name="source">事件日志项的源。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将实例与指定的计算机上的日志关联，并为 <see cref="T:System.Diagnostics.EventLog" /> 实例创建或分配指定的源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数设置<xref:System.Diagnostics.EventLog.Log%2A>属性设置为`logName`参数，<xref:System.Diagnostics.EventLog.MachineName%2A>属性设置为`machineName`参数，并且<xref:System.Diagnostics.EventLog.Source%2A>属性设置为`source`参数。 <xref:System.Diagnostics.EventLog.Source%2A>属性是必需的写入事件日志时。 但是，如果您是仅从事件日志，仅读取<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性是必需的 （只要该服务器上的事件日志具有已与之关联的源）。 如果你是仅从事件日志进行读取，另一个重载的构造函数可能就足够了。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 参数。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例使用源""的本地计算机上将条目写入到事件日志中，"MyNewLog"。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 - 或 -  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" />。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来启动窗体或由另一个组件使用的组件的初始化。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法结束初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> 已初始化完毕。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从事件日志中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志的设置确定它们可以包含多个条目的最大大小。 事件日志已满时，它将停止记录新事件信息，或开始覆盖以前的项。 如果事件录制停止后，可以使用此方法以清除日志中的现有条目并允许它重新开始记录事件。 必须具有对日志所在清除事件日志条目的计算机的管理员权限。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> 关闭事件日志、 检索新读取和写入句柄，释放事件句柄，并重新打开事件日志。 对方法的调用后收到的事件不会清除与现有事件。  
  
   
  
## Examples  
 以下示例清除事件日志。  
  
> [!CAUTION]
>  由于应用程序、 系统、 安全性和其他非自定义日志可能包含重要信息;请务必执行此示例代码之前指定自定义日志。 此示例将删除自定义日志`myNewLog`。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 - 或 -  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <exception cref="T:System.ArgumentException">没有为 <see cref="P:System.Diagnostics.EventLog.Log" /> 属性指定值。 确保日志名称不是一个空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">该日志不存在。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭事件日志并释放读写句柄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>方法调用的受保护<xref:System.ComponentModel.Component.Dispose%2A>方法。 您不需要调用<xref:System.Diagnostics.EventLog.Close%2A>之前调用<xref:System.ComponentModel.Component.Dispose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件日志的读句柄或写句柄未成功释放。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立一个能够将事件信息写入到系统的特定日志中的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">事件源及其目标事件日志的配置属性。</param>
        <summary>通过使用为该事件源和对应的事件日志指定的配置属性，建立一个写入本地化事件消息的有效事件源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于配置新的本地计算机或远程计算机上写入事件日志条目源。 不需要使用此方法来读取事件日志。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法使用输入`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>，<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>和<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>属性，以在新的源和其关联的事件日志的目标计算机上创建注册表值。 新的源名称不能与现有的源名称或目标计算机上的现有事件日志名称匹配。 如果<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>属性未设置，为应用程序事件日志注册源。 如果<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>未设置，在本地计算机上注册了源。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  这一要求的原因是必须搜索所有事件日志，包括安全性，以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入到事件日志。 必须指定事件源写入事件;必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 可以创建现有事件日志或新的事件日志的事件源。 创建新的源为新的事件日志时，系统注册该日志的源，但直到第一个条目写入不创建该日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 每个源只能写入到事件日志中只有一个一次;但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要多个源配置为使用不同的事件日志或不同的资源文件。  
  
 为事件类别和消息字符串，可以使用本地化的资源文件注册事件源。 你的应用程序可以写入事件日志项使用资源标识符，而不指定实际的字符串。 事件查看器使用的资源标识符来查找并显示基于当前语言设置的本地化的资源文件中的相应字符串。 可以注册一个单独的文件，有关事件类别、 消息和参数插入字符串，也可以注册相同的资源文件，所有三种类型的字符串。 使用<xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>， <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>， <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>，和<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>属性来配置要本地化的项写入事件日志的源。 如果你的应用程序直接将字符串值写入事件日志，您不需要设置这些属性。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建它。 如果其他应用程序或组件使用现有的源，请使用更新的配置，而无需删除现有源创建新的源。  
  
> [!NOTE]
>  如果源配置为事件日志，并重新配置为另一个事件日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例确定是否在事件源名为`SampleApplicationSource`在本地计算机上注册。 如果事件源不存在，该示例设置源的消息资源文件，并创建新的事件源。 最后，该示例设置使用中的资源标识符值的事件日志的本地化的显示名称`DisplayNameMsgId`中的资源文件路径和`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。 具体而言，为事件日志的本地化名称定义了资源标识符为 5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="sourceData" /> 中指定的计算机名称无效。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的源名称为 <see langword="null" />。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的日志名称无效。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的日志名称对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
- 或 - 
该日志名称与一个现有事件源名称相匹配。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的源名称导致注册表项路径的长度超过 254 个字符。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的日志名称的前 8 个字符不唯一。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的源名称已经注册过。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在本地计算机上注册时所采用的源名称。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。</param>
        <summary>建立指定的源名称作为向本地计算机上的日志中写入日志项的有效事件源。 此方法还可在本地计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建自定义日志或创建并注册<xref:System.Diagnostics.EventLog.Source%2A>向本地计算机上现有的日志。  
  
 如果`logName`是`null`或空字符串 ("") 时调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，日志将默认为应用程序日志。 如果在本地计算机上不存在该日志，系统创建自定义日志，并注册应用程序作为<xref:System.Diagnostics.EventLog.Source%2A>为该日志。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  这一要求的原因是必须搜索所有事件日志，包括安全性，以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 只需创建事件源，如果将写入事件日志。 之前向事件日志写入条目，您必须注册事件源的事件日志作为有效的事件源。 写入日志条目时，系统会将<xref:System.Diagnostics.EventLog.Source%2A>以查找要在其中放置您的输入相应的日志。 如果您正在读取事件日志，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>时从日志中读取，本地计算机 ("。") 假定。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入到事件日志。 必须指定事件源写入事件;必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 可以创建现有事件日志或新的事件日志的事件源。 创建新的源为新的事件日志时，系统注册该日志的源，但直到第一个条目写入不创建该日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 源必须是本地计算机; 上唯一新的源名称不能与现有的源名称或现有的事件日志名称匹配。 每个源可以一次; 写入一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要多个源配置为使用不同的事件日志或不同的资源文件。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建它。 如果其他应用程序或组件使用现有的源，请使用更新的配置，而无需删除现有源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
- 或 - 
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
- 或 - 
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
- 或 - 
该日志名称与一个现有事件源名称相匹配。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。  
  
- 或 - 
<paramref name="logName" /> 的前 8 个字符与现有事件日志名称的前 8 个字符相匹配。  
  
- 或 - 
无法注册该源，因为它已存在于本地计算机上。  
  
- 或 - 
该源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。 如果不指定值，则 <paramref name="logName" /> 默认为应用程序。</param>
        <param name="machineName">用来注册此事件源的计算机名称，对于本地计算机则为“.”。</param>
        <summary>建立指定的源名称作为向指定计算机上的日志中写入项的有效事件源。 此方法还可用于在指定计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建自定义日志或创建并注册<xref:System.Diagnostics.EventLog.Source%2A>向指定的计算机上现有的日志。  
  
 如果`logName`是`null`或空字符串 ("") 时调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，日志将默认为应用程序日志。 如果指定的计算机上不存在该日志，系统创建自定义日志，并注册应用程序作为<xref:System.Diagnostics.EventLog.Source%2A>为该日志。  
  
 只需创建事件源，如果将写入事件日志。 之前向事件日志写入条目，您必须注册事件源的事件日志作为有效的事件源。 写入日志条目时，系统会将<xref:System.Diagnostics.EventLog.Source%2A>以查找要在其中放置您的输入相应的日志。 如果您正在读取事件日志，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  这一要求的原因是必须搜索所有事件日志，包括安全性，以确定事件源是否唯一。 在 Windows Vista 及更高版本，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入到事件日志。 必须指定事件源写入事件;必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 可以创建现有事件日志或新的事件日志的事件源。 创建新的源为新的事件日志时，系统注册该日志的源，但直到第一个条目写入不创建该日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 源必须是本地计算机; 上唯一新的源名称不能与现有的源名称或现有的事件日志名称匹配。 每个源可以一次; 写入一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要多个源配置为使用不同的事件日志或不同的资源文件。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建它。 如果其他应用程序或组件使用现有的源，请使用更新的配置，而无需删除现有源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`的计算机上`MyServer`，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 不是有效的计算机名称。  
  
- 或 - 
 <paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
- 或 - 
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
- 或 - 
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
- 或 - 
该日志名称与一个现有事件源名称相匹配。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。  
  
- 或 - 
<paramref name="logName" /> 的前 8 个字符与指定计算机上现有事件日志名称的前 8 个字符相匹配。  
  
- 或 - 
源无法注册，因为它已存在于指定的计算机上。  
  
- 或 - 
该源名称与一个现有事件源名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除日志资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”和计算机上的任何自定义事件日志。</param>
        <summary>从本地计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要删除的日志位于本地计算机上，请使用此方法。 只要您具有相应的注册表权限，可以删除该计算机上的任何日志。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 删除指定的日志`logName`从本地计算机。 如果你想要删除的源只能注册到一个日志，请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果只想要删除的日志条目，则调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 并<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以在类本身上调用。 不需要创建的新实例<xref:System.Diagnostics.EventLog>调用这两种方法。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>方法首先删除保存日志的内容的文件。 然后，它访问注册表，并将删除为该日志注册的所有事件源。 如果重新创建在以后的日志，应注册事件源同样，若要重复使用。 如果不注册事件源和其他用户写入的事件源而无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，以前无法将条目写入到日志删除并重新创建的应用程序将向应用程序日志改为编写，因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可以是一个困难的过程。 避免删除任何系统创建的事件日志，如应用程序日志。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除日志。 该示例确定从其源的日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保不没有写入该日志的任何其他源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。  
  
- 或 -
  
 本地计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 - 或 -  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”和指定计算机上的任何自定义事件日志。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>从指定计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要删除的日志位于远程计算机上，请使用此方法。 只要您具有相应的注册表权限，可以删除该计算机上的任何日志。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 删除指定的日志`logName`从指定的计算机`machineName`。 如果你想要删除的源只能注册到一个日志，请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果只想要删除的日志条目，则调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 并<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以在类本身上调用。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用这两种方法。  
  
 此方法首先删除保存日志的内容的文件。 然后，它访问注册表，并将删除为该日志注册的所有事件源。 如果重新创建在以后的日志，应注册事件源同样，若要重复使用。 如果不注册事件源和其他用户写入的事件源而无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，以前无法将条目写入到日志删除并重新创建的应用程序将向应用程序日志改为编写，因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可以是一个困难的过程。 避免删除任何系统创建的事件日志，如应用程序日志。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
   
  
## Examples  
 下面的示例从指定的计算机中删除日志。 该示例确定从其源的日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保不没有写入该日志的任何其他源。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。  
  
- 或 - 
 <paramref name="machineName" /> 不是有效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。  
  
- 或 -
  
 指定的计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 - 或 -  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从事件日志中移除应用程序的事件源注册。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <summary>从本地计算机的事件日志中移除事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于删除的注册<xref:System.Diagnostics.EventLog.Source%2A>从本地计算机。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 访问本地计算机上的注册表，并删除应用程序作为有效的事件源的注册。  
  
 如果您不再需要将条目写入该日志，可以为有效的事件源删除你的组件。 例如，如果您需要将组件从一个日志更改为另一个可能会执行此操作。 一个源一次只能注册到一个日志，因为更改日志需要删除当前注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 删除注册到一个日志源。 如果你想要删除日志本身，则调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果只想要删除的日志条目，则调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 并<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以在类本身上调用。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用这两种方法。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除源。 该示例确定从其源的日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保不没有写入该日志的任何其他源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">本地计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
- 或 - 
您对事件日志的注册表项没有写访问权。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <param name="machineName">要从中移除注册的计算机名，对于本地计算机则为“.”。</param>
        <summary>从指定的计算机上移除应用程序的事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以删除的注册<xref:System.Diagnostics.EventLog.Source%2A>从远程计算机。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 访问指定的计算机上的注册表`machineName`并删除应用程序作为有效的事件源的注册。  
  
 如果您不再需要将条目写入该日志，可以为有效的事件源删除你的组件。 例如，如果您需要将组件从一个日志更改为另一个可能会执行此操作。 一个源一次只能注册到一个日志，因为更改日志需要删除当前注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 删除注册到一个日志源。 如果你想要删除日志本身，则调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果只想要删除的日志条目，则调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 并<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以在类本身上调用。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用这两种方法。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例从指定的计算机中删除源。 该示例确定从其源的日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保不没有写入该日志的任何其他源。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数无效。  
  
- 或 - 
指定计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
- 或 - 
您对事件日志的注册表项没有写访问权。</exception>
        <exception cref="T:System.InvalidOperationException">无法删除 <paramref name="source" />，原因是在注册表中，<paramref name="source" /> 的父注册表项不包含与其同名的子项。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</param>
        <summary>释放由 <see cref="T:System.Diagnostics.EventLog" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当`disposing`参数为 true 时，此方法释放任何托管对象所持有的所有资源，此<xref:System.Diagnostics.EventLog>的引用。 此方法调用每个引用对象的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 重写时<see langword="Dispose(Boolean)" />小心不要引用已经释放的早期调用中的对象<see langword="Dispose" />。 有关如何实现详细信息<see langword="Dispose(Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
有关详细信息<see langword="Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，用以指示 <see cref="T:System.Diagnostics.EventLog" /> 是否接收 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件通知。</summary>
        <value>如果 <see cref="T:System.Diagnostics.EventLog" /> 在有项写入日志时接收通知，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>属性确定是否<xref:System.Diagnostics.EventLog>条目写入到日志时引发事件。 当该属性是`true`，接收的组件<xref:System.Diagnostics.EventLog.EntryWritten>事件将收到通知任何时间中指定的日志中写入一项<xref:System.Diagnostics.EventLog.Log%2A>属性。 如果<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>是`false`，会引发任何事件。  
  
> [!NOTE]
>  仅当在本地计算机上写入条目时，可以接收事件通知。 不能接收在远程计算机上写入项的通知。  
  
   
  
## Examples  
 下面的示例处理<xref:System.Diagnostics.EventLog.EntryWritten>事件。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">事件日志位于远程计算机上。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" /> 的初始化。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束用于窗体或由另一个组件的组件的初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法开始初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可以防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的内容。</summary>
        <value><see cref="T:System.Diagnostics.EventLogEntryCollection" />，保留事件日志中的项。 每个项均与 <see cref="T:System.Diagnostics.EventLogEntry" /> 类的一个实例关联。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.Entries%2A>时从事件日志读取的成员。  
  
 因为该属性是只读的不能修改该条目或写入到日志使用<xref:System.Diagnostics.EventLog.Entries%2A>。 而应指定<xref:System.Diagnostics.EventLog.Source%2A>，并调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>编写新的日志条目。 可以使用<xref:System.Diagnostics.EventLog.Entries%2A>若要计算的事件日志中的条目数，并查看每个<xref:System.Diagnostics.EventLogEntry>集合中。 使用已编制索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成员，才能检索特定项有关的信息，如<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。  
  
 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>仅从日志中读取。 可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称） 属性<xref:System.Diagnostics.EventLog>实例。 在任一情况下，<xref:System.Diagnostics.EventLog.Entries%2A>成员会自动填充的项的事件日志的列表。 在此列表中读取各项，可以选择适当的项的索引。  
  
 读取和写入日志条目之间的重要区别是不需要显式调用读取的方法。 之后<xref:System.Diagnostics.EventLog.Log%2A>并<xref:System.Diagnostics.EventLog.MachineName%2A>指定，<xref:System.Diagnostics.EventLog.Entries%2A>属性自动填充。 如果您更改的值<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>属性，<xref:System.Diagnostics.EventLog.Entries%2A>属性重新读取它的下一个时间。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机"。"，则假定。  
  
   
  
## Examples  
 下面的示例读取事件日志中，"MyNewLog"本地计算机上的条目。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向本地计算机上的事件日志写入项时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取事件通知，必须设置<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>到`true`。 只能在本地计算机上写入项时，才能接收事件通知。 不能接收在远程计算机上写入项的通知。  
  
 创建 <xref:System.Diagnostics.EventLog.EntryWritten> 委托时，需要标识将要处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 只要发生此事件，直到您删除委托调用事件处理程序。 使用委托中处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 系统响应<xref:System.Diagnostics.EventLog.WriteEntry%2A>仅当最后一个的写入事件至少六个秒之前发生。 这意味着你将仅收到一个<xref:System.Diagnostics.EventLog.EntryWritten>六秒钟的间隔内的事件通知，即使多个事件日志更改时发生。 如果插入调用之间的足够长的休眠间隔 （约 10 秒） <xref:System.Diagnostics.EventLog.WriteEntry%2A>，您不太可能错过了活动。 但是，如果更频繁地发生写入事件，您可能无法收到事件通知，直到下一个间隔。 通常情况下，错过的事件通知将不丢失，而延迟。  
  
   
  
## Examples  
 下面的示例处理一个项写入事件。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定指定的日志是否存在。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <summary>确定该日志是否存在于本地计算机上。</summary>
        <returns>如果该日志存在于本地计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以确定本地计算机上是否存在一个日志。 如果你想要确定源是否存在的本地计算机上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由于此方法访问注册表，您必须在本地计算机，则拥有相应的注册表权限否则，查询将返回`false`。  
  
 由于无法在同一台计算机上为新的日志的现有的日志名称，此方法用于创建新日志之前确定是否指定`logName`本地计算机上已存在。 `logName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <param name="machineName">要在其上搜索日志的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定该日志是否存在于指定计算机上。</summary>
        <returns>如果该日志存在于指定的计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以确定远程计算机上是否存在一个日志。 如果你想要确定源是否存在的远程计算机上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由于此方法访问注册表，必须指定计算机上具有相应的注册表权限否则，查询将返回`false`。  
  
 由于无法在同一台计算机上为新的日志的现有的日志名称，此方法用于创建新日志之前确定一个具有指定`logName`指定的服务器上已存在`machineName`参数。 `logName`和`machineName`参数都不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的新实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数的格式无效。 请确保对在其上执行搜索的计算机使用了正确的语法。  
  
- 或 - 
<paramref name="logName" /> 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建事件日志的数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在本地计算机上搜索所有的事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns><see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示本地计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组<xref:System.Diagnostics.EventLog>对象是在本地计算机上的所有事件日志的快照时对调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>进行。 这不是动态集合，因此它不反映删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包括至少三个日志：应用程序、 系统和安全。 如果在本地计算机上创建自定义日志，它们将显示以及数组中。  
  
 若要检索事件日志的列表，您必须具有相应的注册表权限。 这些权限是与调用所需的相同<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例枚举在本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">您对注册表没有读访问权。  
  
 - 或 -  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">在其上搜索事件日志的计算机。</param>
        <summary>在给定计算机上搜索所有事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns><see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示给定计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组<xref:System.Diagnostics.EventLog>对象是指定的计算机上的所有事件日志的快照`machineName`参数时对调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>进行。 这不是动态集合，因此它不反映删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包括至少三个日志：应用程序、 系统和安全。 如果在指定计算机上创建自定义日志，它们将显示以及数组中。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 是`static`方法，使其可以调用上<xref:System.Diagnostics.EventLog>类本身。 不需要创建的实例<xref:System.Diagnostics.EventLog>对象，从而使对方法的调用。  
  
 若要检索事件日志的列表，您必须具有相应的注册表权限。 这些权限是与调用所需的相同<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例获取"myServer"的计算机上的一个日志列表。 然后，它将输出的每个日志的名称。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数是无效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">您对注册表没有读访问权。  
  
 - 或 -  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置读取或写入的日志名称。</summary>
        <value>日志的名称。 这可以是“应用程序”、“系统”、“安全性”或一个自定义的日志名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在服务器上存在三个日志文件：应用程序、 系统和安全。 应用程序和服务使用的应用程序日志文件。 设备驱动程序使用的系统日志文件。 审核打开的系统就会安全日志中生成成功和失败审核事件。 如果必须安装 Windows 服务器上的 Active Directory 等其他应用程序可能有其他默认日志文件。 此外，您可以创建自定义日志文件的本地或远程计算机上。 自定义日志可帮助组织您的项比您的组件将事件写入到默认应用程序日志时所允许的方式更详细的方式。  
  
> [!NOTE]
>  日志名称被限制为八个字符。 根据系统，MyLogSample1 和 MyLogSample2 是相同的日志。  
  
 如果写入事件日志时，它没有足够可用于指定<xref:System.Diagnostics.EventLog.Log%2A>属性。 必须将关联<xref:System.Diagnostics.EventLog.Source%2A>与事件日志资源以将其连接到的特定日志的属性。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>时仅从一个日志，但事件源中读取必须是与服务器的注册表中的事件日志资源相关联。 可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称） 从其读取。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 如果<xref:System.Diagnostics.EventLog.Source%2A>未指定属性，调用<xref:System.Diagnostics.EventLog.Log%2A>如果，则返回空字符串<xref:System.Diagnostics.EventLog.Log%2A>未显式设置 (通过设置<xref:System.Diagnostics.EventLog.Log%2A>属性，或通过构造函数)。 如果<xref:System.Diagnostics.EventLog.Source%2A>已指定<xref:System.Diagnostics.EventLog.Log%2A>返回向其注册该源的日志的名称。  
  
 一个源一次只能注册到一个日志。 如果<xref:System.Diagnostics.EventLog.Source%2A>属性设置的实例<xref:System.Diagnostics.EventLog>，不能更改<xref:System.Diagnostics.EventLog.Log%2A>属性中的为该<xref:System.Diagnostics.EventLog>而无需更改的值<xref:System.Diagnostics.EventLog.Source%2A>或调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一个。 如果您更改<xref:System.Diagnostics.EventLog.Log%2A>属性后的<xref:System.Diagnostics.EventLog.Source%2A>属性已设置，编写一个日志条目将引发异常。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 无法创建新的日志使用<xref:System.Diagnostics.EventLog.Log%2A>属性单独 （不带指定的日志源）。 您可以调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>中，传入新的日志名称作为参数，然后再调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 但是，其目的通常是以创建 （并将项写入） 新的特定于应用程序日志，或从现有的日志读取。  
  
 如果<xref:System.Diagnostics.EventLog.Log%2A>值发生更改，关闭事件日志并释放所有的事件句柄。  
  
> [!CAUTION]
>  如果您设置<xref:System.Diagnostics.EventLog.Log%2A>属性设置为不存在日志的名称，系统将附加<xref:System.Diagnostics.EventLog>到应用程序日志，但不会警告你它正在使用不是你指定的日志。  
  
   
  
## Examples  
 下面的示例读取事件日志中，"NewEventLog"本地计算机上的条目。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的友好名称。</summary>
        <value>一个表示系统的事件查看器中事件日志的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 Windows Vista 及更高版本，用户没有访问安全日志的权限。 如果运行的 Windows Vista 或更高版本作为用户，将收到<xref:System.Security.SecurityException>当你尝试访问安全日志中的事件的显示名称。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的示例枚举在本地计算机上定义的事件日志，并显示<xref:System.Diagnostics.EventLog.LogDisplayName%2A>每个事件日志。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此计算机的注册表中不存在指定的 <see cref="P:System.Diagnostics.EventLog.Log" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>获取指定的源注册到的日志的名称。</summary>
        <returns>与注册表中的指定源关联的日志名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示什么来记录事件。 通常是应用程序的名称或子组件的应用程序的名称时应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。  
  
 当创建新的源，它可以只写入一个日志一次，系统将你的应用程序与事件日志注册为有效项源。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任意字符串，但名称不能由其他计算机上的源。 尝试创建重复<xref:System.Diagnostics.EventLog.Source%2A>值将引发异常。 但是，单个事件日志可以有多个不同源向其写入。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除源。 该示例确定从其源的日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保不没有写入该日志的任何其他源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在其上读取或写入事件的计算机的名称。</summary>
        <value>事件日志驻留的服务器的名称。 默认为本地计算机 (".")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果写入事件日志，必须将关联<xref:System.Diagnostics.EventLog.Source%2A>提供事件日志对象，以将其连接到的特定日志。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>仅从日志中读取的属性。 可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称）。  
  
> [!NOTE]
>  不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 一个源一次只能注册到一个日志。 如果<xref:System.Diagnostics.EventLog.Source%2A>属性设置的实例<xref:System.Diagnostics.EventLog>，不能更改<xref:System.Diagnostics.EventLog.MachineName%2A>属性中的为该<xref:System.Diagnostics.EventLog>而无需更改的值<xref:System.Diagnostics.EventLog.Source%2A>或调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一个。 如果您更改<xref:System.Diagnostics.EventLog.MachineName%2A>属性，<xref:System.Diagnostics.EventLog>关闭所有句柄并重新附加到的日志和新计算机上的源。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>值不能为空字符串。 如果显式设置，则默认为本地计算机 ("。")。  
  
   
  
## Examples  
 下面的示例读取事件日志中，"NewEventLog"指定计算机上的条目。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置最大事件日志大小（以 KB 为单位）。</summary>
        <value>最大事件日志大小（以 KB 为单位）。 默认值为 512，表示最大文件大小为 512 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性表示的事件日志文件的大小限制。 当事件日志达到大小限制，已配置的<xref:System.Diagnostics.EventLog.OverflowAction%2A>值确定是否丢弃新条目，或是否新条目覆盖旧条目。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志注册的所有事件源都写入新条目。  
  
   
  
## Examples  
 下面的示例枚举在本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定值小于 64，或大于 4194240，或不是 64 的偶数倍。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
- 或 - 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取要在事件日志中保留项的天数。</summary>
        <value>事件日志中的项被保留的天数。 默认值为 7。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性可以检查事件日志的当前设置。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>更改最小数目的事件日志中的每个条目必须保留的天数。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值取决于事件日志的已配置的溢出行为。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值为 0。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值为-1。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值大于零，并表示数的事件日志已满时保留事件日志条目的天数。  
  
 事件日志达到其容量限制时，仅会发生溢出行为。 时<xref:System.Diagnostics.EventLog>具有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，并在事件日志达到其最大大小，然后新条目如果它们可以将为其保留时间超出的条目才写入<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>段。 至少保留事件项适合定期存档事件日志时的不同而不同。 否则，则可能会丢失新条目时在事件日志达到其限制。 若要避免丢失事件的新信息，请设置根据特定的事件日志的存档计划事件的最小保留天数。  
  
   
  
## Examples  
 下面的示例枚举在本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">向事件日志写入新项的溢出行为。</param>
        <param name="retentionDays">每个事件日志项要保留的最小天数。 只有在 <paramref name="action" /> 设置为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> 时，才使用此参数。</param>
        <summary>更改已配置的行为，以便在事件日志达到其最大文件大小时写入新项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志的溢出行为指定要写入到日志已达到其最大文件大小的新条目时，会发生什么情况。  
  
> [!NOTE]
>  仅在事件日志达到其最大文件大小时生效的溢出行为。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法可配置事件日志的溢出行为。 <xref:System.Diagnostics.EventLog> 实例。 调用此方法为指定的事件日志后<xref:System.Diagnostics.EventLog.Log%2A>属性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性值反映新配置的溢出行为。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志注册的所有事件源都写入新条目。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>以指示新条目覆盖最旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，则`retentionDays`参数值将被忽略。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.OverwriteOlder>以指示每个新条目覆盖旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。 指定在日志中使用的事件必须保留的天数`retentionDays`参数。 新条目不会覆盖的保持期内写入的事件。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>放弃新事件时已达到最大日志大小。 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，则`retentionDays`参数值将被忽略。  
  
> [!CAUTION]
>  溢出策略设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>指定事件日志已满时，将丢弃新条目。 如果使用此设置，请确保事件日志是定期存档和清除避免达到其最大大小限制。  
  
   
  
## Examples  
 下面的示例显示已配置的溢出策略为指定的事件日志，并允许用户选择新事件日志的溢出策略设置。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 不是有效的 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> 小于 1 或大于 365。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
- 或 - 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已配置的行为，以便在事件日志达到其最大文件大小时存储新项。</summary>
        <value><see cref="T:System.Diagnostics.OverflowAction" /> 值，指定在事件日志达到其最大日志大小时存储新项的已配置行为。 默认值为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志大小增大的新事件写入到它们。 每个事件日志已配置的最大大小限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性定义的最大事件日志文件大小所允许的千字节数。  
  
 使用<xref:System.Diagnostics.EventLog.OverflowAction%2A>属性值来检查事件日志在其最大大小的已配置的溢出行为。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法，以更改事件日志的溢出行为。  
  
> [!NOTE]
>  仅在事件日志达到其最大文件大小时生效的溢出行为。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。  
  
   
  
## Examples  
 下面的示例枚举在本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">本地化资源文件的完全指定的路径。</param>
        <param name="resourceId">在资源文件内指明一个本地化字符串的资源标识符。</param>
        <summary>指定该事件日志的本地化名称，它显示在服务器事件查看器中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>进行注册和自定义事件日志的事件查看器中显示的本地化的名称。  
  
 指定的资源标识符必须对应于资源文件中定义的已本地化字符串。 事件查看器显示使用本地化的字符串和当前区域性设置的自定义事件日志名称。 例如，可以定义多个资源文件中的不同区域性的本地化的事件日志名称。 事件查看器显示与当前用户的区域性设置相对应的本地化的字符串。  
  
 如果在事件查看器无法从资源文件中，加载已本地化的字符串，或如果没有显示名称已注册的事件日志，事件查看器显示中定义的事件日志名称<xref:System.Diagnostics.EventLog.Log%2A>。  
  
> [!NOTE]
>  不需要注册预定义的事件日志的显示名称。 操作系统注册应用程序、 系统和安全事件日志的本地化的显示名称。  
  
   
  
## Examples  
 下面的示例确定是否在事件源名为`SampleApplicationSource`在本地计算机上注册。 如果事件源不存在，该示例设置源的消息资源文件，并创建新的事件源。 最后，该示例设置使用中的资源标识符值的事件日志的本地化的显示名称`DisplayNameMsgId`中的资源文件路径和`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。 具体而言，为事件日志的本地化名称定义了资源标识符为 5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
- 或 - 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在写入事件日志时要注册和使用的源名称。</summary>
        <value>在事件日志中注册为项源的名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示什么来记录事件。 通常是应用程序的名称或子组件的应用程序的名称时应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。  
  
 只需指定事件源，如果将写入事件日志。 之前向事件日志写入条目，您必须注册事件源的事件日志作为有效的事件源。 写入日志条目时，系统会将<xref:System.Diagnostics.EventLog.Source%2A>属性来查找要在其中放置您的输入适当的日志。 如果您正在读取事件日志，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入到事件日志。 必须指定事件源写入事件;必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 可以创建现有事件日志或新的事件日志的事件源。 创建新的源为新的事件日志时，系统注册该日志的源，但直到第一个条目写入不创建该日志。  
  
 源必须是本地计算机; 上唯一新的源名称不能与现有的源名称或现有的事件日志名称匹配。 每个源可以一次; 写入一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要多个源配置为使用不同的事件日志或不同的资源文件。  
  
 如果您更改<xref:System.Diagnostics.EventLog.Source%2A>值，<xref:System.Diagnostics.EventLog>为它注册已关闭并释放所有的事件句柄。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建它。 如果其他应用程序或组件使用现有的源，请使用更新的配置，而无需删除现有源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机更改才能生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在计算机的注册表中搜索给定的事件源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <summary>确定事件源是否已在本地计算机上注册。</summary>
        <returns>如果事件源已在本地计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于确定本地计算机上是否存在的事件源。 如果想要确定日志是否存在于在本地计算机上，使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由于此方法访问注册表，您必须在本地计算机，则拥有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要搜索的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  这一要求的原因是必须搜索所有事件日志，包括安全性，以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  执行时使用的服务<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户没有执行此方法所需的权限。 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。  
  
 由于不能为新的源提供的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，确保源与指定的名称`source`本地计算机上尚不存在。 `source`参数不区分大小写。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">在其上查看的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定事件源是否已在指定的计算机上注册。</summary>
        <returns>如果事件源已在给定计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于确定指定的计算机上是否存在的事件源`machineName`参数。 如果你想要确定使用指定的计算机上是否存在日志<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由于此方法访问注册表，必须在给定的服务器; 上具有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要搜索的事件源在 Windows Vista 及更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  这一要求的原因是必须搜索所有事件日志，包括安全性，以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问该安全日志。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  执行时使用的服务<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户没有执行此方法所需的权限。 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。  
  
 由于不能为新的源提供的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，确保源与指定的名称`source`的计算机上尚不存在。 `source`和`machineName`参数都不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例创建源`MySource`的计算机上`MyServer`，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 是无效的计算机名称。</exception>
        <exception cref="T:System.Security.SecurityException">未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送事件处理程序调用的对象，该调用在有 <see cref="T:System.Diagnostics.EventLog" /> 项写入事件时发出。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用于封送由事件日志上的 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件引发的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法处理<xref:System.Diagnostics.EventLog.EntryWritten>从系统线程池线程上调用事件。 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual Windows 窗体组件，如按钮，通过系统线程池访问组件可能无法工作，或可能会导致异常处理。 通过设置来避免这<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致处理的方法<xref:System.Diagnostics.EventLog.EntryWritten>在其创建该组件在同一线程上调用的事件。  
  
 如果<xref:System.Diagnostics.EventLog>内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>自动设置为控件包含<xref:System.Diagnostics.EventLog>。 例如，如果将置于<xref:System.Diagnostics.EventLog>Form1 的设计器上 (派生自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>属性的<xref:System.Diagnostics.EventLog>设置为 Form1 的实例。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将项写入事件日志。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于向与此关联的事件日志写入信息条目<xref:System.Diagnostics.EventLog>实例。 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用的不同重载<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>上的属性在<xref:System.Diagnostics.EventLog>组件之前可以向日志写入条目。 必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性的这<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上不注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>和注册源。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例在调用之前<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>并<xref:System.Diagnostics.EventLog.Log%2A>不上设置属性在<xref:System.Diagnostics.EventLog>实例，默认为应用程序日志的日志。  
  
> [!NOTE]
>  上面列出的异常的许多都由错误的注册过程中引发<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是预期如果远程计算机未运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的指定项写入<xref:System.Diagnostics.EventLogEntryType>到事件日志。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>上的属性在<xref:System.Diagnostics.EventLog>组件之前可以向日志写入条目。 必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性的这<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上不注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>和注册源。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例在调用之前<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>并<xref:System.Diagnostics.EventLog.Log%2A>不上设置属性在<xref:System.Diagnostics.EventLog>实例，默认为应用程序日志的日志。  
  
> [!NOTE]
>  上面列出的许多异常都由错误的注册过程中引发<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是预期如果远程计算机未运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 下面的示例警告项写入事件日志中，"MyNewLog"本地计算机上。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>使用指定的注册事件源将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于向使用已注册为相应的日志的事件源的源的事件日志写入信息条目。 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用的不同重载<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将条目写入到事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来编写一个包含应用程序定义的项`eventID`到事件日志。 `eventID`与源一起唯一地标识一个事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题并建议要采取的操作。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 除了事件标识符，还可以指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>上的属性在<xref:System.Diagnostics.EventLog>组件之前可以向日志写入条目。 必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性的这<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上不注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>和注册源。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例在调用之前<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>并<xref:System.Diagnostics.EventLog.Log%2A>不上设置属性在<xref:System.Diagnostics.EventLog>实例，默认为应用程序日志的日志。  
  
> [!NOTE]
>  上面列出的许多异常都由错误的注册过程中引发<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是预期如果远程计算机未运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>使用指定的注册事件源，将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的指定项写入<xref:System.Diagnostics.EventLogEntryType>到事件日志中，将源使用已注册为相应的日志的事件源。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 下面的示例警告项写入事件日志中，"MyNewLog"本地计算机上。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来编写一个包含应用程序定义的项`category`到事件日志。 事件查看器使用的类别的事件源写入筛选器事件。 事件查看器可以将类别显示为数字值，或者它可以作为资源标识符使用类别来显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为互为补充的正数值在事件查看器。 例如，-10 显示为 65526，-1，则为 65535。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源的类别资源文件后，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引的字符串中的类别资源文件，则在事件查看器将显示该条目的数字型类别值。 配置类别资源文件，以及数量的资源文件中的类别字符串使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 除了类别，可以指定要写入到事件日志的事件的事件标识符。 事件标识符的事件源，以及唯一地标识一个事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题并建议要采取的操作。  
  
 最后，可以指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>上的属性在<xref:System.Diagnostics.EventLog>组件之前可以向日志写入条目。 必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性的这<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上不注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>和注册源。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例在调用之前<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>并<xref:System.Diagnostics.EventLog.Log%2A>不上设置属性在<xref:System.Diagnostics.EventLog>实例，默认为应用程序日志的日志。  
  
> [!NOTE]
>  上面列出的许多异常都由错误的注册过程中引发<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是预期如果远程计算机未运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>使用指定的注册事件源，将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来编写一个包含应用程序定义的项`eventID`到事件日志中，将源使用已注册为相应的日志的事件源。 `eventID`，以及源代码，唯一标识事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器呈现给用户以帮助用户了解发生的问题并建议要采取的操作这些字符串。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 除了事件标识符的此重载还<xref:System.Diagnostics.EventLog.WriteEntry%2A>允许您指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将应用程序定义特定于事件的数据写入事件日志。 事件查看器不解释该数据。它仅采用组合的十六进制转义序列和文本格式显示原始数据。 请慎用特定于事件的数据，包括它仅当你确信将很有用的某个人可以解决此问题。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，可以专门为您的活动，编写一个查看器或编写一个程序来扫描日志文件并创建报告，包括来自特定于事件的数据的信息。  
  
 除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器使用的类别的事件源写入筛选器事件。 事件查看器可以将类别显示为数字值，或者它可以作为资源标识符使用类别来显示本地化的类别字符串。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为互为补充的正数值在事件查看器。 例如，-10 显示为 65526，-1，则为 65535。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源的类别资源文件后，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引的字符串中的类别资源文件，则在事件查看器将显示该条目的数字型类别值。 配置类别资源文件，以及数量的资源文件中的类别字符串使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 事件标识符的事件源，以及唯一地标识一个事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题并建议要采取的操作。  
  
 最后，可以指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>上的属性在<xref:System.Diagnostics.EventLog>组件之前可以向日志写入条目。 必须创建并写入与源的第一项之前配置的事件源。  
  
 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性的这<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上不注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>和注册源。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例在调用之前<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>并<xref:System.Diagnostics.EventLog.Log%2A>不上设置属性在<xref:System.Diagnostics.EventLog>实例，默认为应用程序日志的日志。  
  
> [!NOTE]
>  上面列出的许多异常都由错误的注册过程中引发<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是预期如果远程计算机未运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>通过使用指定的注册事件源，将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。 事件查看器可使用 <paramref name="category" /> 筛选日志中的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来编写一个包含应用程序定义的项`category`到事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器使用的类别的事件源写入筛选器事件。 事件查看器可以将类别显示为数字值，或者它可以作为资源标识符使用类别来显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为互为补充的正数值在事件查看器。 例如，-10 显示为 65526，-1，则为 65535。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源的类别资源文件后，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引的字符串中的类别资源文件，则在事件查看器将显示该条目的数字型类别值。 配置类别资源文件，以及数量的资源文件中的类别字符串使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 除了类别，可以指定要写入到事件日志的事件的事件标识符。 事件标识符的事件源，以及唯一地标识一个事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题并建议要采取的操作。  
  
 最后，可以指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>（使用指定的注册事件源）将一个包含给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法将应用程序定义特定于事件的数据写入事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器不解释该数据。它仅采用组合的十六进制转义序列和文本格式显示原始数据。 使用特定于事件的数据很谨慎;仅当你确信将很有用，包括它。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，可以专门为您的活动，编写一个查看器或编写一个程序来扫描日志文件并创建报告，包括来自特定于事件的数据的信息。  
  
 除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器使用的类别的事件源写入筛选器事件。 事件查看器可以将类别显示为数字值，或者它可以作为资源标识符使用类别来显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为互为补充的正数值在事件查看器。 例如，-10 将显示为 65526，-1，则为 65535。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源的类别资源文件后，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引的字符串中的类别资源文件，则在事件查看器将显示该条目的数字型类别值。 配置类别资源文件，以及数量的资源文件中的类别字符串使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 事件标识符，与事件源，一起唯一地标识一个事件。 每个应用程序可以定义其自身带编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题并建议要采取的操作。  
  
 最后，可以指定<xref:System.Diagnostics.EventLogEntryType>为写入到事件日志的事件。 `type`由一个图标和日志的事件查看器中的类型列中的文本指示。 此参数指示的事件类型是否为错误、 警告、 信息、 成功审核或失败审核。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用的本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志中的消息。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向事件日志写入本地化事件项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>向事件日志写入本地化项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法向事件日志写入本地化的项。 资源标识符而不是字符串值与指定的事件属性。 事件查看器使用的资源标识符来显示的本地化的资源文件中的相应字符串<xref:System.Diagnostics.EventLog.Source%2A>。 编写使用资源标识符的事件之前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。 可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>并<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入来定义事件条目的类别和事件类型。 此外可以指定一个要插入到本地化的消息文本的独立于语言的字符串数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性上的你<xref:System.Diagnostics.EventLog>组件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源最小值必须具有一个用于定义消息资源文件。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果您向远程计算机的值写入条目`message`字符串可能不会与预期如果远程计算机未运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 如果在本地计算机上不存在，该示例创建一个新的事件源和一个新的事件日志。 事件消息文本被指定的资源文件中使用的资源标识符。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法向事件日志写入本地化的项与其他特定于事件的数据。 资源标识符而不是字符串值与指定的事件属性。 事件查看器使用的资源标识符来显示的本地化的资源文件中的相应字符串<xref:System.Diagnostics.EventLog.Source%2A>。 编写使用资源标识符的事件之前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。 可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>并<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入来定义事件条目的类别和事件类型。 此外可以指定一个要插入到本地化的消息文本的独立于语言的字符串数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 使用事件时需要为事件提供更多详细信息中指定的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不会解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 使用特定于事件的数据很谨慎;仅当你确信将很有用，包括它。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，可以专门为您的活动，编写一个查看器或编写一个程序来扫描事件日志并创建报告，包括来自特定于事件的数据的信息。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性上的你<xref:System.Diagnostics.EventLog>组件之前使用的组件之前<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源最小值必须具有一个用于定义消息资源文件。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
> [!NOTE]
>  如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例，然后才能调用<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本地计算机 ("。") 假定。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
> [!NOTE]
>  如果您向远程计算机的值写入条目`message`字符串可能不会与预期如果远程计算机未运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是一个整数值 (例如，%1)，因为事件查看器将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 如果在本地计算机上不存在，该示例创建一个新的事件源和一个新的事件日志。 事件消息文本被指定的资源文件中使用的资源标识符。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源写入包含给定事件数据和消息替换字符串的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法将使用已注册为相应的日志的事件源的源的事件日志写入本地化的项。 资源标识符而不是字符串值与指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 编写使用资源标识符的事件之前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。 可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>并<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入来定义事件条目的类别和事件类型。 此外可以指定一个要插入到本地化的消息文本的独立于语言的字符串数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 指定的源必须在使用之前注册为事件日志<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源最小值必须具有一个用于定义消息资源文件。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
   
  
## Examples  
 下面的示例将信息性事件条目和警告事件条目写入到现有的事件日志。 事件消息文本被指定的资源文件中使用的资源标识符。 该示例假定已为源中注册相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源，写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法将包含其他特定于事件的数据的本地化的项写入事件日志中，使用已注册为相应的日志的事件源的源。 资源标识符而不是字符串值与指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 编写使用资源标识符的事件之前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`源消息资源文件中定义的消息的输入。 可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>并<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入来定义事件条目的类别和事件类型。 此外可以指定一个要插入到本地化的消息文本的独立于语言的字符串数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 使用事件时需要为事件提供更多详细信息中指定的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不会解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 使用特定于事件的数据很谨慎;仅当你确信将很有用，包括它。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，可以专门为您的活动，编写一个查看器或编写一个程序来扫描事件日志并创建报告，包括来自特定于事件的数据的信息。  
  
 指定的源必须在使用之前注册为事件日志<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源最小值必须具有一个用于定义消息资源文件。  
  
 必须创建并写入与源的第一项之前配置的事件源。 在应用程序的安装过程中创建新的事件源。 这允许操作系统以刷新其注册的事件源的列表和其配置的时间。 如果操作系统没有刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目写入，则必须注册两个单独的源。 例如，配置一个源的资源文件，以及如何将该源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用资源标识符添加到事件日志条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将字符串直接写入事件日志使用的源。  
  
   
  
## Examples  
 下面的示例将信息性事件条目和警告事件条目写入到现有的事件日志。 事件消息文本被指定的资源文件中使用的资源标识符。 该示例假定已为源中注册相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用下面的消息文本文件，内置的资源库 EventLogMsgs.dll。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>