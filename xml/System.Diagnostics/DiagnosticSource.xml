<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d79c7605daf68e0c4169c32fac48c2c1ac277dad" /><Meta Name="ms.sourcegitcommit" Value="cfc0e4215fd0d259582ada2141878befd7c3c8c6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/12/2019" /><Meta Name="ms.locfileid" Value="67854884" /></Metadata><TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c6c3b-101">一个抽象类，它允许针对丰富数据有效负载的生产时日志记录检测代码，以在被检测的进程中使用。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-101">An abstract class that allows code to be instrumented for production-time logging of rich data payloads for consumption within the process that was instrumented.</span></span></summary>
    <remarks><span data-ttu-id="c6c3b-102">有关详细信息，请参阅[DiagnosticSource 用户指南](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md)。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-102">For more information, see [DiagnosticSource User's Guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</span></span></remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c6c3b-103">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-103">The name of the event being written.</span></span></param>
        <summary><span data-ttu-id="c6c3b-104">验证通知事件是否已启用。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-104">Verifies if the notification event is enabled.</span></span></summary>
        <returns><span data-ttu-id="c6c3b-105">如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-105"><see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="c6c3b-106">如果没有为通知昂贵的安装程序，可以在执行此安装程序之前调用 IsEnabled。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-106">If there is expensive setup for the notification, you can call IsEnabled before performing this setup.</span></span> <span data-ttu-id="c6c3b-107">使用者不应假定，它们才会收到的通知 IsEnabled 为 true。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-107">Consumers should not assume that they only get notifications for which IsEnabled is true.</span></span> <span data-ttu-id="c6c3b-108">但是，它是可选的生成者以调用此 API。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-108">However, it is optional for producers to call this API.</span></span> <span data-ttu-id="c6c3b-109">名称应与传递给相同<see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-109">The name should be the same as that passed to <see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c6c3b-110">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-110">The name of the event being written.</span></span></param>
        <param name="arg1"><span data-ttu-id="c6c3b-111">一个对象，它表示 IsEnabled 的附加上下文。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-111">An object that represents the additional context for IsEnabled.</span></span> <span data-ttu-id="c6c3b-112">使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 来检查使用者是否确实要获取此类事件的通知。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-112">Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) to check if consumer wants to get notifications for such events at all.</span></span> <span data-ttu-id="c6c3b-113">基于此，生成方可使用非 <see langword="null" /> 上下文再次调用 IsEnabled(string, object, object)。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-113">Based on that, producer may call IsEnabled(string, object, object) again with non-<see langword="null" /> context.</span></span></param>
        <param name="arg2"><span data-ttu-id="c6c3b-114">可选。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-114">Optional.</span></span> <span data-ttu-id="c6c3b-115">一个对象，它表示 IsEnabled 的附加上下文。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-115">An object that represents the additional context for IsEnabled.</span></span> <span data-ttu-id="c6c3b-116">默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-116"><see langword="null" /> by default.</span></span> <span data-ttu-id="c6c3b-117">使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 或者已在 <paramref name="arg1" /> 中传递所有必要的上下文。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-117">Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) or producer passed all necessary context in <paramref name="arg1" />.</span></span></param>
        <summary><span data-ttu-id="c6c3b-118">验证通知事件是否已启用。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-118">Verifies it the notification event is enabled.</span></span></summary>
        <returns><span data-ttu-id="c6c3b-119">如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-119"><see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
<span data-ttu-id="c6c3b-120">如果成本高昂的安装程序的通知，你可以调用此方法并执行安装程序前提供上下文。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-120">If there is expensive setup for the notification, you can call this method and provide context before performing the setup.</span></span>
          
           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">To be added.</param>
        <param name="payload">To be added.</param>
        <summary><span data-ttu-id="c6c3b-121">将状态从活动转移到将在进程外发生的某些事件或操作，例如传出 HTTP 请求。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-121">Transfers state from an activity to some event or operation, such as an outgoing HTTP request, that will occur outside the process.</span></span></summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c6c3b-122">如果 instumentation 站点位于其中的活动将进程 （如传出 HTTP 请求） 的位置，该站点将想要的活动的状态转移到传出请求。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-122">If an instumentation site is at a location where activities leave the process (such as outgoing HTTP requests), that site will want to transfer state from the activity to the outgoing request.</span></span>

<span data-ttu-id="c6c3b-123">可能的范围内，这应通过检测站点，因为没有之间的协定<xref:System.Diagnostics.Activity>和 ougoing 请求逻辑检测站点上的。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-123">To the extent possible, this should be done by the instrumenation site, because there is a contract between an <xref:System.Diagnostics.Activity> and the ougoing request logic at the instrumentation site.</span></span>   <span data-ttu-id="c6c3b-124">但是，检测站点不能处理策略 （例如，是否活动信息应禁用或编写的兼容性原因的较旧格式）。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-124">However, the instrumenation site can't handle policy (for example, whether activity information should be disabled or written in an older format for compatibility reasons).</span></span>
<span data-ttu-id="c6c3b-125">为此，检测站点需要调用返回到日志记录系统并要求它要解决策略。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-125">For this, the instrumentation site needs to call back out to the logging system and ask it to resolve policy.</span></span> <span data-ttu-id="c6c3b-126">这种情况`OnActivityExport`方法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-126">This is the purpose of the `OnActivityExport` method.</span></span>

<span data-ttu-id="c6c3b-127">`OnActivityExport`给定方法<xref:System.Diagnostics.Activity>以及表示传出请求的有效负载对象。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-127">The `OnActivityExport` method is given the <xref:System.Diagnostics.Activity> as well as a payload object that represents the outgoing request.</span></span> <span data-ttu-id="c6c3b-128">一个<xref:System.Diagnostics.DiagnosticSource>订阅服务器然后包含之前将其发送传出的请求进行更新的功能。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-128">A <xref:System.Diagnostics.DiagnosticSource> subscriber then has the ability to update the outgoing request before it is sent.</span></span>
 
<span data-ttu-id="c6c3b-129">请注意在检测站点 （仅处理一个传出边界上的这些站点） 上很少使用此方法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-129">Note that this method is rarely used at instrumentation sites (only those sites that are on an outgoing boundary of the process).</span></span>   <span data-ttu-id="c6c3b-130">此外，通常检测站点执行 （例如，若要传输特定的传出约定中的所有活动状态） 的默认策略是可能都很正常。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-130">Moreover, typically the default policy that the instrumenation site performs (for example, to transfer all activity state in a particular outgoing convention) is likely to be fine.</span></span> <span data-ttu-id="c6c3b-131">此方法是仅的情况下，其中，它是一个问题。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-131">This method is only for cases where that is a problem.</span></span> <span data-ttu-id="c6c3b-132">因此，此方法应很少使用，主要是此处适合使用 symetry`OnActivityImport`以及前瞻性地保护。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-132">Thus, this method should be used very rarely and is mostly here for symetry with `OnActivityImport` and future-proofing.</span></span>

<span data-ttu-id="c6c3b-133">请注意，`payload`被类型化为<xref:System.Object>内容，但任何特定检测站点和订阅服务器应知道负载的类型，因此强制转换和如有必要对其进行解码。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-133">Note that `payload` is typed as an <xref:System.Object> here, but any particular instrumentation site and subscriber should know the type of the payload and thus cast and decode it if necessary.</span></span>

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="c6c3b-134">受外部事件影响的活动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-134">The activity affected by an external event.</span></span></param>
        <param name="payload"><span data-ttu-id="c6c3b-135">表示传入请求的有效负载。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-135">A payload that represents the incoming request.</span></span></param>
        <summary><span data-ttu-id="c6c3b-136">将状态从将在进程外发生的某些事件或操作（例如传入请求）转移到活动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-136">Transfers state to an activity from some event or operation, such as an incoming request, that occurred outside the process.</span></span></summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c6c3b-137">如果 instumentation 站点以响应某些事件在进程之外创建新的活动，例如传入 HTTP 请求），`OnActivityImport`方法，该站点将想要对传入请求创建一个新的活动和传输状态活动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-137">If an instumentation site creates a new activity in response to some event outside the process, such as an incomming HTTP request), the `OnActivityImport` method allows that site will want to create a new activity and transfer state from the incoming request to the activity.</span></span> 

<span data-ttu-id="c6c3b-138">可能的范围内，这应通过检测站点，因为没有之间的协定<xref:System.Diagnostics.Activity>和检测站点上的传入请求逻辑。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-138">To the extent possible, this should be done by the instrumentation site, because there is a contract between the <xref:System.Diagnostics.Activity> and the incomming request logic at the instrumentation site.</span></span>   <span data-ttu-id="c6c3b-139">但是，检测站点不能处理策略。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-139">However, the instrumentation site can't handle policy.</span></span> <span data-ttu-id="c6c3b-140">（例如，如果执行采样，则完全哪些请求采样？）在这些情况下，检测站点需要调用返回到日志记录系统并要求它要解决策略 （例如，若要决定是否应设置为活动的"采样"位）。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-140">(For example, if sampling is done, exactly which requests should be sampled?) In these cases, the instrumentation site needs to call back out to the logging system and ask it to resolve policy (for example, to decide if the activity's "sampling" bit should be set).</span></span> <span data-ttu-id="c6c3b-141">这种情况`OnActivityImport`方法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-141">This is the purpose of the `OnActivityImport` method.</span></span> <span data-ttu-id="c6c3b-142">给定活动，以及表示传入请求的有效负载对象。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-142">It is given the activity as well as a payload object that represents the incomming request.</span></span> <span data-ttu-id="c6c3b-143">订户的<xref:System.Diagnostics.DiagnosticSource>将有机会来更新此活动根据需要。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-143">The subscribers to the <xref:System.Diagnostics.DiagnosticSource> then have the opportunity to update this activity as desired.</span></span> 

<span data-ttu-id="c6c3b-144">在检测站点 （仅过程的边界上的这些站点），很少使用此方法并 instrumetation 站点实现某些默认策略 (活动设置*某些*方式)，并因此不需要为重写此方法，该默认策略是否正常。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-144">This method is rarely used at instrumentation sites (only those sites that are on the boundary of the process), and the instrumetation site implements some default policy (it sets the activity in *some* way), and so it is not necessary to override this method if that default policy is fine.</span></span> <span data-ttu-id="c6c3b-145">换而言之，应在极少数 （但通常很重要） 的情况下重写此方法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-145">In other words, this method should be overridden in very rare (but often important) cases.</span></span>

<span data-ttu-id="c6c3b-146">请注意，`payload`被类型化为<xref:System.Object>内容，但任何特定检测站点和订阅服务器将知道负载的类型，因此强制转换和如有必要对其进行解码。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-146">Note that `payload` is typed as <xref:System.Object> here, but any particular instrumentation site and subscriber will know the type of the payload and thus cast and decode it if necessary.</span></span>

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartActivity">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Activity StartActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StartActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Activity ^ StartActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StartActivity : System.Diagnostics.Activity * obj -&gt; System.Diagnostics.Activity" Usage="diagnosticSource.StartActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="c6c3b-147">要启动的 <see cref="T:System.Diagnostics.Activity" />。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-147">The <see cref="T:System.Diagnostics.Activity" /> to be started.</span></span></param>
        <param name="args"><span data-ttu-id="c6c3b-148">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-148">An object that represent the value being passed as a payload for the event.</span></span></param>
        <summary><span data-ttu-id="c6c3b-149">启动 <see cref="T:System.Diagnostics.Activity" /> 并写入启动事件。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-149">Starts an <see cref="T:System.Diagnostics.Activity" /> and writes a start event.</span></span></summary>
        <returns><span data-ttu-id="c6c3b-150">便于链接的已启动的活动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-150">The started activity for convenient chaining.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
           
<span data-ttu-id="c6c3b-151"><xref:System.Diagnostics.Activity>描述的逻辑操作、 其上下文和父关系; 当前<xref:System.Diagnostics.Activity>流经操作处理。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-151">The <xref:System.Diagnostics.Activity> describes the logical operation, its context, and parent relation; the current <xref:System.Diagnostics.Activity> flows through the operation processing.</span></span>

<span data-ttu-id="c6c3b-152">此方法启动给定<xref:System.Diagnostics.Activity>，维护全局<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>和<xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType>活动的给定<xref:System.Diagnostics.Activity>，并通知使用者的一个新<xref:System.Diagnostics.Activity>已启动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-152">This method starts the given <xref:System.Diagnostics.Activity>, maintains a global <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> and <xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType> activity for the given <xref:System.Diagnostics.Activity>, and notifies consumers that a new <xref:System.Diagnostics.Activity> was started.</span></span> <span data-ttu-id="c6c3b-153">使用者可以访问<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>添加上下文和/或扩充遥测数据。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-153">Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.</span></span>

<span data-ttu-id="c6c3b-154">生成者可能通过向使用者在有效负载中的其他详细信息。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-154">Producers may pass additional details to the consumer in the payload.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopActivity">
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StopActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StopActivity : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.StopActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity"><span data-ttu-id="c6c3b-155">要停止的活动。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-155">The activity to be stopped.</span></span></param>
        <param name="args"><span data-ttu-id="c6c3b-156">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-156">An object that represents the value passed as a payload for the event.</span></span></param>
        <summary><span data-ttu-id="c6c3b-157">停止给定的 <see cref="T:System.Diagnostics.Activity" />，维护全局 <see cref="P:System.Diagnostics.Activity.Current" /> 活动，并通知使用者 <see cref="T:System.Diagnostics.Activity" /> 已停止。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-157">Stops the given <see cref="T:System.Diagnostics.Activity" />, maintains the global <see cref="P:System.Diagnostics.Activity.Current" /> activity, and notifies consumers that the <see cref="T:System.Diagnostics.Activity" /> was stopped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c6c3b-158">生成者可能通过向使用者在有效负载中的其他详细信息。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-158">Producers may pass additional details to the consumer in the payload.</span></span>

<span data-ttu-id="c6c3b-159">使用者可以访问<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>添加上下文和/或扩充遥测数据。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-159">Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.</span></span>


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c6c3b-160">正在写入的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-160">The name of the event being written.</span></span></param>
        <param name="value"><span data-ttu-id="c6c3b-161">一个对象，它表示作为事件的有效负载传递的值。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-161">An object that represents the value being passed as a payload for the event.</span></span> <span data-ttu-id="c6c3b-162">这通常是一个包含多个子值的匿名类型。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-162">This is often an anonymous type which contains several sub-values.</span></span></param>
        <summary><span data-ttu-id="c6c3b-163">提供记录复杂有效负载的通用方法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-163">Provides a generic way of logging complex payloads.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="c6c3b-164">每个通知提供用于标识以及提供任意信息将传递给通知的对象 （通常是一个匿名类型） 的名称。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-164">Each notification is given a name that identifies it, as well as an object (typically an anonymous type) that provides arbitrary information to pass to the notification.</span></span>  

<span data-ttu-id="c6c3b-165">`name` 应较短。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-165">`name` should be short.</span></span> <span data-ttu-id="c6c3b-166">不要使用完全限定的名称，除非您必须为避免混淆，因为`name`必须是全局唯一。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-166">Don't use a fully qualified name unless you have to to avoid ambiguity, since `name` must be globally unique.</span></span> <span data-ttu-id="c6c3b-167">通常情况下， *componentName.eventName*，其中*componentName*并*eventName*是少于 10 个字符的字符串，是很好地折衷。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-167">Typically, *componentName.eventName*, where *componentName* and *eventName* are strings less than 10 characters, are a good compromise.</span></span>

<span data-ttu-id="c6c3b-168">通知名称不应具有`.`中这些组件名称包含点，因为，就需要这两个具有点会导致二义性。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-168">Notification names should not have `.` in them because component names have dots, and for them both to have dots leads to ambiguity.</span></span> <span data-ttu-id="c6c3b-169">我们建议你使用`_`相反。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-169">We suggest that you use `_` instead.</span></span>

<span data-ttu-id="c6c3b-170">假定侦听器将使用字符串作为前缀来筛选的组。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-170">Assume that listeners will use string prefixing to filter groups.</span></span> <span data-ttu-id="c6c3b-171">因此，具有组件名称的层次结构是一个好的做法。</span><span class="sxs-lookup"><span data-stu-id="c6c3b-171">Therefore, having a hierarchy of component names is a good practice.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
