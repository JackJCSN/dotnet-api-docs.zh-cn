<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d79c7605daf68e0c4169c32fac48c2c1ac277dad" /><Meta Name="ms.sourcegitcommit" Value="cfc0e4215fd0d259582ada2141878befd7c3c8c6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/12/2019" /><Meta Name="ms.locfileid" Value="67854884" /></Metadata><TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>一个抽象类，它允许针对丰富数据有效负载的生产时日志记录检测代码，以在被检测的进程中使用。</summary>
    <remarks>有关详细信息，请参阅[DiagnosticSource 用户指南](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md)。</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">正在写入的事件的名称。</param>
        <summary>验证通知事件是否已启用。</summary>
        <returns>如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

如果没有为通知昂贵的安装程序，可以在执行此安装程序之前调用 IsEnabled。 使用者不应假定，它们才会收到的通知 IsEnabled 为 true。 但是，它是可选的生成者以调用此 API。 名称应与传递给相同<see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />。

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">正在写入的事件的名称。</param>
        <param name="arg1">一个对象，它表示 IsEnabled 的附加上下文。 使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 来检查使用者是否确实要获取此类事件的通知。 基于此，生成方可使用非 <see langword="null" /> 上下文再次调用 IsEnabled(string, object, object)。</param>
        <param name="arg2">可选。 一个对象，它表示 IsEnabled 的附加上下文。 默认值为 <see langword="null" />。 使用者应会收到 <see langword="null" />，它可能表示生成方已调用纯 IsEnabled(string) 或者已在 <paramref name="arg1" /> 中传递所有必要的上下文。</param>
        <summary>验证通知事件是否已启用。</summary>
        <returns>如果通知事件已启用，为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
如果成本高昂的安装程序的通知，你可以调用此方法并执行安装程序前提供上下文。
          
           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">To be added.</param>
        <param name="payload">To be added.</param>
        <summary>将状态从活动转移到将在进程外发生的某些事件或操作，例如传出 HTTP 请求。</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

如果 instumentation 站点位于其中的活动将进程 （如传出 HTTP 请求） 的位置，该站点将想要的活动的状态转移到传出请求。

可能的范围内，这应通过检测站点，因为没有之间的协定<xref:System.Diagnostics.Activity>和 ougoing 请求逻辑检测站点上的。   但是，检测站点不能处理策略 （例如，是否活动信息应禁用或编写的兼容性原因的较旧格式）。
为此，检测站点需要调用返回到日志记录系统并要求它要解决策略。 这种情况`OnActivityExport`方法。

`OnActivityExport`给定方法<xref:System.Diagnostics.Activity>以及表示传出请求的有效负载对象。 一个<xref:System.Diagnostics.DiagnosticSource>订阅服务器然后包含之前将其发送传出的请求进行更新的功能。
 
请注意在检测站点 （仅处理一个传出边界上的这些站点） 上很少使用此方法。   此外，通常检测站点执行 （例如，若要传输特定的传出约定中的所有活动状态） 的默认策略是可能都很正常。 此方法是仅的情况下，其中，它是一个问题。 因此，此方法应很少使用，主要是此处适合使用 symetry`OnActivityImport`以及前瞻性地保护。

请注意，`payload`被类型化为<xref:System.Object>内容，但任何特定检测站点和订阅服务器应知道负载的类型，因此强制转换和如有必要对其进行解码。

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">受外部事件影响的活动。</param>
        <param name="payload">表示传入请求的有效负载。</param>
        <summary>将状态从将在进程外发生的某些事件或操作（例如传入请求）转移到活动。</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

如果 instumentation 站点以响应某些事件在进程之外创建新的活动，例如传入 HTTP 请求），`OnActivityImport`方法，该站点将想要对传入请求创建一个新的活动和传输状态活动。 

可能的范围内，这应通过检测站点，因为没有之间的协定<xref:System.Diagnostics.Activity>和检测站点上的传入请求逻辑。   但是，检测站点不能处理策略。 （例如，如果执行采样，则完全哪些请求采样？）在这些情况下，检测站点需要调用返回到日志记录系统并要求它要解决策略 （例如，若要决定是否应设置为活动的"采样"位）。 这种情况`OnActivityImport`方法。 给定活动，以及表示传入请求的有效负载对象。 订户的<xref:System.Diagnostics.DiagnosticSource>将有机会来更新此活动根据需要。 

在检测站点 （仅过程的边界上的这些站点），很少使用此方法并 instrumetation 站点实现某些默认策略 (活动设置*某些*方式)，并因此不需要为重写此方法，该默认策略是否正常。 换而言之，应在极少数 （但通常很重要） 的情况下重写此方法。

请注意，`payload`被类型化为<xref:System.Object>内容，但任何特定检测站点和订阅服务器将知道负载的类型，因此强制转换和如有必要对其进行解码。

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartActivity">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Activity StartActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StartActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Activity ^ StartActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StartActivity : System.Diagnostics.Activity * obj -&gt; System.Diagnostics.Activity" Usage="diagnosticSource.StartActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">要启动的 <see cref="T:System.Diagnostics.Activity" />。</param>
        <param name="args">一个对象，它表示作为事件的有效负载传递的值。</param>
        <summary>启动 <see cref="T:System.Diagnostics.Activity" /> 并写入启动事件。</summary>
        <returns>便于链接的已启动的活动。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
           
<xref:System.Diagnostics.Activity>描述的逻辑操作、 其上下文和父关系; 当前<xref:System.Diagnostics.Activity>流经操作处理。

此方法启动给定<xref:System.Diagnostics.Activity>，维护全局<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>和<xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType>活动的给定<xref:System.Diagnostics.Activity>，并通知使用者的一个新<xref:System.Diagnostics.Activity>已启动。 使用者可以访问<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>添加上下文和/或扩充遥测数据。

生成者可能通过向使用者在有效负载中的其他详细信息。

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopActivity">
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StopActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StopActivity : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.StopActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">要停止的活动。</param>
        <param name="args">一个对象，它表示作为事件的有效负载传递的值。</param>
        <summary>停止给定的 <see cref="T:System.Diagnostics.Activity" />，维护全局 <see cref="P:System.Diagnostics.Activity.Current" /> 活动，并通知使用者 <see cref="T:System.Diagnostics.Activity" /> 已停止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

生成者可能通过向使用者在有效负载中的其他详细信息。

使用者可以访问<xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>添加上下文和/或扩充遥测数据。


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">正在写入的事件的名称。</param>
        <param name="value">一个对象，它表示作为事件的有效负载传递的值。 这通常是一个包含多个子值的匿名类型。</param>
        <summary>提供记录复杂有效负载的通用方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

每个通知提供用于标识以及提供任意信息将传递给通知的对象 （通常是一个匿名类型） 的名称。  

`name` 应较短。 不要使用完全限定的名称，除非您必须为避免混淆，因为`name`必须是全局唯一。 通常情况下， *componentName.eventName*，其中*componentName*并*eventName*是少于 10 个字符的字符串，是很好地折衷。

通知名称不应具有`.`中这些组件名称包含点，因为，就需要这两个具有点会导致二义性。 我们建议你使用`_`相反。

假定侦听器将使用字符串作为前缀来筛选的组。 因此，具有组件名称的层次结构是一个好的做法。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
