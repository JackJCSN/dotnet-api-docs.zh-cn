<Type Name="CultureInfo" FullName="System.Globalization.CultureInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3a08fa7376e5eece102261e6c6e2759776b96508" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67244341" /></Metadata><TypeSignature Language="C#" Value="public class CultureInfo : ICloneable, IFormatProvider" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit CultureInfo extends System.Object implements class System.ICloneable, class System.IFormatProvider" />
  <TypeSignature Language="DocId" Value="T:System.Globalization.CultureInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class CultureInfo&#xA;Implements ICloneable, IFormatProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class CultureInfo : ICloneable, IFormatProvider" />
  <TypeSignature Language="F#" Value="type CultureInfo = class&#xA;    interface ICloneable&#xA;    interface IFormatProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Globalization</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormatProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供有关特定区域性（对于非托管代码开发，则称为“区域设置”）的信息。 这些信息包括区域性的名称、书写系统、使用的日历、字符串的排序顺序以及对日期和数字的格式化设置。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>类提供特定于区域性的信息，如语言、 子语言、 国家/地区、 日历和与特定区域性关联的约定。 此类还提供对特定于区域性的实例的访问<xref:System.Globalization.DateTimeFormatInfo>， <xref:System.Globalization.NumberFormatInfo>， <xref:System.Globalization.CompareInfo>，和<xref:System.Globalization.TextInfo>对象。 这些对象包含特定于区域性的操作，如大小写、 格式化日期和数字，并比较字符串所需的信息。 <xref:System.Globalization.CultureInfo>类由直接或间接类设置的格式、 分析，或处理特定于区域性的数据，如<xref:System.String>， <xref:System.DateTime>， <xref:System.DateTimeOffset>，与数值类型。  
  
 本节内容：  
  
 [区域性名称和标识符](#CultureNames)   
 [不变、 中立和特定区域性](#Invariant)   
 [自定义区域性](#Custom)   
 [动态区域性数据](#Dynamic)   
 [CultureInfo 和文化的数据](#cultureinfo-and-cultural-data)[当前区域性和当前 UI 区域性](#Current)   
 [获取所有区域性](#GetAll)   
 [区域性和线程](#Threads)   
 [区域性和应用程序域](#AppDomain)   
 [区域性和基于任务的异步操作](#Async)   
 [CultureInfo 对象序列化](#Serialization)   
 [控件面板重写](#CPanel)   
 [替代排序顺序](#AlternateSort)   
 [区域性和 Windows 应用](#Windows)  

<a name="CultureNames"></a>   
## <a name="culture-names-and-identifiers"></a>区域性名称和标识符  
 <xref:System.Globalization.CultureInfo>类指定为每个区域性，基于 RFC 4646 的唯一名称。 名称是与语言相关的 ISO 639 双小写字母的区域性代码和与国家或地区相关的 ISO 3166 双字母的大写字母子区域性代码的组合。 此外，对于面向应用[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]或更高版本并在 Windows 10 或更高版本，对应于有效的 BCP-47 语言标记受支持的区域性名称运行。  
  
> [!NOTE]
>  当区域性名称传递给类构造函数或方法诸如<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>或<xref:System.Globalization.CultureInfo>，其大小写并不重要。  
  
 根据 RFC 4646 的区域性名称的格式是*languagecode2*>-*country/regioncode2*，其中*languagecode2*是两个字母的语言代码并*country/regioncode2*是两个字母子区域性代码。 示例包括 JA-JP 日语 （日本） 和美国英语 （美国）。 在两个字母的语言代码不可用的情况下，使用派生自 ISO 639-2 的三个字母代码。  
  
 请注意，某些区域性名称还指定 ISO 15924 书写符号。 例如，符号指定西里尔语脚本和 Latn 指定拉丁语脚本。 包含的脚本的区域性名称使用模式*languagecode2*-*scripttag*-*country/regioncode2*。 这种类型的区域性名称的一个示例是 uz 符号-UZ 为乌兹别克语 （西里尔文，乌兹别克斯坦）。 在 Windows Vista 之前的 Windows 操作系统，包括脚本的区域性名称使用模式*languagecode2*-*country/regioncode2* - *scripttag*，例如，uz UZ-符号的乌兹别克语 （西里尔文，乌兹别克斯坦）。  
  
 只有两个字母的小写字母语言代码指定一个非特定区域性。 例如，fr 为法语，指定的非特定区域性，de 代表德语指定非特定区域性。  
  
> [!NOTE]
>  有两个区域性名称不符合此规则。 区域性中文 （简体）-Zh-hans，名为和中文 （繁体），名为 Zh-hant，是非特定区域性。 区域性名称表示当前的标准，并且应使用，除非使用旧名称 ZH-CHS 和 ZH-CHT 的理由需要。  
  
 区域性标识符是标准的国际号码缩写，具有唯一标识的已安装的区域性之一的所需的组件。 你的应用程序可以使用预定义的区域性标识符，或定义自定义的标识符。  
  
 某些预定义的区域性名称和标识符使用的此类和中的其他类<xref:System.Globalization?displayProperty=nameWithType>命名空间。 Windows 系统的详细的区域性信息，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。  
  
 请记住的区域性名称和标识符表示可在特定计算机找到的区域性的一个子集。 Windows 版本或 service pack 可以更改的可用区域性。 应用程序添加自定义区域性使用<xref:System.Globalization.CultureAndRegionInfoBuilder>类。 用户将添加使用 Microsoft Locale Builder 工具自己自定义区域性。 Microsoft Locale Builder 编写在托管的代码中使用`CultureAndRegionInfoBuilder`类。  
  
 多个不同的名称是一种文化，值得注意的是与以下的类成员关联的名称与紧密关联：  
  
-   <xref:System.Globalization.CultureInfo.ToString%2A?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.CompareInfo.Name%2A?displayProperty=nameWithType>  
  
<a name="Invariant"></a>   
## <a name="invariant-neutral-and-specific-cultures"></a>不变、 中立和特定区域性  
 区域性通常分为三个集合： 固定区域性、 非特定区域性和特定区域性。  
  
 固定区域性是不区分区域性的。 你的应用程序指定固定区域性的名称使用空字符串 ("") 或由其标识符。 <xref:System.Globalization.CultureInfo.InvariantCulture%2A> 定义固定区域性的实例。 它是关联与英语语言，但不能与任何国家/地区。 几乎所有方法中使用`Globalization`要求区域性的命名空间。  
  
 非特定区域性是关联的区域性与一种语言，但不能与国家/地区。 特定区域性是一个区域性与一种语言和国家/地区相关联。 例如，fr 是法语区域的非特定语言名称和 FR-FR 是特定的法语 （法国） 区域性的名称。 请注意，中文 （简体） 和中文 （繁体） 也被视为非特定区域性。  
  
 创建实例的<xref:System.Globalization.CompareInfo>类不建议一个非特定区域性，因为其包含的数据是任意的。 若要显示和对数据进行排序，指定的语言和区域。 此外，<xref:System.Globalization.CompareInfo.Name%2A>属性的<xref:System.Globalization.CompareInfo>对象创建一个非特定区域性返回仅的国家/地区，并且不包含区域。  
  
 定义的区域性具有层次结构中的特定区域性的父级是一个非特定区域性和非特定区域性的父级是固定的区域性。 <xref:System.Globalization.CultureInfo.Parent%2A>属性包含与特定区域性关联的非特定区域性。 自定义区域性应<xref:System.Globalization.CultureInfo.Parent%2A>为了符合此模式的属性。  
  
 如果针对特定区域性资源不可用在操作系统中，将使用关联的非特定区域性的资源。 如果非特定区域性资源不可用，则使用嵌入在主程序集中的资源。 资源回退进程的详细信息，请参阅[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
 Windows API 中的区域设置的列表是略有不同的.NET Framework 支持的区域性列表。 如果需要与 Windows 互操作性，例如，通过 p/invoke 机制，应用程序应使用特定区域性定义的操作系统。 使用特定区域性可确保与等效的 Windows 区域设置，会使用相同的区域设置标识符来标识的一致性<xref:System.Globalization.CultureInfo.LCID%2A>。  
  
 一个<xref:System.Globalization.DateTimeFormatInfo>或<xref:System.Globalization.NumberFormatInfo>可以创建仅用于固定区域性或特定区域性，不能为非特定区域性。  
  
 如果<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>是<xref:System.Globalization.TaiwanCalendar>但<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>未设置为 ZH-TW，然后<xref:System.Globalization.DateTimeFormatInfo.NativeCalendarName%2A?displayProperty=nameWithType>， <xref:System.Globalization.DateTimeFormatInfo.GetEraName%2A?displayProperty=nameWithType>，并<xref:System.Globalization.DateTimeFormatInfo.GetAbbreviatedEraName%2A?displayProperty=nameWithType>返回空字符串 ("")。  
  
<a name="Custom"></a>   
## <a name="custom-cultures"></a>自定义区域性  
 除了 Windows 操作系统和.NET Framework 支持的预定义区域性，.NET Framework 支持三种类型的自定义区域性：  
  
-   新补充 Windows 或.NET Framework 中可用的区域性的区域性。 例如，应用程序无法安装<xref:System.Globalization.CultureInfo>表示 FJ-FJ （或 Fijan （斐济）） 区域性的系统上的对象。  
  
-   其属性是不同于 Windows 和.NET Framework 支持标准区域性的属性的替换区域性。  
  
-   通过用户重写的标准区域性。 用户可以使用**区域和语言**应用程序中**控制面板**自定义现有区域性的属性值。  
  
> [!NOTE]
>  可以使用<xref:System.Globalization.CultureAndRegionInfoBuilder>类来定义、 保存和注册自定义区域性的补充或替换现有的区域性。 <xref:System.Globalization.CultureAndRegionInfoBuilder.Save%2A?displayProperty=nameWithType>方法将创建可用于在目标系统上安装自定义区域性的区域设置数据标记语言 (LDML) 文件。 有关分步步骤使用信息<xref:System.Globalization.CultureAndRegionInfoBuilder>要创建一个新类或替换区域性，请参阅<xref:System.Globalization.CultureAndRegionInfoBuilder>类主题。  
  
 由于.NET Framework 支持自定义区域性，使用特定于区域性的数据时应考虑以下：  
  
-   自定义区域性可以有超过预定义的区域性的范围的值。 例如，某些区域性具有非常长月份名称、 意外的日期或时间格式或其他不常见的数据。  
  
-   当在用户界面中显示特定于区域性的数据时，应遵守用户的自定义项;例如，用户可能希望采用 24 小时制或 yyyyMMdd 日期格式。  
  
-   请记住，自定义区域性重写默认值。 因此，不能考虑区域性数据保持不变。 在将来可能会更改国家/地区名称、 数字和日期格式和拼写。 如果你想要序列化区分区域性的数据，如要传递到的日期和时间分析函数的日期和时间字符串，应使用固定区域性或特定。  
  
 <xref:System.Globalization.CultureInfo.CultureTypes%2A>的系统上安装的自定义区域性的属性值包含<xref:System.Globalization.CultureTypes?displayProperty=nameWithType>分配标志和自定义区域性<xref:System.Globalization.CultureInfo.LCID%2A>属性值为`LOCALE_CUSTOM_UNSPECIFIED`（0x1000 控制或 4096）。 请注意，从 Windows 10 开始，此值也分配给缺少完整的文化数据的系统定义的区域性。  

## <a name="cultureinfo-and-cultural-data"></a>CultureInfo 和文化的数据

.NET 派生其区域性的数据从各种源，具体取决于实现、 平台和版本的一个：

- 在.NET Framework 3.5 和更早版本中，区域性数据是由 Windows 操作系统和.NET Framework 提供的。

- 在.NET Framework 4 和更高版本中，由 Windows 操作系统提供区域性的数据。

- 在所有版本的.NET Core 在 Windows 上运行，由 Windows 操作系统提供区域性的数据。

- 在所有版本的 Unix 平台上运行的.NET Core，区域性数据由提供[International Components for Unicode (ICU) 库](http://site.icu-project.org/)。 ICU 库的特定版本取决于各个操作系统。

因此，可在特定.NET 实现、 平台或版本上的区域性可能不可用不同.NET 实现、 平台或版本上。

某些`CultureInfo`对象存在差异，具体取决于基础平台。 具体而言，"zh CN"，或中文 （简体，中国） 和 ZH-TW，或中文 （繁体，台湾） 是 Windows 系统上的可用区域性，但它们是在 Unix 系统上的使用别名区域性。 "zh CN"是"zh Hans CN"区域性的别名和"ZH-TW"是"不同-ZH-TW"区域性的别名。 使用别名的区域性不返回通过调用<xref:System.Globalization.CultureInfo.GetCultures%2A>方法并且可能具有不同的属性值，包括不同<xref:System.Globalization.CultureInfo.Parent>比对应的 Windows 的区域性。 对于 ZH-CN 和 ZH-TW 的区域性，这些 differenes 包括：

- 在 Windows 系统上的"zh CN"区域性的父区域性"Zh-hans"，"ZH-TW"区域性的父区域性"Zh-hant"。 这两个这些区域性的父区域性是"zh"。 在 Unix 系统上的这两个区域性父级的"zh"。 这意味着，如果没有为"zh CN"或"ZH-TW"区域性提供特定于区域性的资源，但不要为非特定语言"-Zh-hans"或"Zh-hant"区域性提供资源，你的应用程序将加载在 Windows 上，但不是在 Unix 上的非特定区域性的资源. 在 Unix 系统中，您必须显式设置线程的<xref:System.Globalization.CultureInfo.CurrentUICulture>"Zh-hans"或"Zh-hant"。 

- 在 Windows 系统中，调用<xref:System.Globalization.CultureInfo.Equals%2A?displayProperty=nameWithType>实例上表示"zh CN"区域性，并将其传递"zh Hans CN"实例返回`true`。 在 Unix 系统上的方法调用返回`false`。 此行为也适用于调用<xref:System.Globalization.CultureInfo.Equals%2A>上"ZH-TW"<xref:System.Globalization.CultureInfo>实例并将其传递"不同-Zh-tw"实例。

<a name="Dynamic"></a>   
## <a name="dynamic-culture-data"></a>动态区域性数据  
 固定区域性，除区域性数据是动态的。 这是即使对于预定义的区域性，则返回 true。 例如，国家或地区采用新的货币、 更改其拼写的单词，或更改其首选的日历和区域性定义更改跟踪此事件。  自定义区域性可能会有所变动，恕不另行通知，和任何特定区域性可能会被重写通过自定义替换区域性。 此外，按如下所述，为单个用户可以重写区域首选项。 应用程序应始终在运行时获取区域性的数据。  
  
> [!CAUTION]
>  保存数据时，应用程序应使用固定区域性、 二进制格式或特定于区域性的格式。 根据特定区域性，而非固定区域性，与关联的当前值保存数据可能会变得不可读，或如果该区域性发生更改的含义可能会更改。  
  
<a name="Current"></a>   
## <a name="the-current-culture-and-current-ui-culture"></a>当前区域性和当前 UI 区域性  
 在.NET 应用程序中的每个线程都具有当前区域性和当前 UI 区域性。 当前区域性的日期、 时间、 数字和货币值、 文本、 大小写约定和比较字符串的方法的排序顺序确定的格式设置约定。 当前 UI 区域性用于检索在运行时特定于区域性的资源。  
  
> [!NOTE]
>  有关如何针对每个线程确定当前和当前 UI 区域性的信息，请参阅[区域性和线程](#Threads)部分。 了解如何将当前和当前 UI 区域性确定线程上执行新的应用程序域，并跨应用程序域边界的线程上请参阅[区域性和应用程序域](#AppDomain)部分。 有关如何执行基于任务的异步操作的线程上确定当前的和当前的信息，请参阅[区域性和基于任务的异步操作](#Async)部分。  
  
 有关详细的当前区域性的信息，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性主题。 有关详细的当前 UI 区域性的信息，请参阅<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性主题。  
  
### <a name="retrieving-the-current-and-current-ui-cultures"></a>检索当前和当前 UI 区域性  
 可以获取<xref:System.Globalization.CultureInfo>对象，表示当前区域性中通过两种方式：  
  
-   通过检索的值<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性。  
  
-   通过检索的值[Thread.CurrentThread.CurrentCulture](<xref:System.Threading.Thread.CurrentCulture>)属性。  
  
 下面的示例检索这两个属性值，将其以显示它们相等，并显示当前区域性的名称进行比较。  
  
 [!code-csharp[System.Globalization.CultureInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/Current1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/Current1.vb#1)]  
  
 可以获取<xref:System.Globalization.CultureInfo>对象，表示当前 UI 区域性中通过两种方式：  
  
-   通过检索的值<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性。  
  
-   通过检索的值[Thread.CurrentThread.CurrentUICulture](<xref:System.Threading.Thread.CurrentUICulture>)属性。  
  
 下面的示例检索这两个属性值，将其以显示它们相等，并显示当前 UI 区域性的名称进行比较。  
  
 [!code-csharp[System.Globalization.CultureInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/CurrentUI1.cs#2)]
 [!code-vb[System.Globalization.CultureInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/CurrentUI1.vb#2)]  
  
### <a name="setting-the-current-and-current-ui-cultures"></a>设置当前和当前 UI 区域性  
 若要更改区域性和 UI 线程的区域性，请执行以下操作：  
  
1.  实例化<xref:System.Globalization.CultureInfo>对象，通过调用表示该区域性<xref:System.Globalization.CultureInfo>类构造函数并将其传递区域性的名称。 <xref:System.Globalization.CultureInfo.%23ctor%28System.String%29>构造函数实例化<xref:System.Globalization.CultureInfo>反映用户的对象重写的新区域性是否与当前的 Windows 区域性相同。   <xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29>构造函数允许您指定是否新实例化<xref:System.Globalization.CultureInfo>对象反映用户替代新区域性是否与当前的 Windows 区域性相同。  
  
2.  将分配<xref:System.Globalization.CultureInfo>对象传递给<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>或<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>.NET Core 和.NET Framework 4.6 和更高版本上的属性。 (在.NET Framework 4.5.2 及早期版本中，分配 youc`CultureInfo`对象传递给<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>或<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>属性。)   
  
 下面的示例检索当前区域性。 如果是法语 （法国） 区域性之外的任何内容，但它会将当前区域性更改为法语 （法国）。 否则，它将当前区域性更改为法语 （卢森堡）。  
  
 [!code-csharp[System.Globalization.CultureInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/Change1.cs#3)]
 [!code-vb[System.Globalization.CultureInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/Change1.vb#3)]  
  
 下面的示例检索当前区域性。 如果它是其他任何内容斯洛文尼亚语 （斯洛文尼亚） 区域性，它将当前区域性更改为斯洛文尼亚语 （斯洛文尼亚）。 否则，它将当前区域性更改为克罗地亚语 （克罗地亚）。  
  
 [!code-csharp[System.Globalization.CultureInfo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/ChangeUI1.cs#4)]
 [!code-vb[System.Globalization.CultureInfo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/ChangeUI1.vb#4)]  
  
<a name="GetAll"></a>   
## <a name="getting-all-cultures"></a>获取所有区域性  
 可以通过调用检索数组特定的类别或本地计算机上的所有区域性的区域性<xref:System.Globalization.CultureInfo.GetCultures%2A>方法。 例如，您可以检索自定义区域性、 特定区域性或非特定区域性，单独使用或结合使用。  
  
 下面的示例调用<xref:System.Globalization.CultureInfo.GetCultures%2A>方法两次，第一次<xref:System.Globalization.CultureTypes?displayProperty=nameWithType>要检索所有自定义区域性的枚举成员，然后使用<xref:System.Globalization.CultureTypes?displayProperty=nameWithType>要检索所有替换区域性的枚举成员。  
  
 [!code-csharp[System.Globalization.CultureInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/GetCultures1.cs#5)]
 [!code-vb[System.Globalization.CultureInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/GetCultures1.vb#5)]  
  
<a name="Threads"></a>   
## <a name="culture-and-threads"></a>区域性和线程  
 当启动新的应用程序线程时，其当前区域性和当前 UI 区域性定义由当前系统区域性，而不是当前线程区域性。 以下示例演示了差异。 它将当前区域性和应用程序线程的当前 UI 区域性设置为法语 （法国） 区域性 (FR-FR)。 如果当前区域性已经-FR，该示例会将其设置为英语 （美国） 区域性 (EN-US)。 它显示为货币值的三个随机数字，然后创建一个新线程，后者又将三个更随机数字显示为货币值。 但如中的示例所示的输出，显示由新线程的货币值不能反映法语 （法国） 区域性，与主应用程序线程的输出不同的格式设置约定。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/cs/defaultthread1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Class.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/vb/defaultthread1.vb#1)]  
  
 在之前的.NET framework 版本[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、 最常用的方法，以确保主应用程序线程与所有其他工作线程共享相同的区域性是传递的应用程序范围内区域性名称或<xref:System.Globalization.CultureInfo>对象表示的应用程序范围内区域性<xref:System.Threading.ParameterizedThreadStart?displayProperty=nameWithType>委托。 以下示例使用此方法以确保显示由两个线程的货币值反映相同的区域性的格式设置约定。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/cs/perthread1.cs#2)]
 [!code-vb[System.Globalization.CultureInfo.Class.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/vb/perthread1.vb#2)]  
  
 您可以设置区域性和 UI 区域性的线程池线程中类似的方式通过调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>方法。  
  
 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，你可以设置区域性和 UI 区域性，所有线程的应用程序域中更直接地通过分配<xref:System.Globalization.CultureInfo>对象，表示该区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性。 下面的示例使用这些属性以确保在默认应用程序域中的所有线程都共享相同的区域性。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/cs/setthreads1.cs#3)]
 [!code-vb[System.Globalization.CultureInfo.Class.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.thread/vb/setthreads1.vb#3)]  
  
> [!WARNING]
>  尽管<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性是静态成员，它们定义的默认区域性和仅适用于应用程序域的当前设置这些属性值时的默认 UI 区域性。 有关详细信息，请参阅下一部分中，[区域性和应用程序域](#AppDomain)。  
  
 在分配到的值<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性、 区域性和 UI 区域性的应用程序域中线程还更改如果它们未显式分配区域性。 但是，这些线程反映新的区域性设置，仅当它们在当前应用程序域中执行时。 如果在另一个应用程序域中执行这些线程，其区域性将成为该应用程序域定义的默认区域性。 因此，我们建议你始终将主应用程序线程的区域性设置而不依赖<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性以更改它。  
  
<a name="AppDomain"></a>   
## <a name="culture-and-application-domains"></a>区域性和应用程序域  
 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A> 和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>是显式定义仅适用于时设置或检索属性值的当前应用程序域默认区域性的静态属性。 下面的示例将默认应用程序域中的默认区域性和默认 UI 区域性设置为法语 （法国），然后使用<xref:System.AppDomainSetup>类和<xref:System.AppDomainInitializer>委托到一个新应用程序域中设置的默认区域性和 UI 区域性俄语 （俄罗斯）。 单个线程然后执行每个应用程序域中的两种方法。 请注意，线程的区域性和 UI 区域性没有显式设置;它们派生自的默认区域性和 UI 区域性，线程执行所在的应用程序域。 另请注意<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>并<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性返回的默认<xref:System.Globalization.CultureInfo>进行方法调用时的当前应用程序域的值。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.AppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.appdomain/cs/appdomainex1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Class.AppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.appdomain/vb/appdomainex1.vb#1)]  
  
 有关区域性和应用程序域的详细信息，请参阅中的"应用程序域和线程"一节[应用程序域](~/docs/framework/app-domains/application-domains.md)主题。  
  
<a name="Async"></a>   
## <a name="culture-and-task-based-asynchronous-operations"></a>区域性和基于任务的异步操作  
 [基于任务的异步编程模式](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)使用<xref:System.Threading.Tasks.Task>和<xref:System.Threading.Tasks.Task%601>线程池线程对象上异步执行委托。 运行特定任务的特定线程不提前已知，但仅在运行时确定。  
  
 对于面向应用[!INCLUDE[net_v46](~/includes/net-v46-md.md)]或更高版本、 区域性是一个异步操作的上下文的一部分。 换而言之，应用程序起面向[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，默认情况下异步操作继承的值<xref:System.Globalization.CultureInfo.CurrentCulture%2A>和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>从中启动的线程的属性。 如果当前区域性或当前 UI 区域性不同于系统区域性，当前区域性跨线程边界的部署，并将成为当前正在执行异步操作的线程池线程的区域性。  
  
 下面的示例提供了简单的演示。 它使用<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性设置为目标[!INCLUDE[net_v46](~/includes/net-v46-md.md)]。 该示例定义了<xref:System.Func%601>委派， `formatDelegate`，返回一些数字格式化为货币值。 该示例将当前系统区域性更改为 French (France) 或法语 （法国） 已为当前区域性，英语 （美国）。 然后它：  
  
-   直接调用委托，以便使其在主应用线程上同步运行。  
  
-   创建线程池线程异步执行委托的任务。  
  
-   创建一个任务，该委托线程上同步执行主应用程序通过调用<xref:System.Threading.Tasks.Task.RunSynchronously%2A?displayProperty=nameWithType>方法。  
  
 如示例输出所示，如果当前区域性更改为法语 （法国） 任务以异步方式调用从该线程的当前区域性将成为该异步操作的当前区域性。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture1.vb#1)]  
  
 对于面向版本之前的.NET Framework 的应用， [!INCLUDE[net_v46](~/includes/net-v46-md.md)]，或对于不面向特定版本的.NET framework 的应用，调用线程的区域性不是任务的上下文的一部分。 相反，除非已显式定义，默认情况下的新线程的区域性是系统区域性。 以下示例中，这是与上一示例相同，不同之处在于它缺少<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性，阐释了这一点。 执行示例系统的系统区域性为英语 （美国），因为线程池线程异步执行的区域性是任务的 EN-US 而不是任务的 fr-fr。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture2.cs#2)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture2.vb#2)]  
  
 从.NET Framework 目标版本的应用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更高版本，但之前[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，可以使用<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性以确保调用线程的区域性用于在异步任务在线程池线程上执行。 下面的示例等同于上一示例中，只不过它使用<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性以确保该线程池线程具有与主应用程序线程相同的区域性。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture3.cs#3)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture3.vb#3)]  
  
 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A> 和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>是每个应用域的属性; 也就是说，它们建立默认区域性的所有线程都未显式都分配区域性特定的应用程序域中。 但是，对于面向应用[!INCLUDE[net_v46](~/includes/net-v46-md.md)]或更高版本，调用线程的区域性保持异步任务的上下文的一部分，即使跨应用程序域边界的部署任务。  
  
 下面的示例显示了调用线程的区域性保持基于任务的异步操作的当前区域性，即使跨应用程序域边界的部署执行该任务的方法。 它定义了一个类`DataRetriever`，使用单个方法`GetFormattedNumber`，介于 1 和 1000 格式化为货币值之间返回一个随机的双精度浮点数。 第一个任务运行，只需实例化`DataRetriever`实例并调用其`GetFormattedNumber`方法。 第二个任务报告其当前的应用程序域、 创建新的应用程序域、 实例化`DataRetriever`实例中新的应用程序域，并调用其`GetFormattedNumber`方法。 如示例输出所示，当前区域性保持在调用线程，第一个任务和第二个任务都相同主应用程序域和第二个应用程序域中执行时。  
  
 [!code-csharp[System.Globalization.CultureInfo.Class.Async#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture4.cs#4)]
 [!code-vb[System.Globalization.CultureInfo.Class.Async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture4.vb#4)]  
  
<a name="Serialization"></a>  
## <a name="cultureinfo-object-serialization"></a>CultureInfo 对象序列化  
 当<xref:System.Globalization.CultureInfo>序列化对象，只实际存储<xref:System.Globalization.CultureInfo.Name%2A>和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>。 它是仅在环境中成功反序列其中的<xref:System.Globalization.CultureInfo.Name%2A>具有相同的含义。 以下三个示例演示这为什么不是始终用例：  
  
- 如果<xref:System.Globalization.CultureInfo.CultureTypes%2A>属性值是<xref:System.Globalization.CultureTypes.InstalledWin32Cultures?displayProperty=nameWithType>，和特定版本的 Windows 操作系统中首次引入该区域性，如果不能在早期版本的 Windows 上反序列化。 例如，如果在 Windows 10 中引入了一个区域性，它不能反序列化在 Windows 8 上。  
  
-   如果<xref:System.Globalization.CultureInfo.CultureTypes%2A>值是<xref:System.Globalization.CultureTypes.UserCustomCulture?displayProperty=nameWithType>，和它反序列化计算机没有安装此用户自定义区域性，不能以反序列化。  
  
-   如果<xref:System.Globalization.CultureInfo.CultureTypes%2A>值是<xref:System.Globalization.CultureTypes.ReplacementCultures?displayProperty=nameWithType>，和它反序列化计算机不具有此替换区域性，其反序列化为相同的名称，但不是所有相同的特性。 例如，EN-US 是否在计算机 A，但不是在计算机 B 上, 一个替换区域性，如果<xref:System.Globalization.CultureInfo>对象引用此区域性是在计算机 A 上序列化和反序列化计算机 B 上则没有区域性的自定义特征传输。 已成功，但具有不同的含义，反序列化的区域性。  
  
<a name="CPanel"></a>   
## <a name="control-panel-overrides"></a>控件面板重写  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。 一般情况下，您的应用程序应遵循这些用户重写。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
<a name="AlternateSort"></a>   
## <a name="alternate-sort-orders"></a>替代排序顺序  
 一些文化可支持多个排序顺序。 例如:  
  
-   西班牙语 （西班牙） 区域性都有两种排序顺序： 默认国际排序顺序和传统的排序顺序。 当您实例化<xref:System.Globalization.CultureInfo>对象 ES-ES 区域性名称，则使用国际排序顺序。 当您实例化<xref:System.Globalization.CultureInfo>对象具有 es ES tradnl 区域性名称，则使用传统的排序顺序。  
  
-   ZH-CN （中文 （简体，中国）） 区域性支持两种排序顺序： 按发音 （默认值） 和按笔画数。 当您实例化<xref:System.Globalization.CultureInfo>对象 ZH-CN 区域性名称，则使用默认排序顺序。 当您实例化<xref:System.Globalization.CultureInfo>对象 0x00020804 的本地标识符的字符串按笔画数排序。  
  
 下表列出了支持替代排序顺序和标识符的默认和替代排序顺序的区域性。  
  
|区域性名称|culture|默认排序名称和标识符|替代排序名称和标识符|  
|------------------|-------------|--------------------------------------|----------------------------------------|  
|es-ES|西班牙语 （西班牙）|国际：0x00000C0A|传统：0x0000040A|  
|zh-TW|中文 （台湾）|笔画数：0x00000404|注音符号分类：0x00030404|  
|zh-CN|中文 （中华人民共和国）|发音：0x00000804|笔画数：0x00020804|  
|zh-HK|中文 （中国香港特别行政区）|笔画数：0x00000c04|笔画数：0x00020c04|  
|zh-SG|中文 （新加坡）|发音：0x00001004|笔画数：0x00021004|  
|zh-MO|中文 （澳门特别行政区）|发音：0x00001404|笔画数：0x00021404|  
|ja-JP|日语 （日本）|默认：0x00000411|Unicode：0x00010411|  
|ko-KR|朝鲜语 （韩国）|默认：0x00000412|朝鲜语 Xwansung-Unicode:0x00010412|  
|de-DE|德语 （德国）|字典中：0x00000407|电话簿排序 DIN:0x00010407|  
|hu-HU|匈牙利语 （匈牙利）|默认：0x0000040e|技术排序：0x0001040e|  
|ka-GE|格鲁吉亚语 （格鲁吉亚）|传统：0x00000437|现代排序：0x00010437|  
  
<a name="Windows"></a>   
## <a name="the-current-culture-and-uwp-apps"></a>当前区域性和 UWP 应用  
 在通用 Windows 平台 (UWP) 应用中，<xref:System.Globalization.CultureInfo.CurrentCulture%2A>和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性是读写的就像它们是.NET Framework 和.NET Core 应用程序中。 但是，UWP 应用识别单个区域性。 <xref:System.Globalization.CultureInfo.CurrentCulture%2A>并<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性映射到的第一个值[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)集合。  

在.NET Framework 和.NET Core 应用程序，当前区域性为每个线程设置，并<xref:System.Globalization.CultureInfo.CurrentCulture%2A>和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性反映了区域性和 UI 区域性的当前线程。 在 UWP 应用中，当前的区域性将映射到[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)回收，这是一种全局设置。 设置<xref:System.Globalization.CultureInfo.CurrentCulture%2A>或<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性发生更改的整个应用程序的区域性; 不能针对每个线程设置区域性。
  
## Examples  
 下面的示例演示如何创建<xref:System.Globalization.CultureInfo>西班牙语 （西班牙） 与国际排序，另一个对象<xref:System.Globalization.CultureInfo>使用传统排序的对象。  
  
 [!code-cpp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CPP/spanishspain.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CS/spanishspain.cs#1)]
 [!code-vb[System.Globalization.CultureInfo_esES#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/VB/spanishspain.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Globalization.CultureAndRegionInfoBuilder" />
    <altmember cref="T:System.Globalization.RegionInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Globalization.CultureInfo" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CultureInfo (int culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (culture As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CultureInfo(int culture);" />
      <MemberSignature Language="F#" Value="new System.Globalization.CultureInfo : int -&gt; System.Globalization.CultureInfo" Usage="new System.Globalization.CultureInfo culture" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">预定义的 <see cref="T:System.Globalization.CultureInfo" /> 标识符、现有 <see cref="T:System.Globalization.CultureInfo" /> 对象的 <see cref="P:System.Globalization.CultureInfo.LCID" /> 属性或仅 Windows 区域性标识符。</param>
        <summary>根据区域性标识符指定的区域性初始化 <see cref="T:System.Globalization.CultureInfo" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

中列出了 Windows 系统上可用的区域性的预定义的区域性标识符**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。

 在大多数情况下，`culture`参数映射到相应的国家/地区语言支持 (NLS) 区域设置标识符。 值`culture`参数将成为的值<xref:System.Globalization.CultureInfo.LCID%2A>的新属性<xref:System.Globalization.CultureInfo>。  
  
 我们建议您调用的区域设置名称构造函数<xref:System.Globalization.CultureInfo.%23ctor%2A?displayProperty=nameWithType>，因为区域设置名称要优于 Lcid。 对于自定义区域设置，区域设置名称是必需的。  
  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。 如果指定的区域性标识符与当前的 Windows 区域性的区域性标识符相匹配，此构造函数创建<xref:System.Globalization.CultureInfo>使用这些重写，其中包括的属性的用户设置<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和属性的<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>(例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>) 方法的结果和属性的值是不确定。  
  
 如果指定的区域性标识符与当前的 Windows 区域性标识符不匹配，此构造函数创建<xref:System.Globalization.CultureInfo>，使用的默认值为指定的区域性。  
  
 <xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性始终设置为`true`。  
  
 例如，假设阿拉伯语 （沙特阿拉伯） 系统的当前 Windows 区域性并且用户已为公历从回历更改日历。  
  
-   与`CultureInfo("0x0401")`（区域性名称 ar SA），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.GregorianCalendar>（这是用户设置） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("0x041E")`（区域性名称 TH-TH），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
 对于使用欧元的区域性，情况下，.NET Framework 和 Windows XP 设置的默认货币为欧元。 但是，较旧版本的 Windows 不这样做。 因此，如果将较旧版本的 Windows 用户未更改的货币设置通过控制面板的区域和语言选项部分，货币可能不正确。 若要使用的货币和.NET Framework 默认设置，该应用程序应使用<xref:System.Globalization.CultureInfo>构造函数重载接受`useUserOverride`参数并将其设置为`false`。  
  
> [!NOTE]
>  有关向后兼容性，构造使用的区域性`culture`0x0004 或 0x7c04 参数将具有<xref:System.Globalization.CultureInfo.Name%2A>ZH-CHS 或 ZH-CHT 属性分别。 应改为想要构造使用-Zh-hans 或此不同的当前标准区域性名称的区域性，除非已使用旧名称的原因。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="culture" /> 小于零。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="culture" /> 不是有效的区域性标识符。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="culture" />不是有效的区域性标识符。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此构造函数引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="culture" />从操作系统; 如果操作系统不支持该区域性方法会抛出<see cref="T:System.Globalization.CultureNotFoundException" />异常。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.LCID" />
        <altmember cref="P:System.Globalization.CultureInfo.UseUserOverride" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CultureInfo (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CultureInfo(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Globalization.CultureInfo : string -&gt; System.Globalization.CultureInfo" Usage="new System.Globalization.CultureInfo name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">预定义的 <see cref="T:System.Globalization.CultureInfo" /> 名称、现有 <see cref="T:System.Globalization.CultureInfo" /> 的 <see cref="P:System.Globalization.CultureInfo.Name" /> 或仅 Windows 区域性名称。 <paramref name="name" /> 不区分大小写。</param>
        <summary>根据由名称指定的区域性初始化 <see cref="T:System.Globalization.CultureInfo" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

在 Windows 系统上的预定义的区域性名称的列表，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。  
  
 如果`name`是<xref:System.String.Empty?displayProperty=nameWithType>，在构造函数创建固定区域性的一个实例; 这等效于检索的值<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性。  
  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。 如果与关联的区域性标识符`name`匹配此构造函数的当前 Windows 区域性的区域性标识符创建<xref:System.Globalization.CultureInfo>对象，它使用这些重写值，其中包括用户设置的属性的<xref:System.Globalization.DateTimeFormatInfo>返回的实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和属性的<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 如果与关联的区域性标识符`name`不的匹配此构造函数的当前 Windows 区域性的区域性标识符创建<xref:System.Globalization.CultureInfo>使用的默认值为指定的区域性的对象。  
  
 <xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性始终设置为`true`。  
  
 例如，假设阿拉伯语 （沙特阿拉伯） 是 Windows 的当前区域性和用户可更改回历为公历日历。  
  
-   与`CultureInfo("ar-SA")`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.GregorianCalendar>（这是用户设置） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("th-TH")`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
 <xref:System.Globalization.CultureInfo.LCID%2A>属性的新<xref:System.Globalization.CultureInfo>设置为与指定名称关联的区域性标识符。  
  
 对于使用欧元的区域性，情况下，.NET Framework 和 Windows XP 设置的默认货币为欧元。 但是，较旧版本的 Windows 不这样做。 因此，如果将较旧版本的 Windows 用户未更改的货币设置通过控制面板的区域和语言选项部分，货币可能不正确。 若要使用的货币和.NET Framework 默认设置，该应用程序应使用<xref:System.Globalization.CultureInfo>构造函数重载接受`useUserOverride`参数并将其设置为`false`。  
  
   
  
## Examples  
 下面的示例检索当前区域性。 如果它不是法语 （法国） 区域性，则会调用<xref:System.Globalization.CultureInfo.%23ctor%28System.String%29>构造函数实例化<xref:System.Globalization.CultureInfo>表示法语 （法国） 区域性，并使其成为当前线程区域性的对象。 否则，它实例化<xref:System.Globalization.CultureInfo>表示法语 （卢森堡） 区域性，并使其当前区域性的对象。  
  
 [!code-csharp[System.Globalization.CultureInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Globalization.CultureInfo/cs/Change1.cs#3)]
 [!code-vb[System.Globalization.CultureInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Globalization.CultureInfo/vb/Change1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 null。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 不是有效的区域性名称。 有关详细信息，请参阅“对调用方的说明”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />不是有效的区域性名称。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此构造函数引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="name" />从操作系统; 如果操作系统不支持该区域性，并且<paramref name="name" />不是补充或替换的区域性，该方法将引发名称<see cref="T:System.Globalization.CultureNotFoundException" />异常。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.LCID" />
        <altmember cref="P:System.Globalization.CultureInfo.UseUserOverride" />
        <altmember cref="M:System.Globalization.CultureInfo.CreateSpecificCulture(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CultureInfo (int culture, bool useUserOverride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 culture, bool useUserOverride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.#ctor(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (culture As Integer, useUserOverride As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CultureInfo(int culture, bool useUserOverride);" />
      <MemberSignature Language="F#" Value="new System.Globalization.CultureInfo : int * bool -&gt; System.Globalization.CultureInfo" Usage="new System.Globalization.CultureInfo (culture, useUserOverride)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="useUserOverride" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">预定义的 <see cref="T:System.Globalization.CultureInfo" /> 标识符、现有 <see cref="T:System.Globalization.CultureInfo" /> 对象的 <see cref="P:System.Globalization.CultureInfo.LCID" /> 属性或仅 Windows 区域性标识符。</param>
        <param name="useUserOverride">一个布尔值，它指示是使用用户选定的区域性设置 (<see langword="true" />)，还是使用默认区域性设置 (<see langword="false" />)。</param>
        <summary>基于区域性标识符指定的区域性并基于布尔值（指定是否使用系统中用户选定的区域性设置）来初始化 <see cref="T:System.Globalization.CultureInfo" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

中列出了在 Windows 系统上可用的预定义的区域性标识符**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。

 在大多数情况下，`culture`参数映射到相应的国家/地区语言支持 (NLS) 区域设置标识符。 值`culture`参数将成为的值<xref:System.Globalization.CultureInfo.LCID%2A>的新属性<xref:System.Globalization.CultureInfo>。  
  
 我们建议您调用的区域设置名称构造函数<xref:System.Globalization.CultureInfo.%23ctor%2A?displayProperty=nameWithType>，因为区域设置名称要优于 Lcid。 对于自定义区域设置，区域设置名称是必需的。  
  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 应用程序通常应不禁止用户重写。 请注意，不允许重写不本身保证数据稳定性;请参阅博客文章[区域性数据不应视为稳定 （除外固定）](https://go.microsoft.com/fwlink/?LinkId=156850)。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性设置为`true`并指定的区域性标识符匹配的当前 Windows 区域性标识符，此构造函数创建<xref:System.Globalization.CultureInfo>，使用这些重写值，包括以下属性的用户设置<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和属性的<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 否则，此构造函数创建<xref:System.Globalization.CultureInfo>，使用的默认值为指定的区域性。  
  
 值`useUserOverride`参数将成为的值<xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性。  
  
 例如，假设阿拉伯语 （沙特阿拉伯） 是 Windows 的当前区域性和用户已在日历回历从更改为公历。  
  
-   与`CultureInfo("0x0401", true)`（区域性名称 ar SA），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.GregorianCalendar>（这是用户设置） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("0x0401", false)`（区域性名称 ar SA），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.HijriCalendar>（这是 ar SA 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`false`。  
  
-   与`CultureInfo("0x041E", true)`（区域性名称 TH-TH），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("0x041E", false)`（区域性名称 TH-TH），<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`false`。  
  
 对于使用欧元的区域性，情况下，.NET Framework 和 Windows XP 设置的默认货币为欧元。 但是，较旧版本的 Windows 不这样做。 因此，如果将较旧版本的 Windows 用户未更改的货币设置通过控制面板的区域和语言选项部分，货币可能不正确。 若要使用的货币和.NET Framework 默认设置，该应用程序应设置`useUserOverride`参数`false`。  
  
> [!NOTE]
>  有关向后兼容性，构造使用的区域性`culture`0x0004 或 0x7c04 参数将具有<xref:System.Globalization.CultureInfo.Name%2A>ZH-CHS 或 ZH-CHT 属性分别。 应改为想要构造使用-Zh-hans 或此不同的当前标准区域性名称的区域性，除非已使用旧名称的原因。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="culture" /> 小于零。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="culture" /> 不是有效的区域性标识符。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="culture" />不是有效的区域性标识符。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此构造函数引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="culture" />从操作系统; 如果操作系统不支持该区域性方法会抛出<see cref="T:System.Globalization.CultureNotFoundException" />异常。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.LCID" />
        <altmember cref="P:System.Globalization.CultureInfo.UseUserOverride" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CultureInfo (string name, bool useUserOverride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool useUserOverride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, useUserOverride As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CultureInfo(System::String ^ name, bool useUserOverride);" />
      <MemberSignature Language="F#" Value="new System.Globalization.CultureInfo : string * bool -&gt; System.Globalization.CultureInfo" Usage="new System.Globalization.CultureInfo (name, useUserOverride)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="useUserOverride" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">预定义的 <see cref="T:System.Globalization.CultureInfo" /> 名称、现有 <see cref="T:System.Globalization.CultureInfo" /> 的 <see cref="P:System.Globalization.CultureInfo.Name" /> 或仅 Windows 区域性名称。 <paramref name="name" /> 不区分大小写。</param>
        <param name="useUserOverride">一个布尔值，它指示是使用用户选定的区域性设置 (<see langword="true" />)，还是使用默认区域性设置 (<see langword="false" />)。</param>
        <summary>基于名称指定的区域性并基于布尔值（指定是否使用系统中用户选定的区域性设置）来初始化 <see cref="T:System.Globalization.CultureInfo" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

预定义的区域性名称的列表，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。  
  
如果`name`是<xref:System.String.Empty?displayProperty=nameWithType>，在构造函数创建固定区域性的一个实例; 这等效于检索的值<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性。  
  
 用户可以选择重写一些与通过控制面板的区域和语言选项部分的当前 Windows 区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 应用程序通常应不禁止用户重写。 请注意，不允许重写不本身保证数据稳定性;请参阅博客文章[区域性数据不应视为稳定 （除外固定）](https://go.microsoft.com/fwlink/?LinkId=156850)。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性设置为`true`和与指定的区域性名称关联的区域性标识符匹配的当前 Windows 区域性的区域性标识符，此构造函数创建<xref:System.Globalization.CultureInfo>，它使用这些替代其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和属性的<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 否则，此构造函数创建<xref:System.Globalization.CultureInfo>，使用的默认值为指定的区域性。  
  
 值`useUserOverride`参数将成为的值<xref:System.Globalization.CultureInfo.UseUserOverride%2A>属性。  
  
 例如，假设阿拉伯语 （沙特阿拉伯） 是 Windows 的当前区域性和用户可更改回历为公历日历。  
  
-   与`CultureInfo("ar-SA", true)`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.GregorianCalendar>（这是用户设置） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("ar-SA", false)`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.HijriCalendar>（这是 ar SA 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`false`。  
  
-   与`CultureInfo("th-TH", true)`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`true`。  
  
-   与`CultureInfo("th-TH", false)`，<xref:System.Globalization.CultureInfo.Calendar%2A>设置为<xref:System.Globalization.ThaiBuddhistCalendar>（这是 TH-TH 的默认日历） 和<xref:System.Globalization.CultureInfo.UseUserOverride%2A>设置为`false`。  
  
 <xref:System.Globalization.CultureInfo.LCID%2A>属性的新<xref:System.Globalization.CultureInfo>设置为与指定名称关联的区域性标识符。  
  
 对于使用欧元的区域性，情况下，.NET Framework 和 Windows XP 设置的默认货币为欧元。 但是，较旧版本的 Windows 不这样做。 因此，如果将较旧版本的 Windows 用户未更改的货币设置通过控制面板的区域和语言选项部分，货币可能不正确。 若要使用的货币和.NET Framework 默认设置，该应用程序应设置`useUserOverride`参数`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 null。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 不是有效的区域性名称。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />不是有效的区域性名称。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此构造函数引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="name" />从操作系统; 如果操作系统不支持该区域性，并且<paramref name="name" />不是补充或替换的区域性，该方法将引发名称<see cref="T:System.Globalization.CultureNotFoundException" />异常。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.LCID" />
        <altmember cref="P:System.Globalization.CultureInfo.UseUserOverride" />
        <altmember cref="M:System.Globalization.CultureInfo.CreateSpecificCulture(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Calendar">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.Calendar Calendar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.Calendar Calendar" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.Calendar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Calendar As Calendar" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::Calendar ^ Calendar { System::Globalization::Calendar ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Calendar : System.Globalization.Calendar" Usage="System.Globalization.CultureInfo.Calendar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.Calendar</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取区域性使用的默认日历。</summary>
        <value>表示区域性使用的默认日历的 <see cref="T:System.Globalization.Calendar" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 因此，如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`，此属性的值可能不同于使用由区域性的默认日历。  
  
 你的应用程序更改当前使用的日历<xref:System.Globalization.CultureInfo>通过设置<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A>的属性<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>，这是实例<xref:System.Globalization.DateTimeFormatInfo>类。 新的日历必须是一个中列出的日历<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>。 <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> 此外包括其他属性的自定义日期和时间格式设置与该<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.Calendar" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedData">
      <MemberSignature Language="C#" Value="public void ClearCachedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearCachedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.ClearCachedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearCachedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearCachedData();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedData : unit -&gt; unit" Usage="cultureInfo.ClearCachedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刷新缓存的区域性相关信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 信息，例如默认区域性和格式模式，将缓存第一次请求。 信息可以更改的生命周期内<xref:System.AppDomain>，例如，当用户修改控制面板的区域和语言选项部分。 但是，<xref:System.Globalization.CultureInfo>类不会自动在系统设置中检测更改。  
  
 <xref:System.Globalization.CultureInfo.ClearCachedData%2A>方法将清除的缓存<xref:System.Globalization.CultureInfo>创建的对象<xref:System.Globalization.CultureInfo.GetCultureInfo%2A>，并刷新中的信息<xref:System.Globalization.CultureInfo.CurrentCulture%2A>， <xref:System.Globalization.CultureInfo.CurrentUICulture%2A>，并<xref:System.Globalization.RegionInfo.CurrentRegion%2A>基于当前系统设置的属性。  
  
 <xref:System.Globalization.CultureInfo.ClearCachedData%2A>方法不会刷新中的信息<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>现有线程的属性。 但是，未来的线程将使用任何新<xref:System.Globalization.CultureInfo>属性值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="cultureInfo.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Globalization.CultureInfo" /> 的副本。</summary>
        <returns>当前 <see cref="T:System.Globalization.CultureInfo" /> 的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆是可写即使原始<xref:System.Globalization.CultureInfo>是只读的。 因此，可以修改克隆的属性。  
  
 一个对象的浅表副本是仅对象的副本。 如果对象包含对其他对象的引用，浅表副本不创建所引用对象的副本。 它而是指原始对象。 与此相反，对象的深层副本创建的对象的副本和所有内容直接或间接引用该对象的副本。  
  
 <xref:System.Globalization.CultureInfo.Clone%2A>方法创建一个增强的浅表副本。 返回的对象<xref:System.Globalization.CultureInfo.NumberFormat%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.TextInfo%2A>，和<xref:System.Globalization.CultureInfo.Calendar%2A>属性也会被复制。 因此，克隆<xref:System.Globalization.CultureInfo>对象可以修改其复制的属性，而不会影响原始<xref:System.Globalization.CultureInfo>对象。  
  
   
  
## Examples  
 下面的代码示例显示了 CultureInfo.Clone 还克隆<xref:System.Globalization.DateTimeFormatInfo>并<xref:System.Globalization.NumberFormatInfo>与关联的实例<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CPP/yslin_cultureinfo_clone.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CS/yslin_cultureinfo_clone.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/VB/yslin_cultureinfo_clone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CompareInfo">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CompareInfo CompareInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CompareInfo CompareInfo" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.CompareInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CompareInfo As CompareInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CompareInfo ^ CompareInfo { System::Globalization::CompareInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompareInfo : System.Globalization.CompareInfo" Usage="System.Globalization.CultureInfo.CompareInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为区域性定义如何比较字符串的 <see cref="T:System.Globalization.CompareInfo" />。</summary>
        <value>为区域性定义如何比较字符串的 <see cref="T:System.Globalization.CompareInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo.CompareInfo%2A>属性返回<xref:System.Globalization.CompareInfo>提供区分区域性的排序和字符串比较操作中使用的区域性特定信息的对象。  
  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Globalization.CultureInfo>西班牙语 （西班牙） 与国际排序，另一个<xref:System.Globalization.CultureInfo>使用传统排序。  
  
 [!code-cpp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CPP/spanishspain.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CS/spanishspain.cs#1)]
 [!code-vb[System.Globalization.CultureInfo_esES#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/VB/spanishspain.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CompareInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateSpecificCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CreateSpecificCulture (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo CreateSpecificCulture(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.CreateSpecificCulture(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSpecificCulture (name As String) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ CreateSpecificCulture(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CreateSpecificCulture : string -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.CreateSpecificCulture name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">预定义的 <see cref="T:System.Globalization.CultureInfo" /> 名称或现有 <see cref="T:System.Globalization.CultureInfo" /> 的对象。 <paramref name="name" /> 不区分大小写。</param>
        <summary>创建表示与指定名称关联的特定区域性的 <see cref="T:System.Globalization.CultureInfo" />。</summary>
        <returns>一个表示以下内容的 <see cref="T:System.Globalization.CultureInfo" /> 对象： 
固定的区域性，如果 <paramref name="name" /> 是空字符串 ("")。  
  
- 或 - 
与 <paramref name="name" /> 关联的特定区域性，如果 <paramref name="name" /> 是非特定区域性。  
  
- 或 - 
由 <paramref name="name" /> 指定的区域性，如果 <paramref name="name" /> 已经是特定区域性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>方法包装对的调用<xref:System.Globalization.CultureInfo.%23ctor%28System.String%29>构造函数。  
  
> [!NOTE]
> 在 Windows 系统上的预定义的区域性名称的列表，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。  
  
 区域性分为三个集合： 固定区域性、 非特定区域性和特定区域性。 有关详细信息，请参阅的说明<xref:System.Globalization.CultureInfo>类。  
  
 如果此方法返回的特定区域性的区域性标识符与当前的 Windows 区域性的区域性标识符相匹配，则此方法创建<xref:System.Globalization.CultureInfo>对象，它使用 Windows 区域性重写。 重写中包括的属性的用户设置<xref:System.Globalization.DateTimeFormatInfo>返回的对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和<xref:System.Globalization.NumberFormatInfo>返回的对象<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 若要实例化<xref:System.Globalization.CultureInfo>对象，默认值的区域性设置而不是用户重写时，调用<xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29>构造函数，值为`false`为`useUserOverride`参数。  
  
 尽管<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>方法名称包括术语"特定"，请记住区域性数据可以更改之间的版本中，或由于自定义区域性，或由于用户重写。 有关将数据保存使用固定区域性或二进制或固定的窗体。  
  
   
  
## Examples  
 下面的示例检索的数组<xref:System.Globalization.CultureInfo>对象表示从非特定区域性<xref:System.Globalization.CultureInfo.GetCultures%2A>方法并对数组进行排序。 当它循环访问数组中的元素时，它将传递到每个非特定区域性的名称<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>方法，并显示该方法所返回的特定区域性的名称。  
  
> [!NOTE]
>  该示例使用 ZH-CHS 和 ZH-CHT 区域性名称。 但是，面向 Windows Vista 和更高版本应该使用-Zh-hans 而不是 ZH-CHS 和 Zh-hant 而不是 ZH-CHT 的应用程序。 -Zh-hans 和 Zh-hant 表示当前的标准，除非必须使用较旧名称的原因，否则应使用。  
>   
>  另请注意，示例的结果可能不同的输入中文 （繁体） 是非特定区域性 （zh、 ZH-CHT 或 Zh-hant） 将在其中返回 ZH-TW 的中国台湾 Windows 安装上。  
  
 [!code-csharp[System.Globalization.CultureInfo.CreateSpecificCulture2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CreateSpecificCulture2/CS/createspecificculture2.cs#2)]
 [!code-vb[System.Globalization.CultureInfo.CreateSpecificCulture2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CreateSpecificCulture2/VB/createspecificculture2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 不是有效的区域性名称。  
  
- 或 - 
<paramref name="name" /> 指定的区域性没有特定的区域性与之关联。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="name" /> 为 null。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />不是有效的区域性名称。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此方法将引发<see cref="T:System.Globalization.CultureNotFoundException" />。</para></block>
        <altmember cref="Overload:System.Globalization.CultureInfo.#ctor" />
        <altmember cref="P:System.Globalization.CultureInfo.Parent" />
      </Docs>
    </Member>
    <Member MemberName="CultureTypes">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureTypes CultureTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Globalization.CultureTypes CultureTypes" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.CultureTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CultureTypes As CultureTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureTypes CultureTypes { System::Globalization::CultureTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.CultureTypes : System.Globalization.CultureTypes" Usage="System.Globalization.CultureInfo.CultureTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于当前 <see cref="T:System.Globalization.CultureInfo" /> 对象的区域性类型。</summary>
        <value>一个或多个 <see cref="T:System.Globalization.CultureTypes" /> 值的按位组合。 没有默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.Globalization.CultureTypes>枚举和<xref:System.Globalization.CultureInfo.CultureTypes%2A>属性。  
  
 [!code-csharp[system.globalization.cultureTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureTypes/cs/ct.cs#1)]
 [!code-vb[system.globalization.cultureTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureTypes/vb/ct.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureTypes" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Globalization.CultureInfo.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示当前线程使用的区域性的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</summary>
        <value>表示当前线程使用的区域性的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>此属性返回的对象及其关联的对象确定的日期的默认格式、 时间、 数字、 货币值，排序顺序的文本、 大小写约定，和的字符串比较。  
  
 当前的区域性是执行线程的属性。 检索的值<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性相当于多个高性能的检索<xref:System.Globalization.CultureInfo>对象返回的`Thread.CurrentThread.CurrentCulture`属性。
  
> [!NOTE]
>  在.NET Framework 4.5.2 及更早版本中，<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性是只读的; 也就是说，可以检索属性值，但不能将其设置。 若要更改当前区域性，将分配<xref:System.Globalization.CultureInfo>对象，表示的新区域性`Thread.CurrentThread.CurrentCulture`属性。 从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，则<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性为读写; 可以同时设置和检索属性的值。 如果属性值设置<xref:System.Globalization.CultureInfo>对象，表示新区域性，则`Thread.CurrentThread.CurrentCulture`属性也会更改。  
  
 本节内容：  
  
 [如何确定线程的区域性](#ThreadCulture)   
 [获取当前区域性](#Getting)   
 [将 CurrentCulture 属性显式设置](#ExplicitSetting)   
 [当前区域性和用户重写](#Overrides)   
 [区域性和 Windows 应用](#WindowsAndCurr)  
  
<a name="ThreadCulture"></a>   
## <a name="how-a-threads-culture-is-determined"></a>如何确定线程的区域性  
 在线程启动时，其区域性是最初确定的如下所示：  
  
-   通过检索由指定的区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>线程执行所在，如果属性值不是在应用程序域的属性`null`。  
  
-   如果线程执行基于任务的异步操作和应用面向一个线程池线程[!INCLUDE[net_v46](~/includes/net-v46-md.md)]或更高版本的.NET Framework 中，其区域性由调用线程的区域性。  下面的示例将当前区域性更改为葡萄牙语 （巴西），并启动六项任务，其中每个显示其线程 ID、 其任务 ID 和其当前区域性。 每个任务 （和线程） 已继承调用线程的区域性。  
  
     [!code-csharp[System.Globalization.CultureInfo.CurrentCulture#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/cs/Async1.cs#14)]
     [!code-vb[System.Globalization.CultureInfo.CurrentCulture#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/vb/Async1.vb#14)]  
  
     有关详细信息，请参阅中的"区域性和基于任务的异步操作"部分<xref:System.Globalization.CultureInfo>主题。  
  
-   通过调用 Windows`GetUserDefaultLocaleName`函数。  
  
 请注意，如果设置不同于安装了系统的区域性或用户的首选的区域性的特定区域性并启动应用程序的多个线程，这些线程的当前区域性的区域性，返回的`GetUserDefaultLocaleName`函数，除非您为其分配区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>线程执行所在的应用程序域中的属性。  
  
 有关如何确定线程的区域性的详细信息，请参阅中的"区域性和线程"部分<xref:System.Globalization.CultureInfo>参考页。  
  
<a name="Getting"></a>   
## <a name="getting-the-current-culture"></a>获取当前区域性  
 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性是每个线程设置; 这就是，每个线程可以具有其自己的区域性。 检索的值来获取当前线程的区域性<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性，如下面的示例说明了。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/cs/Get1.cs#5)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/vb/Get1.vb#5)]  
  
 此外可以检索的值从当前线程的区域性<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>属性。  
  
<a name="ExplicitSetting"></a>   
## <a name="explicitly-setting-the-currentculture-property"></a>将 CurrentCulture 属性显式设置  
 着手[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，以更改由现有线程的区域性设置<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性改为新的区域性。 线程跨越应用程序域边界时，如果显式更改这种方式，更改线程的区域性仍然存在。 下面的示例将当前的线程区域性更改为荷兰语 （荷兰）。 它还显示，如果当前线程跨越应用程序域边界，其当前区域性保持更改。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/cs/changeculture11.cs#11)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/vb/changeculture11.vb#11)]  
  
> [!NOTE]
>  通过使用更改区域性<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性需要<xref:System.Security.Permissions.SecurityPermission>权限<xref:System.Security.Permissions.SecurityPermissionFlag.ControlThread>值设置。 由于与线程关联的安全状态，对线程进行操作很危险。 因此，仅对可信的代码，并且仅在必要的时候，则应授予此权限。 不能更改线程的区域性不完全受信任的代码中。  
  
 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，可以显式更改当前线程区域性为特定区域性 （如法语 （加拿大）） 或非特定区域性 （如法语）。 当<xref:System.Globalization.CultureInfo>对象表示非特定区域性，值<xref:System.Globalization.CultureInfo>属性，如<xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>反映与之关联的特定区域性非特定区域性。 例如，英语的非特定区域性的主要区域性为英语 （美国）;正使用德语区域性的主要区域性是德语 （德国）。 下面的示例演示在格式设置时的当前区域性设置为特定区域性、 法语 （加拿大） 和一个非特定区域性差异法语。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/cs/specific12.cs#12)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/vb/specific12.vb#12)]  
  
 此外可以使用<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性连同<xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>属性来设置<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性的 ASP.NET 应用程序向用户首选区域性，如以下示例所示。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/cs/aspculture13.cs#13)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentculture/vb/aspculture13.vb#13)]  
  
<a name="Overrides"></a>   
## <a name="the-current-culture-and-user-overrides"></a>当前区域性和用户重写  
 Windows 允许用户重写的标准属性值<xref:System.Globalization.CultureInfo>对象，并使用其关联的对象**区域和语言选项**控制面板中。 <xref:System.Globalization.CultureInfo>返回对象<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性会反映出这些用户将在以下情况下重写：  
  
-   如果当前线程区域性设置隐式的 Windows`GetUserDefaultLocaleName`函数。  
  
-   如果当前线程区域性定义的<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性对应于当前的 Windows 系统区域。  
  
-   如果当前线程区域性显式设置返回区域性<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>方法和区域性对应于当前的 Windows 系统区域。  
  
-   如果当前线程区域性显式设置为通过实例化一个区域性<xref:System.Globalization.CultureInfo.%23ctor%28System.String%29>构造函数和区域性对应于当前的 Windows 系统区域。  
  
 在某些情况下，特别是对于服务器应用程序，将当前区域性设置为<xref:System.Globalization.CultureInfo>反映用户重写的对象可能不需要。 相反，可以将当前线程区域性设置为<xref:System.Globalization.CultureInfo>对象不会反映用户重写以下方面：  
  
-   通过调用<xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29>构造函数，值为`false`为`useUserOverride`参数。  
  
-   通过调用<xref:System.Globalization.CultureInfo.GetCultureInfo%2A>方法，它返回只读缓存，<xref:System.Globalization.CultureInfo>对象。  
  
<a name="WindowsAndCurr"></a>   
## <a name="the-current-culture-and-uwp-apps"></a>当前区域性和 UWP 应用  
 在通用 Windows 平台 (UWP) 应用中，<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性是读写的就像它是.NET Framework 和.NET Core 应用程序中; 您可以使用它来获取并设置当前区域性。 但是，UWP 应用不区分当前区域性和当前 UI 区域性。 <xref:System.Globalization.CultureInfo.CurrentCulture%2A>并<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性映射到的第一个值[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)集合。  

在.NET Framework 和.NET Core 应用程序，当前区域性为每个线程设置，和<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性反映当前线程的区域性。 在 UWP 应用中，当前的区域性将映射到[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)属性，它是一种全局设置。 设置<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性发生更改的整个应用程序的区域性; 不能针对每个线程设置区域性。
  
## Examples  
 下面的示例演示如何更改<xref:System.Globalization.CultureInfo.CurrentCulture%2A>和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>当前线程。  
  
 [!code-cpp[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/CPP/currentculture.cpp#11)]
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/CS/currentculture.cs#11)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/VB/currentculture.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于设置当前区域性。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentCulture" />
        <altmember cref="P:System.Threading.Thread.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InstalledUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.Parent" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
        <altmember cref="T:System.Security.Permissions.SecurityPermissionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Globalization.CultureInfo.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Globalization.CultureInfo" /> 对象，该对象表示资源管理器在运行时查找区域性特定资源时所用的当前用户接口区域性。</summary>
        <value>资源管理器用于在运行时查找查找区域性特定资源的区域性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前 UI 区域性为每个线程属性。 也就是说，每个线程都具有其自己当前 UI 区域性。 此属性等效于检索，或开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，并设置<xref:System.Globalization.CultureInfo>分配给对象`System.Threading.Thread.CurrentThread.CurrentUICulture`属性。 在线程启动时，其 UI 区域性是最初确定的如下所示：  
  
-   通过检索由指定的区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>线程执行所在，如果属性值不是在应用程序域的属性`null`。  
  
-   如果线程执行基于任务的异步操作和应用面向一个线程池线程[!INCLUDE[net_v46](~/includes/net-v46-md.md)]或更高版本的.NET Framework 中，其 UI 区域性由调用线程的 UI 区域性。  下面的示例将当前 UI 区域性更改为葡萄牙语 （巴西），并启动六项任务，其中每个显示其线程 ID、 其任务 ID 和其当前 UI 区域性。 每个任务 （和线程） 已继承调用线程的 UI 区域性。  
  
     [!code-csharp[System.Globalization.CultureInfo.CurrentUICulture#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/cs/Async1.cs#14)]
     [!code-vb[System.Globalization.CultureInfo.CurrentUICulture#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/vb/Async1.vb#14)]  
  
     有关详细信息，请参阅中的"区域性和基于任务的异步操作"部分<xref:System.Globalization.CultureInfo>主题。  
  
-   通过调用 Windows`GetUserDefaultUILanguage`函数。  
  
> [!NOTE]
>  在中[!INCLUDE[Compact](~/includes/compact-md.md)]，则<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性是只读的。 当前 UI 区域性由系统的区域设置，并且不能以编程方式更改。  
  
 从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，若要更改的用户界面区域性由一个线程，设置<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>属性改为新的区域性。 线程跨越应用程序域边界时，如果您显式更改线程的 UI 区域性中更改这种方式仍然存在。  
  
> [!NOTE]
>  在.NET Framework 4.5.2 及更早版本中，<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性是只读的; 也就是说，可以检索属性值，但不能将其设置。 若要更改当前 UI 区域性，将分配<xref:System.Globalization.CultureInfo>对象，表示到新的 UI 区域性`Thread.CurrentThread.CurrentUICulture`属性。 从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，则<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性为读写; 可以同时设置和检索属性的值。 如果属性值设置<xref:System.Globalization.CultureInfo>对象，表示新区域性，则`Thread.CurrentThread.CurrentCulture`属性也会更改。  
  
 本节内容：  
  
 [获取当前 UI 区域性](#Getting)   
 [显式设置当前 UI 区域性](#Explicit)   
 [隐式设置当前 UI 区域性](#Implicit)   
 [安全注意事项](#Security)   
 [当前 UI 区域性和 Windows 应用程序](#WindowsAndCurrUI)  
  
<a name="Getting"></a>   
## <a name="getting-the-current-ui-culture"></a>获取当前 UI 区域性  
 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性是每个线程设置; 这就是，每个线程可以具有其自己的 UI 区域性。 检索的值来获取当前线程的 UI 区域性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性，如下面的示例说明了。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentUICulture#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/cs/Get1.cs#5)]
 [!code-vb[System.Globalization.CultureInfo.CurrentUICulture#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/vb/Get1.vb#5)]  
  
 此外可以检索的值从当前线程的 UI 区域性<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>属性。  
  
<a name="Explicit"></a>   
## <a name="explicitly-setting-the-current-ui-culture"></a>显式设置当前 UI 区域性  
 从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，可以通过将分配更改当前 UI 区域性<xref:System.Globalization.CultureInfo>对象，表示的新区域性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性。 可以设置当前 UI 区域性，为任一特定区域性设置 （如 EN-US 或 DE-DE） 或非特定区域性 （例如 en 或 de）。 下面的示例将当前 UI 区域性设置为 FR-FR 或法语 （法国）。  
  
 [!code-csharp[System.Globalization.CultureInfo.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/cs/currentuiculture1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.currentuiculture/vb/currentuiculture1.vb#1)]  
  
 在多线程应用程序中，您可以显式设置的任何线程 UI 区域性通过将分配<xref:System.Globalization.CultureInfo>对象表示线程的区域性<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>属性。 如果线程想要设置其区域性是当前线程，则可以分配到的新区域性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性。 如果显式设置线程的 UI 区域性，线程保留相同的区域性，即使它跨越应用程序域边界，并在另一个应用程序域中执行代码。  
  
<a name="Implicit"></a>   
## <a name="implicitly-setting-the-current-ui-culture"></a>隐式设置当前 UI 区域性  
 当一个线程，包括主应用程序线程，第一个，默认情况下创建其当前 UI 区域性设置，如下所示：  
  
-   通过使用由定义的区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性的当前应用程序域的属性值不是如果`null`。  
  
-   通过使用系统的默认区域性。 在系统上使用 Windows 操作系统的公共语言运行时调用 Windows`GetUserDefaultUILanguage`函数可设置当前 UI 区域性。 `GetUserDefaultUILanguage` 返回由用户设置的默认 UI 区域性。 如果用户未设置默认 UI 语言，则返回最初在系统上安装的区域性。  
  
 如果线程跨越应用程序边界，并在另一个应用程序域中执行代码，其区域性确定的新创建的线程相同的方式。  
  
 请注意，如果设置不同于安装了系统的 UI 区域性特定的 UI 区域性或用户的首选的 UI 区域性，并启动应用程序的多个线程，这些线程的当前 UI 区域性返回的区域性`GetUserDefaultUILanguage`函数，除非您为其分配区域性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>线程执行所在的应用程序域中的属性。  
  
<a name="Security"></a>   
## <a name="security-considerations"></a>安全注意事项  
 更改当前线程的区域性，需要<xref:System.Security.Permissions.SecurityPermission>权限<xref:System.Security.Permissions.SecurityPermissionFlag.ControlThread>值设置。  
  
> [!CAUTION]
>  由于与线程关联的安全状态，对线程进行操作很危险。 因此，仅对可信的代码，并且仅在必要的时候，则应授予此权限。 不能更改线程的区域性不完全受信任的代码中。  
  
<a name="WindowsAndCurrUI"></a>   
## <a name="the-current-ui-culture-and-uwp-apps"></a>当前 UI 区域性和 UWP 应用  
 
在通用 Windows 平台 (UWP) 应用中，<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性是读写的就像它是.NET Framework 和.NET Core 应用程序中; 您可以使用它来获取并设置当前区域性。 但是，UWP 应用不区分当前区域性和当前 UI 区域性。 <xref:System.Globalization.CultureInfo.CurrentCulture%2A>并<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性映射到的第一个值[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)集合。

在.NET Framework 和.NET Core 应用程序，当前 UI 区域性为每个线程设置，和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性反映当前线程的 UI 区域性。 在 UWP 应用中，当前的区域性将映射到[Windows.ApplicationModel.Resources.Core.ResourceManager.DefaultContext.Languages](https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext#properties_)属性，它是一种全局设置。 设置<xref:System.Globalization.CultureInfo.CurrentCulture%2A>属性发生更改的整个应用程序的区域性; 不能针对每个线程设置区域性。    
  
## Examples  
 下面的代码示例演示如何更改<xref:System.Globalization.CultureInfo.CurrentCulture%2A>和<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>当前线程。  
  
 [!code-cpp[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/CPP/currentculture.cpp#11)]
 [!code-csharp[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/CS/currentculture.cs#11)]
 [!code-vb[System.Globalization.CultureInfo.CurrentCulture2#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.CurrentCulture2/VB/currentculture.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该属性设置为不能用于定位资源文件的区域性名称。 资源文件名必须仅包含字母、数字、连字符或下划线。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于设置当前 UI 区域性。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Resources.ResourceManager" />
        <altmember cref="P:System.Threading.Thread.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InstalledUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture" />
      </Docs>
    </Member>
    <Member MemberName="DateTimeFormat">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.DateTimeFormatInfo DateTimeFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.DateTimeFormatInfo DateTimeFormat" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.DateTimeFormat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DateTimeFormat As DateTimeFormatInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::DateTimeFormatInfo ^ DateTimeFormat { System::Globalization::DateTimeFormatInfo ^ get(); void set(System::Globalization::DateTimeFormatInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DateTimeFormat : System.Globalization.DateTimeFormatInfo with get, set" Usage="System.Globalization.CultureInfo.DateTimeFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.DateTimeFormatInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Globalization.DateTimeFormatInfo" />，它定义适合区域性的、显示日期和时间的格式。</summary>
        <value>一个 <see cref="T:System.Globalization.DateTimeFormatInfo" />，它定义适合区域性的、显示日期和时间的格式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overrides"></a>Overrides  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 值<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性不计算得出，直到你的应用程序访问的属性。 如果用户可以更改当前区域性为新区域性时运行该应用程序，然后该应用程序访问<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>或<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性，应用程序中检索而不是重写的新区域性的默认值原始区域性。 若要保留原始的当前区域性的重写设置，应用程序应访问<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>和<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性，然后才能更改当前区域性。  
  
   
  
## Examples  
 下面的代码示例显示了 CultureInfo.Clone 还克隆<xref:System.Globalization.DateTimeFormatInfo>并<xref:System.Globalization.NumberFormatInfo>与关联的实例<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CPP/yslin_cultureinfo_clone.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CS/yslin_cultureinfo_clone.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/VB/yslin_cultureinfo_clone.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该属性设置为 null。</exception>
        <exception cref="T:System.InvalidOperationException">设置了 <see cref="P:System.Globalization.CultureInfo.DateTimeFormat" /> 属性或任何 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 属性，但 <see cref="T:System.Globalization.CultureInfo" /> 是只读的。</exception>
        <block subset="none" type="usage"><para>如果<see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" />是<see cref="T:System.Globalization.TaiwanCalendar" />但<see cref="P:System.Threading.Thread.CurrentCulture" />未设置为中文 （台湾），名为 ZH-TW，然后<see cref="P:System.Globalization.DateTimeFormatInfo.NativeCalendarName" />， <see cref="M:System.Globalization.DateTimeFormatInfo.GetEraName(System.Int32)" />，并<see cref="M:System.Globalization.DateTimeFormatInfo.GetAbbreviatedEraName(System.Int32)" />返回空字符串 ("")。</para></block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.Globalization.CultureInfo.GetFormat(System.Type)" />
        <altmember cref="P:System.Globalization.CultureInfo.NumberFormat" />
      </Docs>
    </Member>
    <Member MemberName="DefaultThreadCurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo DefaultThreadCurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo DefaultThreadCurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.DefaultThreadCurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultThreadCurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ DefaultThreadCurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultThreadCurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Globalization.CultureInfo.DefaultThreadCurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前应用程序域中线程的默认区域性。</summary>
        <value>如果当前系统区域性为应用程序域中的默认线程区域性，则为当前应用程序中线程的默认区域性或 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]和早期版本中，默认情况下，所有线程的区域性设置为 Windows 系统区域性。 对于当前区域性不同于默认系统区域性的应用程序，此行为通常是不可取的。 在中[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性使应用程序能够在应用程序域中定义的所有线程的默认区域性。  
  
> [!IMPORTANT]
>  如果未显式设置的区域性的任何现有线程在应用程序域中，设置执行<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性也会更改这些线程的区域性。 但是，如果在另一个应用程序域中执行这些线程，则其区域性定义由<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>该应用程序域中的属性或如果定义没有默认值，则由默认系统区域性。 因此，我们建议您始终显式设置你的主应用程序线程的区域性，并且不依赖于<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性来定义主应用程序线程的区域性。  
  
 除非它已显式设置的值<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>属性是`null`，由默认 Windows 系统区域性定义的应用程序域中线程的未分配显式区域性的区域性。  
  
 有关区域性、 线程和应用程序域的详细信息，请参阅"区域性和线程"和"区域性和应用程序域"部分中<xref:System.Globalization.CultureInfo>参考页。  
  
   
  
## Examples  
 下面的示例说明了在.NET Framework 中定义一个新线程的当前区域性的默认行为。 在启动时，该示例设置当前区域性和当前 UI 区域性为法语 （法国） 除外的默认系统区域性已经是法语 （法国） 的所有系统上。 如果默认系统区域性已经是法语 （法国），则该代码设置当前区域性和当前 UI 区域性为英语 （美国）。 然后，它调用`DisplayRandomNumbers`例程，它生成三个随机数字，并将它们显示为货币值。 接下来，它将创建一个新线程，也会执行`DisplayRandomNumbers`例程。  
  
 [!code-csharp[System.Globalization.CultureInfo.DefaultThreadCurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentculture/cs/defaultculture1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.DefaultThreadCurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentculture/vb/defaultculture1.vb#1)]  
  
 如示例输出所示，当系统区域性为英语 （美国） 的计算机上运行该示例的主线程显示其使用法语 （法国） 区域性的格式设置约定的货币值。 但是，由于工作线程的区域性派生自当前的 Windows 系统区域而不是应用程序的当前区域性，工作线程显示它使用英语 （美国） 区域性的格式设置约定的货币值。  
  
 下面的示例使用<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性以定义的当前区域性和新的应用程序线程的当前 UI 区域性。 在启动时，该示例设置当前区域性和当前 UI 区域性为法语 （法国） 除外的默认系统区域性已经是法语 （法国） 的所有系统上。 如果默认系统区域性已经是法语 （法国），则将当前区域性和当前 UI 区域性设置为英语 （美国）。 然后，它调用`DisplayRandomNumbers`例程，它生成三个随机数字，并将它们显示为货币值。 接下来，它将创建一个新线程，也会执行`DisplayRandomNumbers`例程。  
  
 [!code-csharp[System.Globalization.CultureInfo.DefaultThreadCurrentCulture#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentculture/cs/defaultculture2.cs#2)]
 [!code-vb[System.Globalization.CultureInfo.DefaultThreadCurrentCulture#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentculture/vb/defaultculture2.vb#2)]  
  
 如示例输出所示，当系统区域性为英语 （美国） 的计算机上运行该示例的主线程和工作线程都将显示使用法语 （法国） 区域性的格式设置约定及其货币值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture" />
      </Docs>
    </Member>
    <Member MemberName="DefaultThreadCurrentUICulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo DefaultThreadCurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo DefaultThreadCurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultThreadCurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ DefaultThreadCurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultThreadCurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Globalization.CultureInfo.DefaultThreadCurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前应用程序域中线程的默认 UI 区域性。</summary>
        <value>如果当前系统 UI 区域性为当前应用程序域中的默认线程 UI 区域性，则当前应用程序域中线程的默认 UI 区域性或 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]和早期版本中，默认情况下，所有线程的 UI 区域性设置为 Windows 系统区域性。 对于当前 UI 区域性不同于默认系统区域性的应用程序，此行为通常是不可取的。 在中[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性，可以在应用程序域中定义的所有线程的默认 UI 区域性。  
  
> [!IMPORTANT]
>  如果未显式设置的 UI 区域性的任何现有线程在应用程序域中，设置执行<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性也会更改这些线程的区域性。 但是，如果在另一个应用程序域中执行这些线程，则其区域性定义由<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>该应用程序域中的属性或如果定义没有默认值，则由默认系统区域性。 因此，我们建议始终显式设置主应用程序线程的区域性并不依赖于<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性来定义主应用程序线程的区域性。  
  
 除非它已显式设置的值<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性是`null`，和应用程序域中所有未分配显式区域性的线程的当前区域性定义的默认 Windows 系统区域性。  
  
 有关区域性、 线程和应用程序域的详细信息，请参阅"区域性和线程"和"区域性和应用程序域"部分中<xref:System.Globalization.CultureInfo>参考页。  
  
   
  
## Examples  
 下面的示例说明了在.NET Framework 中定义一个新线程的当前区域性的默认行为。 它使用英语和俄罗斯语语言资源。 名为 GreetingStrings.txt 的以下文本文件包含英语语言资源：  
  
```  
greeting =Hello again!  
newGreeting=Hello!  
```  
  
 编译为二进制.resources 文件通过使用名为 GreetingStrings.resources[资源文件生成器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)使用以下命令。  
  
```console  
resgen greetingstrings.txt  
```  
  
 名为 GreetingStrings.ru-RU.txt 的以下文本文件包含俄语语言资源：  
  
```  
greeting=Еще раз привет!  
newGreeting=Привет!  
```  
  
 编译为二进制.resources 文件通过使用名为 GreetingStrings.ru RU.resources[资源文件生成器](~/docs/framework/tools/resgen-exe-resource-file-generator.md)使用以下命令。  
  
```console  
resgen greetingstrings.ru-RU.txt  
```  
  
 应用程序代码，如下所示，驻留在文件中名为 Example1.vb 或 Example1.cs。 它被编译为可执行文件的 Visual Basic 编译器使用以下命令：  
  
```console  
vbc Example1.vb /resource:GreetingStrings.resources  
```  
  
 对于 C# 编译器，该命令是类似：  
  
```console  
csc /resource:GreetingStrings.resources Example1.cs  
```  
  
 这将创建包含示例的可执行代码以及其回退区域性的资源程序集。 此外可以使用[程序集链接器](~/docs/framework/tools/al-exe-assembly-linker.md)创建俄语 （俄罗斯） 区域性的资源文件使用以下命令：  
  
```console  
>al /embed:greetingstrings.ru-RU.resources /c:ru-RU /template:example1.exe /out:ru-RU\Example1.resources.dll  
```  
  
 在启动时，该示例设置当前区域性和当前 UI 区域性为俄语 （俄罗斯） 除外的默认系统区域性已经是俄语的所有系统上 （俄罗斯）。 如果默认系统区域性已经是俄语 （俄罗斯）、 代码集的当前区域性和当前 UI 区域性以英语 （美国）。 然后，它调用`ShowGreeting`例程，后者将显示在后续方法调用的简单字符串就是第一次和略有不同的字符串。 接下来，它将创建一个新线程，也会执行`ShowGreeting`例程。  
  
 [!code-csharp[System.Globalization.CultureInfo.DefaultThreadCurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentuiculture/cs/example1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.DefaultThreadCurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentuiculture/vb/example1.vb#1)]  
  
 如示例输出所示，当系统区域性为英语 （美国） 的计算机上运行该示例的主线程在俄语中显示其初始字符串。 但是，因为工作线程的区域性派生自当前的 Windows 系统区域而不是应用程序的当前区域性，工作线程以英语显示其字符串。  
  
 下面的示例使用<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A>属性以定义的当前区域性和新的应用程序线程的当前 UI 区域性。  
  
 该示例与上面的示例使用相同的资源文件。 编译并将本地化的俄语语言资源嵌入到附属程序集的命令也是完全相同，只不过可执行程序集的名称会更改。  
  
 在启动时，该示例设置当前区域性和当前 UI 区域性为俄语 （俄罗斯） 除外的默认系统区域性已经是俄语的所有系统上 （俄罗斯）。 如果已经默认系统区域性是俄语 （俄罗斯），它将设置当前区域性和当前 UI 区域性为英语 （美国）。 然后，它调用`ShowGreeting`例程，后者将显示在后续方法调用的简单字符串就是第一次和略有不同的字符串。 接下来，它将创建一个新线程，也会执行`ShowGreeting`例程。  
  
 [!code-csharp[System.Globalization.CultureInfo.DefaultThreadCurrentUICulture#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentuiculture/cs/example2.cs#2)]
 [!code-vb[System.Globalization.CultureInfo.DefaultThreadCurrentUICulture#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.defaultthreadcurrentuiculture/vb/example2.vb#2)]  
  
 如示例输出所示，当系统区域性为英语 （美国） 的计算机上运行该示例的主线程和工作线程以俄语语言显示它们的字符串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在集运算中，<see cref="P:System.Globalization.CultureInfo.Name" /> 属性值无效。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentCulture" />
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public virtual string DisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.DisplayName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayName : string" Usage="System.Globalization.CultureInfo.DisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取完整的本地化区域性名称。</summary>
        <value>格式的完整本地化的区域性名称*languagefull* [*country/regionfull*]，其中*languagefull*是语言的完整名称和*country/regionfull*是国家/地区的完整名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性表示的本地化的名称<xref:System.Globalization.CultureInfo>对象。  
  
 区域性名称可能因脚本编写或格式设置约定。 应使用返回的名称进行显示，并尝试对其进行分析。  
  
 如果通过创建自定义区域性<xref:System.Globalization.CultureAndRegionInfoBuilder>类，<xref:System.Globalization.CultureInfo.DisplayName%2A>属性初始化的值为<xref:System.Globalization.CultureInfo.NativeName%2A>属性。  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示与 0x0004 和 0x7C04 区域性标识符的 ZH-CHS 和 ZH-CHT 区域性。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="EnglishName">
      <MemberSignature Language="C#" Value="public virtual string EnglishName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EnglishName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.EnglishName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EnglishName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EnglishName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnglishName : string" Usage="System.Globalization.CultureInfo.EnglishName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取格式为 languagefull [country/regionfull] 的英语区域性名称。</summary>
        <value>格式的区域性名称*languagefull* [*country/regionfull*]，where *languagefull*是语言的完整名称和*国家/地区 /regionfull*是国家/地区的完整名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，<xref:System.Globalization.CultureInfo.EnglishName%2A>对于特定的区域性名称 EN-US 是"英语 （美国）"。  
  
 此属性的值是相同的而不考虑.NET Framework 的语言版本。  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cultureInfo.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">将与当前 <see cref="T:System.Globalization.CultureInfo" /> 进行比较的对象。</param>
        <summary>确定指定的对象是否与当前 <see cref="T:System.Globalization.CultureInfo" /> 具有相同的区域性。</summary>
        <returns>如果 <paramref name="value" /> 与当前 <see cref="T:System.Globalization.CultureInfo" /> 具有相同的区域性，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 两个<xref:System.Globalization.CultureInfo>对象被视为相等，如果他们<xref:System.Globalization.CultureInfo.Name%2A>和<xref:System.Globalization.CultureInfo.CompareInfo%2A>属性相等。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetConsoleFallbackUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo GetConsoleFallbackUICulture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Globalization.CultureInfo GetConsoleFallbackUICulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetConsoleFallbackUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsoleFallbackUICulture () As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Globalization::CultureInfo ^ GetConsoleFallbackUICulture();" />
      <MemberSignature Language="F#" Value="member this.GetConsoleFallbackUICulture : unit -&gt; System.Globalization.CultureInfo" Usage="cultureInfo.GetConsoleFallbackUICulture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果默认的图形用户界面区域性不合适，则获取适合控制台应用程序的备用用户界面区域性。</summary>
        <returns>用于在控制台上读取和显示文本的备用区域性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 阿拉伯语、 希伯来语、 乌尔都语和叙利亚语等语言基于双向文本。 Windows 应用程序，有一个图形用户界面，支持双向语言。 但是，控制台应用程序，采用操作系统控制台的文本用户界面，不提供的双向支持。 因此，如果本地化为阿拉伯语或希伯来语的控制台应用程序，你的应用程序控制台屏幕上显示不可读的文本。  
  
 用户界面区域性指定应用程序需要支持用户输入和输出，以及默认情况下与操作系统的系统区域性相同的资源。 例如，<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性返回的阿拉伯语区域性为阿拉伯语操作系统。 使用<xref:System.Globalization.CultureInfo.GetConsoleFallbackUICulture%2A>方法来检索适合控制台应用程序用户界面的区域性。 你的应用程序检索备用用户界面区域性后，它应将区域性分配给当前线程的当前用户接口区域性。 有关详细信息，请参阅的"显式设置当前 UI 区域性"部分<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>属性。  
  
 以下是具有从预定义的区域性名称的不同回退用户界面区域性名称的预定义的区域性。  
  
|预定义的区域性|区域性名称|备用用户界面区域性名称|  
|------------------------|------------------|------------------------------------------|  
|阿姆哈拉语|am|en-US|  
|阿姆哈拉语 （埃塞俄比亚）|am-ET|en-US|  
|（非特定阿拉伯语）|ar|en-US|  
|阿拉伯语 （阿拉伯联合酋长国）|ar-AE|en-US|  
|阿拉伯语 （巴林）|ar-BH|en-US|  
|阿拉伯语 （阿尔及利亚）|ar-DZ|fr-FR|  
|阿拉伯语 （埃及）|ar-EG|en-US|  
|阿拉伯语 （伊拉克）|ar-IQ|en-US|  
|阿拉伯语 （约旦）|ar-JO|en-US|  
|阿拉伯语 （科威特）|ar-KW|en-US|  
|阿拉伯语 （黎巴嫩）|ar-LB|en-US|  
|阿拉伯语 （利比亚）|ar LY|en-US|  
|阿拉伯语 （摩洛哥）|ar-MA|fr-FR|  
|阿拉伯语 （阿曼）|ar OM|en-US|  
|阿拉伯语 （卡塔尔）|ar-QA|en-US|  
|阿拉伯语 （沙特阿拉伯）|ar-SA|en-US|  
|阿拉伯语 （叙利亚）|ar SY|en-US|  
|阿拉伯语 （突尼斯）|ar-TN|fr-FR|  
|阿拉伯语 （也门）|ar-YE|en-US|  
|阿萨姆|as|en-US|  
|阿萨姆语 （印度）|as-IN|en-US|  
|孟加拉语|bn|en-US|  
|孟加拉语 （孟加拉国）|bn-BD|en-US|  
|孟加拉语 （印度）|bn IN|en-US|  
|藏语|bo|en-US|  
|藏语 （中国）|bo-CN|en-US|  
|迪维希语|dv|en-US|  
|迪维希语 （印度）|dv-MV|en-US|  
|波斯语|fa|en-US|  
|波斯语 （伊朗）|fa-IR|en-US|  
|古吉拉特语|gu|en-US|  
|古吉拉特语 （印度）|gu-IN|en-US|  
|希伯来语|he|en-US|  
|希伯来语 （以色列）|he-IL|en-US|  
|印地语|你好|en-US|  
|印地语 （印度）|hi-IN|en-US|  
|彝语|ii|en-US|  
|彝语 （中国）|ii-CN|en-US|  
|因纽特|iu-Cans|en-US|  
|因纽特 （加拿大）|iu-Cans-CA|en-US|  
|高棉语|密钥主机|en-US|  
|高棉语 （柬埔寨）|km-KH|en-US|  
|卡纳达语|kn|en-US|  
|埃纳德语 （印度）|kn-IN|en-US|  
|孔卡尼语|kok|en-US|  
|孔卡尼语 （印度）|kok-IN|en-US|  
|老挝语|lo|en-US|  
|老挝语 （老挝人民民主共和国）|lo-LA|en-US|  
|马拉雅拉姆语|ml|en-US|  
|马拉雅拉姆语 （印度）|ml-IN|en-US|  
|莫霍克语|moh|en-US|  
|莫霍克语 （加拿大）|moh-CA|en-US|  
|马拉地语|mr|en-US|  
|马拉地语 （印度）|mr-IN|en-US|  
|尼泊尔语|ne|en-US|  
|尼泊尔语 （尼泊尔）|ne-NP|en-US|  
|挪威语|否|nb-NO|  
|Odiya|or|en-US|  
|Odiya （印度）|or-IN|en-US|  
|旁遮普语|pa|en-US|  
|旁遮普语 （印度）|pa-IN|en-US|  
|达里语|pr|en-US|  
|达里语 （阿富汗）|prs-AF|en-US|  
|普什图语|ps|en-US|  
|普什图语 （阿富汗）|ps-AF|en-US|  
|梵文|sa|en-US|  
|梵语 （印度）|sa-IN|en-US|  
|僧伽罗语|si|en-US|  
|僧伽罗语 （斯里兰卡）|si-LK|en-US|  
|叙利亚语|syr|en-US|  
|叙利亚语 （叙利亚）|syr SY|en-US|  
|泰米尔语|ta|en-US|  
|泰米尔语 （印度）|ta-IN|en-US|  
|泰卢固语|te|en-US|  
|泰卢固语 （印度）|te-IN|en-US|  
|泰语|th|en-US|  
|泰语 （泰国）|th Th|en-US|  
|维吾尔语|ug|en-US|  
|维吾尔语 （中国）|ug-CN|en-US|  
|乌尔都语|在|en-US|  
|乌尔都语 （巴基斯坦）|ur-PK|en-US|  
|越南语|vi|en-US|  
|越南语 （越南）|vi-VN|en-US|  
  
 你的应用程序可以使用<xref:System.Globalization.CultureAndRegionInfoBuilder>创建替换的区域性和区域性可以具有所选控制台回退区域性。  
  
   
  
## Examples  
 下面的代码示例显示区域性对象与关联的备用用户界面区域性。  
  
 [!code-cpp[sys.glob.ci.getCFUIC#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.glob.ci.getCFUIC/cpp/cfuic.cpp#1)]
 [!code-csharp[sys.glob.ci.getCFUIC#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.glob.ci.getCFUIC/CS/cfuic.cs#1)]
 [!code-vb[sys.glob.ci.getCFUIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.glob.ci.getCFUIC/VB/cfuic.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCultureInfo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索某个区域性的缓存的只读实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCultureInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo GetCultureInfo (int culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo GetCultureInfo(int32 culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetCultureInfo(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCultureInfo (culture As Integer) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ GetCultureInfo(int culture);" />
      <MemberSignature Language="F#" Value="static member GetCultureInfo : int -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.GetCultureInfo culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">区域设置标识符 (LCID)。</param>
        <summary>使用特定的区域性标识符检索某个区域性的缓存的只读实例。</summary>
        <returns>一个只读 <see cref="T:System.Globalization.CultureInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议使用此方法的字符串重载 (<xref:System.Globalization.CultureInfo.GetCultureInfo%28System.String%29>)，因为区域设置名称应使用而不是 lcid 的数量。 对于自定义区域设置，区域设置名称为必需。  
  
 如果`culture`是为当前区域性，返回的区域设置标识符<xref:System.Globalization.CultureInfo>对象不会反映任何用户重写。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="culture" /> 小于零。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="culture" /> 指定不支持的区域性。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="culture" />不是有效的区域性标识符。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此方法将引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="culture" />从操作系统; 如果操作系统不支持该区域性方法会抛出<see cref="T:System.Globalization.CultureNotFoundException" />。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.LCID" />
        <altmember cref="M:System.Globalization.CultureInfo.ClearCachedData" />
      </Docs>
    </Member>
    <Member MemberName="GetCultureInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo GetCultureInfo (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo GetCultureInfo(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetCultureInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCultureInfo (name As String) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ GetCultureInfo(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetCultureInfo : string -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.GetCultureInfo name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">区域性的名称。 <paramref name="name" /> 不区分大小写。</param>
        <summary>使用特定的区域性名称检索某个区域性的缓存的只读实例。</summary>
        <returns>一个只读 <see cref="T:System.Globalization.CultureInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

在 Windows 系统上的预定义的区域性名称的列表，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。  
  
 <xref:System.Globalization.CultureInfo.GetCultureInfo%2A>方法检索缓存，只读<xref:System.Globalization.CultureInfo>对象。 它提供更好的性能比相应地调用<xref:System.Globalization.CultureInfo.%23ctor%28System.String%29?displayProperty=nameWithType>构造函数。  
  
 如果`name`的当前区域性，返回名称<xref:System.Globalization.CultureInfo>对象不会反映任何用户重写。 这使该方法适用于服务器应用程序或工具没有在系统上的实际用户帐户且需要有效地加载多个区域性。  
  
 如果`name`是<xref:System.String.Empty?displayProperty=nameWithType>，该方法将返回固定区域性。 这相当于检索的值<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 null。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 指定不支持的区域性。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />不是有效的区域性名称。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此方法将引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="name" />从操作系统; 如果操作系统不支持该区域性，并且<paramref name="name" />不是补充或替换的区域性，该方法将引发名称<see cref="T:System.Globalization.CultureNotFoundException" />。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
      </Docs>
    </Member>
    <Member MemberName="GetCultureInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo GetCultureInfo (string name, string altName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo GetCultureInfo(string name, string altName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetCultureInfo(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCultureInfo (name As String, altName As String) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ GetCultureInfo(System::String ^ name, System::String ^ altName);" />
      <MemberSignature Language="F#" Value="static member GetCultureInfo : string * string -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.GetCultureInfo (name, altName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="altName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">区域性的名称。 <paramref name="name" /> 不区分大小写。</param>
        <param name="altName">区域性的名称提供了 <see cref="T:System.Globalization.TextInfo" /> 和 <see cref="T:System.Globalization.CompareInfo" /> 对象，这些对象用于对 <paramref name="name" /> 进行初始化。 <paramref name="altName" /> 不区分大小写。</param>
        <summary>检索某个区域性的缓存的只读实例。 参数指定了一个使用 <see cref="T:System.Globalization.TextInfo" /> 和 <see cref="T:System.Globalization.CompareInfo" /> 对象进行初始化的区域性，而这些对象则是由另一个区域性指定的。</summary>
        <returns>一个只读 <see cref="T:System.Globalization.CultureInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 系统上的预定义的区域性名称的列表，请参阅**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。  
  
 <xref:System.Globalization.CultureInfo.GetCultureInfo%2A>方法获取缓存，只读<xref:System.Globalization.CultureInfo>对象。 它提供更好的性能比相应地调用<xref:System.Globalization.CultureInfo.%23ctor%2A>构造函数。 该方法用于创建类似于指定的区域性`name`参数，但具有不同的排序和大小写规则。  
  
 如果`name`或`altName`是名称的当前区域性，返回的对象不能反映任何用户重写。 如果`name`是<xref:System.String.Empty?displayProperty=nameWithType>，该方法将返回固定区域性。 这相当于检索的值<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性。 如果`altName`是<xref:System.String.Empty?displayProperty=nameWithType>，该方法使用的书写体系和比较指定固定区域性的规则。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 或 <paramref name="altName" /> 为 null。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 或 <paramref name="altName" /> 用于指定不支持的区域性。 有关详细信息，请参阅“调用方备注”部分。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />或<paramref name="altName" />不是有效的区域性名称。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此方法将引发<see cref="T:System.Globalization.CultureNotFoundException" />。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="name" />从操作系统; 如果操作系统不支持该区域性，并且<paramref name="name" />不是补充或替换的区域性，该方法将引发名称<see cref="T:System.Globalization.CultureNotFoundException" />异常。 下运行的应用程序起[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]或更高版本 Windows 7 或更高版本，该方法尝试检索<see cref="T:System.Globalization.CultureInfo" />对象，其标识符为<paramref name="name" />从操作系统; 如果操作系统不支持该区域性，并且<paramref name="name" />不是补充或替换的区域性，该方法将引发名称<see cref="T:System.Globalization.CultureNotFoundException" />异常。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="M:System.Globalization.CultureInfo.ClearCachedData" />
      </Docs>
    </Member>
    <Member MemberName="GetCultureInfoByIetfLanguageTag">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetCultureInfoByIetfLanguageTag(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCultureInfoByIetfLanguageTag (name As String) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ GetCultureInfoByIetfLanguageTag(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetCultureInfoByIetfLanguageTag : string -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.GetCultureInfoByIetfLanguageTag name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">按 RFC 4646 标准指定的语言名称。</param>
        <summary>已否决。 检索只读的 <see cref="T:System.Globalization.CultureInfo" /> 对象，其语言特征由指定的 RFC 4646 语言标记标识。</summary>
        <returns>一个只读 <see cref="T:System.Globalization.CultureInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法和<xref:System.Globalization.CultureInfo.IetfLanguageTag%2A>属性已弃用。 而不是使用这些元素，该应用程序应使用的新<xref:System.Globalization.CultureInfo>对象并调用到<xref:System.Globalization.CultureInfo.Name%2A>属性。 IETF 标记和名称是相同的。  
  
 维护 Internet 工程任务组 (IETF) 的 RFC 4646 标准定义一个 IETF 语言标记，提供了统一的方法来确定一种语言。 一个 IETF 语言标记的格式是返回的区域性名称相同<xref:System.Globalization.CultureInfo.Name%2A>属性，但不唯一地标识一个区域性。 如果这些区域性具有相同的语言特征，不同的区域性将共享同一个 IETF 语言标记。 中包含一个区域性的语言特征<xref:System.Globalization.TextInfo>对象与关联<xref:System.Globalization.CultureInfo>对象。  
  
 一个 IETF 语言标记组成是必需的语言标识符、 可选脚本标识符和可选区域标识符。  
  
 你的应用程序应使用检索到的区域性来控制特定于语言的任务，例如管理拼写或语法检查器。 应用程序不应使用检索到的区域性以控制特定于区域性的任务，例如文本进行排序或格式化时间和日期。  
  
 有关详细信息，请参阅 RFC 4646、"标记为标识语言"和最新草案标准、 草稿-phillips-langtags-05.txt，在[ http://go.microsoft.com/fwlink/?LinkId=100231 ](https://go.microsoft.com/fwlink/?LinkId=100231)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 null。</exception>
        <exception cref="T:System.Globalization.CultureNotFoundException"><paramref name="name" /> 与支持的区域性不符。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本抛<see cref="T:System.ArgumentException" />如果<paramref name="name" />支持的区域性的名称不对应。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此方法将引发<see cref="T:System.Globalization.CultureNotFoundException" />。</para></block>
        <altmember cref="P:System.Globalization.CultureInfo.TextInfo" />
        <altmember cref="T:System.Globalization.CultureAndRegionInfoBuilder" />
        <altmember cref="M:System.Globalization.CultureInfo.ClearCachedData" />
      </Docs>
    </Member>
    <Member MemberName="GetCultures">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo[] GetCultures (System.Globalization.CultureTypes types);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo[] GetCultures(valuetype System.Globalization.CultureTypes types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetCultures(System.Globalization.CultureTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCultures (types As CultureTypes) As CultureInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Globalization::CultureInfo ^&gt; ^ GetCultures(System::Globalization::CultureTypes types);" />
      <MemberSignature Language="F#" Value="static member GetCultures : System.Globalization.CultureTypes -&gt; System.Globalization.CultureInfo[]" Usage="System.Globalization.CultureInfo.GetCultures types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Globalization.CultureTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">按位组合的列举值，用于筛选要检索的区域性。</param>
        <summary>获取由指定 <see cref="T:System.Globalization.CultureTypes" /> 参数筛选的支持的区域性列表。</summary>
        <returns>一个数组，该数组包含由 <paramref name="types" /> 参数指定的区域性。 区域性数组未排序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo.GetCultures%2A>最常与调用方法`types`参数设置为以下值：  
  
-   <xref:System.Globalization.CultureTypes.SpecificCultures>表示返回所有特定区域性。  
  
-   <xref:System.Globalization.CultureTypes.NeutralCultures>表示返回所有非特定区域性和固定区域性。  
  
-   <xref:System.Globalization.CultureTypes.AllCultures>表示返回所有非特定和特定区域性、 Windows 系统中安装的区域性和由用户创建的自定义区域性。  
  
-   <xref:System.Globalization.CultureTypes.UserCustomCulture>表示返回所有自定义区域性，例如那些由注册<xref:System.Globalization.CultureAndRegionInfoBuilder>类。 在 Windows 10 之前的 Windows 版本<xref:System.Globalization.CultureTypes.UserCustomCulture>值适用于所有用户定义的自定义区域性。 从 Windows 10 开始，它适用于系统区域性缺少完整的文化数据并不具有唯一本地标识符，由<xref:System.Globalization.CultureInfo.LCID%2A>属性值。 因此，如下所示的代码将返回不同的结果时在 Windows 10 和 Windows 的早期版本上运行。  
  
     [!code-csharp[System.Globalization.CultureInfo.GetCultures#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures3.cs#2)]
     [!code-vb[System.Globalization.CultureInfo.GetCultures#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures3.vb#2)]  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示与 0x0004 和 0x7C04 区域性标识符的 ZH-CHS 和 ZH-CHT 区域性。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="types" /> 指定了无效的 <see cref="T:System.Globalization.CultureTypes" /> 值组合。</exception>
        <altmember cref="T:System.Globalization.CultureTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetFormat">
      <MemberSignature Language="C#" Value="public virtual object GetFormat (Type formatType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFormat(class System.Type formatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetFormat(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFormat (formatType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetFormat(Type ^ formatType);" />
      <MemberSignature Language="F#" Value="abstract member GetFormat : Type -&gt; obj&#xA;override this.GetFormat : Type -&gt; obj" Usage="cultureInfo.GetFormat formatType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormatProvider.GetFormat(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formatType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="formatType">要为其获取格式化对象的 <see cref="T:System.Type" />。 此方法仅支持 <see cref="T:System.Globalization.NumberFormatInfo" /> 和 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 两种类型。</param>
        <summary>获取一个定义如何格式化指定类型的对象。</summary>
        <returns><see cref="P:System.Globalization.CultureInfo.NumberFormat" /> 属性的值，如果 <paramref name="formatType" /> 是 <see cref="T:System.Globalization.NumberFormatInfo" /> 类的 <see cref="T:System.Globalization.CultureInfo" /> 对象，则该属性为包含当前 <see cref="T:System.Type" /> 的默认数字格式信息的 <see cref="T:System.Globalization.NumberFormatInfo" />。  
  
- 或 - 
<see cref="P:System.Globalization.CultureInfo.DateTimeFormat" /> 属性的值，如果 <paramref name="formatType" /> 是 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 类的 <see cref="T:System.Globalization.CultureInfo" /> 对象，则该属性为包含当前 <see cref="T:System.Type" /> 的默认日期和时间格式信息的 <see cref="T:System.Globalization.DateTimeFormatInfo" />。  
  
- 或 - 
如果 <paramref name="formatType" /> 是其他任何对象，则为 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo.GetFormat%2A> 可实现 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>。  
  
 `NumberFormatInfo` 提供了与中的基本数据类型的格式方法结合使用的特定于区域性的数字格式。 `DateTimeFormatInfo` 控制如何针对特定区域性格式化日期和时间值。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.NumberFormat" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cultureInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用作当前 <see cref="T:System.Globalization.CultureInfo" /> 的哈希函数，适合用在哈希算法和数据结构（如哈希表）中。</summary>
        <returns>当前 <see cref="T:System.Globalization.CultureInfo" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
 此方法为根据 <xref:System.Globalization.CultureInfo.Equals%2A> 方法视为相等的两个对象生成相同的哈希代码。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Globalization.CultureInfo.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IetfLanguageTag">
      <MemberSignature Language="C#" Value="public string IetfLanguageTag { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IetfLanguageTag" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.IetfLanguageTag" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IetfLanguageTag As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IetfLanguageTag { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IetfLanguageTag : string" Usage="System.Globalization.CultureInfo.IetfLanguageTag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>已否决。 获取某种语言的 RFC 4646 标准标识。</summary>
        <value>一个字符串，表示某种语言的 RFC 4646 标准标识。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此属性和<xref:System.Globalization.CultureInfo.GetCultureInfoByIetfLanguageTag%2A>方法已弃用。 相反，应使用<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>属性。 IETF 标记和名称是相同的。  
  
 维护 Internet 工程任务组 (IETF) 的 RFC 4646 标准定义一个 IETF 语言标记，提供了统一的方法来确定一种语言。 一个 IETF 语言标记的格式是类似于返回的区域性名称<xref:System.Globalization.CultureInfo.Name%2A>属性，但不唯一地标识一个区域性。 也就是说，不同的区域性共享同一个 IETF 语言标记，如果这些区域性具有相同的语言特征。 中包含一个区域性的语言特征<xref:System.Globalization.TextInfo>对象与关联<xref:System.Globalization.CultureInfo>对象。  
  
 一个 IETF 语言标记组成是必需的语言标识符、 可选脚本标识符和可选区域标识符。  
  
 有关详细信息，请参阅[RFC 5646"标记为标识语言](https://go.microsoft.com/fwlink/?LinkId=230876)。 子标记的列表，请参阅[IANA 语言子标记注册表](https://go.microsoft.com/fwlink/?LinkId=230877)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.TextInfo" />
        <altmember cref="T:System.Globalization.CultureAndRegionInfoBuilder" />
      </Docs>
    </Member>
    <Member MemberName="InstalledUICulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo InstalledUICulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo InstalledUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.InstalledUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InstalledUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ InstalledUICulture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstalledUICulture : System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.InstalledUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示操作系统中安装的区域性的 <see cref="T:System.Globalization.CultureInfo" />。</summary>
        <value>表示操作系统中安装的区域性的 <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在已本地化的操作系统，如日语版本的 Windows，此属性返回的操作系统的区域性。 此属性等效于`GetSystemDefaultUILanguage`Windows API 中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.ResourceManager" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.Parent" />
      </Docs>
    </Member>
    <Member MemberName="InvariantCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo InvariantCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo InvariantCulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.InvariantCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvariantCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ InvariantCulture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InvariantCulture : System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.InvariantCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取不依赖于区域性（固定）的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</summary>
        <value>不依赖于区域性（固定）的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 固定区域性不区分区域性;它是关联与英语语言，但不能与任何国家/地区。 固定区域性按名称指定通过使用空字符串 ("") 对的调用中<xref:System.Globalization.CultureInfo>实例化方法。 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 此外将检索固定区域性的实例。 它可以在几乎所有方法中使用<xref:System.Globalization>要求区域性的命名空间。 如返回属性的对象<xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>，和<xref:System.Globalization.CultureInfo.NumberFormat%2A>还反映字符串比较和格式设置的固定区域性的约定。  
  
 与不同的是区分区域性的数据，可能会发生更改的用户自定义或对.NET Framework 或操作系统的更新，固定区域性稳定时间和已安装的区域性特定和数据不能由用户自定义。 这样，固定区域性特别有用的操作，需要依赖于区域性的结果，如格式设置和分析操作保留格式的数据，或排序和排序操作需要的数据显示在无论区域性固定的顺序。  
  
## <a name="string-operations"></a>字符串操作  
 为区分区域性的字符串操作不受当前线程区域性的约定和的上都是一致的区域性，可以使用固定区域性。 例如，可能想要按固定顺序或适用于不考虑当前线程区域性的字符串的一组标准的大小写约定的已排序的数据。 若要执行此操作，可以传递<xref:System.Globalization.CultureInfo.InvariantCulture%2A>对象具有方法<xref:System.Globalization.CultureInfo>参数，如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29>和<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>。  
  
## <a name="persisting-data"></a>保存数据  
 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性可用于将数据保存在独立于区域性的格式。 这提供了已知的格式不会更改，可用来序列化和反序列化各个区域性的数据。 反序列化数据后，它可以适当地根据当前用户的区域性约定进行格式化。  
  
 例如，如果您选择保留以字符串形式的日期和时间数据，则可以传递<xref:System.Globalization.CultureInfo.InvariantCulture%2A>对象传递给<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>或<xref:System.DateTimeOffset.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法来创建字符串，并且您可以将传递<xref:System.Globalization.CultureInfo.InvariantCulture%2A>对象传递给<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>或<xref:System.DateTimeOffset.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>将字符串转换回为日期和时间值的方法。 此方法可确保基础的日期和时间值不会更改时读取或写入来自不同的区域性的用户数据。  
  
 下面的示例使用固定区域性来持久保存<xref:System.DateTime>以字符串形式的值。 然后，分析字符串，并使用法语 （法国） 和德语 （德国） 区域性的格式设置约定来显示其值。  
  
 [!code-csharp[System.Globalization.CultureInfo.InvariantCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.invariantculture/cs/persist1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.InvariantCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.invariantculture/vb/persist1.vb#1)]  
  
## <a name="security-decisions"></a>安全决策  
 如果您要做 （如是否允许对系统资源的访问） 的安全决策基于字符串比较或大小写更改的结果，您不应使用固定区域性。 相反，应通过调用包含的方法来执行区分大小写或不区分大小写的序号比较<xref:System.StringComparison>参数并提供任一<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>作为自变量。 如果更改当前区域性或运行代码的计算机上的区域性与可用来测试代码的区域性，则执行区分区域性的字符串操作的代码可能导致安全漏洞。 与此相反，序号比较仅取决于比较的字符的二进制值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InstalledUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.Parent" />
        <altmember cref="P:System.Globalization.CultureInfo.IsNeutralCulture" />
      </Docs>
    </Member>
    <Member MemberName="IsNeutralCulture">
      <MemberSignature Language="C#" Value="public virtual bool IsNeutralCulture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNeutralCulture" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.IsNeutralCulture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsNeutralCulture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsNeutralCulture { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNeutralCulture : bool" Usage="System.Globalization.CultureInfo.IsNeutralCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Globalization.CultureInfo" /> 是否表示非特定区域性。</summary>
        <value>如果当前 <see cref="T:System.Globalization.CultureInfo" /> 表示非特定区域性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非特定区域性是关联的区域性与一种语言，但不是与任何国家/地区 / 区域。 它不同于特定区域性，它是一种语言和国家/地区或区域与关联的区域性。 例如，fr 是法语区域性非特定语言的名称，而-FR 是法国法语区域性的名称。  
  
 如果此属性返回`false`，区域性是特定区域性或固定区域性。  
  
   
  
## Examples  
 下面的代码示例确定哪些使用简体中文的语言的区域性非特定区域性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.IsNeutralCulture2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.IsNeutralCulture2/CPP/neutralculture.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.IsNeutralCulture2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.IsNeutralCulture2/CS/neutralculture.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.IsNeutralCulture2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.IsNeutralCulture2/VB/neutralculture.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Globalization.CultureInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Globalization.CultureInfo" /> 是否为只读。</summary>
        <value>如果当前 <see langword="true" /> 为只读，则为 <see cref="T:System.Globalization.CultureInfo" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Globalization.CultureInfo>是只读的<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>和<xref:System.Globalization.CultureInfo.NumberFormat%2A>实例也是只读的。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Globalization.CultureInfo.IsReadOnly%2A>还有助于保护<xref:System.Globalization.DateTimeFormatInfo>并<xref:System.Globalization.NumberFormatInfo>与关联的实例<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/CPP/yslin_cultureinfo_readonly.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/CS/yslin_cultureinfo_readonly.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/VB/yslin_cultureinfo_readonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CultureInfo.ReadOnly(System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="KeyboardLayoutId">
      <MemberSignature Language="C#" Value="public virtual int KeyboardLayoutId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyboardLayoutId" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.KeyboardLayoutId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyboardLayoutId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyboardLayoutId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyboardLayoutId : int" Usage="System.Globalization.CultureInfo.KeyboardLayoutId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取活动的输入法区域设置标识符。</summary>
        <value>一个指定输入区域设置标识符的 32 位有符号数字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 输入法区域设置标识符以前称为键盘布局。 输入法区域设置标识符是输入的更广泛概念，而不是键盘布局，因为它还可以指示语音到文本转换器、 输入法编辑器 (IME) 或任何其他形式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public virtual int LCID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int LCID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int" Usage="System.Globalization.CultureInfo.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Globalization.CultureInfo" /> 的区域性标识符。</summary>
        <value>当前 <see cref="T:System.Globalization.CultureInfo" /> 的区域性标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在大多数情况下，区域性标识符映射到相应的 NLS 区域设置标识符。  
  
 在 Windows 10 中，区域设置标识符之前的 Windows 版本中`LOCALE_CUSTOM_UNSPECIFIED`（0x1000 控制或 4096） 分配给由用户创建的自定义区域性。 从 Windows 10 开始，它被分配给任何区域性不具有唯一的区域设置标识符并不具有完整的系统提供数据。 因此，用于循环访问的区域性和检索那些具有代码<xref:System.Globalization.CultureInfo.LCID%2A>的值`LOCALE_CUSTOM_UNSPECIFIED`返回的更大子集<xref:System.Globalization.CultureInfo>对象; 如果在 Windows 10 下运行。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Globalization.CultureInfo>西班牙语 （西班牙） 与国际排序顺序，另一个<xref:System.Globalization.CultureInfo>与传统的排序顺序。  
  
 [!code-cpp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CPP/spanishspain.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CS/spanishspain.cs#1)]
 [!code-vb[System.Globalization.CultureInfo_esES#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/VB/spanishspain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Globalization.CultureInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取格式为 languagecode2-country/regioncode2 的区域性名称。</summary>
        <value>格式的区域性名称*languagecode2*-*country/regioncode2*。 *languagecode2*派生自 ISO 639-1 小写的双字母代码。 *country/regioncode2*派生自 ISO 3166，一般包含两个大写字母，或一个 BCP-47 语言标记。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

有关预定义的区域性名称和标识符的列表，<xref:System.Globalization.CultureInfo.Name%2A>属性可以在 Windows 上都返回系统，请参阅**语言标记**中的列[Windows支持的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c). 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。 此外，从 Windows 10 开始`name`可以是任何有效的 BCP-47 语言标记。 请注意区域性名称发生更改，并且它们还可以反映自定义区域性的名称。  
  
 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>属性遵循命名标准中提供<xref:System.Globalization.CultureInfo>类主题。 它将返回不包括任何可能的备选排序顺序的区域性名称的缩写形式。 例如，如果您实例化<xref:System.Globalization.CultureInfo>对象使用字符串"de DE_phoneb"以反映备用排序顺序，<xref:System.Globalization.CultureInfo.Name%2A>属性将返回"DE-DE"。  
  
 若要获取区域性的完整名称，应使用<xref:System.Globalization.CultureInfo.DisplayName%2A>， <xref:System.Globalization.CultureInfo.EnglishName%2A>，或<xref:System.Globalization.CultureInfo.NativeName%2A>属性。  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="NativeName">
      <MemberSignature Language="C#" Value="public virtual string NativeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NativeName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.NativeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NativeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NativeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NativeName : string" Usage="System.Globalization.CultureInfo.NativeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为区域性设置的显示名称，它由语言、国家/地区以及可选的书写符号组成。</summary>
        <value>区域性名称。 由语言的全名、国家/地区的全名以及可选脚本组成。 有关其格式的讨论，请参见对 <see cref="T:System.Globalization.CultureInfo" /> 类的说明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值是相同的而不考虑.NET Framework 的语言版本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="NumberFormat">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.NumberFormatInfo NumberFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.NumberFormatInfo NumberFormat" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.NumberFormat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property NumberFormat As NumberFormatInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::NumberFormatInfo ^ NumberFormat { System::Globalization::NumberFormatInfo ^ get(); void set(System::Globalization::NumberFormatInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NumberFormat : System.Globalization.NumberFormatInfo with get, set" Usage="System.Globalization.CultureInfo.NumberFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.NumberFormatInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Globalization.NumberFormatInfo" />，它定义适合区域性的、显示数字、货币和百分比的格式。</summary>
        <value>一个 <see cref="T:System.Globalization.NumberFormatInfo" />，它定义适合区域性的、显示数字、货币和百分比的格式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overrides"></a>Overrides  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 值<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性和<xref:System.Globalization.CultureInfo.NumberFormat%2A>之前用户可以访问该属性不会计算属性。 如果用户使用控制面板来运行，然后访问该应用程序时，将当前区域性更改为新区域性<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>或<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性，该应用程序检索新区域性的默认值。 不重写原始区域性。 若要保留原始的当前区域性的重写设置，应用程序应访问<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>和<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性，然后才能更改当前区域性。  
  
   
  
## Examples  
 下面的代码示例显示了 CultureInfo.Clone 还克隆<xref:System.Globalization.DateTimeFormatInfo>并<xref:System.Globalization.NumberFormatInfo>与关联的实例<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CPP/yslin_cultureinfo_clone.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/CS/yslin_cultureinfo_clone.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Clone/VB/yslin_cultureinfo_clone.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该属性设置为 null。</exception>
        <exception cref="T:System.InvalidOperationException">设置了 <see cref="P:System.Globalization.CultureInfo.NumberFormat" /> 属性或任何 <see cref="T:System.Globalization.NumberFormatInfo" /> 属性，但 <see cref="T:System.Globalization.CultureInfo" /> 是只读的。</exception>
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="M:System.Globalization.CultureInfo.GetFormat(System.Type)" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
      </Docs>
    </Member>
    <Member MemberName="OptionalCalendars">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.Calendar[] OptionalCalendars { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.Calendar[] OptionalCalendars" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.OptionalCalendars" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OptionalCalendars As Calendar()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Globalization::Calendar ^&gt; ^ OptionalCalendars { cli::array &lt;System::Globalization::Calendar ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OptionalCalendars : System.Globalization.Calendar[]" Usage="System.Globalization.CultureInfo.OptionalCalendars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.Calendar[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该区域性可使用的日历的列表。</summary>
        <value>类型为 <see cref="T:System.Globalization.Calendar" /> 的数组，表示当前 <see cref="T:System.Globalization.CultureInfo" /> 代表的区域性所使用的日历。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你的应用程序更改当前使用的日历<xref:System.Globalization.CultureInfo>通过设置<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A>的属性<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>，这是实例<xref:System.Globalization.DateTimeFormatInfo>类。 新的日历必须是一个中列出的日历<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>。 <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> 此外包括其他属性的自定义日期和时间格式设置与该<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何确定<xref:System.Globalization.GregorianCalendar>区域性支持的版本。  
  
 [!code-cpp[System.Globalization.GregorianCalendarTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.GregorianCalendarTypes/CPP/gregoriancalendartypes.cpp#1)]
 [!code-csharp[System.Globalization.GregorianCalendarTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.GregorianCalendarTypes/CS/gregoriancalendartypes.cs#1)]
 [!code-vb[System.Globalization.GregorianCalendarTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.GregorianCalendarTypes/VB/gregoriancalendartypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.Calendar" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CultureInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CultureInfo ^ Parent { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示当前 <see cref="T:System.Globalization.CultureInfo" /> 的父区域性的 <see cref="T:System.Globalization.CultureInfo" />。</summary>
        <value>表示当前 <see cref="T:System.Globalization.CultureInfo" /> 的父区域性的 <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 区域性具有层次结构中的特定区域性的父是非特定区域性，是一个非特定区域性的父<xref:System.Globalization.CultureInfo.InvariantCulture%2A>，和的父<xref:System.Globalization.CultureInfo.InvariantCulture%2A>为固定区域性本身。 父区域性包含仅的信息所共有及其子级集。  
  
 如果为特定区域性资源不可用在系统中，使用非特定区域性的资源。 如果非特定区域性资源不可用，则使用嵌入在主程序集中的资源。 资源回退进程的详细信息，请参阅[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)。  
  
   
  
## Examples  
 下面的代码示例确定使用中文语言每个特定区域性的父区域性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.Parent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Parent/CPP/parentculture.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.Parent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Parent/CS/parentculture.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.Parent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.Parent/VB/parentculture.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Globalization.CultureInfo.#ctor" />
        <altmember cref="M:System.Globalization.CultureInfo.CreateSpecificCulture(System.String)" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InstalledUICulture" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo ReadOnly (System.Globalization.CultureInfo ci);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CultureInfo ReadOnly(class System.Globalization.CultureInfo ci) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.ReadOnly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (ci As CultureInfo) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CultureInfo ^ ReadOnly(System::Globalization::CultureInfo ^ ci);" />
      <MemberSignature Language="F#" Value="static member ReadOnly : System.Globalization.CultureInfo -&gt; System.Globalization.CultureInfo" Usage="System.Globalization.CultureInfo.ReadOnly ci" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ci" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="ci">要包装的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</param>
        <summary>返回指定的 <see cref="T:System.Globalization.CultureInfo" /> 对象周围的只读包装器。</summary>
        <returns><paramref name="ci" /> 周围的只读 <see cref="T:System.Globalization.CultureInfo" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此包装器可防止对进行任何修改`ci`，或返回的对象`ci`。<xref:System.Globalization.CultureInfo.DateTimeFormat%2A> 和`ci`。<xref:System.Globalization.CultureInfo.NumberFormat%2A> 属性。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Globalization.CultureInfo.ReadOnly%2A>方法可帮助保护<xref:System.Globalization.DateTimeFormatInfo>并<xref:System.Globalization.NumberFormatInfo>与关联的实例<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/CPP/yslin_cultureinfo_readonly.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/CS/yslin_cultureinfo_readonly.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.ReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.ReadOnly/VB/yslin_cultureinfo_readonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ci" /> 为 null。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="TextInfo">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.TextInfo TextInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.TextInfo TextInfo" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.TextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TextInfo As TextInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::TextInfo ^ TextInfo { System::Globalization::TextInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextInfo : System.Globalization.TextInfo" Usage="System.Globalization.CultureInfo.TextInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.TextInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取定义与区域性关联的书写体系的 <see cref="T:System.Globalization.TextInfo" />。</summary>
        <value>定义与区域性关联的书写体系的 <see cref="T:System.Globalization.TextInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo.TextInfo%2A>属性提供特定于区域性的大小写的字符串的信息。 若要执行非区域性敏感型大小写，该应用程序应使用<xref:System.Globalization.CultureInfo.TextInfo%2A>属性的<xref:System.Globalization.CultureInfo.InvariantCulture%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Globalization.CultureInfo>西班牙语 （西班牙） 与国际排序顺序，另一个<xref:System.Globalization.CultureInfo>与传统的排序顺序。  
  
 [!code-cpp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CPP/spanishspain.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo_esES#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/CS/spanishspain.cs#1)]
 [!code-vb[System.Globalization.CultureInfo_esES#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo_esES/VB/spanishspain.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.TextInfo" />
      </Docs>
    </Member>
    <Member MemberName="ThreeLetterISOLanguageName">
      <MemberSignature Language="C#" Value="public virtual string ThreeLetterISOLanguageName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ThreeLetterISOLanguageName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ThreeLetterISOLanguageName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ThreeLetterISOLanguageName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreeLetterISOLanguageName : string" Usage="System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Globalization.CultureInfo" /> 的语言的由三个字母构成的 ISO 639-2 代码。</summary>
        <value>当前 <see cref="T:System.Globalization.CultureInfo" /> 的语言的由三个字母构成的 ISO 639-2 代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，英语的三个字母缩写形式是"eng"。  
  
> [!NOTE]
>  当进程之间通信或保存数据通常是更好地为使用完整<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>。 使用只包含语言可能会丢失上下文和数据。  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="ThreeLetterWindowsLanguageName">
      <MemberSignature Language="C#" Value="public virtual string ThreeLetterWindowsLanguageName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ThreeLetterWindowsLanguageName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ThreeLetterWindowsLanguageName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ThreeLetterWindowsLanguageName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreeLetterWindowsLanguageName : string" Usage="System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 Windows API 中定义的由三个字母构成的语言代码。</summary>
        <value>Windows API 中定义的由三个字母构成的语言代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 Windows API 方法相同的值`GetLocaleInfo`的值。 例如，英语 （美国） Windows API 中定义的三个字母代码是"enu"。  
  
> [!NOTE]
>  当进程之间通信或保存数据通常是更好地为使用完整<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>。 使用只包含语言可能会丢失上下文和数据。  
  
   
  
## Examples  
 下面的代码示例显示了非特定区域性的多个属性。  
  
> [!NOTE]
>  此示例分别显示的较旧 ZH-CHS 和 ZH-CHT 0x0004 和 0x7C04 区域性标识符，使用的区域性名称。 但是，Windows Vista 应用程序应使用-Zh-hans 名称而不是 ZH-CHS 和 Zh-hant 名称而不是 ZH-CHT。 -Zh-hans 和 Zh-hant 名称表示当前的标准，并且应使用，除非使用较旧名称的理由需要。  
  
 [!code-cpp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CPP/getcultures.cpp#1)]
 [!code-csharp[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/CS/getcultures.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.GetCultures#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CultureInfo.GetCultures/VB/getcultures.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CultureInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cultureInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个字符串，该字符串包含当前 <see cref="T:System.Globalization.CultureInfo" /> 的名称，其格式为 languagecode2 -country/regioncode2。</summary>
        <returns>包含当前 <see cref="T:System.Globalization.CultureInfo" /> 名称的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。 它将返回传递到的区域性名称的规范化的版本<xref:System.Globalization.CultureInfo.%23ctor%28System.String%29>或<xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29>构造函数或设置为<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A>或<xref:System.Globalization.CultureInfo.GetCultureInfo%28System.String%29>方法。 它将结果字符串规范化的转换中的字符*languagecode2*到中的小写和转换字符*country/regioncode2*为大写如有必要。  
  
 中列出了在 Windows 系统上的预定义的区域性名称**语言标记**中的列[支持的 Windows 的语言/区域名称的列表](https://docs.microsoft.com/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c)。 区域性名称遵循由定义的标准[BCP 47](https://tools.ietf.org/html/bcp47)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ToString" />
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
      </Docs>
    </Member>
    <Member MemberName="TwoLetterISOLanguageName">
      <MemberSignature Language="C#" Value="public virtual string TwoLetterISOLanguageName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TwoLetterISOLanguageName" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TwoLetterISOLanguageName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TwoLetterISOLanguageName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TwoLetterISOLanguageName : string" Usage="System.Globalization.CultureInfo.TwoLetterISOLanguageName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Globalization.CultureInfo" /> 的语言的由两个字母构成的 ISO 639-1 代码。</summary>
        <value>当前 <see cref="T:System.Globalization.CultureInfo" /> 的语言的由两个字母构成的 ISO 639-1 代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，英语的两字母缩写形式为"en"。 <xref:System.Globalization.CultureInfo.TwoLetterISOLanguageName%2A>用于固定区域性的属性值为"iv"。  
  
> [!NOTE]
>  当进程之间通信或保存数据通常是更好地为使用完整<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>。 使用只包含语言可能会丢失上下文和数据。  
  
 如果 ISO 639-1 未定义特定区域性的两个字母的语言代码<xref:System.Globalization.CultureInfo.TwoLetterISOLanguageName%2A>属性将返回三个或多个字母组成的字符串。 有关详细信息，请参阅示例。  
  
   
  
## Examples  
 以下示例列出了区域性其<xref:System.Globalization.CultureInfo.TwoLetterISOLanguageName%2A>属性不是两个字母的语言代码组成。  
  
 [!code-csharp[System.Globalization.CultureInfo.TwoLetterISOLanguageName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.twoletterisolanguagename/cs/twoletterisolanguagename1.cs#1)]
 [!code-vb[System.Globalization.CultureInfo.TwoLetterISOLanguageName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.twoletterisolanguagename/vb/twoletterisolanguagename1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.Name" />
        <altmember cref="P:System.Globalization.CultureInfo.DisplayName" />
        <altmember cref="P:System.Globalization.CultureInfo.NativeName" />
        <altmember cref="P:System.Globalization.CultureInfo.EnglishName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName" />
        <altmember cref="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName" />
      </Docs>
    </Member>
    <Member MemberName="UseUserOverride">
      <MemberSignature Language="C#" Value="public bool UseUserOverride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseUserOverride" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CultureInfo.UseUserOverride" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UseUserOverride As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseUserOverride { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseUserOverride : bool" Usage="System.Globalization.CultureInfo.UseUserOverride" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Globalization.CultureInfo" /> 对象是否使用用户选定的区域性设置。</summary>
        <value>如果当前 <see cref="T:System.Globalization.CultureInfo" /> 使用用户选定的区域性设置，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户可以选择重写一些与 Windows 通过控制面板的区域和语言选项部分的当前区域性关联的值。 例如，用户可以选择以不同格式显示日期，或使用一种货币而不是默认区域性。  
  
 如果<xref:System.Globalization.CultureInfo.UseUserOverride%2A>是`true`和指定的区域性匹配的 Windows，当前区域性<xref:System.Globalization.CultureInfo>使用这些重写值，其中包括用户设置的属性<xref:System.Globalization.DateTimeFormatInfo>返回实例<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性，和的属性<xref:System.Globalization.NumberFormatInfo>返回实例<xref:System.Globalization.CultureInfo.NumberFormat%2A>属性。 如果用户设置与不兼容与关联的区域性<xref:System.Globalization.CultureInfo>，例如，如果在所选的日历不是之一<xref:System.Globalization.CultureInfo.OptionalCalendars%2A>，方法的结果和属性的值是不确定。  
  
 当设置此属性<xref:System.Globalization.CultureInfo>创建。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>