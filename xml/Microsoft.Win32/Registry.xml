<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f305c4ddd19e71fb1c769c3f0ba41404d364554" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67238673" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供表示 Windows 注册表中的根项的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象，并提供访问项/值对的 <see langword="static" /> 方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类提供在运行 Windows 的计算机上的注册表中找到的标准的根键集。 注册表是有关应用程序、 用户和默认的系统设置的信息存储设施。 例如，应用程序可以使用注册表来存储需要关闭应用程序后, 保留的信息以及重新加载应用程序时访问相同的信息。 例如，可以将颜色首选项、 屏幕位置或窗口的大小。 可以通过将信息存储在注册表中的其他位置来控制此数据为每个用户。  
  
 基本或根<xref:Microsoft.Win32.RegistryKey>实例公开的`Registry`类描述子项和注册表中的值的基本存储机制。 所有键都是只读的因为注册表取决于其存在。 公开的项`Registry`是：  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 存储用户首选项有关的信息。  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 存储在本地计算机的配置信息。  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 类型 （和类） 的相关信息存储和其属性。  
  
 <xref:Microsoft.Win32.Registry.Users>  
 存储有关默认用户配置的信息。  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 存储的软件组件的性能信息。  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 存储非用户特定的硬件信息。  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 将动态数据存储。  
  
 一旦您确定要在其下存储/检索信息从注册表根项，可以使用<xref:Microsoft.Win32.RegistryKey>类来添加或删除子项，并处理给定密钥的值。  
  
 硬件设备可以将信息放在自动使用插接口注册表中。 安装设备驱动程序软件可以通过写入到标准 Api 在注册表中放的信息。  
  
## <a name="static-methods-for-getting-and-setting-values"></a>用于获取和设置值的静态方法  
 在.NET Framework 2.0 版中，<xref:Microsoft.Win32.Registry>类还包含`static`<xref:Microsoft.Win32.Registry.GetValue%2A>和<xref:Microsoft.Win32.Registry.SetValue%2A>用于设置和检索从注册表项值的方法。 这些方法打开和关闭注册表项的每个它们使用，因此它们不会执行的时间以及中的类似方法<xref:Microsoft.Win32.RegistryKey>类，当您访问大量的值。  
  
 <xref:Microsoft.Win32.RegistryKey>类还提供了可以设置注册表项，来检索它之前, 测试一个值的数据类型和删除项的 Windows 访问控制安全性的方法。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示根项，第二个示例演示`static`<xref:Microsoft.Win32.Registry.GetValue%2A>和<xref:Microsoft.Win32.Registry.SetValue%2A>方法。  
  
 示例 1  
  
 下面的代码示例演示如何检索的 HKEY_USERS 项、 子项和打印它们在屏幕上的名称。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作`RegistryKey`来操作该注册表项。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例将多个数据类型的值存储在一个示例密钥，创建密钥，因为它会检索并显示的值。 该示例演示如何存储和检索默认 （无名） 的名称/值对，以及如何使用`defaultValue`不存在名称/值对时。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义文档的类型（或类）以及与那些类型关联的属性。 该字段读取 Windows 注册表基项 HKEY_CLASSES_ROOT。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 常规应用程序和 OLE 应用程序使用此项下存储的数据。 此密钥还可以提供向后的兼容性 Windows 3.1 注册数据库存储 DDE 和 OLE 支持的信息。 文件查看器和用户界面扩展将其 OLE 类标识符存储在此项，并在此注册表注册处理服务器。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关非用户特定的硬件的配置信息。 该字段读取 Windows 注册表基项 HKEY_CURRENT_CONFIG。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员映射到中的子项<xref:Microsoft.Win32.Registry.LocalMachine>。  
  
 使用此成员的示例是存储其数据，具体取决于是否在系统连接到网络的不同的服务器名称的应用程序。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关当前用户首选项的信息。 此字段读取 Windows 注册表基项 HKEY_CURRENT_USER。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存储在此项的信息包括环境变量和程序组、 颜色、 打印机、 网络连接和应用程序首选项有关的数据的设置。 此密钥，可以更轻松地建立当前用户的设置。 在此项时，软件供应商存储要在其应用程序中使用的当前特定于用户的首选项。 Microsoft，例如，创建要用于每个应用程序创建其自己的 Microsoft 密钥下的子项及其应用程序 HKEY_CURRENT_USER\Software\Microsoft 项。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含动态注册表数据。 该字段读取 Windows 注册表基项 HKEY_DYN_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me 注册表支持静态数据 （这存储在注册表中的磁盘上） 和动态数据 （如性能统计信息需要经常更改）。 此动态数据区域可以远程和本地运行的 Win32 应用程序是允许虚拟设备驱动程序 (VxDs) 提供实时数据的机制。 它还允许系统监视器在远程 Windows 98/Windows Me 系统上提供性能统计信息。  
  
 Vxd 不限于性能数据。 他们可以提供他们想要将从传递 Ring 0 到 3 环高效而无需占用 CPU 的任何数据。 注册表支持通过存储指向一个函数，返回一个值 （或多个值） 的动态数据。 当注册表调用查询值与动态键关联，将调用该函数返回的所需的值。  
  
> [!NOTE]
>  动态密钥引入了在 Microsoft Windows 95 中以处理动态注册表数据。 支持仅在 Windows 98/Windows me 一起提供。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。 请注意，此示例中可能不返回任何结果，因为可能没有可用的动态数据，或者你可能未运行 Windows 98 / me 一起提供。 在其他系统上，使用此密钥可能会导致错误。  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">操作系统不支持动态数据，即操作系统非 Windows 98、Windows 98 Second Edition 或 Windows Millennium Edition。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="defaultValue">当 <paramref name="valueName" /> 不存在时返回的值。</param>
        <summary>检索与指定的注册表项中的指定名称关联的值。 如果在指定的项中未找到该名称，则返回您提供的默认值；或者，如果指定的项不存在，则返回 <see langword="null" />。</summary>
        <returns>如果由 <paramref name="keyName" /> 指定的子项不存在，则返回 <see langword="null" />；否则，返回与 <paramref name="valueName" /> 关联的值；或者，如果未找到 <paramref name="defaultValue" />，则返回 <paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串`valueName`不区分大小写。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称相关联的值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要检索此未命名的值，指定`null`或空字符串 ("") 为`valueName`。  
  
 有效的根名称是 HKEY_CURRENT_USER、 HKEY_LOCAL_MACHINE、 HKEY_CLASSES_ROOT，HKEY_USERS、 HKEY_PERFORMANCE_DATA、 HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。 例如，在 Visual Basic 中的字符串"HKEY_CURRENT_USER\MyTestKey"访问子项"MyTestKey"HKEY_CURRENT_USER 根目录中的键/值对。  
  
 当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩充字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它将展开使用本地环境中的数据的环境字符串。 如果已存储为一个字符串值，该值包含对环境变量的可展开引用 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，<xref:Microsoft.Win32.RegistryKey.GetValue%2A>不会展开它。 检索通过调用后，可以扩展此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  从 HKEY_PERFORMANCE_DATA 中检索数据的建议的方法是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A>并<xref:Microsoft.Win32.Registry.SetValue%2A>方法打开和关闭注册表项的方法以及它们使用，因此它们不会执行每次<xref:Microsoft.Win32.RegistryKey>类如果访问大量的值。  
  
 <xref:Microsoft.Win32.RegistryKey> 此外提供允许您将访问控制列表 (ACL) 添加到注册表项，来检索它之前, 测试一个值的数据类型和删除项的方法。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例密钥，创建密钥，因为它会检索并显示的值。 该示例演示如何存储和检索默认 （无名） 的名称/值对，以及如何使用`defaultValue`不存在名称/值对时。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取注册表项的类型 REG_EXPAND_SZ。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含本地计算机的配置数据。 该字段读取 Windows 注册表基项 HKEY_LOCAL_MACHINE。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` 包含五个密钥：  
  
 硬件  
 介绍在计算机中的物理硬件设备驱动程序使用该硬件，并映射和链接，用户模式代码的内核模式驱动程序的相关的数据的方法。 此密钥中的所有数据将重新都创建每次启动系统。 说明子项介绍实际的计算机硬件。 DeviceMap 子项包含格式特定于驱动程序的特定类的其他数据。 ResourceMap 子项描述的设备驱动程序声明的硬件资源。 Windows NT 诊断程序 (Winmsdp.exe) 可以报告其内容的易读的窗体中。  
  
 SAM  
 目录服务数据库的用户和组帐户，以及在 Windows 2000 Server 域的安全信息 （SAM 是安全帐户管理器，名为目录服务数据库）。  
  
 安全性  
 包含的本地安全策略，例如，特定的用户权限。 只能由 Windows 2000 安全子系统使用此密钥。  
  
 软件  
 每台计算机软件数据库。 此项包含有关与各种项的其他配置数据一起在本地计算机上安装软件的数据。  
  
 系统  
 控制系统启动、 设备驱动程序加载、 Windows 2000 服务和操作系统的行为。  
  
 按照约定，如果在存在相似的数据<xref:Microsoft.Win32.Registry.CurrentUser>并在列表视图<xref:Microsoft.Win32.Registry.LocalMachine>中的数据<xref:Microsoft.Win32.Registry.CurrentUser>优先。 但是，在此项的值可以还扩展 （而不是替换） Registry.LocalMachine 中的数据。 此外，某些项 （如设备驱动程序加载项） 是外部 Registry.LocalMachine 它们出现的情况下没有意义。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含软件组件的性能信息。 该字段读取 Windows 注册表基项 HKEY_PERFORMANCE_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个软件组件创建其对象计数器时它在安装，并在执行时将计数器数据写入的项。 可以访问此数据，如可访问任何其他注册表数据，使用<xref:Microsoft.Win32.RegistryKey>函数。  
  
 尽管使用注册表收集性能数据，但数据不会存储在注册表数据库。 相反，使用此密钥访问注册表会导致系统从相应的系统对象管理器收集的数据。  
  
 若要从本地系统获取性能数据，请使用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法，与 Registry.PerformanceData 键。 第一次调用将打开 （您不必显式首次打开此项） 的密钥。 但是，务必使用<xref:Microsoft.Win32.RegistryKey.Close%2A>方法关闭该密钥的句柄完成后获取性能数据。 用户不能安装或删除的软件组件，其性能数据正在使用中。  
  
 若要从远程系统获取性能数据，必须使用<xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A>方法，与远程系统和 Registry.PerformanceData 密钥的计算机名称。 此调用会检索表示远程系统的性能数据的密钥。 若要检索的数据，调用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>使用此密钥，而不是 Registry.PerformanceData 密钥。  
  
> [!NOTE]
>  在 Windows Server 2003 中，用户必须至少属于 Performance Monitor Users 组才能访问此基项的子项。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。 请注意此示例中通常可以返回任何结果，因为可能会不有任何性能数据。  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置注册表项中的名称/值对的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例密钥，创建密钥，因为它会检索并显示的值。 该示例演示如何存储和检索默认 （无名） 的名称/值对，以及如何使用`defaultValue`不存在名称/值对时。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <summary>设置指定的注册表项的指定名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则`valueName`参数将不再限制为最多 255 个字符; 但是，`keyName`参数仍具有 255 个字符限制。  
  
 由于许多值可以存储在注册表中的每个项，必须使用`valueName`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称相关联的值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要设置此未命名的值，指定`null`或空字符串 ("") 为`valueName`。  
  
 如果`valueName`不存在的项中创建和关联的值设置为`value`。  
  
 如果`keyName`指定子项不存在，在指定的根中创建子项。 例如，在 Visual Basic 中的字符串"HKEY_CURRENT_USER\MyTestKey"创建子项"MyTestKey"在 HKEY_CURRENT_USER 根目录。 字符串"HKEY_CURRENT_USER\MyTestKey\Key2\Key3"创建"MyTestKey"、"MyTestKey\Key2"和"MyTestKey\Key2\Key3"嵌套的子项。  
  
 有效的根名称包含 HKEY_CURRENT_USER、 HKEY_LOCAL_MACHINE、 HKEY_CLASSES_ROOT，HKEY_USERS、 HKEY_PERFORMANCE_DATA、 HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法打开注册表项、 设置的值，并关闭该密钥每次调用它。 如果您需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>方法可能会提供更好的性能。 <xref:Microsoft.Win32.RegistryKey>类还提供了方法，您可以将访问控制列表 (ACL) 添加到注册表项，以检索它之前, 测试一个值的数据类型并删除密钥。  
  
 此重载<xref:Microsoft.Win32.Registry.SetValue%2A>将 64 位整数存储为字符串 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)。 若要存储为 64 位数字<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>值，请使用<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法重载。  
  
 此重载<xref:Microsoft.Win32.Registry.SetValue%2A>存储所有字符串值作为<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>对象，即使它们包含对环境变量可展开的引用。 若要保存为可展开的字符串的字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，使用<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法重载。  
  
 此重载是等效于调用<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法的重载<xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me)，注册表不是 Unicode，并不是所有 Unicode 字符都是有效的所有代码页。 最佳的匹配项都替换为对当前代码页无效的 Unicode 字符。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例密钥，创建密钥，因为它会检索并显示的值。 该示例演示如何存储和检索默认 （无名） 的名称/值对，以及如何使用`defaultValue`不存在名称/值对时。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。  
  
- 或 - 
 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入；例如，它是根级节点。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <param name="valueKind">在存储数据时使用的注册表数据类型。</param>
        <summary>通过使用指定的注册表数据类型，设置该指定的注册表项的名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则`valueName`参数将不再限制为最多 255 个字符; 但是，`keyName`参数将继续具有 255 个字符限制。  
  
 由于许多值可以存储在注册表中的每个项，必须使用`valueName`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称相关联的值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要设置此未命名的值，指定`null`或空字符串 ("") 为`valueName`。  
  
 如果`valueName`不存在的项中创建和关联的值设置为`value`。  
  
 如果`keyName`指定子项不存在，在指定的根中创建子项。 例如，在 Visual Basic 中的字符串"HKEY_CURRENT_USER\MyTestKey"创建子项"MyTestKey"在 HKEY_CURRENT_USER 根目录。 字符串"HKEY_CURRENT_USER\MyTestKey\Key2\Key3"创建"MyTestKey"、"MyTestKey\Key2"和"MyTestKey\Key2\Key3"嵌套的子项。  
  
 有效的根名称包含 HKEY_CURRENT_USER、 HKEY_LOCAL_MACHINE、 HKEY_CLASSES_ROOT，HKEY_USERS、 HKEY_PERFORMANCE_DATA、 HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法打开注册表项、 设置的值，并关闭该密钥每次调用它。 如果您需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>方法可能会提供更好的性能。 <xref:Microsoft.Win32.RegistryKey>类还提供了方法，您可以将访问控制列表 (ACL) 添加到注册表项，以检索它之前, 测试一个值的数据类型并删除密钥。  
  
 如果指定的类型`value`不匹配指定`valueKind`，且不能为数据转换，<xref:System.ArgumentException>引发。 例如，可以存储<xref:System.Int64?displayProperty=nameWithType>作为<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但前提是其值小于最大值<xref:System.Int32?displayProperty=nameWithType>。 不能存储作为单个字符串值<xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如果已装箱的值将传递进行<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>，执行该转换使用固定区域性。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me)，注册表不是 Unicode，并不是所有 Unicode 字符都是有效的所有代码页。 最佳的匹配项都替换为对当前代码页无效的 Unicode 字符。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例密钥，创建密钥，因为它会检索并显示的值。 该示例演示如何存储和检索默认 （无名） 的名称/值对，以及如何使用`defaultValue`不存在名称/值对时。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。  
  
- 或 - 
 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。  
  
- 或 - 
<paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入（例如，它是根级节点，或者未用写访问权限打开该项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关默认用户配置的信息。 该字段读取 Windows 注册表基项 HKEY_USERS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此密钥包含为每个用户的计算机的分支。 默认配置被提供本地计算机上为新用户并为默认值当前用户，如果用户未更改首选项。 因为 Windows 98 / 我还支持 Registry.Users，应用程序可以在它们在 Windows 2000 的相同方式访问特定于用户的信息。 每个用户的信息存储在单独的文件，可以存储在本地或网络服务器上。 Windows 98 / 我可以将此文件复制到用户的当前系统，以便设置可以在一台计算机之间移动使用的用户。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称在屏幕上的打印。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法来创建感兴趣的特定子项的一个实例。 然后，可以使用中的其他操作<xref:Microsoft.Win32.RegistryKey>来操作该注册表项。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>