<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e57106e06a17e4a92a26615648326f471aa90dd" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63908814" /></Metadata><TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="d8ea4-101">哈希集中的元素类型。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-101">The type of elements in the hash set.</span></span></typeparam>
    <summary><span data-ttu-id="d8ea4-102">表示值的集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-102">Represents a set of values.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-103"><xref:System.Collections.Generic.HashSet%601>类提供了高性能设置操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="d8ea4-104">一组是不包含任何重复的元素的集合，并且其元素是顺序不分先后。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d8ea4-105"><xref:System.Collections.Generic.HashSet%601> 实现<xref:System.Collections.Generic.IReadOnlyCollection%601>开头的接口[!INCLUDE[net_v46](~/includes/net-v46-md.md)]; 在以前版本的.NET Framework 中，<xref:System.Collections.Generic.HashSet%601>类未实现此接口。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="d8ea4-106">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-107">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-108"><xref:System.Collections.Generic.HashSet%601>类的数学集的模型为基础，并提供高性能设置的操作类似于访问的密钥<xref:System.Collections.Generic.Dictionary%602>或<xref:System.Collections.Hashtable>集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="d8ea4-109">简单来说，<xref:System.Collections.Generic.HashSet%601>类可以认为的<xref:System.Collections.Generic.Dictionary%602>不包含值的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="d8ea4-110">一个<xref:System.Collections.Generic.HashSet%601>集合不排序，并且不能包含重复元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="d8ea4-111">如果顺序或元素重复，更注重应用程序的性能，请考虑使用<xref:System.Collections.Generic.List%601>类一起使用<xref:System.Collections.Generic.List%601.Sort%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="d8ea4-112"><xref:System.Collections.Generic.HashSet%601> 提供了许多数学设置操作，如集添加 （联合），并设置减法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="d8ea4-113">下表列出了所提供<xref:System.Collections.Generic.HashSet%601>操作和及其数学等效项。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="d8ea4-114">Hashset 集合操作</span><span class="sxs-lookup"><span data-stu-id="d8ea4-114">HashSet operation</span></span>|<span data-ttu-id="d8ea4-115">数学等效项</span><span class="sxs-lookup"><span data-stu-id="d8ea4-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="d8ea4-116">Union 或将其设置的添加</span><span class="sxs-lookup"><span data-stu-id="d8ea4-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="d8ea4-117">交集</span><span class="sxs-lookup"><span data-stu-id="d8ea4-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="d8ea4-118">集减法</span><span class="sxs-lookup"><span data-stu-id="d8ea4-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="d8ea4-119">余集</span><span class="sxs-lookup"><span data-stu-id="d8ea4-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="d8ea4-120">列出的 set 操作中，除了<xref:System.Collections.Generic.HashSet%601>类还提供了用于确定集是否相等，重叠的集，方法和一组是子集或另一个集的超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
<span data-ttu-id="d8ea4-121">**仅限.NET framework:** 对于非常大<xref:System.Collections.Generic.HashSet%601>对象，可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`的属性[ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration 元素`true`中运行时环境。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-121">**.NET Framework only:** For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="d8ea4-122">从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则<xref:System.Collections.Generic.HashSet%601>类实现<xref:System.Collections.Generic.ISet%601>接口。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="d8ea4-123">HashSet 和 LINQ Set 运算</span><span class="sxs-lookup"><span data-stu-id="d8ea4-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="d8ea4-124">LINQ 提供了对访问`Distinct`， `Union`，`Intersect`并`Except`set 实现的任何数据源上的操作<xref:System.Collections.IEnumerable>或<xref:System.Linq.IQueryable>接口。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="d8ea4-125"><xref:System.Collections.Generic.HashSet%601> 提供了更大、 更可靠集合操作的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="d8ea4-126">例如，<xref:System.Collections.Generic.HashSet%601>提供的比较，例如<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>和<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="d8ea4-127">LINQ 的主要区别将操作设置并<xref:System.Collections.Generic.HashSet%601>操作是 LINQ set 运算始终返回一个新<xref:System.Collections.Generic.IEnumerable%601>集合，而<xref:System.Collections.Generic.HashSet%601>等效的方法修改当前的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="d8ea4-128">通常情况下，如果必须创建新组或应用程序需要访问仅向提供的组操作，使用 LINQ 设置对任何操作<xref:System.Collections.Generic.IEnumerable%601>将足以集合或数组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="d8ea4-129">但是，如果应用程序需要额外的一组操作访问权限或不需要或不必要创建一个新集合，使用<xref:System.Collections.Generic.HashSet%601>类。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="d8ea4-130">下表显示<xref:System.Collections.Generic.HashSet%601>操作和其等效的 LINQ set 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="d8ea4-131">Hashset 集合操作</span><span class="sxs-lookup"><span data-stu-id="d8ea4-131">HashSet operation</span></span>|<span data-ttu-id="d8ea4-132">LINQ 等效项</span><span class="sxs-lookup"><span data-stu-id="d8ea4-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="d8ea4-133">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="d8ea4-134">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="d8ea4-135">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="d8ea4-136">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="d8ea4-137">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="d8ea4-138">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="d8ea4-139">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="d8ea4-140">未提供。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-141">下面的示例演示如何合并两个不同的集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="d8ea4-142">此示例创建两个<xref:System.Collections.Generic.HashSet%601>对象，它们分别奇数和偶数数字来填充它们。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="d8ea4-143">第三个<xref:System.Collections.Generic.HashSet%601>集，其中包含偶数值，从创建对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="d8ea4-144">该示例然后调用<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>方法，它将奇数的数字组添加到第三个组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d8ea4-145">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-146">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的一个新实例，该实例为空并使用集类型的默认相等比较器。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-147">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-148">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-149">此构造函数是 o （1） 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-150">下面的示例演示如何创建并填充两个<xref:System.Collections.Generic.HashSet%601>对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="d8ea4-151">此示例摘自一个更大的示例为提供<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="d8ea4-152">其元素被复制到新集中的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-152">The collection whose elements are copied to the new set.</span></span></param>
        <summary><span data-ttu-id="d8ea4-153">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的一个新实例，该实例使用集类型的默认相等比较器，包含从指定的集合复制的元素，并且有足够的容量容纳所复制的这些元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-154">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-155">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-156">如果`collection`包含重复项，则集将包含一个唯一的每个元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="d8ea4-157">将不引发任何异常。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-157">No exception will be thrown.</span></span> <span data-ttu-id="d8ea4-158">因此，结果集的大小不是相同的大小`collection`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="d8ea4-159">此构造函数是 O (`n`) 操作，其中`n`是中的元素数`collection`参数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-160">下面的示例演示如何创建<xref:System.Collections.Generic.HashSet%601>从一组现有的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="d8ea4-161">在此示例中，两个集都具有奇数和偶数整数分别创建。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="d8ea4-162">第三个<xref:System.Collections.Generic.HashSet%601>然后偶数集从创建对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-163"><paramref name="collection" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-163"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="d8ea4-164">在比较集中的值时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现，或为 <see langword="null" /> 以使用集类型的默认 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="d8ea4-165">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的一个新实例，该实例为空并使用集类型的指定相等比较器。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-166">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-167">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-168">此构造函数是 o （1） 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="d8ea4-169"><see cref="T:System.Collections.Generic.HashSet`1" /> 的初始大小</span><span class="sxs-lookup"><span data-stu-id="d8ea4-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <summary><span data-ttu-id="d8ea4-170">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的一个新实例，该实例为空，但已为 <paramref name="capacity" /> 项保留空间并使用集类型的默认相等比较器。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-171">因为调整大小是代价较高 （需要研究），这会尝试尽可能地减少需要通过设置值的基础的初始容量调整大小`capacity`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="d8ea4-172">其元素被复制到新集中的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-172">The collection whose elements are copied to the new set.</span></span></param>
        <param name="comparer"><span data-ttu-id="d8ea4-173">在比较集中的值时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现，或为 <see langword="null" /> 以使用集类型的默认 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="d8ea4-174">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的一个新实例，该实例使用集类型的指定相等比较器，包含从指定的集合复制的元素，并且有足够的容量容纳所复制的这些元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-175">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-176">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-177">如果`collection`包含重复项，则集将包含一个唯一的每个元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="d8ea4-178">将不引发任何异常。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-178">No exception will be thrown.</span></span> <span data-ttu-id="d8ea4-179">因此，结果集的大小不是相同的大小`collection`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="d8ea4-180">此构造函数是 O (`n`) 操作，其中`n`是中的元素数`collection`参数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-181">下面的示例使用所提供<xref:System.Collections.Generic.IEqualityComparer%601>的元素允许不区分大小写比较<xref:System.Collections.Generic.HashSet%601>车辆类型的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-182"><paramref name="collection" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-182"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="d8ea4-183"><see cref="T:System.Collections.Generic.HashSet`1" /> 的初始大小</span><span class="sxs-lookup"><span data-stu-id="d8ea4-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <param name="comparer"><span data-ttu-id="d8ea4-184">比较集中的值时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现；如果要使用集类型的默认 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现，则为 null（在 Visual Basic 中为 Nothing）。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="d8ea4-185">初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的新实例，该实例使用集类型的指定相等比较器，并且其容量足以容纳 <paramref name="capacity" /> 元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-186">因为调整大小是代价较高 （需要研究），这会尝试尽可能地减少需要通过设置值的基础的初始容量调整大小`capacity`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="d8ea4-187"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象，其中包含序列化 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象所需的信息。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="d8ea4-188"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 结构，其中包含与 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象关联的序列化流的源和目标。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-189">用序列化数据初始化 <see cref="T:System.Collections.Generic.HashSet`1" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-190">反序列化来重建通过流传输的对象期间调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="d8ea4-191">有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="d8ea4-192">要添加到集中的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-192">The element to add to the set.</span></span></param>
        <summary><span data-ttu-id="d8ea4-193">将指定的元素添加到集中。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-193">Adds the specified element to a set.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-194">如果该元素添加到 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中则为 <see langword="true" />；如果该元素已存在则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-194"><see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-195">如果<xref:System.Collections.Generic.HashSet%601.Count%2A>的容量已相等<xref:System.Collections.Generic.HashSet%601>对象时，容量会自动调整以适应新的项。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="d8ea4-196">如果<xref:System.Collections.Generic.HashSet%601.Count%2A>小于内部数组的容量，则此方法为 o （1） 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="d8ea4-197">如果<xref:System.Collections.Generic.HashSet%601>对象必须调整大小，此方法将成为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-198">下面的示例演示如何创建并填充两个<xref:System.Collections.Generic.HashSet%601>对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="d8ea4-199">此示例摘自一个更大的示例为提供<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-200">从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中移除所有元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> 设置为零并且对其他对象的集合的元素也被释放。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="d8ea4-202">容量是在调用之前保持不变<xref:System.Collections.Generic.HashSet%601.TrimExcess%2A>进行。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="d8ea4-203">此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-204">下面的示例创建并填充<xref:System.Collections.Generic.HashSet%601>集合，然后清除它，并释放该集合所引用的内存。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8ea4-205">获取用于确定集中的值是否相等的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></summary>
        <value><span data-ttu-id="d8ea4-206">用于确定集中的值是否相等的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-207">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="d8ea4-208">要在 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中查找的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-209">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是否包含指定的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-210">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象包含指定的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-210"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-211">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-212">下面的示例演示如何从值中删除<xref:System.Collections.Generic.HashSet%601>集合使用<xref:System.Collections.Generic.HashSet%601.Remove%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="d8ea4-213">在此示例中，<xref:System.Collections.Generic.HashSet%601.Contains%2A>方法验证集，然后再删除它包含一个值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d8ea4-214">将 <see cref="T:System.Collections.Generic.HashSet`1" /> 集合中的元素复制到数组中。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d8ea4-215">作为从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象复制的元素的目标的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="d8ea4-216">该数组的索引必须从零开始。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-216">The array must have zero-based indexing.</span></span></param>
        <summary><span data-ttu-id="d8ea4-217">将 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象的元素复制到数组中。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-218">此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-219"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-219"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d8ea4-220">作为从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象复制的元素的目标的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="d8ea4-221">该数组的索引必须从零开始。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-221">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="d8ea4-222"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-222">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="d8ea4-223">从指定数组索引处开始，将 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象的元素复制到数组中。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-224">此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-225"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-225"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d8ea4-226"><paramref name="arrayIndex" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-226"><paramref name="arrayIndex" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d8ea4-227"><paramref name="arrayIndex" /> 大于目标 <paramref name="array" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-227"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d8ea4-228">作为从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象复制的元素的目标的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="d8ea4-229">该数组的索引必须从零开始。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-229">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="d8ea4-230"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-230">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <param name="count"><span data-ttu-id="d8ea4-231">要复制到 <paramref name="array" /> 的元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-231">The number of elements to copy to <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="d8ea4-232">从指定数组索引处开始，将 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象的指定数目的元素复制到数组中。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-233">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-234"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-234"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d8ea4-235"><paramref name="arrayIndex" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-235"><paramref name="arrayIndex" /> is less than 0.</span></span>  
  
<span data-ttu-id="d8ea4-236">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d8ea4-236">-or-</span></span> 
 <span data-ttu-id="d8ea4-237"><paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-237"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d8ea4-238"><paramref name="arrayIndex" /> 大于目标 <paramref name="array" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-238"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span>  
  
<span data-ttu-id="d8ea4-239">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d8ea4-239">-or-</span></span> 
 <span data-ttu-id="d8ea4-240"><paramref name="count" /> 大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 末尾的可用空间。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-240"><paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8ea4-241">获取集中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-241">Gets the number of elements that are contained in a set.</span></span></summary>
        <value><span data-ttu-id="d8ea4-242">集中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-242">The number of elements that are contained in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-243">容量<xref:System.Collections.Generic.HashSet%601>对象是该对象可以容纳的元素数目。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="d8ea4-244">一个<xref:System.Collections.Generic.HashSet%601>自动对象的容量会增加，如元素添加到的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="d8ea4-245">容量始终是大于或等于<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="d8ea4-246">如果<xref:System.Collections.Generic.HashSet%601.Count%2A>添加元素时超出容量，容量设置为第一个质数的最大双精度的以前的容量。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="d8ea4-247">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-248">下面的示例演示如何创建、 填充和操作两个<xref:System.Collections.Generic.HashSet%601>对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="d8ea4-249">在此示例中，这两个集的内容和<xref:System.Collections.Generic.HashSet%601.Count%2A>显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-250">返回 <see cref="T:System.Collections.IEqualityComparer" /> 对象，该对象可用于对 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行相等测试。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-251"><see cref="T:System.Collections.IEqualityComparer" /> 对象，可用于对 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行深入的相等测试。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-252"><xref:System.Collections.IEqualityComparer>在只有一个级别的相等性检查的对象; 但是，你可以链接在一起在其他级别的比较器来执行更深入的相等性测试。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="d8ea4-253">调用此方法是 o （1） 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-254">要从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中移除的项的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-254">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-255">从当前 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中移除指定集合中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-255">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-256"><xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>方法是数学上的集减法运算的等效项。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-256">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="d8ea4-257">此方法为 O (`n`) 操作，其中`n`是中的元素数`other`参数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-257">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-258">下面的示例创建两个<xref:System.Collections.Generic.HashSet%601>具有重叠的数据集的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-258">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="d8ea4-259">从较大的组使用然后删除较低的值范围<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-259">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-260"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-260"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-261">返回循环访问 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象的枚举器。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-261">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-262"><see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> 对象的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-262">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-263">`foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏枚举器的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-263">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="d8ea4-264">因此，使用`foreach`建议而不是直接操作枚举器。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-264">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="d8ea4-265">枚举器可用于读取集合中的数据，但不能用于修改基础集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-265">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="d8ea4-266">最初，枚举数定位在集合中第一个元素的前面。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-266">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="d8ea4-267">在此位置上，<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>未定义属性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-267">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="d8ea4-268">因此，您必须调用<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-268">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="d8ea4-269"><xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>属性返回同一对象，直到<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-269">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="d8ea4-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 设置为下一个元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="d8ea4-271">如果<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-271">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="d8ea4-272">当枚举数位于此位置上，对后续调用<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>还返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-272">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="d8ea4-273">如果最后一次调用到<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>是不确定的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-273">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="d8ea4-274">不能设置<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>再次为集合的第一个元素必须创建新的枚举数对象相反。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-274">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="d8ea4-275">只要集合保持不变，枚举数就保持有效。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-275">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="d8ea4-276">如果进行了更改到集合中，例如添加、 修改或删除元素，该枚举数将失效且不可恢复，并且下次调用<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>或<xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A>引发<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-276">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="d8ea4-277">枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-277">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="d8ea4-278">若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-278">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="d8ea4-279">若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-279">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="d8ea4-280"><xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-280">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="d8ea4-281">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-281">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="d8ea4-282"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象，其中包含序列化 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象所需的信息。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-282">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="d8ea4-283"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 结构，其中包含与 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象关联的序列化流的源和目标。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-283">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-284">实现 <see cref="T:System.Runtime.Serialization.ISerializable" /> 接口并返回序列化 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象所需的数据。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-284">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-285">调用此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-285">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-286"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-286"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="d8ea4-287">用于提供序列化服务。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-287">for providing serialization services.</span></span> <span data-ttu-id="d8ea4-288">安全操作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-288">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="d8ea4-289">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="d8ea4-289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-290">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-290">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-291">修改当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象，以仅包含该对象和指定集合中存在的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-291">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-292">如果使用该集合表示`other`参数是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-292">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-293">否则，此方法为 O (`n` + `m`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>并`m`是中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-293">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-294"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-294"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-295">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-295">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-296">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是否为指定集合的真子集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-296">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-297">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是 <paramref name="other" /> 的真子集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-297"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-298">一个空集是任何其他集合的真子集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-298">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="d8ea4-299">因此，此方法会返回`true`如果该集合表示由当前<xref:System.Collections.Generic.HashSet%601>对象为空除非`other`参数也是一个空集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-299">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="d8ea4-300">此方法始终返回`false`如果<xref:System.Collections.Generic.HashSet%601.Count%2A>大于或等于的中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-300">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="d8ea4-301">如果使用该集合表示`other`是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，则此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-301">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-302">否则，此方法为 O (`n` + `m`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>并`m`是中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-302">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-303">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与相互比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-303">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="d8ea4-304">在此示例中，`lowNumbers`是一个子集和的真子集`allNumbers`直到`allNumbers`使用的修改<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>方法，以包含存在两个集内的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-304">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="d8ea4-305">一次`allNumbers`并`lowNumbers`是相同的`lowNumbers`仍是的子集`allNumbers`但不再真子集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-305">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-306"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-306"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-307">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-307">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-308">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是否为指定集合的真超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-308">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-309">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是 <paramref name="other" /> 的真超集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-309"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-310">一个空集是任何其他集合的真超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-310">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="d8ea4-311">因此，此方法会返回`true`如果使用该集合表示`other`参数为空除非当前<xref:System.Collections.Generic.HashSet%601>集合也为空。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-311">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="d8ea4-312">此方法始终返回`false`如果<xref:System.Collections.Generic.HashSet%601.Count%2A>小于或等于的中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-312">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="d8ea4-313">如果使用该集合表示`other`是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-313">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-314">否则，此方法为 O (`n` + `m`) 操作，其中`n`是中的元素数`other`并`m`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-314">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-315">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与相互比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-315">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="d8ea4-316">在此示例中，`allNumbers`是一个超集和的真超集`lowNumbers`直到`allNumbers`使用的修改<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>方法，以包含存在两个集内的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-316">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="d8ea4-317">一次`allNumbers`并`lowNumbers`是相同的`allNumbers`仍是一个超集`lowNumbers`但不再的真超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-317">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-318"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-318"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-319">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-319">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-320">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是否为指定集合的子集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-320">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-321">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是 <paramref name="other" /> 的子集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-321"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-322">空集是任何其他集合，包括空集; 的子集因此，此方法会返回`true`如果该集合表示由当前<xref:System.Collections.Generic.HashSet%601>对象为空，即使`other`参数为空集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-322">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="d8ea4-323">此方法始终返回`false`如果<xref:System.Collections.Generic.HashSet%601.Count%2A>中的元素数大于`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-323">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="d8ea4-324">如果使用该集合表示`other`是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-324">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-325">否则，此方法为 O (`n` + `m`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>并`m`是中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-325">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-326">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与相互比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-326">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="d8ea4-327">在此示例中，`lowNumbers`是一个子集和的真子集`allNumbers`直到`allNumbers`使用的修改<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>方法，以包含存在两个集内的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-327">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="d8ea4-328">一次`allNumbers`并`lowNumbers`是相同的`lowNumbers`仍是的子集`allNumbers`但不再真子集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-328">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-329"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-329"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-330">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-330">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-331">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是否为指定集合的超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-331">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-332">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象是 <paramref name="other" /> 的超集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-332"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-333">所有集合，包括空集，都是空集的超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-333">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="d8ea4-334">因此，此方法会返回`true`如果使用该集合表示`other`参数为空，即使当前<xref:System.Collections.Generic.HashSet%601>对象为空。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-334">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="d8ea4-335">此方法始终返回`false`如果<xref:System.Collections.Generic.HashSet%601.Count%2A>中的元素数少于`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-335">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="d8ea4-336">如果使用该集合表示`other`是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-336">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-337">否则，此方法为 O (`n` + `m`) 操作，其中`n`是中的元素数`other`并`m`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-337">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-338">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与相互比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-338">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="d8ea4-339">在此示例中，`allNumbers`是一个超集和的真超集`lowNumbers`直到`allNumbers`使用的修改<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>方法，以包含存在两个集内的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-339">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="d8ea4-340">一次`allNumbers`并`lowNumbers`是相同的`allNumbers`仍是一个超集`lowNumbers`但不再的真超集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-340">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-341"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-341"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="d8ea4-342">反序列化事件源。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-342">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="d8ea4-343">实现 <see cref="T:System.Runtime.Serialization.ISerializable" /> 接口，并在完成反序列化之后引发反序列化事件。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-343">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-344">调用此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-344">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="d8ea4-345">与当前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象关联的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象无效。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-345">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-346">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-346">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-347">确定当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象和指定的集合是否共享常见元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-347">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-348">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象与 <paramref name="other" /> 至少共享一个公共元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-348"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-349">此方法为 O (`n`) 操作，其中`n`是中的元素数`other`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-349">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-350">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与每个另一种比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-350">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="d8ea4-351">在此示例中，`allNumbers`并`lowNumbers`将显示以共享通用元素使用<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-351">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-352"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-352"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="d8ea4-353">要移除的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-353">The element to remove.</span></span></param>
        <summary><span data-ttu-id="d8ea4-354">从 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中移除指定的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-354">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-355">如果成功找到并移除该元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-355"><see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="d8ea4-356">如果在 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象中找不到 <paramref name="item" />，则此方法返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-356">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-357">如果<xref:System.Collections.Generic.HashSet%601>对象不包含指定的元素，该对象将保持不变。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-357">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="d8ea4-358">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-358">No exception is thrown.</span></span>  
  
 <span data-ttu-id="d8ea4-359">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-359">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-360">下面的示例演示如何从值中删除<xref:System.Collections.Generic.HashSet%601>集合使用<xref:System.Collections.Generic.HashSet%601.Remove%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-360">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="d8ea4-361">在此示例中，可以随意将零从<xref:System.Collections.Generic.HashSet%601>集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-361">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><span data-ttu-id="d8ea4-362"><see cref="T:System.Predicate`1" /> 委托，用于定义要移除的元素应满足的条件。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-362">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span></span></param>
        <summary><span data-ttu-id="d8ea4-363">从 <see cref="T:System.Collections.Generic.HashSet`1" /> 集合中移除与指定的谓词所定义的条件相匹配的所有元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-363">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-364">已从 <see cref="T:System.Collections.Generic.HashSet`1" /> 集合中移除的元素的个数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-364">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-365">调用此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-365">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-366">下面的示例演示如何从值中删除<xref:System.Collections.Generic.HashSet%601>集合使用<xref:System.Collections.Generic.HashSet%601.Remove%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-366">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="d8ea4-367">在此示例中，从删除所有奇数<xref:System.Collections.Generic.HashSet%601>由指定的集合`match`委托。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-367">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-368"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-368"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-369">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-369">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-370">确定 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象与指定的集合中是否包含相同的元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-370">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-371">如果 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象等于 <paramref name="other" />，则为 <see langword="true" />；否则为 false。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-371"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-372"><xref:System.Collections.Generic.HashSet%601.SetEquals%2A>方法将忽略重复项和中的元素顺序`other`参数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-372">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="d8ea4-373">如果使用该集合表示`other`是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-373">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-374">否则，此方法为 O (`n` + `m`) 操作，其中`n`是中的元素数`other`并`m`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-374">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-375">下面的示例创建两个不同<xref:System.Collections.Generic.HashSet%601>对象，并将其与每个另一种比较。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-375">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="d8ea4-376">最初，这两个集是否不相等，这可以通过使用<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-376">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="d8ea4-377">`allNumbers` <xref:System.Collections.Generic.HashSet%601>然后修改对象，其后集相等。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-377">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-378"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-378"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-379">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-379">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-380">修改当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象，以仅包含该对象或指定集合中存在的元素（但不可包含同时在该对象和指定集合中都存在的元素）。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-380">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-381">如果`other`参数是<xref:System.Collections.Generic.HashSet%601>具有相同的相等性比较器与当前集合<xref:System.Collections.Generic.HashSet%601>对象，此方法为 O (`n`) 操作。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-381">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="d8ea4-382">否则，此方法为 O (`n` + `m`) 操作，其中`n`是中的元素数`other`并`m`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-382">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-383">下面的示例创建两个<xref:System.Collections.Generic.HashSet%601>具有重叠的数据集的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-383">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="d8ea4-384">然后修改包含更小的值集，使用<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>方法，以包含不存在两个集内的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-384">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-385"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-385"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="d8ea4-386">要添加到 <see cref="T:System.Collections.Generic.ICollection`1" /> 对象中的对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-386">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-387">向 <see cref="T:System.Collections.Generic.ICollection`1" /> 对象添加一个项。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-387">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-388">如果<xref:System.Collections.Generic.List%601.Count%2A>是小于<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-388">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="d8ea4-389">如果必须增加容量以容纳新元素，此方法将成为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.List%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-389">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d8ea4-390"><see cref="T:System.Collections.Generic.ICollection`1" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-390">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8ea4-391">获取一个值，该值指示集合是否为只读。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-391">Gets a value indicating whether a collection is read-only.</span></span></summary>
        <value><span data-ttu-id="d8ea4-392">如果该集合为只读，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-392"><see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-393">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-393">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-394">返回循环访问集合的枚举数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-394">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-395">一个可用于循环访问集合的 <see cref="T:System.Collections.Generic.IEnumerator`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-395">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-396">`foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏枚举器的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-396">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="d8ea4-397">因此，建议使用 `foreach`，而不是直接操作枚举数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-397">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="d8ea4-398">枚举器可用于读取集合中的数据，但不能用于修改基础集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-398">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="d8ea4-399">最初，枚举数定位在集合中第一个元素的前面。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-399">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="d8ea4-400">在此位置上，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>未定义属性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-400">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="d8ea4-401">因此，您必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.IEnumerator%601.Current%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-401">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="d8ea4-402"><xref:System.Collections.Generic.IEnumerator%601.Current%2A>属性返回同一对象，直到<xref:System.Collections.IEnumerator.MoveNext%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-402">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="d8ea4-403"><xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为下一个元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-403"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="d8ea4-404">如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-404">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="d8ea4-405">当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-405">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="d8ea4-406">如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>是不确定的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-406">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="d8ea4-407">不能设置<xref:System.Collections.Generic.IEnumerator%601.Current%2A>再次为集合的第一个元素必须创建新的枚举数对象相反。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-407">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="d8ea4-408">只要集合保持不变，枚举数就保持有效。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-408">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="d8ea4-409">如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-409">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="d8ea4-410">枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-410">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="d8ea4-411">若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-411">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="d8ea4-412">若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-412">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="d8ea4-413"><xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-413">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="d8ea4-414">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-414">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-415">返回循环访问集合的枚举数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-415">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-416">一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-416">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-417">`foreach`语句的C#语言 (`for each`中C++，`For Each`在 Visual Basic 中) 隐藏枚举器的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-417">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="d8ea4-418">因此，建议使用 `foreach`，而不是直接操作枚举数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-418">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="d8ea4-419">枚举器可用于读取集合中的数据，但不能用于修改基础集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-419">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="d8ea4-420">最初，枚举数定位在集合中第一个元素的前面。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-420">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="d8ea4-421"><xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-421"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="d8ea4-422">在此位置上，<xref:System.Collections.IEnumerator.Current%2A>未定义属性。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-422">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="d8ea4-423">因此，您必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.IEnumerator.Current%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-423">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="d8ea4-424"><xref:System.Collections.IEnumerator.Current%2A>属性返回同一个对象，直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-424">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="d8ea4-425"><xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-425"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="d8ea4-426">如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-426">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="d8ea4-427">当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-427">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="d8ea4-428">如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-428">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="d8ea4-429">若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-429">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="d8ea4-430">只要集合保持不变，枚举数就保持有效。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-430">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="d8ea4-431">如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-431">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="d8ea4-432">枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-432">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="d8ea4-433">若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-433">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="d8ea4-434">若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-434">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="d8ea4-435"><xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-435">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="d8ea4-436">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-436">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8ea4-437">将 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象的容量设置为它所包含的元素的实际个数，向上舍入为接近的特定于实现的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-437">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-438">可以使用<xref:System.Collections.Generic.HashSet%601.TrimExcess%2A>方法来最大程度减少<xref:System.Collections.Generic.HashSet%601>了解将添加任何新元素后的对象的内存开销。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-438">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="d8ea4-439">若要完全清除<xref:System.Collections.Generic.HashSet%601>对象并释放它引用的所有内存，请调用此方法之后调用<xref:System.Collections.Generic.HashSet%601.Clear%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-439">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="d8ea4-440">此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.Generic.HashSet%601.Count%2A>。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-440">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-441">下面的示例创建并填充<xref:System.Collections.Generic.HashSet%601>集合，然后清除集合并释放它所引用的内存。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-441">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="actualValue" Type="T" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="d8ea4-442">要搜索的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-442">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="d8ea4-443">搜索操作在集内找到的值；如果搜索操作未生成任何匹配项，则返回 T 的默认值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-443">The value from the set that the search found, or the default value of T when the search yielded no match.</span></span></param>
        <summary><span data-ttu-id="d8ea4-444">在集内搜索给定的值，并返回所找到的相等值（如果有）。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-444">Searches the set for a given value and returns the equal value it finds, if any.</span></span></summary>
        <returns><span data-ttu-id="d8ea4-445">一个指示搜索是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-445">A value indicating whether the search was successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-446">当你想要重用的以前存储的引用，而不是一个新构造，以便多个共享的引用可以发生），或查找一个值，尽管具有比当前具有的值的更完整数据时这很有用其比较器函数指示它们相等。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-446">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="d8ea4-447">要与当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象进行比较的集合。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-447">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d8ea4-448">修改当前的 <see cref="T:System.Collections.Generic.HashSet`1" /> 对象，以包含该对象本身、指定集合中存在的所有元素或两者。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-448">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8ea4-449">此方法为 O (`n`) 操作，其中`n`是中的元素数`other`参数。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-449">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8ea4-450">下面的示例演示如何合并两个不同的集。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-450">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="d8ea4-451">此示例创建两个<xref:System.Collections.Generic.HashSet%601>对象，它们分别奇数和偶数数字来填充它们。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-451">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="d8ea4-452">第三个<xref:System.Collections.Generic.HashSet%601>集，其中包含偶数值，从创建对象。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-452">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="d8ea4-453">该示例然后调用<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>方法，它将奇数的数字组添加到第三个组。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-453">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d8ea4-454"><paramref name="other" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d8ea4-454"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>