<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9b37c8e1edd3c56d17ae1b4eeca2dc35ddc46257" /><Meta Name="ms.sourcegitcommit" Value="10aa513a7461eb2abbf8d1e35d2a045d4e5a9be7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/09/2019" /><Meta Name="ms.locfileid" Value="67664447" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Encapsulates HTTP-response information from an ASP.NET operation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和属性<xref:System.Web.HttpResponse>类通过公开<xref:System.Web.HttpApplication.Response%2A>的属性<xref:System.Web.HttpApplication>， <xref:System.Web.HttpContext>， <xref:System.Web.UI.Page>，并<xref:System.Web.UI.UserControl>类。  
  
 以下方法<xref:System.Web.HttpResponse>类仅在回发的方案中支持和不在异步回备份方案：  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 当你使用时启用部分页更新<xref:System.Web.UI.UpdatePanel>控件来更新选定的区域，而不是使用一种回发中更新整个页面的页面。 有关详细信息，请参阅[UpdatePanel 控件概述](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a)并[部分页呈现概述](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)。  
  
   
  
## Examples  
 请求页时，下面的示例绘制三个重叠的矩形。 代码首先设置<xref:System.Web.HttpResponse.ContentType%2A>为 image/jpeg，属性，以便整个页面将呈现为 JPEG 图像。 然后，代码调用<xref:System.Web.HttpResponse.Clear%2A>方法，以确保任何多余内容随此响应发送。 接下来，代码会设置<xref:System.Web.HttpResponse.BufferOutput%2A>属性设置为 true，以便发送到请求的客户端之前完全处理页。 然后创建用于绘制矩形的两个对象：<xref:System.Drawing.Bitmap>和一个<xref:System.Drawing.Graphics>对象。 在页中创建的变量用作坐标绘制矩形和最大的矩形内显示的字符串。  
  
 绘制了三个矩形和显示在其内部的字符串，当<xref:System.Drawing.Bitmap>保存到<xref:System.IO.Stream>与关联的对象<xref:System.Web.HttpResponse.OutputStream%2A>属性，并且其格式设置为 JPEG。 该代码调用<xref:System.Drawing.Image.Dispose%2A>和<xref:System.Drawing.Graphics.Dispose%2A>方法以释放资源由两个图形对象。 最后，该代码调用<xref:System.Web.HttpResponse.Flush%2A>方法发送到请求的客户端缓冲的响应。  
  
> [!NOTE]
>  在代码中，<xref:System.Web.HttpResponse>的对象引用由关键字`Response`。 例如，`Response.Clear()`是指<xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType>方法。 <xref:System.Web.UI.Page>类具有名为的属性<xref:System.Web.UI.Page.Response%2A>的当前实例，该代理公开<xref:System.Web.HttpResponse>。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> object that enables custom HTTP output.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Web.HttpResponse" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员支持 .NET Framework 结构，不能在代码中直接使用。  
  
 方法和属性<xref:System.Web.HttpResponse>类公开通过内部<xref:System.Web.HttpContext.Response%2A>在 ASP.NET 中的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">A file, cache key, or <see cref="T:System.Web.Caching.CacheDependency" /> to add to the list of application dependencies.</param>
        <summary>Associates a set of cache dependencies with the response to facilitate invalidation of the response if it is stored in the output cache and the specified dependencies change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A>方法，若要创建缓存的响应之间的依赖项和一个<xref:System.Web.Caching.CacheDependency>对象。  
  
   
  
## Examples  
 下面的示例演示如何使用创建的缓存依赖项<xref:System.Web.HttpResponse.AddCacheDependency%2A>方法和一个<xref:System.Web.Caching.CacheDependency>对象。  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="dependencies" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called too late in the cache processing pipeline, after the cached response was already created.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Makes the validity of a cached response dependent on other items in the cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">The <see cref="T:System.Collections.ArrayList" /> that contains the keys of the items that the current cached response is dependent upon.</param>
        <summary>Makes the validity of a cached response dependent on other items in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当项目中引用`cacheKeys`从缓存中删除参数，当前项的缓存的响应无效。  
  
   
  
## Examples  
 下面的示例演示如何使用 ASP.NET 页面输出缓存。 页的代码创建<xref:System.Collections.ArrayList>对象中存储的项与相关联的密钥<xref:System.Web.Caching.Cache>对象。 接下来，代码将传递<xref:System.Collections.ArrayList>作为参数对的调用中<xref:System.Web.HttpResponse.AddCacheItemDependencies%2A>方法。 这使输出缓存响应无效，如果任何文件中指定<xref:System.Collections.ArrayList>更改。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">An array of item keys that the cached response is dependent upon.</param>
        <summary>Makes the validity of a cached item dependent on another item in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当任一`cacheKey`已从缓存移除，当前项的缓存的响应无效。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">The key of the item that the cached response is dependent upon.</param>
        <summary>Makes the validity of a cached response dependent on another item in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当项相对应的`cacheKey`从缓存中删除参数，当前项的缓存的响应无效。  
  
   
  
## Examples  
 下面的示例是进行输出缓存的 ASP.NET 用户控件。 控件调用的代码<xref:System.Web.HttpResponse.AddCacheItemDependency%2A>方法中存储的项的键<xref:System.Web.Caching.Cache>对象作为其参数传递。 如果在缓存中不存在项，在输出缓存中存储的控件的响应将会失效。 这意味着，在后续请求时，该控件的响应的新版本将添加到输出缓存。  
  
 接下来，代码检查某个项是否与相关联`bookData`密钥存储在`Cache`对象，并显示两行文本依赖于结果之一。 然后，代码会设置<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>的属性<xref:System.Web.UI.WebControls.DataGrid>控件，它名为`dgBooks`，通过调用自定义`DataHelper`类的共享`GetBookData`方法，并填充<xref:System.Web.UI.WebControls.DataGrid>与<xref:System.Web.UI.Control.DataBind%2A>方法。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a group of file names to the collection of file names on which the current response is dependent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">The collection of files to add.</param>
        <summary>Adds a group of file names to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例是 ASP.NET 页面输出缓存。 页的代码创建<xref:System.Collections.ArrayList>的文件路径，然后传递<xref:System.Collections.ArrayList>调用中的参数作为<xref:System.Web.HttpResponse.AddFileDependencies%2A>方法。 这使输出缓存的响应无效 if 中指定的任何的文件<xref:System.Collections.ArrayList>更改。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filenames">An array of files to add.</param>
        <summary>Adds an array of file names to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例将添加到的文件名称的数组<xref:System.Web.HttpResponse.AddFileDependencies%2A>文件依赖项列表。 如果文件发生更改，缓存的响应无效。  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to add.</param>
        <summary>Adds a single file name to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你使用<xref:System.Web.HttpResponse.AddFileDependency%2A>方法添加文件依赖关系，则还必须指定输出缓存以编程方式或以声明方式。 例如，若要指定以声明方式缓存的输出，请使用[@ OutputCache](https://msdn.microsoft.com/library/28a9e101-fb44-4198-9cb6-b8a52312fec2)指令。 有关详细信息，请参阅[如何：具有文件依赖项的页面输出缓存](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db)。  
  
   
  
## Examples  
 下面的示例演示如何将添加到单个文件名称<xref:System.Web.HttpResponse.AddFileDependency%2A>文件依赖项列表。 如果文件发生更改，缓存的响应会失效。  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">缓存 ASP.NET 页面</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the HTTP header to add <paramref name="value" /> to.</param>
        <param name="value">The string to add to the header.</param>
        <summary>Adds an HTTP header to the output stream. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> is provided for compatibility with earlier versions of ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> 等同于<xref:System.Web.HttpResponse.AppendHeader%2A>，提供仅为了与 ASP 的早期版本的兼容性。 使用 ASP.NET 中，使用<xref:System.Web.HttpResponse.AppendHeader%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">The callback method.</param>
        <summary>Registers a callback that the ASP.NET runtime will invoke immediately before response headers are sent for this request.</summary>
        <returns>An <see cref="T:System.Web.ISubscriptionToken" /> object that represents the subscription to the OnSendingHeaders pseudo-event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果本机模块第一次刷新响应意味着没有调用 AddOnSendingHeaders 方法。  
  
 伪事件 OnSendingHeaders 与 IHttpModule 级别管道事件不同，因为它是每个请求订阅而不是每个应用程序订阅。 其目的是回调可能会修改响应状态代码，或可能的响应 cookie 或标头设置。 其他用法注释和需要注意的问题：  
  
-   仅当在集成的管道模式管道中运行 IIS 并且仅当尚未尚未响应标头发送当前请求的此方法非常有效。  
  
-   ASP.NET 运行时不保证在调用该回调的线程有关的任何信息。 例如，可能会调用回调以同步方式在后台线程中如果正在执行后台刷新。 <xref:System.Web.HttpContext.Current%2A> 不保证在此类线程中不可用。  
  
-   回调必须调用的操作的响应实体正文或刷新过程中时得到任何方法。 例如，回调必须调用<xref:System.Web.HttpResponse.Redirect%2A>，因为该方法可能操作的响应实体正文。  
  
-   回调必须包含短时间运行的同步代码。 尝试调用异步操作或等待此类操作可能导致死锁。  
  
-   回调不会引发异常;否则行为是不确定的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">The <see cref="T:System.Web.HttpCookie" /> to add to the output stream.</param>
        <summary>Adds an HTTP cookie to the intrinsic cookie collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建名为的新 cookie `LastVisit`、 的 cookie 的值设置为当前日期和时间，并将该 cookie 追加到当前的 cookie 集合。 Cookie 集合中的所有 cookie 都发送到客户端在`Set-Cookie`标头的 HTTP 输出流。  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A cookie is appended after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the HTTP header to add to the output stream.</param>
        <param name="value">The string to append to the header.</param>
        <summary>Adds an HTTP header to the output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用<xref:System.Web.HttpResponse.AppendHeader%2A>方法来发送特定于缓存的标头在同一时间使用的缓存对象模型 (<xref:System.Web.HttpResponse.Cache%2A>) 以设置缓存策略，适用于缓存的 HTTP 响应标头 (`Cache-Control`， `Expires`， `Last-Modified`， `Pragma`，和`Vary`) 使用的缓存对象模型时可能会被删除。 此行为使 ASP.NET 能够维护限制性最强的设置。 例如，考虑包括用户控件的页面。 如果这些控件具有冲突的缓存策略，将使用限制性最强的缓存策略。 如果一个用户控件设置的标头"`Cache-Control: Public`"和另一个用户控件设置的限制性更强的标头"`Cache-Control: Private`"通过调用<xref:System.Web.HttpCachePolicy.SetCacheability%2A>，则"`Cache-Control: Private`"标头将发送响应。  
  
 标准 http/1.1 标头的列表，请参阅第 14，"标头字段定义"节中[超文本传输协议-HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) World Wide Web 联合会 (W3C) 网站上的规范。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Web.HttpResponse.AppendHeader%2A>方法添加到自定义标头<xref:System.Web.HttpResponse>对象发送到请求的客户端。  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The header is appended after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">The text to add to the log file.</param>
        <summary>Adds custom log information to the Internet Information Services (IIS) log file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要允许记录在日志文件中的指定字符串，首先必须启用**URI 查询**的选项**扩展日志记录属性**你想要的活动记录在 IIS 中的站点对话框.  
  
 若要自定义扩展中的日志记录 IIS 6.0，请执行以下步骤：  
  
1.  在 IIS 管理器中，展开本地计算机节点，展开 Web 或 FTP 站点文件夹，右键单击 Web 或 FTP 站点，然后单击**属性**。  
  
2.  单击**Web 或 FTP 站点**选项卡，然后选择**启用日志记录**复选框 （如果尚未选择）。  
  
3.  在中**活动的日志格式**框中，单击**W3C 扩展日志文件格式**。  
  
4.  单击**属性**。  
  
5.  单击**高级**选项卡上，选择你想要登录，然后单击属性**确定**。  
  
   
  
## Examples  
 下面的示例演示如何将一个字符串追加到日志。  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Windows Server 2003 产品帮助</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">The virtual path to a resource.</param>
        <summary>Adds a session ID to the virtual path if the session is using <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> session state and returns the combined path. If <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> session state is not used, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> returns the original virtual path.</summary>
        <returns>The <paramref name="virtualPath" /> with the session ID inserted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 是仅用于无 cookie 会话来构造绝对 Href。  
  
   
  
## Examples  
 下面的示例声明一个名为的字符串变量`urlConverted`，并将其设置的结果<xref:System.Web.HttpResponse.ApplyAppPathModifier%2A>方法调用。 然后代码将传递到的变量的值<xref:System.Web.UI.WebControls.HyperLink>控件的<xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A>属性。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">The callback object.</param>
        <param name="state">The response state.</param>
        <summary>Sends the currently buffered response to the client.</summary>
        <returns>The asynchronous result object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果基础<xref:System.Web.HttpWorkerRequest>对象支持异步刷新操作和从异步模块事件或异步处理程序调用此方法，以异步方式执行刷新操作。 否则，以同步方式执行刷新操作。 对于 IIS 6.0 及更高版本支持异步刷新。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The response is already completed.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">The bytes to write to the output stream.</param>
        <summary>Writes a string of binary characters to the HTTP output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例文本文件读入缓冲区并将缓冲区写入到 HTTP 输出流。  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to buffer output and send it after the complete response is finished processing.</summary>
        <value>如果缓冲了发送到客户端的输出，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A>属性已弃用的<xref:System.Web.HttpResponse.BufferOutput%2A>属性，提供仅为了与 ASP 的早期版本的兼容性。 使用 ASP.NET 中，使用<xref:System.Web.HttpResponse.BufferOutput%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to buffer output and send it after the complete page is finished processing.</summary>
        <value>如果缓冲了发送到客户端的输出，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例设置<xref:System.Web.HttpResponse.ContentType%2A>属性为 image/jpeg，响应会调用<xref:System.Web.HttpResponse.Clear%2A>方法来删除其他内容，可能会附加到响应，然后设置<xref:System.Web.HttpResponse.BufferOutput%2A>属性设置为 true，以便将整个页面之前的任何内容发送到请求的客户端处理。  
  
 有关完整示例，请参阅<xref:System.Web.HttpResponse>类。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caching policy (such as expiration time, privacy settings, and vary clauses) of a Web page.</summary>
        <value>包含当前响应的缓存策略相关信息的 <see cref="T:System.Web.HttpCachePolicy" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将当前的缓存策略的属性写入到 HTTP 输出流。  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Cache-Control" /> HTTP header that matches one of the <see cref="T:System.Web.HttpCacheability" /> enumeration values.</summary>
        <value><see cref="T:System.Web.HttpCacheability" /> 枚举值的字符串表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`Private`， `Public`，和`No-Cache`是字符串，并且必须用引号 ("")。 如果<xref:System.Web.HttpResponse.CacheControl%2A>属性设置为一个值，之一不匹配<xref:System.Web.HttpCacheability>枚举值，则<xref:System.ArgumentException>引发。 如果<xref:System.Web.HttpResponse.CacheControl%2A>未设置属性，响应的可缓存性设置为<xref:System.Web.HttpCacheability.NoCache>。  
  
 `CacheControl`， <xref:System.Web.HttpResponse.Expires%2A>，和<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>属性已被否决。 相反的方法<xref:System.Web.HttpCachePolicy>类是可通过<xref:System.Web.HttpResponse.Cache%2A>内部函数的对象，以控制 Internet 信息服务 (IIS) 输出缓存和客户端缓存。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The string value set does not match one of the <see cref="T:System.Web.HttpCacheability" /> enumeration values.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP character set of the output stream.</summary>
        <value>输出流的 HTTP 字符集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset`属性可以设置为`null`若要禁止显示 HTTP`Content-Type`标头。  
  
   
  
## Examples  
 以下示例检查是否输出流的字符集是中央欧语 (ISO)。  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The <see langword="Charset" /> property was set after headers were sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all content output from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A>方法不会清除标头信息。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Web.HttpResponse.ContentType%2A>属性为 image/jpeg，响应会调用<xref:System.Web.HttpResponse.Clear%2A>方法来删除其他内容，可能会附加到响应，然后设置<xref:System.Web.HttpResponse.BufferOutput%2A>属性设置为 true，以便将完成页之前的任何内容发送到请求的客户端处理。  
  
 有关完整示例，请参阅<xref:System.Web.HttpResponse>类。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all content output from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A>方法不会清除标头信息。  
  
   
  
## Examples  
 以下示例清除缓冲区流中的所有内容。  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all headers from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例调用<xref:System.Web.HttpResponse.ClearHeaders%2A>方法以确保没有标头会发送与当前响应。 此方法可以是如果 ASP.NET 响应生成的一个映像，如 JPEG 文件尤其重要。 在此示例中<xref:System.Web.HttpResponse.ContentType%2A>属性设置为 image/jpeg。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Headers are cleared after the HTTP headers have been sent.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Threading.CancellationToken" /> object that is tripped when the client disconnects.</summary>
        <value>取消标记。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 API 是线程安全的。 但是，有一些限制应如何使用取消标记。 未正确使用可能会导致争用条件、 死锁或其他意外的行为。 请记住以下准则：  
  
-   确保不调用此 api 边界外的单个请求，因为 ASP.NET 将释放请求结束时的取消标记。 就释放之前，该令牌曾经将转换为已取消状态不能保证。 例如，如果在请求完成而无需具有断开连接的客户端，该令牌将被释放而无需首先具有已取消。  
  
-   不等待<xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>，如这异步通知的初衷背道而驰，并且会导致死锁。  
  
-   不要调用<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>重载调用的回调在原始<xref:System.Threading.SynchronizationContext>对象。  
  
-   不要使用<xref:System.Web.HttpContext>对象或其他非线程安全 ASP.NET 固有对象从在回调中提供给<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>方法。 回调可能与其他 ASP.NET 同时运行或应用程序代码。  
  
-   保留的短时间运行的回调方法和非阻塞。  
  
-   请尽量避免引发异常从回调方法中。  
  
 在 Internet 信息服务 (IIS) 7.5 或更高版本在集成模式下仅支持此属性。 如果调用的正确 IIS 版本或管道模式不，<xref:System.PlatformNotSupportedException>引发。 若要确定 IIS 版本，请使用<xref:System.Web.HttpRuntime.IISVersion%2A>。 若要确定管道模式，请使用<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the socket connection to a client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法以突然发生的方式将终止与客户端的连接，不适合进行常规的 HTTP 请求处理。 该方法将重置数据包发送到客户端，这可能导致上服务器、 客户端，或在某处之间删除响应进行缓冲处理的数据。  
  
 但是，通常应调用<xref:System.Web.HttpApplication.CompleteRequest%2A>改为如果你想要跳转到<xref:System.Web.HttpApplication.EndRequest>事件并发送到客户端的响应。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP character set of the output stream.</summary>
        <value>包含当前响应的字符集相关信息的 <see cref="T:System.Text.Encoding" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认值`ContentEncoding`可以在 ASP.NET 配置文件中指定[全球化元素 （ASP.NET 设置架构）](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)部分。 如果<xref:System.Web.HttpResponse.ContentEncoding%2A>指定客户端，则将重写默认配置设置。  
  
   
  
## Examples  
 下面的示例将写入到输出流编码的字符集的人工可读说明。  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Attempted to set <see cref="P:System.Web.HttpResponse.ContentEncoding" /> to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP MIME type of the output stream.</summary>
        <value>输出流的 HTTP MIME 类型。 默认值为 “<see langword="text/html" />” 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例设置<xref:System.Web.HttpResponse.ContentType%2A>属性为 image/jpeg，响应会调用<xref:System.Web.HttpResponse.Clear%2A>方法来删除其他内容，可能会附加到响应，然后设置<xref:System.Web.HttpResponse.BufferOutput%2A>属性设置为 true，以便将完成页之前的任何内容发送到请求的客户端处理。  
  
 有关完整示例，请参阅<xref:System.Web.HttpResponse>类。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The <see cref="P:System.Web.HttpResponse.ContentType" /> property is set to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the response cookie collection.</summary>
        <value>响应 cookie 集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 包括两个内部 cookie 集合。 通过访问的集合<xref:System.Web.HttpRequest.Cookies%2A>的集合<xref:System.Web.HttpRequest>包含传输中的服务器到客户端的 cookie`Cookie`标头。 通过访问的集合<xref:System.Web.HttpResponse.Cookies%2A>的集合<xref:System.Web.HttpResponse>包含在服务器上创建和传输到客户端中的新 cookie`Set-Cookie`标头。  
  
 使用添加 cookie 后<xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType>集合，cookie 可立即在<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>集合，即使尚未发送到客户端响应。  
  
   
  
## Examples  
 下面的示例创建名为的新 cookie `LastVisit`、 的 cookie 的值设置为当前日期和时间，并将该 cookie 添加到当前的 cookie 集合。 Cookie 集合中的所有 cookie 都发送到客户端在`Set-Cookie`标头的 HTTP 输出流。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables kernel caching for the current response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支持内核缓存，则此方法无效。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables IIS user-mode caching for this response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支持 IIS 用户模式缓存，此方法将返回而不执行任何操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sends all currently buffered output to the client, stops execution of the page, and raises the <see cref="E:System.Web.HttpApplication.EndRequest" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是仅与 ASP 的兼容性，即与前面带有 ASP.NET 的基于 COM 的 Web 编程技术的兼容性。 如果你想要跳转到<xref:System.Web.HttpApplication.EndRequest>事件并发送到客户端的响应，通常最好是调用<xref:System.Web.HttpApplication.CompleteRequest%2A>相反。  
  
 若要模拟的行为`End`ASP 中的方法，此方法尝试引发<xref:System.Threading.ThreadAbortException>异常。 如果此尝试成功，将中止调用线程，这是对站点的性能造成不利影响。 在这种情况下，在调用任何代码<xref:System.Web.HttpResponse.End%2A>执行方法。  
  
 如果<xref:System.Web.HttpResponse.End%2A>方法不能引发<xref:System.Threading.ThreadAbortException>，而是将响应字节数刷新到客户端。 这是以同步方式，也可以是对站点的性能造成不利影响。  
  
 在任一情况下 (是否<xref:System.Threading.ThreadAbortException>成功引发异常)，响应管道将向前跳到<xref:System.Web.HttpApplication.EndRequest>事件。  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A>方法不会引发异常，并在调用后的代码<xref:System.Web.HttpApplication.CompleteRequest%2A>方法可能会执行。 如果您的意图是为了避免执行的后续代码，并且对性能的影响<xref:System.Web.HttpResponse.End%2A>是可以接受的可以调用<xref:System.Web.HttpResponse.End%2A>而不是<xref:System.Web.HttpApplication.CompleteRequest%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">The call to <see cref="M:System.Web.HttpResponse.End" /> has terminated the current request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The asynchronous result object.</param>
        <summary>Completes an asynchronous flush operation.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchronous flush is not supported and the <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchronous flush is not supported and the <paramref name="asyncResult" /> parameter cannot be cast to a <c>FlushAsyncResult</c> object.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of minutes before a page cached on a browser expires. If the user returns to the same page before it expires, the cached version is displayed. <see cref="P:System.Web.HttpResponse.Expires" /> is provided for compatibility with earlier versions of ASP.</summary>
        <value>在页过期之前的分钟数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`，<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>并<xref:System.Web.HttpResponse.CacheControl%2A>属性已弃用的方法<xref:System.Web.HttpCachePolicy>类可通过<xref:System.Web.HttpResponse.Cache%2A>内部函数的对象，以控制 Internet 信息服务 (IIS) 输出缓存和客户端缓存。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the absolute date and time at which to remove cached information from the cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> is provided for compatibility with earlier versions of ASP.</summary>
        <value>该页过期时的日期和时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`， <xref:System.Web.HttpResponse.Expires%2A>，并<xref:System.Web.HttpResponse.CacheControl%2A>属性已弃用的方法<xref:System.Web.HttpCachePolicy>类可通过<xref:System.Web.HttpResponse.Cache%2A>内部函数的对象，以控制 Internet 信息服务 (IIS) 输出缓存和客户端缓存。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a wrapping filter object that is used to modify the HTTP entity body before transmission.</summary>
        <value>作为输出筛选器的 <see cref="T:System.IO.Stream" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您创建`Stream`对象并设置<xref:System.Web.HttpResponse.Filter%2A>属性设置为`Stream`对象，所有 HTTP 输出发送<xref:System.Web.HttpResponse.Write%2A>通过筛选器。  
  
   
  
## Examples  
 下面的示例是 ASP.NET 页的设置<xref:System.Web.HttpResponse.Filter%2A>属性设置为的新实例`UpperCaseFilter`类中，自定义<xref:System.IO.Stream>将转换为大写形式将通过此模块的所有文本的类。 有关请求的信息保存到文本文件，然后<xref:System.Web.HttpResponse.Filter%2A>属性设置。 响应筛选器准备就绪后，该代码调用<xref:System.Web.HttpRequest.MapPath%2A>方法来获取名为的文本文件的绝对路径`TestFile.txt`用作响应内容的源。 该代码随后创建一个新<xref:System.IO.StreamReader>对象，以便从开始到结束，然后调用读取文本文件<xref:System.Web.HttpResponse.Write%2A>方法来显示页面上的文件的内容。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtering is not allowed with the entity.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sends all currently buffered output to the client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 强制所有当前缓冲的输出发送到客户端。 <xref:System.Web.HttpResponse.Flush%2A>方法可以多次调用请求处理过程。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Drawing.Graphics.Save%2A>方法来保存<xref:System.Drawing.Bitmap>对象传递给<xref:System.Web.HttpResponse.OutputStream%2A>属性并将转换为 JPEG 图像格式。 然后，代码调用`Dispose`方法<xref:System.Drawing.Bitmap>对象和一个<xref:System.Drawing.Graphics>对象，释放正在使用的资源。 然后，它调用<xref:System.Web.HttpResponse.Flush%2A>方法发送到请求的客户端响应的内容。  
  
 有关完整示例，请参阅<xref:System.Web.HttpResponse>类。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The cache is flushed after the response has been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronously sends all currently buffered output to the client.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.Text.Encoding" /> object that represents the encoding for the current header output stream.</summary>
        <value>包含当前标头的字符集相关信息的 <see cref="T:System.Text.Encoding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A>属性可让您能够禁用或更改<xref:System.Text.Encoding>对象上使用的响应标头<xref:System.Text.ASCIIEncoding>， <xref:System.Text.UnicodeEncoding>， <xref:System.Text.UTF7Encoding>，或<xref:System.Text.UTF8Encoding>对象。 默认编码值是<xref:System.Text.UTF8Encoding>类。  
  
 通过更改的类型<xref:System.Web.HttpResponse.HeaderEncoding%2A>属性，可能会延长特定恶意攻击或原因通过响应标头发送敏感数据的风险。 标头注入攻击，可以避免，部分，通过保留<xref:System.Web.HttpResponse.HeaderEncoding%2A>属性的默认设置的响应。 对易受攻击的应用程序的攻击可能回显导致将受信任的数据作为响应标头的一部分。 如果<xref:System.Web.HttpResponse.HeaderEncoding%2A>延续行的标头中或如果任何标头构造基于不受信任数据的结果，应发送到响应流之前验证标头数据，一项要求已禁用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The encoding value is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">The encoding value is <see cref="P:System.Text.Encoding.Unicode" />.  
  
-or- 
The headers have already been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of response headers.</summary>
        <value>响应标头的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A>属性仅支持使用[!INCLUDE[iisver](~/includes/iisver-md.md)]集成的管道模式并且至少.NET Framework 3.0。 当您尝试访问<xref:System.Web.HttpResponse.Headers%2A>属性和这两个条件之一不满足，<xref:System.PlatformNotSupportedException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires the integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework version 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">升级到 IIS 7.0 的 ASP.NET 应用程序：IIS 7.0 集成模式和经典模式之间的差异</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the response headers have been written.</summary>
        <value>如果已写入响应标头，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the client is still connected to the server.</summary>
        <value>如果客户端当前仍在连接，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A>属性返回`false`满足以下条件时：  
  
-   向客户端连接已终止。 发生这种情况<xref:System.Web.HttpResponse.Close%2A>调用方法时，或如果客户端停止 Web 页的执行，或浏览到另一页。  
  
-   <xref:System.Web.HttpWorkerRequest>处理请求的对象是`null`或<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法将返回`false`。 如果自定义<xref:System.Web.HttpWorkerRequest>对象将处理请求，则<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法可能会基于设置自定义条件。 例如，自定义辅助角色请求可能会在一段时间后强制超时。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Web.HttpResponse.IsClientConnected%2A>属性检查是否正在请求页的客户端仍连接到服务器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>为 true，该代码调用<xref:System.Web.HttpResponse.Redirect%2A>方法，并在客户端将查看另一页。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>为 false，则该代码调用<xref:System.Web.HttpResponse.End%2A>方法，并且所有页面处理会终止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether the client is being transferred to a new location.</summary>
        <value>如果位置响应标头的值与当前位置不同，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A>具有属性<xref:System.Web.HttpResponse.RedirectLocation%2A>来测试并确定是否绝对 URI 属性，该属性是传输到客户端在 HTTP`Location`标头是不同于当前的 URI 和新正在的目标的 URI将传输到  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enables output of text to the outgoing HTTP response stream.</summary>
        <value>实现到客户端的自定义输出的 <see cref="T:System.IO.TextWriter" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例是一个包含 ASP.NET 页面<xref:System.Web.UI.WebControls.TextBox>具有控件及其<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>属性设置为<xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>。 该页的代码接受用户输入中的文本<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>，使用<xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法以 html 格式进行编码，和<xref:System.Web.HttpResponse.Output%2A>属性显示到页的编码的字符串。  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enables binary output to the outgoing HTTP content body.</summary>
        <value>表示传出 HTTP 内容主体的原始内容的 IO <see cref="T:System.IO.Stream" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 2.0 版中，从开始使用时<xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法返回的 IO 流<xref:System.Web.HttpResponse.OutputStream%2A>属性，可能会引发以下异常：  
  
-   <xref:System.ArgumentOutOfRangeException>如果`offset`或`count`参数为负或如果`buffer`参数的长度减去`offset`参数小于或等于零。  
  
-   <xref:System.ArgumentNullException>如果`buffer`参数是`null`。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Drawing.Image.Save%2A>方法来保存<xref:System.Drawing.Bitmap>对象传递给<xref:System.Web.HttpResponse.OutputStream%2A>属性，并将图像转换为 JPEG 格式。 然后，代码调用 Dispose 方法上<xref:System.Drawing.Bitmap>对象和一个<xref:System.Drawing.Graphics>对象，释放正在使用的资源。 最后，该代码调用<xref:System.Web.HttpResponse.Flush%2A>方法发送到请求的客户端响应的内容。  
  
 有关完整示例，请参阅<xref:System.Web.HttpResponse>类。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" /> is not available.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to add to the <see langword="PICS-Label" /> header.</param>
        <summary>Appends a HTTP <see langword="PICS-Label" /> header to the output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Internet 内容所选内容 (PICS) 平台是内容标记的 World Wide Web 联合会 (W3C) 标准。 照片图像是实质上是一种用于创建分级系统的语言。  
  
 任何值可以是 PICS 标签;ASP.NET 不会验证标签。 字符串的最大长度为 255 个字符。 有关 PICS 标准和语法的详细信息，请参阅[World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) Web 站点。  
  
   
  
## Examples  
 下面的示例是显示图像的 ASP.NET 页。 该页的代码调用<xref:System.Web.HttpResponse.Pics%2A>方法以设置 HTTP`PICS-Label`响应的标头。 作为参数传递的字符串<xref:System.Web.HttpResponse.Pics%2A>方法表示 Internet 内容分级关联 (ICRA) 网站上生成的评分标签。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promotes a promised object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">The URL of the push request. It should be the virtual path of the relative resource that the server wants to push to the client.</param>
        <summary>This API is to support applications sending push promises to HTTP 2.0 clients. You can find more details regarding to Http2 server push at <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是不确定的 PushPromise 和应用程序不应具有依赖于它的逻辑。 其唯一用途是在某些情况下的性能优势。 有可能会导致完全忽略推送请求的多个条件 （协议和实现）。 预期结果基于即发即弃。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="2" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">The URL of the push request. It should be the virtual path of the relative resource that the server wants to push to the client.</param>
        <param name="method">Http request method that would be used by the push request.</param>
        <param name="headers">Http request header that would be used by the push request.</param>
        <summary>This API is to support applications sending push promises to HTTP 2.0 clients. You can find more details regarding to Http2 server push at <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是不确定的 PushPromise 和应用程序不应具有依赖于它的逻辑。 其唯一用途是在某些情况下的性能优势。 有可能会导致完全忽略推送请求的多个条件 （协议和实现）。 预期结果基于即发即弃。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirects a client to a new URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">The target location. This may be an application-relative virtual path.</param>
        <summary>Redirects a request to a new URL and specifies the new URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Web.HttpResponse.Redirect%2A>等效于调用<xref:System.Web.HttpResponse.Redirect%2A>第二个参数设置为`true`。  
  
 <xref:System.Web.HttpResponse.Redirect%2A> 调用<xref:System.Web.HttpResponse.End%2A>该类会引发<xref:System.Threading.ThreadAbortException>完成后的异常。 此异常有不利的影响对 Web 应用程序性能。 因此，我们建议，而不是此重载使用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>重载，并传递`false`有关`endResponse`参数，然后再调用<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 有关更多信息，请参见 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  移动页仅，如果你的应用程序依赖无 cookie 会话，或从移动设备需要的无 cookie 会话可能会收到请求，使用波形符 (\~) 的路径中可能会导致创建新的会话，并有可能丢失会话数据。 如使用路径移动控件上设置属性"\~/path"，路径使用解析<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"\~/path"之前将其分配给该属性。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。 将控制转移到另一页的替代方法是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常效率更高，因为它不会一次往返过程导致向客户端。 有关详细信息，请参阅[如何：将用户重定向到另一页](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下面的示例强制无条件重定向到另一个 Web 站点。  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A redirection is attempted after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">The location of the target.</param>
        <param name="endResponse">Indicates whether execution of the current page should terminate.</param>
        <summary>Redirects a client to a new URL. Specifies the new URL and whether execution of the current page should terminate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 绝对 URL (例如， `http://www.contoso.com/default.aspx`) 或相对 URL (例如，Default.aspx) 可为指定的目标位置，但某些浏览器可能会拒绝的相对 URL。  
  
 当你使用此方法在页处理程序中一页，并开始新请求的另一页，设置的终止请求`endResponse`到`false`，然后调用<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 如果指定`true`有关`endResponse`参数，此方法调用<xref:System.Web.HttpResponse.End%2A>原始请求，将引发方法<xref:System.Threading.ThreadAbortException>操作完成时的异常。 此异常有不利的影响对 Web 应用程序性能，这就是原因传递`false`为`endResponse`建议参数。 有关更多信息，请参见 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  移动页，如果你的应用程序依赖无 cookie 会话，或从移动设备需要的无 cookie 会话可能会收到请求，使用波形符 (\~) 路径可在创建新的会话和有可能会丢失会话数据。 如使用路径移动控件上设置属性"\~/path"，路径使用解析<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"\~/path"之前将其分配给该属性。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。 将控制转移到另一页的替代方法是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常效率更高，因为它不会一次往返过程导致向客户端。 有关详细信息，请参阅[如何：将用户重定向到另一页](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Web.HttpResponse.IsClientConnected%2A>属性检查是否正在请求页的客户端仍连接到服务器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>为 true，该代码调用<xref:System.Web.HttpResponse.Redirect%2A>方法，并在客户端将查看另一页。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>为 false，则该代码调用<xref:System.Web.HttpResponse.End%2A>方法，并且所有页面处理会终止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> contains a newline character.</exception>
        <exception cref="T:System.Web.HttpException">A redirection is attempted after the HTTP headers have been sent.</exception>
        <exception cref="T:System.ApplicationException">The page request is the result of a callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the HTTP <see langword="Location" /> header.</summary>
        <value>通过 HTTP <see langword="Location" /> 标头传输到客户端的绝对 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何使用此属性来指定重定向 URL，当你通过使用 HTTP 301 响应代码的代码的永久重定向。  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The HTTP headers have already been written.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a permanent redirection from a requested URL to a specified URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">The location to redirect the request to.</param>
        <summary>Performs a permanent redirection from the requested URL to the specified URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法重载提供 301 的 HTTP 状态代码在响应中，并且包含重定向到请求的 URL。 301 的 HTTP 状态代码为 HTTP 响应中的标准代码。 它表示存在的永久重定向，并且它提供的重定向位置。  
  
 调用<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法重载会终止响应。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> includes a newline character (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endResponse" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">The location to redirect the request to.</param>
        <param name="endResponse"><see langword="true" /> to terminate the response; otherwise <see langword="false" />. The default is <see langword="false" />.</param>
        <summary>Performs a permanent redirection from the requested URL to the specified URL, and provides the option to complete the response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法重载提供 301 的 HTTP 状态代码在响应中，并且包含重定向到请求的 URL。 此方法的重载还提供了用于指定是否终止或用于完成响应执行重定向后的选项。 301 的 HTTP 状态代码为 HTTP 响应中的标准代码。 它表示存在的永久重定向，并且它提供的重定向位置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> includes a newline character (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirects a request to a new URL by using route parameter values, a route name, or both.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法中传递的对象转换为`routeValues`到<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>通过使用对象<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>构造函数。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到已命名的参数的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <summary>Redirects a request to a new URL by using a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法会将传入的路由名称`routeName`到通过使用 URL<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Products`。  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法调用<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到已命名的参数的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法中传递的对象转换为`routeValues`到<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>通过使用对象<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>构造函数。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Product`并具有名为的参数`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>调用方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 302 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Product`并具有名为的参数`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values, a route name, or both.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法中传递的对象转换为`routeValues`到<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>通过使用对象<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>构造函数。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 301 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到已命名的参数的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法会将传入的路由名称`routeName`到通过使用 URL<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 301 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Products`。  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法调用<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 301 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到已命名的参数的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using the route parameter values and the name of the route that correspond to the new URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.RedirectPermanent%2A>方法替换第二个参数设置为`false`。  
  
 此方法中传递的对象转换为`routeValues`到<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>通过使用对象<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>构造函数。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 301 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Product`并具有名为的参数`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了方便编码提供此方法。 它相当于调用<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法替换第二个参数设置为`false`。  
  
 此方法调用<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法来确定的 URL。  
  
 ASP.NET 执行通过返回 HTTP 状态代码为 301 重定向。  
  
   
  
## Examples  
 下面的示例演示如何调用此方法以重定向到名为的路由`Product`并具有名为的参数`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes cached items from the output cache by using the default output-cache provider.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The virtual absolute path to the items that are removed from the cache.</param>
        <summary>Removes from the cache all cached items that are associated with the default output-cache provider. This method is static.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法删除默认输出缓存提供程序与关联的输出缓存项。 调用<xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A>方法删除与网站配置文件中指定的自定义输出缓存提供程序相关联的输出缓存项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> is not an absolute virtual path.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="providerName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">The virtual absolute path of the items that are removed from the cache.</param>
        <param name="providerName">The provider that is used to remove the output-cache artifacts that are associated with the specified path.</param>
        <summary>Uses the specified output-cache provider to remove all output-cache items that are associated with the specified path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法删除与网站配置文件中指定的自定义输出缓存提供程序相关联的输出缓存项。 若要删除与默认输出缓存提供程序关联的输出缓存项，请调用<xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> is an invalid path.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">The cookie in the collection to be updated.</param>
        <summary>Because the <b>HttpResponse.SetCookie</b> method is intended for internal use only, you should not call it in your code. Instead, you can call the <b>HttpResponse.Cookies.Set</b> method, as the following example shows.<br /> Updates an existing cookie in the cookie collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例更新现有的 cookie 的值。  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Attempted to set the cookie after the HTTP headers were sent.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the <see langword="Status" /> line that is returned to the client.</summary>
        <value>设置状态代码会使描述 HTTP 输出状态的字符串返回到客户端。 默认值为 200 (OK)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> 已弃用的<xref:System.Web.HttpResponse.StatusDescription%2A>，提供仅为了与 ASP 的早期版本的兼容性。 使用 ASP.NET 中，使用<xref:System.Web.HttpResponse.StatusDescription%2A>相反。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Status is set to an invalid status code.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP status code of the output returned to the client.</summary>
        <value>表示返回到客户端的 HTTP 输出状态的整数。 默认值为 200 (OK)。 有关有效状态代码的列表，请参阅[Http 状态代码](https://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查输出流的状态代码。 如果不等于 200 状态代码，则执行其他代码。  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.StatusCode" /> is set after the HTTP headers have been sent.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP status string of the output returned to the client.</summary>
        <value>描述返回到客户端的 HTTP 输出的状态的字符串。 默认值为 "OK"。 有关有效状态代码的列表，请参阅[Http 状态代码](https://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查输出流的状态字符串。 如果状态不等于"确定"，则执行其他代码。  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="StatusDescription" /> is set after the HTTP headers have been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The selected value has a length greater than 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value qualifying the status code of the response.</summary>
        <value>表示 [!INCLUDE[iisver](~/includes/iisver-md.md)] 子状态代码的整数值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A>属性中的集成的管道模式仅支持[!INCLUDE[iisver](~/includes/iisver-md.md)]和至少.NET Framework 3.0 版。 当您将设置<xref:System.Web.HttpResponse.SubStatusCode%2A>记录状态属性，[!INCLUDE[iisver](~/includes/iisver-md.md)]如果配置失败请求跟踪。 独立于是否配置跟踪，代码永远不会发送最终响应请求的一部分。 有关详细信息，请参阅[故障排除失败的请求使用失败请求跟踪在 IIS 7.0 中](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Web.HttpResponse.SubStatusCode%2A>中的事件处理程序属性<xref:System.Web.HttpApplication>的实例<xref:System.Web.HttpApplication.PostAuthenticateRequest>事件。 将代码文件放在 Web 应用程序的 App_Code 文件夹中并配置 Web.config 文件以注册该模块。 有关详细信息，请参见[演练：创建和注册自定义 HTTP 模块](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453)。  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires the integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">The status code is set after all HTTP headers have been sent.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the connection supports asynchronous flush operations.</summary>
        <value>如果连接支持异步刷新操作，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值<xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to send HTTP content to the client.</summary>
        <value>若要取消输出，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查是否<xref:System.Web.HttpRequest.IsSecureConnection%2A>属性设置为 false。 如果是，<xref:System.Web.HttpResponse.SuppressContent%2A>属性设置为 true，则停止发送响应。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to suppress the default <c>Cache Control: private</c> header for the current HTTP response.</summary>
        <value><see langword="true" /> 若要取消默认<c>缓存控制： 私有</c>标头为当前 HTTP 响应中; 否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，ASP.NET 将发送`Cache-Control: private`响应标头除非已为此响应指定显式的缓存策略。 此属性，可禁止显示此默认响应标头基于每个请求。 标头仍为整个应用程序通过设置抑制<xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A>中[httpRuntime 元素 （ASP.NET 设置架构）](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369)或[（ASP.NET 设置架构）caching的outputCache元素](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 取消显示默认值时要格外小心`Cache-Control: private`标头为代理和其他中间方可能会将响应而无需此标头视为可缓存默认情况下。 此种处理方式可能会导致意外的缓存的敏感信息。 请参阅[RFC 2616 第秒 13.4](https://tools.ietf.org/html/rfc2616)有关详细信息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether forms authentication redirection to the login page should be suppressed.</summary>
        <value>如果应取消窗体身份认证重定向，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，窗体身份验证转换为 HTTP 401 状态代码 302 重定向到登录页。 这并不适合某些类别的错误，例如当身份验证成功，但授权失败，或当前的请求时是 AJAX 或 web 服务请求。 此属性提供了一种方法来取消重定向行为，并将原始的状态代码发送到客户端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the specified file directly to an HTTP response output stream without buffering it in memory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <summary>Writes the specified file directly to an HTTP response output stream, without buffering it in memory.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <param name="offset">The position in the file to begin to write to the HTTP output.</param>
        <param name="length">The number of bytes to be transmitted.</param>
        <summary>Writes the specified part of a file directly to an HTTP response output stream without buffering it in memory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定 0 作为`offset`参数和-1 作为`length`参数，发送整个文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="offset" /> parameter is less than zero.  
  
-or- 
The <paramref name="length" /> parameter is less than -1.  
  
-or- 
The <paramref name="length" /> parameter specifies a number of bytes that is greater than the number of bytes the file contains minus the offset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The out-of-process worker request is not supported.  
  
-or- 
The response is not using an <see cref="T:System.Web.HttpWriter" /> object.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="offset" /> parameter is less than zero or greater than the file size.  
  
-or- 
The <paramref name="length" /> parameter is less than -1 or greater than the value of the <paramref name="offset" /> parameter plus the file size.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether [!INCLUDE[iisver](~/includes/iisver-md.md)] custom errors are disabled.</summary>
        <value>若要禁用 IIS 自定义错误，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>属性仅在你的应用程序托管在 IIS 7.0 及更高版本时使用。 当以经典模式运行时<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>属性的默认值是`true`。 在集成模式下运行时<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>属性的默认值是`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information to an HTTP response output stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">The character to write to the HTTP output stream.</param>
        <summary>Writes a character to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例创建一系列的写入 ASP.NET 页使用 Write 方法的常数。 该代码调用此版本的 Write 方法写入页的单个字符常量。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to write to the HTTP output stream.</param>
        <summary>Writes an <see cref="T:System.Object" /> to an HTTP response stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string to write to the HTTP output stream.</param>
        <summary>Writes a string to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从客户端接收或传输到客户端时，未通过验证从 Web 客户端接收的输入，动态生成的 HTML 页面可能会引入安全风险。 输入提交到 Web 站点并随后写回给客户端中嵌入的恶意脚本可能看上去来自受信任的源。 此安全风险被称为跨站点脚本攻击。 您应始终验证时它会将传输从你的站点到客户端浏览器从客户端收到的数据。  
  
 此外，每当收到作为输入的任何数据以 HTML 的形式写出时，您应该对其进行编码使用一种技术，如<xref:System.Web.HttpServerUtility.HtmlEncode%2A>或<xref:System.Web.HttpServerUtility.UrlEncode%2A>防止执行恶意脚本。 此方法可用于收到它时未进行验证的数据。  
  
 在编码或筛选数据时，必须指定为您的 Web 页面设置，以便你的筛选器可以识别并删除不属于的设置 （如非字母数字序列），可能会产生恶意脚本中嵌入任何字节序列的字符它们。  
  
 有关跨站点脚本攻击的详细信息，请参阅文章 Q252985，"如何为防止跨站点脚本安全问题"上[Microsoft 知识库文章](https://go.microsoft.com/fwlink/?LinkID=37115)Web 站点。  
  
   
  
## Examples  
 下面的示例将回显到客户端的浏览器的客户端的名称。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法中去除任何恶意脚本和提交中的无效字符`UserName`输入的字段。  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The character array to write.</param>
        <param name="index">The position in the character array where writing starts.</param>
        <param name="count">The number of characters to write, beginning at <paramref name="index" />.</param>
        <summary>Writes an array of characters to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例创建一系列的写入 ASP.NET 页使用 Write 方法的常数。 该代码调用此版本的 Write 方法写入页的单个字符常量。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <summary>Writes the contents of the specified file directly to an HTTP response output stream as a file block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此方法用于大型文件时，调用该方法可能引发异常。 可以使用此方法使用的文件的大小取决于 Web 服务器的硬件配置。 有关详细信息，参见位于，"PRB:Response.WriteFile 无法下载大型文件"上[Microsoft 知识库文章](https://go.microsoft.com/fwlink/?linkid=149903)Web 站点。  
  
   
  
## Examples  
 下面的示例将一个名为文本文件的所有内容都写入`Login.txt`（其中可能包含文本的 HTML 文本和输入控件） 直接向输出流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write into a memory block.</param>
        <param name="readIntoMemory">Indicates whether the file will be written into a memory block.</param>
        <summary>Writes the contents of the specified file directly to an HTTP response output stream as a memory block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此方法用于大型文件时，调用该方法可能引发异常。 可以使用此方法使用的文件的大小取决于 Web 服务器的硬件配置。 有关详细信息，参见位于，"PRB:Response.WriteFile 无法下载大型文件"上[Microsoft 知识库文章](https://go.microsoft.com/fwlink/?linkid=149903)Web 站点。  
  
   
  
## Examples  
 下面的示例将文件写入内存。  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">The file handle of the file to write to the HTTP output stream.</param>
        <param name="offset">The byte position in the file where writing will start.</param>
        <param name="size">The number of bytes to write to the output stream.</param>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此方法用于大型文件时，调用该方法可能引发异常。 可以使用此方法使用的文件的大小取决于 Web 服务器的硬件配置。 有关详细信息，参见位于，"PRB:Response.WriteFile 无法下载大型文件"上[Microsoft 知识库文章](https://go.microsoft.com/fwlink/?linkid=149903)Web 站点。  
  
   
  
## Examples  
 下面的示例将一个名为文本文件的所有内容都写入`Login.txt`（其中可能包含文本的 HTML 文本和输入控件） 直接向输出流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the file size minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output stream.</param>
        <param name="offset">The byte position in the file where writing will start.</param>
        <param name="size">The number of bytes to write to the output stream.</param>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此方法用于大型文件时，调用该方法可能引发异常。 可以使用此方法使用的文件的大小取决于 Web 服务器的硬件配置。 有关详细信息，参见位于，"PRB:Response.WriteFile 无法下载大型文件"上[Microsoft 知识库文章](https://go.microsoft.com/fwlink/?linkid=149903)Web 站点。  
  
   
  
## Examples  
 下面的示例将一个名为文本文件的所有内容都写入`Login.txt`（其中可能包含文字文本和 HTML 输入控件） 直接向输出流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the file size minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">The method, user control, or object to substitute.</param>
        <summary>Allows insertion of response substitution blocks into the response, which allows dynamic generation of specified response regions for output cached responses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.Web.HttpResponse.WriteSubstitution%2A>在输出缓存的页面中的缓存后替换的方法。 通过传递<xref:System.Web.HttpContext>对象到回调方法，具有规定<xref:System.Web.HttpResponseSubstitutionCallback>签名，您可以替换缓存的输出内容的页面缓存中任何给定位置。 若要开始替换，调用<xref:System.Web.HttpResponse.WriteSubstitution%2A>方法，并向其传递回调方法，它必须是线程安全并可以是以下之一：  
  
-   容器页或用户控件上的静态方法。  
  
-   静态或实例方法对另一个任意对象。  
  
 在页上，对第一个请求上<xref:System.Web.HttpResponse.WriteSubstitution%2A>调用<xref:System.Web.HttpResponseSubstitutionCallback>委托以生成输出。 然后，它将替换缓冲区添加到响应，以保留要在今后的请求调用的委托。 最后，它会降低客户端的可缓存性从公开为仅服务器不在客户端上缓存来确保以后对页重新调用的请求委托。  
  
> [!NOTE]
>  缓存后替换不支持缓存的用户控件的输出缓存用户控件级别应用。 这也称为分段缓存。 有关详细信息，请参阅[缓存的 ASP.NET 页面的某些部分](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The target of the <paramref name="callback" /> parameter is of type <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">设置页面的可缓存性</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">缓存 ASP.NET 页面的部分</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">动态更新缓存的页面的部分</related>
      </Docs>
    </Member>
  </Members>
</Type>