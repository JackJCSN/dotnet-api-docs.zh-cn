<Type Name="LinqDataSource" FullName="System.Web.UI.WebControls.LinqDataSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2428f9fb506effcb3a27648da9609ff286984250" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68393183" /></Metadata><TypeSignature Language="C#" Value="public class LinqDataSource : System.Web.UI.WebControls.ContextDataSource, System.Web.DynamicData.IDynamicDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LinqDataSource extends System.Web.UI.WebControls.ContextDataSource implements class System.Web.DynamicData.IDynamicDataSource, class System.Web.UI.IDataSource" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.LinqDataSource" />
  <TypeSignature Language="VB.NET" Value="Public Class LinqDataSource&#xA;Inherits ContextDataSource&#xA;Implements IDynamicDataSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class LinqDataSource : System::Web::UI::WebControls::ContextDataSource, System::Web::DynamicData::IDynamicDataSource" />
  <TypeSignature Language="F#" Value="type LinqDataSource = class&#xA;    inherit ContextDataSource&#xA;    interface IDynamicDataSource&#xA;    interface IDataSource" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.ContextDataSource</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.5">System.Web.UI.DataSourceControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.DynamicData.IDynamicDataSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Selecting")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ContextTypeName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.ico")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持通过标记文本在 ASP.NET 网页中使用语言集成查询 (LINQ)，以从数据对象中检索和修改数据。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题内容：  
  
-   [介绍](#introduction)  
  
-   [操作顺序](#order_of_operations)  
  
-   [数据排序](#ordering_data)  
  
-   [数据分组](#grouping_data)  
  
-   [数据修改](#data_modifications)  
  
-   [在运行时计算值](#evaluating_value_at_run_time)  
  
-   [使用存储过程](#working_with_stored_procedures)  
  
-   [声明性语法](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>介绍  
 语言集成查询 (LINQ) 是一种查询语法, 它可定义一组查询运算符, 使遍历、筛选和投影操作能够以声明性方式在任何中表示。基于网络的编程语言。 数据对象可以是内存中的数据集合或表示来自数据库的数据的对象。 您可以检索或修改数据, 而不必为每个操作都编写 SQL 命令。  
  
 使用<xref:System.Web.UI.WebControls.LinqDataSource>控件, 可以通过在标记文本中设置属性来在 ASP.NET 网页中使用 LINQ。 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 来自动生成数据命令。 有关 LINQ to SQL 的详细信息, 请参阅[LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 从内存中数据集合中检索数据时, 请将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数据集合的类。 将<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为返回数据集合的属性或字段。 例如, 你可能有一个名为`Person`的类, 该类包含一个名为`FavoriteCities`的属性, 该属性将返回字符串值的数组。 在这种情况下, 将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置`Person`为, 并<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>将属性`FavoriteCities`设置为。  
  
 查询数据库时, 必须首先创建表示该数据库及其表的实体类。 您可以使用[!INCLUDE[vs_ordesigner_long](~/includes/vs-ordesigner-long-md.md)]或 SqlMetal 实用程序来生成这些类。 然后, 将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为表示数据库的类, 并<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>将属性设置为表示数据库表的属性。  
  
<a name="order_of_operations"></a>   
## <a name="order-of-operations"></a>操作顺序  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件按以下顺序应用数据操作:  
  
1.  Where (指定要返回的数据记录)。  
  
2.  排序依据 (排序)。  
  
3.  分组依据 (对共享值的数据记录进行聚合)。  
  
4.  排序依据 (排序分组数据)。  
  
5.  选择 (指定要返回的字段或属性)。  
  
6.  自动排序 (按用户选择的属性对数据记录进行排序)。  
  
7.  自动页面 (检索用户选择的一小部分数据记录)。  
  
 您可以向<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性添加条件以筛选从查询返回的数据记录。 如果未<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>设置该属性<xref:System.Web.UI.WebControls.LinqDataSource> , 控件将从数据对象中检索每个记录。  
  
<a name="ordering_data"></a>   
## <a name="ordering-data"></a>数据排序  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性可以指定返回数据的属性名称, 以便进行排序。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.LinqDataSource>当你使用具有[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]的控件并且<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`时, 你必须在<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性中提供一个值。 默认情况下, <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性为`true`。 如果为<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性分配一个值, 则还必须在查询中返回的属性列表中包含所有标识列。  
  
<a name="grouping_data"></a>   
## <a name="grouping-data"></a>数据分组  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性可以指定哪些属性用于合并具有相同值的数据记录。 当对`Key` `It`数据进行分组时,可以在属性中包括和,它们是动态<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>创建的属性。 `Key`属性指的是用于对数据进行分组的属性中的值。 例如, 如果按名为`Category`的属性分组, 则`Key`属性将包含`Category`属性中的所有唯一值。 `It`属性引用数据分组中的单个记录的集合。 您可以循环访问`It`属性来检索在分组操作中合并的各个记录。 例如, 如果按名为`Category`的属性分组, 则属性将`It`包含在`Category`属性中共享公共值的所有单个记录。  
  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性可指定用于对分组数据进行排序的属性。 当对数据进行分组时<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> , 属性将指定如何对分组数据中的单个记录进行排序。  
  
 默认情况下, <xref:System.Web.UI.WebControls.LinqDataSource>控件从数据对象中检索所有属性的值。 如果要使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>可用属性的子集, 则可以使用属性来指定要返回的属性。 选择操作应用于 Where、Order By 和 Group By 操作之后。 因此, 如果在 Select 子句中创建了别名, 则该别名在其他子句中不可用。  
  
<a name="data_modifications"></a>   
## <a name="data-modifications"></a>数据修改  
 您可以使用<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>、 <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>和<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>属性指定是否启用了数据修改。 用于修改<xref:System.Web.UI.WebControls.LinqDataSource>控件中数据的用户界面通常是通过数据绑定控件 (例如<xref:System.Web.UI.WebControls.DetailsView>控件) 提供的。 除了将、 <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>或<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> <xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>设置为`true`以外, 还需要满足以下条件才能启用自动数据修改:  
  
-   不能为属性赋值。 <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>  
  
-   不能为属性赋值。 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>  
  
-   分配给<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性的类必须派生自<xref:System.Data.Linq.DataContext>。  
  
-   分配给<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性的属性必须派生自<xref:System.Data.Linq.Table%601>。  
  
 可以通过两种方式限制在数据绑定控件中显示哪些属性。 可以将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为属性的子集, 也可以通过添加<xref:System.Web.UI.WebControls.DataControlField>控件来定义数据绑定控件的字段。 但是, 如果设置了<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性, 则表示不能启用自动更新、插入和删除操作。 如果要在使用可用属性的子集时启用自动数据修改, 请不要设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 相反, 从数据对象检索所有属性, 并使用数据绑定控件来管理要显示的属性。 <xref:System.Web.UI.WebControls.DetailsView>使用控件<xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A> `false`或控件时, 还必须将或<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>属性设置为。 <xref:System.Web.UI.WebControls.GridView> 这会阻止数据绑定控件自动包含用于编辑和删除数据的按钮。 数据绑定控件中未显示的任何值都存储在视图状态中。 当执行数据更新时, 它们将以不更改的形式传递到数据源。  
  
<a name="evaluating_value_at_run_time"></a>   
## <a name="evaluating-values-at-run-time"></a>在运行时计算值  
 如果需要在运行时评估值以便对值进行排序、筛选或分组, 则可以将参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>添加到<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>、 <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>、或<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。  
  
 如果要指定默认值, 则可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合中。  
  
 如果要在执行数据操作之前检查或修改值, 可以<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>处理、 <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>、 <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>或<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。 您还可以处理这些事件, 以便取消数据操作, 或检查在基于用户输入设置数据类中的属性时发生的验证错误。  
  
 若要在数据操作完成后检查值, 请处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>、 <xref:System.Web.UI.WebControls.LinqDataSource.Inserted>、 <xref:System.Web.UI.WebControls.LinqDataSource.Selected>或<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件。  
  
<a name="working_with_stored_procedures"></a>   
## <a name="working-with-stored-procedures"></a>使用存储过程  
 通过为<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件<xref:System.Web.UI.WebControls.LinqDataSource>创建事件处理程序, 可以使用该控件从存储过程中检索数据。 在事件处理程序中, 调用数据上下文类中的方法, 该方法表示存储过程, 并将结果设置为<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A> <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs>对象的属性。 如果要对数据启用自动更新、插入和删除操作, 则从方法返回的类型必须与<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性中指定的类型匹配。 有关创建数据上下文方法的详细信息, 请[参阅如何:创建映射到存储过程和函数的 DataContext 方法（O/R 设计器）](https://msdn.microsoft.com/library/e7ca32f1-50b3-48af-ad92-ceafd749296a)。  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>声明性语法  
  
```  
<asp:LinqDataSource  
    AutoGenerateOrderByClause="True|False"  
    AutoGenerateWhereClause="True|False"  
    AutoPage="True|False"  
    AutoSort="True|False"  
    ContextTypeName="string"  
    EnableDelete="True|False"  
    EnableInsert="True|False"  
    EnableTheming="True|False"  
    EnableUpdate="True|False"  
    EnableViewState="True|False"  
    GroupBy="string"  
    ID="string"  
    OnContextCreated="ContextCreated event handler"  
    OnContextCreating="ContextCreating event handler"  
    OnContextDisposing="ContextDisposing event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDeleted="Deleted event handler"  
    OnDeleting="Deleting event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnInserted="Inserted event handler"  
    OnInserting="Inserting event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnSelected="Selected event handler"  
    OnSelecting="Selecting event handler"  
    OnUnload="Unload event handler"  
    OnUpdated="Updated event handler"  
    OnUpdating="Updating event handler"  
    OrderBy="string"  
    runat="server"  
    Select="string"  
    SkinID="string"  
    StoreOriginalValuesInViewState="True|False"  
    TableName="string"  
    Visible="True|False"  
    Where="string"  
>  
        <GroupByParameters />  
        <InsertParameters />  
        <OrderByParameters />  
        <SelectParameters />  
        <WhereParameters />  
</asp:LinqDataSource>  
```  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个控件, 该控件从名为`Products`的实体类中检索数据。 实体类可能是使用[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal 实用程序生成的。 此<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性设置为仅返回`Price`属性中值大于50的记录。 <xref:System.Web.UI.WebControls.GridView>控件绑定<xref:System.Web.UI.WebControls.LinqDataSource>到控件以显示数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例显示一个<xref:System.Web.UI.WebControls.LinqDataSource>控件, 该控件允许用户在数据源中更新、删除和插入记录。 控件将绑定<xref:System.Web.UI.WebControls.LinqDataSource>到控件, 并使用户能够查看和修改数据。 <xref:System.Web.UI.WebControls.DetailsView> 请注意, 不需要 SQL 命令即可选择、更新、删除或插入记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 下面的示例演示了一个<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件的事件处理程序, 该事件根据网页中的值设置数据对象。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示一个<xref:System.Web.UI.WebControls.LinqDataSource>配置为按两列分组的控件。 属性引用具有两个属性 (和`Color`) `ProductCategory`的对象。 `Key` 所表示`It`的对象已重命名为 (化名`Products`为)。 重命名`Products`的对象包含分组中各个记录的集合。 每个实例都将包含`Products`表中的所有列。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例演示两<xref:System.Web.UI.WebControls.ListView>个控件, 这些控件在上<xref:System.Web.UI.WebControls.LinqDataSource>一示例的控件中显示数据。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组数据, 另<xref:System.Web.UI.WebControls.ListView>一个控件显示属于该组的产品的各个名称。 嵌套的数据绑定控件的<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`, 这`It`是对象的别名。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinqDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinqDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateOrderByClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateOrderByClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateOrderByClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateOrderByClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateOrderByClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateOrderByClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否根据 <see cref="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" /> 集合中的值动态创建 Order By 子句。</summary>
        <value><see langword="true" />如果控件创建 Order By 子句, <see langword="false" />则为; 否则为。 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性设置为`true`时, <xref:System.Web.UI.WebControls.LinqDataSource>控件将动态创建基于<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中的值的 Order By 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控件按第一个参数对数据进行排序, 并另外对每个附加参数的数据进行排序。 包含`null`或空值的参数不包含在 Order By 子句中。  
  
 如果设置为<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> ,`true`则不设置属性, 因为分析器会动态创建<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> Order By 子句。 如果将设置为<xref:System.Web.UI.WebControls.LinqDataSource> `true` ,并且<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>为属性赋值, 则该控件引发异常。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个控件, <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>该控件`true`的设置为。 参数包含在基于用户<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> <xref:System.Web.UI.WebControls.DropDownList>从控件中选择的属性名称对数据进行排序的集合中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateWhereClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateWhereClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateWhereClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateWhereClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateWhereClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateWhereClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.AutoGenerateWhereClause</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否基于 <see cref="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" /> 集合中定义的值来动态创建 Where 子句。</summary>
        <value>如果 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件将创建 Where 子句，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`true`时, <xref:System.Web.UI.WebControls.LinqDataSource>控件将从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中的参数动态创建 Where 子句。 添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中的每个参数都必须将<xref:System.Web.UI.WebControls.Parameter.Name%2A>其属性设置为与正在查询的数据对象中的属性匹配的值。 自动生成的 Where 子句将检查在<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中指定的值是否等于数据对象中的匹配属性的值。 如果提供多个参数, 则这些参数将与逻辑`AND`操作链接。 包含`null`或空值的参数不包含在 Where 子句中。  
  
 自动生成<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>的子句只能测试相等性, 只能链接到`AND`操作的参数。 如果必须添加不<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>测试相等`true`性的条件, 或者必须将参数与`OR`操作相关联, 请不要将属性设置为。 可以通过将<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`false` , 并在该<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> <xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中的每个参数的属性中添加占位符, 来完成这些任务。 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>在属性中, 在每个占位符名称前面加上 @ 符号。  
  
 当属性为时, <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>不会设置属性, `true`因为分析器会动态创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> 如果该<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性为`true` , 则该<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> 控件引发异常,并且为属性赋值。<xref:System.Web.UI.WebControls.LinqDataSource>  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个控件, <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>该控件`true`的设置为。 <xref:System.Web.UI.WebControls.GridView>控件绑定<xref:System.Web.UI.WebControls.LinqDataSource>到控件以显示从查询返回的数据。 包含用三个值填充的控件。<xref:System.Web.UI.WebControls.DropDownList> 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中, 其名称设置为`Category,` , 与数据对象的一个属性匹配。 将<xref:System.Web.UI.WebControls.ControlParameter.ControlID%2A>其属性设置为<xref:System.Web.UI.WebControls.DropDownList>控件的 ID。 控件自动创建属性, 以根据用户从<xref:System.Web.UI.WebControls.DropDownList>控件中选择的值来筛选记录。 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> <xref:System.Web.UI.WebControls.LinqDataSource> 查询返回的记录`Category`的属性与用户<xref:System.Web.UI.WebControls.DropDownList>从控件中选择的值匹配。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default7.aspx#7)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default7.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoPage">
      <MemberSignature Language="C#" Value="public bool AutoPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoPage { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPage : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时在数据的各部分之间导航。</summary>
        <value>如果用户可以对数据进行分页，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将属性设置为`true` , <xref:System.Web.UI.WebControls.LinqDataSource>以在控件中启用分页。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> 若要使用户能够对数据进行分页, 请连接一个数据绑定控件, 该控件提供用于分页到<xref:System.Web.UI.WebControls.LinqDataSource>控件的接口。 当属性设置为`true`时, <xref:System.Web.UI.WebControls.LinqDataSource>控件在数据绑定控件中只检索一页中的记录。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> 它使用<xref:System.Linq.Enumerable.Skip%2A>和<xref:System.Linq.Enumerable.Take%2A>方法检索当前页的记录。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个控件<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A> , 其属性设置`true`为, <xref:System.Web.UI.WebControls.GridView>并且有一个绑定到该<xref:System.Web.UI.WebControls.LinqDataSource>控件的控件。 将<xref:System.Web.UI.WebControls.GridView.AllowPaging%2A> <xref:System.Web.UI.WebControls.GridView>控件的属性设置为`true` , 以提供允许用户逐页浏览数据的接口。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSort">
      <MemberSignature Language="C#" Value="public bool AutoSort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSort" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoSort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSort : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时对数据进行排序。</summary>
        <value>如果用户可以对数据进行排序，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件支持两种对数据进行排序的方法。 您可以使用<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性启用运行时排序, 也可以<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>将属性设置为在设计时定义排序。  
  
 将属性设置为`true` , <xref:System.Web.UI.WebControls.LinqDataSource>以便在基于数据绑定控件中的排序表达式的控件中启用排序。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> 数据绑定控件提供了接口, 使用户能够在运行时选择要用于排序的属性。  
  
 您可以通过将<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为用于排序的属性或属性, 以编程方式设置返回数据的顺序。 当属性设置为属性<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>且属性为`true`时, 将在<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性中的表达式后应用数据绑定控件中的排序表达式。 <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> 因此, 这将确定数据的最终排序。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个控件<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> , 其属性设置`true`为, <xref:System.Web.UI.WebControls.GridView>并且有一个绑定到该<xref:System.Web.UI.WebControls.LinqDataSource>控件的控件。 将<xref:System.Web.UI.WebControls.GridView.AllowSorting%2A> <xref:System.Web.UI.WebControls.GridView>控件的属性设置为`true` , 以提供允许用户对数据进行排序的接口。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ ContextCreated;" />
      <MemberSignature Language="F#" Value="member this.ContextCreated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.ContextCreated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.ContextCreated>处理事件以检查上下文类型对象, 或检查在创建对象时引发的异常。 从与此事件关联的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A> <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象的属性中检索上下文类型对象。 从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性中检索在数据操作过程中引发的异常。  
  
 上下文类型对象是在 select、update、insert 和 delete 操作过程中创建的, 并在整个请求中重复使用。  
  
 不引发事件时有一次。 这是在<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件中以编程<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>方式将属性设置为对象时的情况。 另一种情况是, 原始值不必存储在视图状态中, 或者<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性中的对象<xref:System.Data.Linq.ITable>实现接口。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreating As EventHandler(Of LinqDataSourceContextEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceContextEventArgs ^&gt; ^ ContextCreating;" />
      <MemberSignature Language="F#" Value="member this.ContextCreating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " Usage="member this.ContextCreating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, <xref:System.Web.UI.WebControls.LinqDataSource>该控件创建<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>在属性中指定的类型的实例。 <xref:System.Web.UI.WebControls.LinqDataSource>控件调用数据上下文对象的无参数构造函数来创建对象的实例。 您可能必须使用非参数构造函数, 或者必须创建一个与<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性中指定的对象不同的对象。 在这种情况下, 必须处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件并手动创建数据上下文对象。  
  
 上下文类型对象是在 select、update、insert 和 delete 操作过程中创建的。  
  
 不引发事件时有一次。 这是以编程方式将<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性设置为<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件的事件处理程序中的对象时。 另一种情况是, 原始值不必存储在视图状态中, 或者<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性中的对象<xref:System.Data.Linq.ITable>实现接口。  
  
   
  
## Examples  
 下面的示例演示如何通过在<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件期间使用非参数构造函数来创建数据上下文对象。 该代码将对象分配给<xref:System.Web.UI.WebControls.LinqDataSourceContextEventArgs.ObjectInstance%2A>属性。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextDisposing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextDisposing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextDisposing As EventHandler(Of LinqDataSourceDisposeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDisposeEventArgs ^&gt; ^ ContextDisposing;" />
      <MemberSignature Language="F#" Value="member this.ContextDisposing : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " Usage="member this.ContextDisposing : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在释放上下文类型对象前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextDisposing>事件以手动释放对象, 或在销毁对象之前执行特定于对象的清理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextTypeName">
      <MemberSignature Language="C#" Value="public override string ContextTypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContextTypeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextTypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContextTypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextTypeName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含属性（其值包含要检索的数据）的类型的名称。</summary>
        <value>要从中检索数据的类的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.WebControls.LinqDataSource>控件从内存中数据集合或数据库检索数据时, 必须指定两个属性。 第一个是表示数据源的数据上下文类。 第二个是数据上下文类中包含数据的属性。 将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为数据上下文类的名称, 并<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>将属性设置为包含数据的数据集合。  
  
 例如, 从数据库中检索数据时, 请将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为表示数据库的类的名称。 还将<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为表示数据库中的表的属性。 若要从数据库生成类, 请使用[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal 实用程序来自动生成这些类。  
  
 从内存中的数据集合 (如数组) 中检索数据时, 请将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数组属性的类的名称。 然后将<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为可获取数组的属性。  
  
 若要通过<xref:System.Web.UI.WebControls.LinqDataSource>控件启用自动更新、插入或删除操作, 则分配<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>给属性的类必须派生自<xref:System.Data.Linq.DataContext>。 此外, 分配<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>给属性的属性必须派生自<xref:System.Data.Linq.Table%601>。 如果不需要启用自动更新、插入或删除操作, 则可以将任何类型的类的名称分配给<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。  
  
 有关如何从类的实例中选择数据的信息, 请参见<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含字符串数组的类。 它还演示如何将属性设置为表示数据库的类 (由[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]生成)。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 在此示例`ExampleDataContext`中不显示名为的类, 它表示数据库表。 要使此示例正常运行, 必须通过添加一个名为 Example 的 LINQ To SQL 类并将名为 "Movie" 的[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]表拖到上来创建此类。 生成一个名`ExampleDataContext`为的类, `Movies`其中包含名为的属性。  
  
 下面的示例显示了`MovieLibrary` <xref:System.Web.UI.WebControls.LinqDataSource>在控件中引用的名为的类。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="CreateQueryableView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateQueryableView" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateQueryableView () As QueryableDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::WebControls::QueryableDataSourceView ^ CreateQueryableView();" />
      <MemberSignature Language="F#" Value="override this.CreateQueryableView : unit -&gt; System.Web.UI.WebControls.QueryableDataSourceView" Usage="linqDataSource.CreateQueryableView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.QueryableDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回可查询的视图。</summary>
        <returns>可查询的视图。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateView">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.LinqDataSourceView CreateView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.LinqDataSourceView CreateView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateView" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateView () As LinqDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::LinqDataSourceView ^ CreateView();" />
      <MemberSignature Language="F#" Value="abstract member CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView&#xA;override this.CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView" Usage="linqDataSource.CreateView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.LinqDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与此控件相关联的 <see cref="T:System.Web.UI.WebControls.LinqDataSourceView" /> 类的新实例。</summary>
        <returns>充当数据绑定控件的接口的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要提供自定义视图, 可以在派生类中重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public int Delete (System.Collections.IDictionary keys, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Delete(class System.Collections.IDictionary keys, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Delete(System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete (keys As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Delete(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Delete (keys, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要删除的记录的行键值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行删除操作。</summary>
        <returns>受删除操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 您不必从代码中调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法。 当使用<xref:System.Web.UI.WebControls.LinqDataSource>带有数据绑定控件的控件时, 数据绑定控件将在用户采取操作删除记录时<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>自动调用方法。 若要创建自己<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>的删除数据的进程, 请显式调用方法。 例如, 如果要基于数据绑定<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>控件之外的事件删除记录, 则可以调用方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Deleted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成删除操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Deleted>处理事件, 以捕获删除操作中的任何异常, 或在操作完成后检查输出参数。 可以从传递给事件处理程序的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象中检索输出参数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection DeleteParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection DeleteParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeleteParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ DeleteParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此属性。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleting As EventHandler(Of LinqDataSourceDeleteEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDeleteEventArgs ^&gt; ^ Deleting;" />
      <MemberSignature Language="F#" Value="member this.Deleting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " Usage="member this.Deleting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行删除操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Deleting>处理事件以验证要删除的对象, 检查数据类中的数据验证错误, 更改删除操作之前的值, 或取消删除操作。 控件将<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象传递<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>给事件的事件处理程序。 <xref:System.Web.UI.WebControls.LinqDataSource> <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象包含要删除的数据, 并允许您取消删除操作。 如果数据类引发<xref:System.Web.UI.WebControls.LinqDataSourceValidationException>异常, 则<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象在<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.Exception%2A>属性中包含该异常。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件的事件处理程序中引发了异常, 则必须在该事件处理程序中处理异常。 异常将不会传递到<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>事件的事件处理程序 ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象的属性)。 属性仅包含<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件之后引发的异常。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件的事件处理程序。 此代码基于<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.OriginalObject%2A>属性中的属性和网页中的值取消删除操作。 在此示例中, 当`OnSale`属性设置为`true`时, 用户必须选择一个<xref:System.Web.UI.WebControls.CheckBox>控件以确认是否应删除记录。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDelete">
      <MemberSignature Language="C#" Value="public bool EnableDelete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDelete" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableDelete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableDelete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDelete : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableDelete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件删除数据记录。</summary>
        <value>如果启用了自动删除操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果希望允许用户`true`通过<xref:System.Web.UI.WebControls.LinqDataSource>控件删除数据记录, 请将属性设置为。<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A> 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>为`true`时,<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 自动创建用于删除数据的命令。 您必须包含一个接口, 该接口允许用户选择要删除的记录, 例如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 当设置<xref:System.Web.UI.WebControls.LinqDataSource> 属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性时, 控件不支持自动删除操作。 <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> 在这种情况下<xref:System.Web.UI.WebControls.LinqDataSource> , 如果尝试删除操作, 控件将引发异常。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>设置为`true`的控件。 <xref:System.Web.UI.WebControls.DetailsView>控件显示数据, 并创建一个按钮, 该按钮允许用户删除数据记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableInsert">
      <MemberSignature Language="C#" Value="public bool EnableInsert { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInsert" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableInsert As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableInsert { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableInsert : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableInsert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件插入数据记录。</summary>
        <value>如果启用了自动插入操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果希望允许用户`true`通过<xref:System.Web.UI.WebControls.LinqDataSource>控件插入新数据记录, 请将属性设置为。<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A> 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>为`true`时,<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 自动创建用于插入数据的命令。 您必须包含一个接口, 该接口允许用户插入新记录, 例如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 当设置<xref:System.Web.UI.WebControls.LinqDataSource> 属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性时, 控件不支持自动插入操作。 <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> 在这种情况下<xref:System.Web.UI.WebControls.LinqDataSource> , 如果尝试插入操作, 控件将引发异常。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>设置为`true`的控件。 <xref:System.Web.UI.WebControls.DetailsView>控件显示数据并显示一个按钮, 该按钮将控件切换到插入模式, 用户可在其中创建和保存新记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableObjectTracking">
      <MemberSignature Language="C#" Value="public bool EnableObjectTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableObjectTracking" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableObjectTracking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableObjectTracking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableObjectTracking : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否跟踪对数据上下文对象所做的更改。</summary>
        <value>如果跟踪数据上下文对象的更改，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A>属性仅在从 LINQ to SQL 数据上下文对象选择数据时使用。  
  
 与只读数据交互时, 将<xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A>属性设置为可`false`提高性能, 因为数据不会进行缓存以确定其是否已更改。 但是, 它还禁用延迟的查询执行。 如果要使用延迟的查询`true`执行, 则必须将此属性设置为。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EnableUpdate">
      <MemberSignature Language="C#" Value="public bool EnableUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUpdate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUpdate : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件更新数据记录。</summary>
        <value>如果启用了自动更新操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果希望允许用户`true`使用<xref:System.Web.UI.WebControls.LinqDataSource>控件更新数据记录, 请将属性设置为。<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A> 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>为`true`时,<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 自动创建用于更新数据的命令。 必须包含允许用户更新记录 (如<xref:System.Web.UI.WebControls.DetailsView>控件) 的接口。  
  
 当设置<xref:System.Web.UI.WebControls.LinqDataSource> 属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性时, 控件不支持自动更新操作。 <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A> 在这种情况下<xref:System.Web.UI.WebControls.LinqDataSource> , 如果尝试更新操作, 控件将引发异常。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Web.UI.WebControls.LinqDataSource>一个<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>设置为`true`的控件。 <xref:System.Web.UI.WebControls.DetailsView>控件显示数据, 并创建一个按钮, 该按钮允许用户更新数据记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.DataSourceView GetView (string viewName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.DataSourceView GetView(string viewName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetView(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetView (viewName As String) As DataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::DataSourceView ^ GetView(System::String ^ viewName);" />
      <MemberSignature Language="F#" Value="override this.GetView : string -&gt; System.Web.UI.DataSourceView" Usage="linqDataSource.GetView viewName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetView(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataSourceView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewName" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="viewName">要检索的视图名称，必须是“DefaultView”。</param>
        <summary>返回与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象关联的数据源视图。</summary>
        <returns>与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象关联的数据源视图。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<xref:System.Web.UI.WebControls.LinqDataSource>控件仅支持一个数据源视图。 <xref:System.Web.UI.WebControls.LinqDataSourceView>对象的默认名称为 "DefaultView"。 <xref:System.Web.UI.WebControls.LinqDataSourceView>对象定义数据源控件的功能、从基础数据库检索数据, 以及执行排序、插入、删除和更新等操作。

]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><p>viewName 为 null（Visual Basic 中为 Nothing）或除“DefaultView”以外的名称。</p></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="GetViewNames">
      <MemberSignature Language="C#" Value="protected override System.Collections.ICollection GetViewNames ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.ICollection GetViewNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetViewNames" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetViewNames () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::ICollection ^ GetViewNames();" />
      <MemberSignature Language="F#" Value="override this.GetViewNames : unit -&gt; System.Collections.ICollection" Usage="linqDataSource.GetViewNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetViewNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回名称的集合，这些名称表示与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件关联的视图对象的列表。</summary>
        <returns>具有一个包含名称“DefaultView”的元素的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
控件在其基础数据上仅支持一个名为`DefaultView`的视图。 <xref:System.Web.UI.WebControls.LinqDataSource> 因此`GetViewNames` , 该方法返回一个集合, 该集合仅包含一个包含此视图名称的元素。

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public string GroupBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ GroupBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行分组的属性。</summary>
        <value>用于创建 Group By 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性可以指定用于合并具有相同值的数据记录的属性。 例如, 如果将<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为`Name`, 则具有相同`Name`属性值的查询中的所有记录都将作为单个合并记录返回。  
  
 可以通过<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A> `new`在函数中包含所有属性, 并使用逗号分隔每个属性, 从而将多个属性分配给该属性。 例如, `Name`若要按属性分组, 然后`Category`将<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为`new(Name, Category)`。  
  
 用于分组的属性中的值是通过名为`Key`的生成的属性返回的。 将`Key`属性包含<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>在属性中以检索分组值。 `Key` 可以`As`使用关键字将属性设置为别名, 但不需要使用别名。 例如, 可以将<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为名为`Category`的属性。 您可以通过<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>将属性设置为来`Category` `new(Key As ProductCategory)`检索属性中的合并值。  
  
 可以通过在`It` <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中包含属性来访问分组中的单个记录。 `It`属性包含共享分组属性中的值的记录的集合。 您可以循环访问`It`属性来检索各个记录。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性通常与聚合方法一起使用。 您可以使用以下聚合方法:  
  
-   `Count()`  
  
-   `Average(`*列*`)`  
  
-   `Sum(`*列*`)`  
  
-   `Max(`*列*`)`  
  
-   `Min(`*列*`)`  
  
-   `Where(`*条件*`)`  
  
-   `Any()`  
  
-   `All(`*条件*`)`  
  
 有关详细信息，请参阅 [NIB：LinqDataSource Web 服务器控件概述](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[如何:使用 LinqDataSource 控件](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)对数据进行分组和聚合。  
  
   
  
## Examples  
 下面的示例显示一个<xref:System.Web.UI.WebControls.LinqDataSource>控件, 该控件按名为`Category`的属性对返回的数据进行分组。 它将返回共享值并计算分组记录的平均价格。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 下面的示例演示一个<xref:System.Web.UI.WebControls.LinqDataSource>配置为按两列分组的控件。 属性引用具有两个属性 (和`Color`) `ProductCategory`的对象。 `Key` 所表示`It`的对象已重`Products`命名。 重命名`Products`的对象包含分组中各个记录的集合, 每个实例都包含 Products 表中的所有列。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例演示两<xref:System.Web.UI.WebControls.ListView>个控件, 用于在上一个<xref:System.Web.UI.WebControls.LinqDataSource>示例中显示控件中的数据。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组数据, 另<xref:System.Web.UI.WebControls.ListView>一个控件显示属于该组的产品的各个名称。 嵌套的数据绑定控件的<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`, 这`It`是对象的别名。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection GroupByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection GroupByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ GroupByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Group By 子句的参数集合。</summary>
        <value>用于创建 Group By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合中的参数在运行时创建 Group by 子句。 <xref:System.Web.UI.WebControls.LinqDataSource> 通常不会使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合对数据进行分组。 您可以改为<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>使用属性。 仅当在<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>运行时必须设置 Group by 子句中的值并且该值不是属性名时, 才使用该集合。 例如, 根据数据记录<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>中的`LastName`属性是否等于用户提供的值, 使用集合对数据进行分组。  
  
 如果要按属性对数据进行分组, 并且无需在运行时设置该属性, 则可以在<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性中定义分组属性。 例如, 若要返回按分组的数据库表中的`LastName`值, <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>则将设置为 "LastName" 而不使用任何参数。 如果要按属性动态分组数据, 请为<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件创建一个事件处理程序, 并根据需要<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>自定义属性。  
  
 不能将属性的名称指定为<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合中的参数的值。 如果要将条件添加<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A> <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>到必须在运行时设置的属性, 请将参数添加到集合。  
  
 若要设置集合中<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>的值, 请为每个参数分配一个名称, 然后<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>在该命名参数的属性中添加占位符。 在 Group By 子句中, 每个参数名称前面加上 @ 符号。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public int Insert (System.Collections.IDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Insert(class System.Collections.IDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Insert(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (values As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Insert(System::Collections::IDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.Insert : System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Insert values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="values">要插入到数据源的行值。</param>
        <summary>执行插入操作。</summary>
        <returns>受插入操作影响的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 您不必从代码中调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法。 当用户采取操作插入新记录时, <xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>数据绑定控件将自动调用方法。 若要创建自己<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>的插入数据的进程, 请显式调用方法。  
  
   
  
## Examples  
 下面的示例演示如何在用户单击按钮后, 以编程方式在数据源中插入新记录。 此代码将包含<xref:System.Collections.Specialized.ListDictionary>默认值的对象传递<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>给方法。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx.vb#1)]  
  
 下面的示例演示上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Inserted;" />
      <MemberSignature Language="F#" Value="member this.Inserted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Inserted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成插入操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Inserted>处理事件以从插入操作捕获任何异常, 或在插入操作完成后检查值。 您可以通过传递到事件处理程序<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>的对象检索新值。 例如, 可以使用<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象检索数据库为新数据记录生成的标识属性。  
  
   
  
## Examples  
 下面的示例演示如何为<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件创建一个事件处理程序, 该事件用于检查异常并检索新记录的标识属性。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/cs/Default.aspx#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserting As EventHandler(Of LinqDataSourceInsertEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceInsertEventArgs ^&gt; ^ Inserting;" />
      <MemberSignature Language="F#" Value="member this.Inserting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " Usage="member this.Inserting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行插入操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>处理事件以验证要插入的对象, 检查数据类中的数据验证错误, 更改插入操作之前的值, 或取消插入操作。 传递给此事件的事件处理程序的对象包含要插入到数据源中的新对象。<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>  
  
 如果在插入操作过程中发生验证错误, 则<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象将包含由数据类引发的验证异常。 如果要插入的值与数据类中的属性的类型不匹配, 则会发生验证错误, 或者, 如果未通过自定义验证检查, 则会发生验证错误。 在<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件的事件处理程序中, 可以检索验证异常并采取适当的操作。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件的事件处理程序中引发了异常, 则必须在该事件处理程序中处理异常。 异常将不会传递到<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件的事件处理程序 ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象的属性)。 属性仅包含<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件之后引发的异常。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 下面的示例演示在插入操作之前修改<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>数据的事件的事件处理程序。 该<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs.NewObject%2A>属性中的对象将强制转换为一个名`Product`为的类型。 `Product`对象`DateModified`的属性设置为当前日期和时间。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/vb/Default.aspx.vb#1)]  
  
 下面的示例演示了检索验证异常的<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件的事件处理程序。  
  
```vb  
Protected Sub LinqDataSource_Inserting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceInsertEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Inserting(object sender,   
        LinqDataSourceInsertEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例将检索验证异常。 如果值与属性的类型不匹配, 则可能会引发异常。 它也可能是自定义的检查 (如以下示例中的检查) 引发的。 方法检查`Age`属性的数目是否为负数。 `OnAgeChanging`  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection InsertParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection InsertParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InsertParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ InsertParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InsertParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在插入操作过程中使用的参数的集合。</summary>
        <value>在插入操作过程中使用的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 插入操作所需的值由数据绑定控件传递到<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当要提供默认值或定义是否将空值转换为`null`时, 可以指定 insert 参数。 您不必为要插入的每个值都提供参数, 只是在用户不提供值时必须处理的值。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合中提供的值仅用于在数据源中定义但未绑定到数据控件中的字段。 例如, 假设某个数据库表具有名称为 "名称"、"地址" 和 "邮政编码" 的<xref:System.Web.UI.WebControls.ListView>列, 但绑定到该表的控件仅绑定到 "名称" 和 "地址" 字段。 <xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合中的值将仅用于 "邮政编码" 字段。 它们不会用于 "名称" 和 "地址" 字段。 即使没有为这些字段输入值, 也是如此。 如果数据绑定控件自动生成数据源中的所有字段的字段, 则不会使用该集合<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>中的任何值。  
  
   
  
## Examples  
 下面的示例显示<xref:System.Web.UI.WebControls.LinqDataSource>一个控件, 该控件具有<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>在集合中提供默认值的参数。 如果用户未提供`Category`属性的值, 则由参数提供的默认值将保存在数据库中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default9.aspx#9)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default9.aspx#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected override void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadViewState : obj -&gt; unit" Usage="linqDataSource.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="savedState">一个对象，它表示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的状态。</param>
        <summary>加载必须保持的 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件中的值的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
方法用于加载以前保存的<xref:System.Web.UI.WebControls.LinqDataSource>控件视图状态。 `LoadViewState`

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="linqDataSource.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="linqDataSource.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Unload" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public string OrderBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行排序的字段。</summary>
        <value>用于创建 Order By 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性可以指定返回数据中用于排序的属性。 用于对数据进行排序的属性必须存在于原始数据源中, 但不一定要包含在<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中。 您`Ascending`可以向`Descending` `ASC`字符串<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>中的属性添加空格、 `DESC` 、或, 以指定如何返回排序的数据。  
  
 通过使用逗号分隔每个属性, 可以<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>在属性中提供多个属性。 例如, 若要按名为`LastName`和`FirstName`的属性进行排序<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A> , 请将属性设置为 "LastName, FirstName"。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.LinqDataSource>当你使用具有[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]的控件并且<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`时, 你必须在<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性中提供一个值。 默认情况下, <xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性为`true`。 如果为<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性分配一个值, 则还必须在查询中返回的属性列表中包含所有标识列。  
  
 如果将`true`属性设置为, 则在运行时, 数据绑定控件可以向<xref:System.Web.UI.WebControls.LinqDataSource>控件传递一个排序表达式。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A> 应用<xref:System.Web.UI.WebControls.LinqDataSource> <xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性后, 控件将应用数据绑定控件中的排序表达式。 因此, 根据数据绑定控件中的排序表达式返回数据。  
  
   
  
## Examples  
 下面的示例基于属性中的`Category`值以逆序字母顺序返回数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default4.aspx#4)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default4.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order By 子句的参数集合。</summary>
        <value>用于创建 Order By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中的参数在运行时创建 Order By 子句。 <xref:System.Web.UI.WebControls.LinqDataSource> 通常, 将参数<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> `true`添加到集合时, 将属性设置为。 <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> 当属性设置为`true`时<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> , 集合中的每个参数都按其在<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中指定的顺序添加到 Order by 子句中。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> 当属性为`true`时, 无需命名参数, 因为它们按顺序应用并且与占位符不匹配。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>  
  
 如果无需在运行时在 Order by 子句中设置值, 则无需使用该<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 您可以定义用于对<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性中的数据进行排序的字段。 例如, 若要从按排序的数据库表返回值`LastName`, 则<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>将设置为 "LastName", 不使用任何参数。  
  
 您可以设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中的参数, 并将参数与<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性中的占位符匹配, 但这种方法的应用程序是有限的。 使用此方法时, <xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中的参数无法表示列名称。 您可以将参数设置为值, 然后将该值与属性中的值进行比较。 例如, 你可以基于属性中的值是否小于参数表示的运行时值来对数据进行排序。  
  
   
  
## Examples  
 下面的示例显示一个 <xref:System.Web.UI.WebControls.LinqDataSource> 控件，其 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> 属性设置为 `true`。 参数包含在基于用户<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A> <xref:System.Web.UI.WebControls.DropDownList>从控件中选择的属性名称对数据进行排序的集合中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsBy">
      <MemberSignature Language="C#" Value="public string OrderGroupsBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderGroupsBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderGroupsBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderGroupsBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于对分组数据进行排序的字段。</summary>
        <value>用于创建订单组 By 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性指定数据组的排序方式。 例如, 您可以按`CategoryID`属性分组, 然后按`Price`属性的平均值对每个类别 ID 组进行排序。  
  
 只有在已对<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>数据进行分组后, 才能设置属性。 如果在未<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性的情况下设置属性, <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常。  
  
 用于对数据进行排序的属性必须是用于对数据进行分组的属性, 或者是分组数据上聚合函数的结果。 若要指定数据的排序方式, 可以向<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>字符串中的属性名称添加空格和字符串 "升序"、"ASC"、"降序" 或 "DESC"。  
  
 可以在<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性中指定多个属性。 使用逗号分隔每个属性。  
  
   
  
## Examples  
 下面的示例演示如何使用两个属性对数据进行分组, 以及如何使用这些属性之一对分组数据进行排序。 使用名`Products` `CategoryID`为和`Discontinued`的属性对名为的表中的数据进行分组。 分组数据按`CategoryID`属性进行排序。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default.aspx#1)]  
  
 下面的示例演示如何使用属性对数据进行分组, 以及如何根据聚合函数的结果对数据进行排序。 `Products`表中的数据通过`CategoryID`使用属性进行分组。 它基于每个组中的`UnitPrice`属性的平均值进行排序。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderGroupsByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderGroupsByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order Groups By 子句的参数集合。</summary>
        <value>用于创建订单组 By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件在运行时使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合中的参数来创建订单组 by 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 仅当必须在顺序<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>组 by 子句中设置运行时值时, 才向集合添加值。 您可以使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性定义用于对数据进行排序的字段。  
  
 可以在<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合中设置参数, 并将参数与<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性中的占位符匹配。 但是, 在使用此方法时, <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合中的参数不能表示列名; 它们必须表示值。 您可以将参数设置为值, 然后将该值与属性进行比较。 例如, 你可以基于属性中的值是否小于参数表示的运行时值来对数据进行排序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected override object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="override this.SaveViewState : unit -&gt; obj" Usage="linqDataSource.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的当前视图状态。</summary>
        <returns>一个包含 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的已保存状态的对象。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public string Select { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Select" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberSignature Language="VB.NET" Value="Public Property Select As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Select { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Select : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置属性和计算值，它们包含在检索到的数据中。</summary>
        <value>用于创建 Select 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性<xref:System.Web.UI.WebControls.LinqDataSource> , 控件将从数据对象中检索所有属性 (数据列)。 使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性可以检索对象的属性子集, 或在检索数据时计算新值。  
  
 您可以通过将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为要包含在返回的数据中的属性的名称来指定要检索的属性。  
  
 如果从数据对象检索属性的子集, 则该<xref:System.Web.UI.WebControls.LinqDataSource>控件会动态创建一个类, 其中仅包含你<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>在属性中指定的属性。 如果计算数据对象中不是属性的属性, 也会动态创建类。 在这些情况下, 从查询返回的对象不是在<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性中指定的类的实例。 相反, 你必须使用`new` <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中的方法, 以指示从查询返回一个新类。 例如`FirstName` , 若要仅从包含以上属性的对象中返回和`LastName`属性, 请将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为`new(FirstName, LastName)`。 控件将动态创建你`new`在方法中指定的新类。 <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 可以使用`As`关键字为选定的值分配别名。 如果分配了别名, 则必须在`new`方法中包含别名属性。 任何绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件结果的数据绑定控件都必须通过别名引用属性。 <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>例如, 如果将属性设置为`new(Region As SalesRegion, Revenue / 1000 As RevenueThousands)`, 则数据绑定控件可以访问两个属性: `SalesRegion`和`RevenueThousands`。  
  
 根据下表`new`中列出的<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>条件, 使用属性中的函数。  
  
|选择|使用 new|示例|  
|------------|----------------|-------------|  
|单个属性。|`new`不需要。|`Select="Category"`|  
|多个属性。|`new`需.|`Select="new(Category, Name)"`|  
|具有别名的单个或多个属性。|`new`需.|`Select="new(Category As CategoryGroup)"`|  
  
 如果要启用自动数据修改, 但不希望显示数据对象中的所有属性, 请不要设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 而是通过数据绑定控件管理显示。 <xref:System.Web.UI.WebControls.DetailsView>使用控件`false` <xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A>或控件时,<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>还必须将或属性设置为。 <xref:System.Web.UI.WebControls.GridView> 数据绑定控件中未显示的任何值都存储在视图状态中。 当执行数据更新时, 它们将以不更改的形式传递到数据源。  
  
 在查询中对数据进行分组时, 可以在<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中包含聚合方法。 您可以使用以下聚合方法:  
  
-   `Count()`  
  
-   `Average(`*列*`)`  
  
-   `Sum(`*列*`)`  
  
-   `Max(`*列*`)`  
  
-   `Min(`*列*`)`  
  
-   `Where(`*条件*`)`  
  
-   `Any()`  
  
-   `All(`*条件*`)`  
  
 有关详细信息，请参阅 [NIB：LinqDataSource Web 服务器控件概述](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[如何:使用 LinqDataSource 控件](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)对数据进行分组和聚合。  
  
 当对`Key` `It`数据进行分组时,可以在属性中包括和,它们是动态<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>创建的属性。 `Key`属性指的是用于对数据进行分组的属性中的值。 例如, 如果按名为`Category`的属性分组, 则`Key`属性将包含`Category`属性中的每个唯一值。 `It`属性引用数据分组中的单个记录的集合。 您可以循环访问`It`属性来检索在分组操作中合并的各个记录。 例如, 如果按名为`Category`的属性分组, 则属性将`It`包含在`Category`属性中共享公共值的所有单个记录。  
  
 如果在对<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>数据`It`进行分组时在属性中包含关键字, 则必须为`It`关键字指定别名。 <xref:System.Web.UI.WebControls.LinqDataSource> 如果`It`没有别名, 控件将引发异常。 可以为`Key`关键字指定别名, 但这不是必需的。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为数据对象中的属性子集。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default10.aspx#10)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default10.aspx#10)]  
  
 下面的示例演示如何检索已用于对数据进行分组的属性中的值, 以及如何检索分组记录的平均值。 `Key`关键字包含用于对数据进行分组的属性。 在此示例中`Key` , 将包含`ProductCategory`属性中的共享值。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selected As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Selected;" />
      <MemberSignature Language="F#" Value="member this.Selected : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Selected : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>数据检索操作完成后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Selected>处理事件以从数据检索操作捕获任何异常, 或在检索操作完成后检查数据对象。 对象可从传递给事件<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>处理程序的对象中获取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selecting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selecting As EventHandler(Of LinqDataSourceSelectEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceSelectEventArgs ^&gt; ^ Selecting;" />
      <MemberSignature Language="F#" Value="member this.Selecting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " Usage="member this.Selecting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行数据检索操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>处理事件, 以便执行以下任务:  
  
-   修改数据检索的参数。  
  
-   以编程方式生成查询。  
  
-   修改排序或分页的值。  
  
-   执行自定义排序或分页。  
  
-   取消数据检索操作。  
  
 传递给此事件的事件处理程序的对象包含数据检索操作的参数。<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs> 您可以在执行查询之前修改<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件处理程序中的参数, 也可以创建新的结果集并将其分配<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>给属性。  
  
 在此事件的处理程序中实现自定义排序或分页的能力可能受到绑定到的<xref:System.Web.UI.WebControls.LinqDataSource>控件的限制。 例如, 单击<xref:System.Web.UI.WebControls.GridView>控件的列标题时, 控件将执行自动排序, 这可能会重写在事件处理程序中建立的任何顺序。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件的事件处理程序中引发了异常, 则必须在该事件处理程序中处理异常。 异常将不会传递到<xref:System.Web.UI.WebControls.LinqDataSource.Selected>事件的事件处理程序 ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象的属性)。 属性仅包含<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件之后引发的异常。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件的事件处理程序。 处理程序将创建一个查询, 该查询从网页中的字符串值数组中检索值。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示如何将<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性分配给从表示存储过程的方法返回的对象。  
  
```vb  
Protected Sub LinqDataSource_Selecting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceSelectEventArgs)  
    Dim exampleContext As ExampleDataContext = New ExampleDataContext()  
    e.Result = exampleContext.GetRegisteredCustomers()  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Selecting(object sender,   
        LinqDataSourceSelectEventArgs e)  
{  
    ExampleDataContext exampleContext = new ExampleDataContext();  
    e.Result = exampleContext.GetRegisteredCustomers();  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection SelectParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection SelectParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ SelectParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在数据检索操作过程中使用的参数的集合。</summary>
        <value>用于创建 Select 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合中的参数在运行时创建 Select 子句。 <xref:System.Web.UI.WebControls.LinqDataSource> 当要在 Select 子句<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>中使用运行时值时, 将参数添加到集合中。 例如, 可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合以表示用户配置文件中的属性。 然后, 可以使用该属性和数据源中的值计算新值。  
  
 如果不需要在运行时在 Select 子句中设置值, 则无需使用该<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合。 您可以定义要在<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中检索的属性。 例如, 若要从数据库`FirstName`表`LastName`中返回和值, 请将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>设置为 "FirstName, LastName" 而不使用任何参数。  
  
 若要设置<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合中的值, 请<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>在命名参数的属性中添加占位符。 在 Select 子句中, 每个参数名称前面加上 @ 符号。  
  
 不能使用<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合中的参数来表示属性名称。 若要将<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性动态设置为属性的名称, 请为<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件创建一个事件处理程序, 并根据<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>需要自定义属性。  
  
   
  
## Examples  
 下面的示例演示如何使用用户提供的值在返回的数据中计算值。 用户可以在文本框中输入表示生产天数的值。 该值除以数据库中的一个值, 该值表示生产产品的天数。 返回的值指示在指定天数内可制造的产品数。 用户的输入通过<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合包含在 Select 命令中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreOriginalValuesInViewState">
      <MemberSignature Language="C#" Value="public bool StoreOriginalValuesInViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StoreOriginalValuesInViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberSignature Language="VB.NET" Value="Public Property StoreOriginalValuesInViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StoreOriginalValuesInViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StoreOriginalValuesInViewState : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示数据源中的数据是否存储在视图状态中，以确保数据在更新或删除之前不会由其他进程更改。</summary>
        <value>如果将值存储在视图状态中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, 当更新和删除操作已启用时, <xref:System.Web.UI.WebControls.LinqDataSource>该控件会将所有记录的原始值存储在视图状态中。 控件存储属性中未标记为的`UpdateCheck.Never`所有主键和所有属性的值。 `Column` <xref:System.Web.UI.WebControls.LinqDataSource> 您可以在`UpdateCheck`中设置属性`Column`的属性[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。  
  
 在 LINQ to SQL 更新或删除数据之前, 它会根据数据源中的当前值检查视图状态中的值。 如果值不匹配, 则数据源记录已更改。 在这种情况下, LINQ to SQL 会引发异常, 并且不会继续更新或删除操作。 有关 LINQ to SQL 的详细信息, 请参阅[LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 将原始值存储在视图状态中可能会导致页面大小不必要地变大, 并且可能会向恶意用户公开敏感数据。 您可以通过将<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性设置为来`false`禁用在视图状态中存储值。 如果执行此操作, 则必须提供自己的方法来确保数据未更改。 如果将<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性设置为`false`, 则不会在数据绑定控件的视图状态中保留原始值。 在这种情况下, LINQ to SQL 无法验证数据的完整性。 即使数据源中的数据没有实际更改, LINQ to SQL 也会引发指示数据冲突的异常。  
  
 如果基础数据源包含更新期间自动更新的时间戳字段, 则只能将该值存储在视图状态中。 在这种情况下, 将实体类中的 timestamp 属性设置`IsVersion=true`为, 并将所有属性都`UpdateCheck.Never`设置为。 由于每次数据库中的数据发生更改时, 数据库都会自动更新时间戳字段, 因此, 如果数据已更改, LINQ to SQL 将从该值确定。 这有助于减少视图状态的大小, 并且不公开敏感数据。 LINQ to SQL 将通过将视图状态中的时间戳值与数据库中的时间戳值进行比较来检查数据一致性。 有关详细信息，请参见[演练：使用带有 LinqDataSource 控件的时间戳来检查数据完整性](https://msdn.microsoft.com/library/e7700162-4f05-4130-81f7-3be1361027fa)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.ContextType">
      <MemberSignature Language="C#" Value="Type System.Web.DynamicData.IDynamicDataSource.ContextType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#ContextType" />
      <MemberSignature Language="VB.NET" Value=" Property ContextType As Type Implements IDynamicDataSource.ContextType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System::Web::DynamicData::IDynamicDataSource::ContextType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.ContextType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>与类关联的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例被强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.EntitySetName">
      <MemberSignature Language="C#" Value="string System.Web.DynamicData.IDynamicDataSource.EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#EntitySetName" />
      <MemberSignature Language="VB.NET" Value=" Property EntitySetName As String Implements IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="C++ CLI" Value="property System::String ^ System::Web::DynamicData::IDynamicDataSource::EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EntitySetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>实体的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例被强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.Exception">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#Exception" />
      <MemberSignature Language="VB.NET" Value="Custom Event Exception As EventHandler(Of DynamicValidatorEventArgs) Implements System.Web.DynamicData.IDynamicDataSource" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Web.DynamicData.IDynamicDataSource.Exception</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例被强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数据上下文类中的属性或字段的名称，该数据上下文类表示一个数据集合。</summary>
        <value>包含属性（该属性包含数据集合）名称的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>将属性设置为表示要检索的数据的属性或字段的名称。 在连接到数据库表时, 属性的名称通常与表的名称相同。 连接到内存中数据集合时, 请将<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为返回数据集合的属性或字段的名称。  
  
 可以分配一个属性, 该属性可将任何类型<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>返回到属性以进行检索操作。 如果由属性表示的对象未实现<xref:System.Collections.IEnumerable>, 则该<xref:System.Web.UI.WebControls.LinqDataSource>控件将自动包装对象的实例<xref:System.Collections.IEnumerable>中的对象。  
  
 若要启用自动更新、插入或删除操作, <xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>分配给属性的类必须派生自<xref:System.Data.Linq.DataContext> , 并且分配<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>给属性的属性必须派生<xref:System.Data.Linq.Table%601>自。  
  
 有关如何从类的实例中选择数据的信息, 请参见<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例演示两<xref:System.Web.UI.WebControls.LinqDataSource>个控件。 在一个<xref:System.Web.UI.WebControls.LinqDataSource>控件中<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> , 属性设置为类中的属性。 该属性返回字符串数组。 在另<xref:System.Web.UI.WebControls.LinqDataSource>一个控件中<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A> , 将属性设置为表示数据库表的属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 在此示例`ExampleDataContext`中不显示名为的类, 它表示数据库表。 要使此示例正常运行, 必须通过添加一个名为 Example 的 LINQ to SQL 类并将名为 "Movie" 的[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]表拖到上来创建此类。 生成一个名`ExampleDataContext`为的类, `Movies`其中包含名为的属性。  
  
 下面的示例显示了`MovieLibrary` <xref:System.Web.UI.WebControls.LinqDataSource>在控件中引用的名为的类。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="linqDataSource.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>跟踪对 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的视图状态的更改，以便可将这些更改存储在该控件的 <see cref="T:System.Web.UI.StateBag" /> 对象中。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Collections.IDictionary keys, System.Collections.IDictionary values, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Collections.IDictionary keys, class System.Collections.IDictionary values, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Update(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (keys As IDictionary, values As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ values, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Update : System.Collections.IDictionary * System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Update (keys, values, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="values" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要更新的记录的行键值。</param>
        <param name="values">要在数据源中更新的行值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行更新操作。</summary>
        <returns>受更新操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 您不必从代码中调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法。 当用户采取操作更新记录时, 数据<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>绑定控件将自动调用方法。 若要创建自己<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>的用于更新数据的进程, 请显式调用方法。  
  
   
  
## Examples  
 下面的示例演示如何在用户单击按钮后以编程方式更新数据源中的记录。 该代码传递<xref:System.Collections.Specialized.ListDictionary>包含键值的对象<xref:System.Collections.Specialized.ListDictionary> 、包含<xref:System.Collections.Specialized.ListDictionary>原始值的对象, 以及包含<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法的新值的对象。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx.vb#1)]  
  
 下面的示例演示上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Updated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Updated;" />
      <MemberSignature Language="F#" Value="member this.Updated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Updated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成更新操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Updated>处理事件以从更新操作捕获任何异常, 或在更新操作完成后检查输出参数的值。 输出参数可从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序的对象获取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection UpdateParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection UpdateParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ UpdateParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdateParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此集合。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Updating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updating As EventHandler(Of LinqDataSourceUpdateEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceUpdateEventArgs ^&gt; ^ Updating;" />
      <MemberSignature Language="F#" Value="member this.Updating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " Usage="member this.Updating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行更新操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.Updating>处理事件以验证要更新的对象, 检查数据类中的数据验证错误, 更改更新操作之前的值, 或取消更新操作。 传递给事件处理程序的对象包含原始对象和更新的对象。<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs>  
  
 如果在更新操作过程中发生验证错误, 则<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象将包含由数据类引发的验证异常。 如果要更新的值与数据类中的属性的类型不匹配, 则会发生验证错误, 或者, 如果未通过自定义验证检查, 则会发生验证错误。 在<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件的事件处理程序中, 可以检索验证异常并采取适当的操作。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件的事件处理程序中引发了异常, 则必须在该事件处理程序中处理异常。 异常将不会传递到<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件的事件处理程序 ( <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象的属性)。 属性仅包含<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件之后引发的异常。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件的事件处理程序。 此代码对属性<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.OriginalObject%2A> <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>和属性的属性进行比较, 以查看值是否已更改。 如果值已更改, 则将<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>属性的值设置为。 `true`  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/vb/Default.aspx.vb#1)]  
  
 下面的示例演示了检索验证异常的<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件的事件处理程序。  
  
```vb  
Protected Sub LinqDataSource_Updating(ByVal sender As Object, _  
        ByVal e As LinqDataSourceUpdateEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Updating(object sender,   
        LinqDataSourceUpdateEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例将检索验证异常。 如果值与属性的类型不匹配, 则可能会引发异常。 它也可能是自定义的检查 (如以下示例中的检查) 引发的。 方法检查`Age`属性的数目是否为负数。 `OnAgeChanging`  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public string Where { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Where" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberSignature Language="VB.NET" Value="Public Property Where As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Where { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Where : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.Where</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定要将记录包含在检索到的数据中必须为真的条件。</summary>
        <value>用于创建 Where 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性指定要从查询返回的记录的条件。 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性的语法与中C#LINQ Where 子句的语法相同。  
  
 指定导致布尔值的表达式, 如果表达式的计算`true`结果为, 则该行将包含在结果集中。 表达式由列名、比较运算符和要比较的值组成, 如下面的示例中所示:  
  
```  
<asp:LinqDataSource ... Where="Price > 50"...>  
```  
  
 若要指定由`AND`逻辑 or `OR`运算符链接的多个表达式`&&` , 请使用作为逻辑 and `||`运算符并用作逻辑 or 运算符, 如下面的示例中所示:  
  
```  
<asp:LinqDataSource ... Where="Price > 50 && Price < 100"...>  
<asp:LinqDataSource ... Where="Price <= 50 || Price >= 100"...>  
```  
  
 如果要根据文本字符串值测试属性, 则文本字符串值必须用双引号引起来。 若要在标记中执行此操作<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> , 请将子句值括在单引号中, 如下面的示例中所示:  
  
```  
<asp:LinqDataSource ... Where='Category = "Sports"' ... >  
```  
  
 若要在代码中使用文本字符串值进行测试, 请使用适用于所使用的语言的转义符, 以便插入双引号, 如下面的示例所示:  
  
```vb  
LinqDataSource1.Where = "Category = ""Sports"""  
```  
  
```csharp  
LinqDataSource1.Where = "Category = \"Sports\"";  
```  
  
 如果要测试字符串是否大于或小于另一个字符串, 必须使用<xref:System.String>类的方法, 而不是在列名称和字符串值之间使用`<`或`>`运算符。 下面的示例演示如何选择其类别值小于、小于或等于、大于或大于或等于 "体育" 的行:  
  
```  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") < 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") <= 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") > 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") >= 0' ... >  
```  
  
 你<xref:System.String>还可以使用类的其他方法, <xref:System.String.StartsWith%2A>例如、 <xref:System.String.EndsWith%2A>和<xref:System.String.Contains%2A>。 有关如何比较字符串的详细信息, 请参阅[比较字符串](~/docs/standard/base-types/comparing.md)。 有关 Where 子句语法的详细信息, 请参阅[ C# Operators](https://msdn.microsoft.com/library/0301e31f-22ad-49af-ac3c-d5eae7f0ac43)和[Where 子句](~/docs/csharp/language-reference/keywords/where-clause.md)。  
  
 除了基于你在创建网页时定义的静态值进行筛选以外, 还可以根据在运行时计算的动态值进行筛选。 在这种情况下, 可以在<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性中包含一个命名参数, 作为值的占位符。 然后, 将具有匹配名称的参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。  
  
 或者, 可以将<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`true` , 并<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>定义集合中的参数。 当属性为`true`时, 无需在<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性中包含命名参数。 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A> 相反, <xref:System.Web.UI.WebControls.LinqDataSource>控件会自动从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>属性中的参数生成 Where 子句。  
  
 有关如何筛选数据的详细信息, 请参阅[演练:使用 LinqDataSource 和 GridView 控件](https://msdn.microsoft.com/library/c1cca3e8-86e4-4e69-a29f-1c05b91f2205)选择和筛选部分数据。  
  
   
  
## Examples  
 下面的示例演示如何根据静态条件筛选从查询返回的数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例演示如何根据用户在运行时提供的值来筛选数据。 在此示例<xref:System.Web.UI.WebControls.DropDownList>中, 控件<xref:System.Web.UI.WebControls.GridView>和控件显示在该页上。 当用户在<xref:System.Web.UI.WebControls.DropDownList>控件中选择一个值时<xref:System.Web.UI.WebControls.LinqDataSource> , 控件将仅从`Products`表中选择`UserPrice`值等于所选值的行。 然后<xref:System.Web.UI.WebControls.GridView> , 该控件将显示筛选后的数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WhereParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection WhereParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection WhereParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WhereParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ WhereParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WhereParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.WhereParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Where 子句的参数集合。</summary>
        <value>用于创建 <see cref="P:System.Web.UI.WebControls.LinqDataSource.Where" /> 属性中 Where 子句的参数的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中的参数在运行时创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource> 当要以编程方式<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>在 Where 子句中设置一个或多个条件时, 可以将参数添加到集合中。 例如, 您可以在数据库表中搜索姓氏等于<xref:System.Web.UI.WebControls.TextBox>控件值的记录。 在这种情况下, 可将参数添加<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>到文本框值的集合。  
  
 如果在 Where 子句中无需在运行时设置值, 则无需使用该<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 可以在<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性中定义要检索的字段。 例如, 若要从数据库表返回值, 而`LastName`该数据库表的标记中等于 "Adams <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A> ", `'LastName = "Adams"'`则将属性设置为不带任何参数。  
  
 若要设置集合中<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>的值, 请为每个参数分配一个名称, 然后<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>在该参数的属性中添加占位符。 在 Where 子句中, 每个参数名称前面加上 @ 符号。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合动态创建 Where 子句。 控件返回的所有记录的`Price`列中的值大于用户在<xref:System.Web.UI.WebControls.DropDownList>控件中选择的值。 <xref:System.Web.UI.WebControls.LinqDataSource>  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>