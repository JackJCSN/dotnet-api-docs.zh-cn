<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c08141570b114082146d0cd7184fc89c6417b48" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243675" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示不可变的正则表达式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>类表示.NET Framework 正则表达式引擎。 它可用于快速分析大量的文本来查找特定的字符模式;若要提取、 编辑、 替换或删除文本子字符串;并将提取的字符串添加到集合以生成报表。  
  
> [!NOTE]
>  如果你的主要兴趣是通过确定是否符合特定模式来验证一个字符串，则可以使用<xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>类。  
  
 若要使用的正则表达式，定义你希望确定文本流中使用的语法中所述的模式[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 接下来，您可以根据需要实例化<xref:System.Text.RegularExpressions.Regex>对象。 最后，调用执行某项操作，例如替换与正则表达式模式匹配的文本或识别的模式匹配的方法。  
  
> [!NOTE]
>  一些常见的正则表达式模式，请参阅[正则表达式示例](~/docs/standard/base-types/regular-expression-examples.md)。 也有大量的正则表达式模式，例如在一个联机库[常规 Expressions.info](https://www.regular-expressions.info/examples.html)。  
  
<a name="remarks"></a> 详细了解使用<xref:System.Text.RegularExpressions.Regex>类，请参阅本主题中的以下部分：  
  
-   [正则表达式 vs。字符串方法](#regex_vs_string)  
  
-   [静态端口与实例方法](#static_vs_instance)  
  
-   [执行正则表达式操作](#regex_ops)  
  
-   [定义超时值](#define_timeout)  
  
 若要详细了解正则表达式语言，请参阅[正则表达式语言 - 快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)，或下载和打印下面的小册子之一：  
  
 [快速参考（Word (.docx) 格式）](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [快速参考（PDF (.pdf) 格式）](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>正则表达式 vs。字符串方法  
 <xref:System.String?displayProperty=nameWithType>类包含多个可用于执行使用文本模式匹配的搜索和比较方法。 例如， <xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.EndsWith%2A?displayProperty=nameWithType>，并<xref:System.String.StartsWith%2A?displayProperty=nameWithType>方法确定字符串实例是否包含指定的子字符串; 并<xref:System.String.IndexOf%2A?displayProperty=nameWithType>， <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>， <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType>方法返回的起始一个字符串中指定的子字符串的位置。 使用的方法<xref:System.String?displayProperty=nameWithType>类时要搜索特定字符串。 使用<xref:System.Text.RegularExpressions.Regex>类时要搜索的字符串中的特定模式。 有关详细信息和示例，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)。  
  
 [返回到备注](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>静态端口与实例方法  
 定义正则表达式模式后，可以将其提供给通过两种方式中的正则表达式引擎：  
  
-   通过实例化<xref:System.Text.RegularExpressions.Regex>对象，表示正则表达式。 若要执行此操作，可以传递到正则表达式模式<xref:System.Text.RegularExpressions.Regex.%23ctor%2A>构造函数。 一个<xref:System.Text.RegularExpressions.Regex>对象是不可变; 当您实例化<xref:System.Text.RegularExpressions.Regex>对象在正则表达式对象的正则表达式不能更改。  
  
-   通过提供正则表达式和要搜索的文本`static`(`Shared`在 Visual Basic 中)<xref:System.Text.RegularExpressions.Regex>方法。 这使您可以使用正则表达式而无需显式创建<xref:System.Text.RegularExpressions.Regex>对象。  
  
 所有<xref:System.Text.RegularExpressions.Regex>模式标识方法包括这两个静态和实例重载。  
  
 正则表达式引擎必须编译特定模式，然后才能使用该模式。 因为<xref:System.Text.RegularExpressions.Regex>对象是不可变，这是发生的一次性过程时<xref:System.Text.RegularExpressions.Regex>调用类构造函数或静态方法。 若要消除重复编译单个正则表达式的需求，正则表达式引擎缓存已编译的正则表达式的静态方法调用中使用。 因此，正则表达式模式匹配方法提供可比较的性能，适用于静态和实例方法。  
  
> [!IMPORTANT]
>  在.NET Framework 版本 1.0 和 1.1 中，所有已编译正则表达式中，是否使用它们在实例或静态方法调用，缓存。 从.NET Framework 2.0 开始，缓存仅在静态方法调用中使用正则表达式。  
  
 但是，缓存产生负面影响以下两种情况下的性能：  
  
-   当您使用正则表达式对大量静态方法调用。 默认情况下，正则表达式引擎缓存 15 的最近使用过静态正则表达式。 如果你的应用程序使用 15 个以上的静态正则表达式，则必须重新编译正则表达式。 若要防止此类重新编译，可以增加<xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>属性。  
  
-   当您实例化新<xref:System.Text.RegularExpressions.Regex>具有先前已编译的正则表达式的对象。 例如，以下代码定义文本流中找到重复的单词的正则表达式。 尽管该示例使用单个正则表达式，但它实例化一个新<xref:System.Text.RegularExpressions.Regex>对象来处理每个文本行。 这会导致每次迭代循环的重新编译的正则表达式。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     若要防止重新编译，您应实例化一个<xref:System.Text.RegularExpressions.Regex>对象都可以访问的所有代码都需要它，如下面的重写示例中所示。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [返回到备注](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>执行正则表达式操作  
 你是否决定要实例化<xref:System.Text.RegularExpressions.Regex>对象并调用其方法或调用静态方法，<xref:System.Text.RegularExpressions.Regex>类提供了以下的模式匹配功能：  
  
-   匹配项的验证。 在调用<xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法，以确定是否存在匹配项。  
  
-   检索单个匹配项。 在调用<xref:System.Text.RegularExpressions.Regex.Match%2A>方法来检索<xref:System.Text.RegularExpressions.Match>对象，表示一个字符串或部分字符串的第一个匹配项。 可以通过调用来检索后续匹配项<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
-   检索的所有匹配项。 在调用<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法来检索<xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType>对象，表示找到的字符串的字符串或部分的所有匹配项。  
  
-   替换匹配的文本。 在调用<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法替换匹配的文本。 也可以由正则表达式定义的替换文本。 此外，某些<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法包括<xref:System.Text.RegularExpressions.MatchEvaluator>参数，它允许您以编程方式定义的替换文本。  
  
-   创建从输入字符串的部分构成的字符串数组。 在调用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法拆分输入的字符串与正则表达式定义的位置。  
  
 其模式匹配方法，除了<xref:System.Text.RegularExpressions.Regex>类包括了一些特殊用途方法：  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A>方法可转义可能被解释为正则表达式或输入的字符串中的正则表达式运算符的任何字符。  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法中删除这些转义符。  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法创建包含预定义的正则表达式的程序集。 .NET Framework 包含在这些特殊用途的程序集的示例<xref:System.Web.RegularExpressions?displayProperty=nameWithType>命名空间。  
  
 [返回到备注](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>定义超时值  
 .NET Framework 支持提供了大量功能和灵活性在模式匹配中的全功能正则表达式语言。 但是，功能和灵活性为代价： 性能不佳的风险。 执行效果不佳的正则表达式是创建起来极其方便。 在某些情况下，依赖于过度回溯正则表达式操作可以出现停止响应时它们处理与正则表达式模式大致匹配的文本。 有关.NET Framework 正则表达式引擎的详细信息，请参阅[的正则表达式行为的详细信息](~/docs/standard/base-types/details-of-regular-expression-behavior.md)。 有关过度回溯的详细信息，请参阅[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，可以定义超时间隔的正则表达式匹配项。 如果正则表达式引擎不能识别在此时间间隔内的匹配项，匹配的操作将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 在大多数情况下，这可以防止正则表达式引擎尝试匹配与正则表达式模式大致匹配的文本而浪费处理能力。 它还可能表示，但是的超时间隔设置得过低，或当前计算机负载性能，导致整体性能降低。  
  
 如何处理异常取决于异常的原因。 如果因为超时间隔设置得太低，会发生异常，或者由于过多机负载，可以增大超时间隔和重试匹配操作。 如果发生异常的原因的正则表达式依赖于过度回溯，可以假定不存在匹配项，并 （可选） 你可以记录信息将帮助您修改正则表达式模式。  
  
 可以通过调用设置的超时间隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>构造函数实例化正则表达式对象时。 对于静态方法，可以设置超时间隔，通过调用具有匹配方法的重载`matchTimeout`参数。 如果未显式设置超时值，默认超时值确定，如下所示：  
  
-   通过使用应用程序范围内超时的值，如果一个存在。 这可以是适用于的应用程序域中任何超时值<xref:System.Text.RegularExpressions.Regex>实例化对象或调用静态方法。 可以通过调用设置的应用程序范围的超时值<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法将指定的字符串表示形式<xref:System.TimeSpan>"REGEX_DEFAULT_MATCH_TIMEOUT"属性值。  
  
-   通过使用值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>，如果已不设置任何应用程序范围的超时值。  
  
> [!IMPORTANT]
>  我们建议在所有正则表达式模式匹配操作设置超时值。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)。  
  
 [返回到备注](#remarks)  
  
   
  
## Examples  
 以下示例使用正则表达式检查重复出现的字符串中的单词。 正则表达式`\b(?<word>\w+)\s+(\k<word>)\b`可以解释为下表中所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|开始在字边界匹配。|  
|`(?<word>\w+)`|匹配一个或多个单词字符，最多字边界。 命名此捕获的组`word`。|  
|`\s+`|匹配一个或多个空白字符。|  
|`(\k<word>)`|与名为的捕获的组匹配`word`。|  
|`\b`|与字边界匹配。|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 下面的示例演示如何使用正则表达式来检查是否一个字符串，或者表示货币值，或者具有正确的格式来表示货币值。 在这种情况下，正则表达式动态生成从<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>用户的当前区域性的属性。 如果系统的当前区域性为 EN-US，所生成的正则表达式是`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`。 下表中所示，可以解释此正则表达式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|从字符串的开头。|  
|`\s*`|匹配零个或多个空白字符。|  
|`[\+-]?`|匹配正号或负号的零个或一个匹配的项。|  
|`\s?`|匹配零个或一个空白字符。|  
|`\$?`|匹配零个或一个匹配项的美元符号。|  
|`\s?`|匹配零个或一个空白字符。|  
|`\d*`|匹配零个或多个十进制数字。|  
|`\.?`|匹配零个或一个小数点符号。|  
|`\d{2}?`|与两个十进制数字匹配零个或一个时间。|  
|`(\d*\.?\d{2}?){1}`|匹配模式的至少一次分隔小数点符号的整数和小数位数。|  
|`$`|匹配字符串的末尾。|  
  
 正则表达式在这种情况下，假定的有效货币字符串不包含组分隔符符号，并且它具有没有小数部分位数或小数位数由当前区域性定义<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>属性。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 因为动态生成正则表达式在此示例中，我们不知道在设计时是否当前区域性的货币符号、 十进制符号或正和负号可能会错误地解释为正则正则表达式引擎表达式语言运算符。 若要防止出现任何错误解释，该示例将为每个动态生成的字符串<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" />类是不可变 （只读） 和线程安全。 <see cref="T:System.Text.RegularExpressions.Regex" /> 可以在任何线程上创建对象，并将其线程之间共享。 有关详细信息，请参阅[的线程安全](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)。</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework 正则表达式</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">正则表达式 — 快速参考（以 Word 格式下载）</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">正则表达式 — 快速参考（以 PDF 格式下载）</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此构造函数受保护时仅可由派生的类调用<xref:System.Text.RegularExpressions.Regex>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>为指定的正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主题。  
  
 调用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>构造函数是等效于调用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>构造函数，值为<xref:System.Text.RegularExpressions.RegexOptions.None>为`options`参数。  
  
 一个<xref:System.Text.RegularExpressions.Regex>对象是不可变的这意味着，它可以仅用于在创建它时定义的匹配模式。 但是，可能没有正在重新编译的情况下使用任意次数。  
  
 此构造函数实例化正则表达式对象的定义中的任意字母字符区分大小写的匹配项时，尝试`pattern`。 对于不区分大小写的匹配项，请使用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>构造函数。  
  
   
  
## Examples  
 下面的示例演示如何使用此构造函数来实例化正则表达式相匹配的单词的开头的字母"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 请注意，正则表达式模式不能与匹配单词"The"开头的文本，因为比较是区分大小写的默认值。 不区分大小写比较的示例，请参阅<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此构造函数创建<see cref="T:System.Text.RegularExpressions.Regex" />使用在其中创建应用程序域的默认超时值的对象。 如果不为应用程序域中，定义了超时值<see cref="T:System.Text.RegularExpressions.Regex" />对象使用的值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这将阻止该操作超时。用于创建建议的构造函数<see cref="T:System.Text.RegularExpressions.Regex" />对象是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">包含串行化模式和 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 信息的对象。</param>
        <param name="context">此序列化的目标。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>使用序列化数据初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 包含的模式为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> 包含无效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 标志。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">修改正则表达式的枚举值的按位组合。</param>
        <summary>使用修改模式的选项为指定的正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主题。  
  
 一个<xref:System.Text.RegularExpressions.Regex>对象是不可变的这意味着可以使用用于在创建它时定义匹配参数。 但是，可能没有正在重新编译的情况下使用任意次数。  
  
   
  
## Examples  
 下面的示例演示如何使用此构造函数来实例化正则表达式相匹配的单词的开头的字母"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 请注意，匹配集合包含的单词"The"，因为文本开头`options`参数定义了不区分大小写的比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 包含无效标志。</exception>
        <block subset="none" type="usage"><para>此构造函数创建<see cref="T:System.Text.RegularExpressions.Regex" />使用在其中创建应用程序域的默认超时值的对象。 如果不为应用程序域中，定义了超时值<see cref="T:System.Text.RegularExpressions.Regex" />对象使用的值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这将阻止该操作超时。用于创建建议的构造函数<see cref="T:System.Text.RegularExpressions.Regex" />对象是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">修改正则表达式的枚举值的按位组合。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用修改模式的选项和指定在超时前多久模式匹配方法应进行匹配尝试的值为指定正则表达式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主题。  
  
 一个<xref:System.Text.RegularExpressions.Regex>对象是不可变的这意味着可以使用仅为创建时定义的匹配模式。 但是，可能没有正在重新编译的情况下使用任意次数。  
  
 `matchTimeout`参数指定多长时间模式匹配方法应尝试超时之前找到匹配项。如果在该时间间隔内不找到任何匹配项，模式匹配方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写任何定义的应用程序域中的默认超时值<xref:System.Text.RegularExpressions.Regex>创建对象。 观察到的实例模式匹配方法`matchTimeout`超时间隔包括以下：  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 将设置的超时间隔可阻止依赖于过度回溯出现停止响应时它们处理输入的正则表达式，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 若要设置合理的超时间隔，请考虑以下因素：  
  
-   长度和复杂性的正则表达式模式。 长而复杂的正则表达式需要比更简短和简单的更多的时间。  
  
-   预期的机负载。 处理将更多的时间会有 CPU 和内存使用率高的系统上。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>构造函数实例化<xref:System.Text.RegularExpressions.Regex>一秒的超时值的对象。 正则表达式模式 `(a+)+$`（与行尾的一个或多个“a”字符的一个或多个序列匹配）受过度回溯的约束。 如果<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>是引发，该示例会增大到三秒的最大值的超时值。 否则，它放弃尝试与模式匹配。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置已编译的正则表达式的当前静态缓存中的最大项数。</summary>
        <value>静态缓存中的最大项数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>类维护的静态方法调用中使用的已编译正则表达式的内部缓存。 如果在设置操作中指定的值小于当前缓存大小，直到缓存大小是否等于指定的值会丢弃缓存项。  
  
 默认情况下，缓存包含 15 个已编译的静态正则表达式。 你的应用程序通常不会修改缓存的大小。 使用<xref:System.Text.RegularExpressions.Regex.CacheSize%2A>属性仅当你想要关闭缓存，或当你具有较大的缓存。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">集运算中的值小于零。</exception>
        <block subset="none" type="usage"><para>在之前的.NET Framework 中[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 正则表达式使用在这两个静态和实例方法调用缓存。 从[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 仅正则表达式的静态方法调用中使用的缓存。</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将命名捕获组映射到其索引值的字典。</summary>
        <value>将命名捕获组映射到其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性受保护;只能从派生自的类访问<xref:System.Text.RegularExpressions.Regex>类。  
  
 设置操作尝试将分配给属性的值转换<xref:System.Collections.Hashtable>对象; 如果此转换失败，则会调用<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">向设置操作中的 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 属性分配的值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将编号捕获组映射到其索引值的字典。</summary>
        <value>将编号捕获组映射到其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性受保护;只能从派生自的类访问<xref:System.Text.RegularExpressions.Regex>类。  
  
 设置操作尝试将分配给属性的值转换<xref:System.Collections.Hashtable>对象; 如果此转换失败，则会调用<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">向设置操作中的 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 属性分配的值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>编译正则表达式，并将其保存到单个程序集的磁盘中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

在.NET Core 上调用`Regex.CompileToAssembly`方法引发<xref:System.PlatformNotSupportedException>; 不支持写出程序集。
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象编译为命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>方法中定义的每个正则表达式中生成.NET Framework 程序集`regexinfos`由一个类表示数组。 通常情况下，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>从单独的应用程序生成的已编译的正则表达式的程序集调用方法。 包含在程序集中的每个正则表达式具有以下特征：  
  
-   派生自<xref:System.Text.RegularExpressions.Regex>类。  
  
-   它分配由定义的完全限定的名称`fullnamespace`并`name`其对应的参数<xref:System.Text.RegularExpressions.RegexCompilationInfo>对象。  
  
-   它有一个默认的 （或无参数） 构造函数。  
  
 通常，程序集或应用程序，它独立于创建该程序集的代码中找到实例化并使用已编译的正则表达式的代码。  
  
   
  
## Examples  
 以下示例创建名为 RegexLib.dll 程序集。 程序集包括两个已编译的正则表达式。 第一种`Utilities.RegularExpressions.DuplicatedString`，匹配两个完全相同的连续单词。 第二个， `Utilities.RegularExpressions.EmailAddress`，检查字符串是否具有正确的格式为电子邮件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 然后，检查字符串的重复单词的正则表达式是实例化，并使用下面的示例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 此第二个示例成功编译需要对 RegexLib.dll （由第一个示例创建程序集） 的引用添加到项目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果你正在开发的系统上[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或安装其单点发行版，面向[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，并使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法创建的程序集包含已编译的正则表达式。 尝试使用正则表达式之一在于，在系统上的程序集具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]将引发异常。 若要解决此问题，可执行下列操作之一： 
-生成包含已编译的正则表达式的系统上的程序集[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安装更高版本。  
  
-而不是调用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />和从程序集中检索已编译的正则表达式，使用静态或实例<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />选项实例化时<see cref="T:System.Text.RegularExpressions.Regex" />对象或调用正则表达式模式匹配方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <param name="attributes">定义要应用于程序集的特性的数组。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象编译为具有指定特性的命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>方法中定义的每个正则表达式中生成.NET Framework 程序集`regexinfos`由一个类表示数组。 通常情况下，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>从单独的应用程序生成的已编译的正则表达式的程序集调用方法。 包含在程序集中的每个正则表达式具有以下特征：  
  
-   派生自<xref:System.Text.RegularExpressions.Regex>类。  
  
-   它分配由定义的完全限定的名称`fullnamespace`并`name`其对应的参数<xref:System.Text.RegularExpressions.RegexCompilationInfo>对象。  
  
-   它有一个默认的 （或无参数） 构造函数。  
  
 通常，程序集或应用程序，它独立于创建该程序集的代码中找到实例化并使用已编译的正则表达式的代码。  
  
 因为<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法生成的.NET Framework 程序集从方法调用而不是使用特定语言的类定义关键字 (如`class`C# 中或`Class`...`End Class` 在 Visual Basic 中)，它不允许使用开发语言的标准属性语法要分配给该程序集的.NET Framework 属性。 `attributes`参数提供了一种替代方法，用于定义应用于程序集的属性。 你想要应用于程序集的每个属性，请执行以下操作：  
  
1.  创建一个数组<xref:System.Type>表示你想要调用的特性构造函数的参数类型的对象。  
  
2.  检索<xref:System.Type>对象，表示你想要将应用于新的程序集的特性类。  
  
3.  调用<xref:System.Type.GetConstructor%2A>方法的特性<xref:System.Type>对象来检索<xref:System.Reflection.ConstructorInfo>对象，表示你想要调用的特性构造函数。 传递<xref:System.Type.GetConstructor%2A>方法的数组的<xref:System.Type>表示构造函数的参数类型的对象。  
  
4.  创建<xref:System.Object>定义要传递给特性的构造函数的参数的数组。  
  
5.  实例化<xref:System.Reflection.Emit.CustomAttributeBuilder>对象表示通过其构造函数<xref:System.Reflection.ConstructorInfo>在步骤 3 中检索对象和<xref:System.Object>步骤 4 中创建的数组。  
  
 然后，可以传递这些<xref:System.Reflection.Emit.CustomAttributeBuilder>对象而不是`attributes`参数<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 以下示例创建名为 RegexLib.dll 的程序集并应用<xref:System.Reflection.AssemblyTitleAttribute>到该属性。 程序集包括两个已编译的正则表达式。 第一种`Utilities.RegularExpressions.DuplicatedString`，匹配两个完全相同的连续单词。 第二个， `Utilities.RegularExpressions.EmailAddress`，检查字符串是否具有正确的格式为电子邮件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 你可以验证<xref:System.Reflection.AssemblyTitleAttribute>特性已应用于程序集通过检查其清单使用 ILDasm 之类的反射实用工具。  
  
 然后，检查字符串的重复单词的正则表达式是实例化，并使用下面的示例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 此第二个示例成功编译需要对 RegexLib.dll （由第一个示例创建程序集） 的引用添加到项目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果你正在开发的系统上[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或安装其单点发行版，面向[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，并使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法创建的程序集包含已编译的正则表达式。 尝试使用正则表达式之一在于，在系统上的程序集具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]将引发异常。 若要解决此问题，可执行下列操作之一： 
-生成包含已编译的正则表达式的系统上的程序集[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安装更高版本。  
  
-而不是调用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />和从程序集中检索已编译的正则表达式，使用静态或实例<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />选项实例化时<see cref="T:System.Text.RegularExpressions.Regex" />对象或调用正则表达式模式匹配方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">描述要编译的正则表达式的数组。</param>
        <param name="assemblyname">程序集的文件名。</param>
        <param name="attributes">定义要应用于程序集的特性的数组。</param>
        <param name="resourceFile">要包含在程序集中的 Win32 资源文件的名称。</param>
        <summary>将一个或多个指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象和一个指定的资源文件编译为具有指定特性的命名程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions. 包含在程序集中的每个正则表达式具有以下特征：  
  
-   派生自<xref:System.Text.RegularExpressions.Regex>类。  
  
-   它分配由定义的完全限定的名称`fullnamespace`并`name`其对应的参数<xref:System.Text.RegularExpressions.RegexCompilationInfo>对象。  
  
-   它有一个默认的 （或无参数） 构造函数。  
  
 通常，程序集或应用程序，它独立于创建该程序集的代码中找到实例化并使用已编译的正则表达式的代码。  
  
 因为<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法生成的.NET Framework 程序集从方法调用而不是使用特定语言的类定义关键字 (如`class`C# 中或`Class`...`End Class` 在 Visual Basic 中)，它不允许使用开发语言的标准属性语法要分配给该程序集的.NET Framework 属性。 `attributes`参数提供了一种替代方法，用于定义应用于程序集的属性。 你想要应用于程序集的每个属性，请执行以下操作：  
  
1.  创建一个数组<xref:System.Type>表示你想要调用的特性构造函数的参数类型的对象。  
  
2.  检索<xref:System.Type>对象，表示你想要将应用于新的程序集的特性类。  
  
3.  调用<xref:System.Type.GetConstructor%2A>方法的特性<xref:System.Type>对象来检索<xref:System.Reflection.ConstructorInfo>对象，表示你想要调用的特性构造函数。 传递<xref:System.Type.GetConstructor%2A>方法的数组的<xref:System.Type>表示构造函数的参数类型的对象  
  
4.  创建<xref:System.Object>定义要传递给特性的构造函数的参数的数组。  
  
5.  实例化<xref:System.Reflection.Emit.CustomAttributeBuilder>对象表示通过其构造函数<xref:System.Reflection.ConstructorInfo>在步骤 3 中检索对象和<xref:System.Object>步骤 4 中创建的数组。  
  
 You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 参数的 <see cref="P:System.Reflection.AssemblyName.Name" /> 属性值是一个空字符串或 null。  
  
- 或 - 
<paramref name="regexinfos" /> 中的一个或多个对象的正则表达式模式包含无效语法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> 参数指定了无效的 Win32 资源文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="resourceFile" /> 参数指定的文件。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持创建已编译的正则表达式的程序集。</exception>
        <block subset="none" type="usage"><para>如果你正在开发的系统上[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或安装其单点发行版，面向[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，并使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法创建的程序集包含已编译的正则表达式。 尝试使用正则表达式之一在于，在系统上的程序集具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]将引发异常。 若要解决此问题，可执行下列操作之一： 
-生成包含已编译的正则表达式的系统上的程序集[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安装更高版本。  
  
-而不是调用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />和从程序集中检索已编译的正则表达式，使用静态或实例<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />选项实例化时<see cref="T:System.Text.RegularExpressions.Regex" />对象或调用正则表达式模式匹配方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">编译和重复使用</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">包含要转换的文本的输入字符串。</param>
        <summary>通过替换为转义码来转义最小的字符集（\\、*、+、?、|、{、[、(、)、^、$、.、# 和空白）。 这将指示正则表达式引擎按原义解释这些字符而不是解释为元字符。</summary>
        <returns>由转换为转义形式的元字符组成的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 将字符串转换，以便正则表达式引擎会将解释为字符文本可能包含任何元字符。 例如，考虑正则表达式，它可以提取由左和右括号 （[和]） 从文本分隔的注释。 在下面的示例中，正则表达式"[(.*?)]"被解释为字符类。 而不是匹配输入文本中嵌入的注释，正则表达式匹配每个左或右括号、 句点、 星号或问号。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 但是，如果将左大括号转义将其传递到<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，正则表达式成功匹配输入字符串中嵌入的注释中。 下面的示例阐释了这一点。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 使用静态文本定义的正则表达式，将按字面意思而不是元字符作为解释的字符也可转义由其前面的反斜杠符号 (\\) 以及通过调用<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。 使用在设计时未知的字符以动态方式定义正则表达式中调用<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法是确保，正则表达式引擎将单个字符解释为文本而不是非常重要比为元字符。  
  
> [!NOTE]
>  如果正则表达式模式包含的数字符号 （#） 或文本空白字符，则必须进行转义如果输入的文本分析与<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>选项处于启用状态。  
  
 虽然<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法可转义直接打开方括号 ([)，并打开大括号 （{） 字符，它未转义其对应的结束字符 (] 和})。 在大多数情况下，转义这些不是必需。 如果右括号或大括号前面没有其相应的开始字符，正则表达式引擎将按字面意思解释它。 如果左大括号或大括号被解释为元字符，正则表达式引擎会解释第一个相应的结束字符为元字符。 如果这不是所需的行为，应通过显式预先计算的反斜杠转义右括号或大括号 (\\) 字符。 有关说明，请参阅示例部分。  
  
   
  
## Examples  
 下面的示例从文本中提取注释。 它假定注释分隔开始注释符号，并由用户选择的结束注释符号。 注释符号将按原义解释，因为它们传递给<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，以确保它们不能被曲解为元字符。 此外，该示例显式检查用户输入的结束注释符号是否为右方括号 (]) 或大括号 （}）。 如果是，反斜杠字符 (\\)，以便将按字面意思解释预置到大括号或大括号。 请注意，此示例还使用<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>集合以显示注释，而不是其开始和结束注释符号以及注释。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">正则表达式中的字符转义</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>此成员替代 <see cref="M:System.Object.Finalize" /> 且该主题可能包括更完整的文档。

允许 <see cref="T:System.Object" /> 在"垃圾回收"回收 <see cref="T:System.Object" /> 之前尝试释放资源并执行其他清理操作。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回正则表达式的捕获组名数组。</summary>
        <returns>组名的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 组名称的集合包含在表达式中的命名捕获组使用的字符串的集合。 即使未显式命名的捕获组，它们会自动分配了数字名称 （"0"、"1"、"2"、"3"等）。 "0"名为组表示由正则表达式模式匹配的所有文本。 已编号的组先于显式命名的组在集合中，并已命名的组显示在正则表达式模式中定义的顺序。  
  
 可以使用<xref:System.Array.Length%2A>属性返回此方法以确定正则表达式中的组数的数组。  
  
   
  
## Examples  
 下面的示例定义了常规用途`ShowMatches`显示正则表达式组和其匹配的文本的名称的方法。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 在此情况下，正则表达式模式`\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})`旨在分析简单句子，并确定其第一个单词，最后一个单词和结束标点符号。 下表显示了如何解释正则表达式模式：  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`(?<FirstWord>\w+)`|匹配一个或多个单词字符。 这是`FirstWord`已命名的组。|  
|\s?|匹配零个或一个空白字符。|  
|(\w+)|匹配一个或多个单词字符。 这是第二个捕获组。|  
|\s|与空白字符匹配。|  
|((\w+)\s)*|匹配零个或多个匹配项的一个或多个单词字符后跟空白区域。 这是第一个捕获组。|  
|(?\<LastWord>\w+)?|匹配零个或一个匹配项的一个或多个单词字符。 这是`LastWord`已命名的组。|  
|(?\<标点 > \p{Po})|匹配的字符的 Unicode 类别是标点，其他。 这是`Punctuation`已命名的组。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与数组中的组名相对应的捕获组号的数组。</summary>
        <returns>组号的整数数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过数字访问未命名和已命名的捕获组。 未命名的组从左到右从 1 开始编号。 （索引 0 （零） 中的捕获组表示匹配作为一个整体。）已命名的组进行然后编号从左到右从一个更大的数字比的数未命名捕获组。  
  
 通过字符串名称来引用其数量，而不是通过组可以提供更快的访问。  
  
   
  
## Examples  
 下面的示例定义正则表达式， `\b((?<word>\w+)\s*)+(?<end>[.?!])`，匹配的句子。 正则表达式包含三个捕获组： 捕获各个单词，连同空格字符，可以按照它; 未命名的组名为的组`word`捕获句子; 中的单个单词和一组名为`end`捕获结束句子的标点。 此示例调用<xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A>方法以获取所有捕获的数字进行分组，，然后显示其捕获的字符串。 此外，<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法用来指示特定编号的组是否对应于命名的组。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 正则表达式模式可以解释为下表中所示内容。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`(?<word>\w+)`|匹配一个或多个单词字符并将匹配的字符串分配给一个名为组`word`。|  
|`\s*`|匹配零个或多个空白字符。|  
|`((?<word>\w+)\s*)`|分配`word`跟任何的捕获的组捕获的空白字符到第一个捕获组。|  
|`((?<word>\w+)\s*)+`|与任何空白字符后, 接一个或多个时间的一个或多个单词字符的模式匹配。|  
|`(?<end>[.?!])`|匹配句号、问号或感叹号。 将分配到的匹配的字符`end`捕获组。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">正则表达式中的分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">要转换为相应组名的组号。</param>
        <summary>获取与指定组号相对应的组名。</summary>
        <returns>包含与指定组号关联的组名的字符串。 如果没有与 <paramref name="i" /> 对应的组名，此方法会返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正则表达式模式可能包含已命名或编号的捕获组，其中描述中的模式匹配的子表达式。 分隔语法已编号的组 (*子表达式*) 和分配有根据正则表达式中其顺序的编号。 已命名的组进行分隔语法 (？`<`*名称*`>`*subexpression*) 或 (？*名称*'*subexpression*)，其中*名称*是子表达式将标识的名称。 （有关详细信息，请参阅[分组构造](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。）<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法标识为命名的组和正则表达式中其序号位置的已编号的组。 序号位置 0 始终表示整个正则表达式。 所有带编号组然后进行计数之前已命名的组，而不考虑其在正则表达式模式中的实际位置。  
  
 如果`i`是数的命名组，该方法返回的组的名称。 如果`i`是数字的未命名的组，该方法返回数字的字符串表示形式。 例如，如果`i`为 1，该方法将返回"1"。 如果`i`不是数字的捕获组，该方法将返回<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 如果找到的模式匹配，则此方法返回的值然后将用于检索<xref:System.Text.RegularExpressions.Group>对象，表示从捕获的组<xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>属性。 <xref:System.Text.RegularExpressions.GroupCollection>返回对象<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例定义匹配包含美国城市名称、 状态名称和邮政编码的地址行的正则表达式模式。 该示例使用<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法来检索捕获组的名称。 然后使用这些名称来检索相应的捕获的组的匹配项。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 以下表达式所定义的正则表达式模式：  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|匹配一个或多个字母或空格字符。 将此捕获的组的名称分配`city`。|  
|`,`|匹配后跟一个空白字符的逗号 （，）。|  
|`(?<state>[A-Za-z]{2})`|匹配两个字母字符。 将此捕获的组的名称分配`state`。 此组应跟一个空白字符。|  
|`(?<zip>\d{5}(-\d{4})?)`|匹配零个或一个匹配项的连字符后跟四个数字后跟五个数字。 将此捕获的组的名称分配`zip`。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要转换为相应组号的组名。</param>
        <summary>返回与指定组名相对应的组号。</summary>
        <returns>与指定组名相对应的组号，如果 <paramref name="name" /> 不是有效组名，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正则表达式模式可能包含已命名或编号的捕获组，其中描述中的模式匹配的子表达式。 分隔语法已编号的组 (*子表达式*) 和分配有根据正则表达式中其顺序的编号。 已命名的组进行分隔语法 (？`<`*名称*`>`*subexpression*) 或 (？*名称*'*subexpression*)，其中*名称*是子表达式将标识的名称。 （有关详细信息，请参阅[分组构造](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。）<xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A>方法标识为命名的组和正则表达式中其序号位置的已编号的组。 序号位置 0 始终表示整个正则表达式。 所有带编号组然后进行计数之前已命名的组，而不考虑其在正则表达式模式中的实际位置。  
  
 如果`name`存在在正则表达式模式中，此方法返回该编号的组数字的字符串表示形式。 如果`name`对应于已命名捕获在正则表达式模式中存在的组，该方法返回其对应的编号。 比较`name`与组名称是区分大小写。 如果`name`不对应到捕获组的名称或捕获组，该方法的数字的字符串表示形式返回-1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">分组构造</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定模式匹配操作不应超时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>类构造函数和静态匹配方法使用<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常量，以指示尝试查找模式匹配应不会超时。  
  
> [!WARNING]
>  将正则表达式引擎的超时值设置为<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>可能会导致依赖于过度回溯，才会出现停止响应时处理与正则表达式模式大致匹配的文本的正则表达式。 如果禁用超时，应确保正则表达式不依赖于过度回溯，还可以处理与正则表达式模式大致匹配的文本。  
>   
>  有关处理回溯的详细信息，请参阅[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常量可作为的值提供`matchTimeout`自变量的以下成员：  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">引用已初始化。</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作超时之前在一个模式匹配操作中可以经过的最长时间。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示正则表达式在输入字符串中是否找到匹配项。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>指示 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式在指定的输入字符串中是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或以确保符合特定模式的一个字符串，而无需检索该字符串以进行后续操作。 如果你想要确定是否一个或多个字符串与正则表达式模式匹配，然后检索成员以进行后续操作，调用<xref:System.Text.RegularExpressions.Regex.Match%2A>或<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>方法来确定字符串是否是有效的部件号。 正则表达式假定的部件号具有特定格式包含三个由连字符分隔的字符组成。 第一个集，其中包含四个字符，必须由字母数字字符后跟两个数字字符后跟字母数字字符组成。 第二个集，其中包括三个字符，必须为数值。 第三个组，其中包括四个字符，必须以字母数字字符后跟三个数字字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 正则表达式模式为：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|开始在行的开头匹配。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|匹配三个数字字符。|  
|`(-\d{3}){2}`|找到连字符后跟三个数字字符，并将匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`$`|结束行的末尾匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">开始搜索的字符位置。</param>
        <summary>指示 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式在指定的输入字符串中，从该字符串中的指定起始位置开始是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或以确保符合特定模式的一个字符串，而无需检索该字符串以进行后续操作。 如果你想要确定是否一个或多个字符串与正则表达式模式匹配，然后检索成员以进行后续操作，调用<xref:System.Text.RegularExpressions.Regex.Match%2A>或<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法来确定字符串是否是有效的部件号。 它会搜索为跟随字符串中的冒号 （:） 字符的部件号。 <xref:System.String.IndexOf%28System.Char%29>方法用于确定冒号字符，然后传递到的位置<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法。 正则表达式假定的部件号具有特定格式包含三个由连字符分隔的字符组成。 第一个集，其中包含四个字符，必须由字母数字字符后跟两个数字字符后跟字母数字字符组成。 第二个集，其中包括三个字符，必须为数值。 第三个组，其中包括四个字符，必须以字母数字字符后跟三个数字字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 正则表达式模式为：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|匹配三个数字字符。|  
|`(-\d{3}){2}`|找到连字符后跟三个数字字符，并将匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`$`|结束行的末尾匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>指示所指定的正则表达式在指定的输入字符串中是否找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或以确保符合特定模式的一个字符串，而无需检索该字符串以进行后续操作。 如果你想要确定是否一个或多个字符串与正则表达式模式匹配，然后检索成员以进行后续操作，调用<xref:System.Text.RegularExpressions.Regex.Match%2A>或<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法。  
  
 静态<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式`pattern`并调用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>实例方法。 此正则表达式模式由正则表达式引擎缓存供快速检索。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法来确定字符串是否是有效的部件号。 正则表达式假定的部件号具有特定格式包含三个由连字符分隔的字符组成。 第一个集，其中包含四个字符，必须由字母数字字符后跟两个数字字符后跟字母数字字符组成。 第二个集，其中包括三个字符，必须为数值。 第三个组，其中包括四个字符，必须以字母数字字符后跟三个数字字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 正则表达式模式为：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|开始在行的开头匹配。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|匹配三个数字字符。|  
|`(-\d{3}){2}`|找到连字符后跟三个数字字符，并将匹配此模式的两个匹配项。|  
|`[a-zA-Z0-9]`|匹配的单个字母字符 (`a`通过`z`或`A`通过`Z`) 或数字字符。|  
|`$`|结束行的末尾匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于在其中调用该方法的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法用于验证的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>指示所指定的正则表达式是否使用指定的匹配选项在指定的输入字符串中找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或以确保符合特定模式的一个字符串，而无需检索该字符串以进行后续操作。 如果你想要确定是否一个或多个字符串与正则表达式模式匹配，然后检索成员以进行后续操作，调用<xref:System.Text.RegularExpressions.Regex.Match%2A>或<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法。  
  
 静态<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式`pattern`和指定的正则表达式选项`options`并调用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>实例方法。 此正则表达式模式由正则表达式引擎缓存供快速检索。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法来确定字符串是否是有效的部件号。 正则表达式假定的部件号具有特定格式包含三个由连字符分隔的字符组成。 第一个集，其中包含四个字符，必须由字母数字字符后跟两个数字字符后跟字母数字字符组成。 第二个集，其中包括三个字符，必须为数值。 第三个组，其中包括四个字符，必须以字母数字字符后跟三个数字字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 正则表达式模式为：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|从字符串开头开始匹配。|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|匹配三个数字字符。|  
|`(-\d{3}){2}`|找到连字符后跟三个数字字符，并将匹配此模式的两个匹配项...|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`$`|在字符串的结尾结束匹配。|  
  
 调用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法替换`options`参数设置为<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>等效于定义以下正则表达式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 有关比较，请参阅示例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法用于验证的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>指示所指定的正则表达式是否使用指定的匹配选项和超时间隔在指定的输入字符串中找到了匹配项。</summary>
        <returns>如果正则表达式找到匹配项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用于验证字符串或以确保符合特定模式的一个字符串，而无需检索该字符串以进行后续操作。 如果你想要确定是否一个或多个字符串与正则表达式模式匹配，然后检索成员以进行后续操作，调用<xref:System.Text.RegularExpressions.Regex.Match%2A>或<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法。  
  
 静态<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式`pattern`和指定的正则表达式选项`options`并调用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>实例方法。 此正则表达式模式由正则表达式引擎缓存供快速检索。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `matchTimeout`参数指定如何长时间模式匹配方法应尝试超时之前找到匹配项。将设置的超时间隔可阻止依赖于过度回溯出现停止响应时它们处理输入的正则表达式，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果在该时间间隔内不找到任何匹配项，则该方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写应用程序域执行该方法定义的任何默认超时值。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法来确定字符串是否是有效的部件号。 正则表达式假定的部件号具有特定格式包含三个由连字符分隔的字符组成。 第一个集，其中包含四个字符，必须由字母数字字符后跟两个数字字符后跟字母数字字符组成。 第二个集，其中包括三个字符，必须为数值。 第三个组，其中包括四个字符，必须以字母数字字符后跟三个数字字符。 匹配正则表达式模式应涉及最少搜索输入字符串，因此，该方法设置的超时间隔为 500 毫秒。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 正则表达式模式为：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|从字符串开头开始匹配。|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`\d{2}`|匹配两个数字字符。|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`-`|匹配连字符。|  
|`\d{3}`|匹配三个数字字符。|  
|`(-\d{3}){2}`|找到连字符后跟三个数字字符，并将匹配此模式的两个匹配项。|  
|`[A-Z0-9]`|匹配任何单个字母字符`A`通过`Z`，或任意数字字符。|  
|`$`|在字符串的结尾结束匹配。|  
  
 调用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法替换`options`参数设置为<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>等效于定义以下正则表达式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 有关比较，请参阅示例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在输入字符串中搜索匹配正则表达式模式的子字符串，并将第一个匹配项作为单个 <see cref="T:System.Text.RegularExpressions.Match" /> 对象返回。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>在指定的输入字符串中搜索 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法返回输入字符串中的正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 此方法返回中的第一个子字符串`input`匹配正则表达式模式。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 此外可以通过调用来检索单个方法调用中的所有匹配<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例查找正则表达式模式匹配在字符串中，然后列出匹配组、 捕获的内容和捕获位置。  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 正则表达式模式`(\w+)\s+(car)`匹配单词"car"以及它前面的字词的匹配项。 它被解释为下表中所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`(\w+)`|匹配一个或多个单词字符。 这是第一个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
|(car)|匹配文本字符串"car"。 这是第二个捕获组。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">开始搜索的字符位置（从零开始）。</param>
        <summary>从输入字符串中的指定起始位置开始，在该字符串中搜索正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法返回与匹配正则表达式模式，启动时或之后的第一个子字符串`startat`字符位置，在输入字符串中。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 为其正则表达式模式<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法搜索定义之一调用<xref:System.Text.RegularExpressions.Regex>类构造函数。 有关元素构成的正则表达式模式的详细信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 可以选择通过使用指定字符串中的起始位置`startat`参数。 当正则表达式引擎分析从左到右 （默认值） 时，匹配和扫描将移向右，从中指定的字符处开始`startat`。 正则表达式引擎从右到左的分析时 (当正则表达式模式构造与<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>选项)，匹配和扫描中相反方向移动，以在字符开头`startat`-1。 如果未指定起始位置，开始为默认值执行搜索`startat`位置。 如果正则表达式进行搜索，从左到右，默认值`startat`位置位于的左端`input`; 如果它将搜索从右到左，默认`startat`位置位于右端的`input`。  
  
 如果你想要限制匹配项，以便它在字符串中特定的字符位置开始，并且正则表达式引擎不会扫描匹配项的字符串的其余部分，定位到正则表达式和`\G`（在从左到右的左侧模式中，或从右到左模式右侧)。 这会限制匹配，因此它必须恰好在启动`startat`。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 此方法返回找到时或之后的第一个子字符串`startat`的字符位置`input`匹配正则表达式模式。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 此外可以通过调用来检索单个方法调用中的所有匹配<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在指定的输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法返回输入字符串中的正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 静态<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。 在这种情况下，正则表达式引擎缓存正则表达式模式。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 此方法返回中的第一个子字符串`input`匹配正则表达式模式。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 此外可以通过调用来检索单个方法调用中的所有匹配<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法以查找包含至少一个的第一个单词`z`字符，然后调用<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法查找任何其他匹配项。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 正则表达式模式 `\b\w*z+\w*\b` 的含义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w*`|匹配零个、 一个或多个单词字符。|  
|`z+`|匹配一个或多个匹配项的`z`字符。|  
|`\w*`|匹配零个、 一个或多个单词字符。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法检索的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，它允许您设置的超时间隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="beginning">输入字符串中从零开始的字符位置，它定义要搜索的最左侧的位置。</param>
        <param name="length">子字符串中包含在搜索中的字符数。</param>
        <summary>从指定的起始位置开始，在输入字符串中搜索正则表达式的第一个匹配项，并且仅搜索指定数量的字符。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法返回输入字符串的一部分中的正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 为其正则表达式模式<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法搜索定义之一调用<xref:System.Text.RegularExpressions.Regex>类构造函数。 有关元素构成的正则表达式模式的详细信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法搜索的一部分`input`由定义`beginning`和`length`正则表达式模式的参数。 `beginning` 始终定义要在搜索中包括的最左侧字符的索引和`length`定义要搜索的字符最大数目。 它们一起定义搜索的范围。 如果搜索继续从左到右 （默认值），正则表达式引擎将搜索从索引处的字符`beginning`索引处的字符`beginning`  +  `length` -1。 如果通过实例化正则表达式引擎<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>选项，以便搜索将继续从右到左、 从索引处的字符的正则表达式引擎搜索`beginning`  +  `length` -1 到字符索引处`beginning`。 此方法返回此范围内找到第一个匹配项。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置超时值，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> 小于零或大于 <paramref name="input" /> 的长度。  
  
- 或 - 
 <paramref name="length" /> 小于零或大于 <paramref name="input" /> 的长度。  
  
- 或 - 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> 表示 <paramref name="input" /> 范围外的某个位置。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>使用指定的匹配选项在输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法返回输入字符串中的正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 静态<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>构造函数并调用实例<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 此方法返回中找到的第一个子字符串`input`匹配正则表达式模式。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 此外可以通过调用来检索单个方法调用中的所有匹配<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果匹配操作的执行时间超出了指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
   
  
## Examples  
 下面的示例定义正则表达式匹配以字母开头的单词"a"。 它使用<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>选项以确保正则表达式查找开头的单词这两个大写字母"a"和一个小写字母"a"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 正则表达式模式 `\ba\w*\b` 的含义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`a`|匹配的字符"a"。|  
|`\w*`|匹配零个、 一个或多个单词字符。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法检索的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，它允许您设置的超时间隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的匹配选项和超时间隔在输入字符串中搜索指定的正则表达式的第一个匹配项。</summary>
        <returns>一个包含有关匹配的信息的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法返回输入字符串中的正则表达式模式匹配的第一个子字符串。 有关用于生成正则表达式模式的语言元素的信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 静态<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法等效于构造<xref:System.Text.RegularExpressions.Regex>对象<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>构造函数并调用实例<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以确定是否正则表达式模式已找到输入字符串中通过检查所返回的值<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Group.Success%2A>属性。 如果找到匹配项，返回<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Capture.Value%2A>属性包含的子字符串从`input`匹配正则表达式模式。 如果不找到任何匹配项，则其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 此方法返回中找到的第一个子字符串`input`匹配正则表达式模式。 您可以通过重复调用返回检索后续匹配项<xref:System.Text.RegularExpressions.Match>对象的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 此外可以通过调用来检索单个方法调用中的所有匹配<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 `matchTimeout`参数指定如何长时间模式匹配方法应尝试超时之前找到匹配项。将设置的超时间隔可阻止依赖于过度回溯出现停止响应时它们处理输入的正则表达式，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果在该时间间隔内不找到任何匹配项，则该方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写应用程序域执行该方法定义的任何默认超时值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在输入字符串中搜索正则表达式的所有匹配项并返回所有匹配。</summary>
        <block subset="none" type="usage"><para>当通过调用重复的匹配尝试<see cref="Overload:System.Text.RegularExpressions.Regex.Matches" />方法中，正则表达式引擎提供空匹配项特殊处理。 通常情况下，正则表达式引擎开始搜索下一个匹配完全上一个匹配项离开的位置。 但是之后在空匹配项，, 正则表达式引擎提前一个字符之前尝试下一个匹配项。 此行为可确保正则表达式引擎会通过字符串前进。 否则为在空匹配项不会导致任何向前移动，因为下一个匹配项将在与上一个匹配项，相同的位置开始，它将重复匹配同一个空字符串。  
  
在下面的示例中，正则表达式模式<c>*</c>搜索的零个或多个字母"a"字符串"abaabb"中。 如示例所示，生成输出<see cref="T:System.Text.RegularExpressions.MatchCollection" />对象包含六个<see cref="T:System.Text.RegularExpressions.Match" />对象。 第一个匹配尝试查找第一个"a"。 与完全其中第一个匹配结束，第一个 b; 之前在第二个匹配项开始它查找"a"的零个匹配项，并返回一个空字符串。 第三个匹配项不开始恰好第二个匹配结束的地方，因为返回空字符串的第二个匹配项。 相反，它从一个字符开始更高版本之后第一个"b"。 第三个匹配查找两个匹配项的"a"，并返回"aa"。 第四个匹配尝试结束的地方开始第三个匹配项之前第二个"b"，, 并返回一个空字符串。 第五个匹配尝试再次提升一个字符，以便它在第三个"b"之前开始，并返回一个空字符串。 第六个匹配项开始后的最后一个"b"，并再次返回一个空字符串。  
  
[!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <summary>在指定的输入字符串中搜索正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法是类似于<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>找到输入字符串，而不是单个匹配项中的方法，前者返回有关所有匹配项的信息。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 该集合包含唯一的匹配项，并终止于第一个非-匹配。  
  
 为其正则表达式模式<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法搜索定义之一调用<xref:System.Text.RegularExpressions.Regex>类构造函数。 有关元素构成的正则表达式模式的详细信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回<xref:System.Text.RegularExpressions.MatchCollection>对象。 访问此集合的成员，如<xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType>和<xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>导致要立即填充的集合。 若要利用延迟计算，应遍历集合使用一个构造，如`foreach`C# 中和`For Each`...`Next` 口。  
  
 由于其迟缓计算中，调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法不会引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 但是，将引发异常，对执行操作时<xref:System.Text.RegularExpressions.MatchCollection>时，返回的此方法的对象<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>属性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和匹配的操作超出超时时间间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>的方法来确定一个句子中以"es"结尾的所有单词。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串"es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="startat">在输入字符串中开始搜索的字符位置。</param>
        <summary>从字符串中的指定起始位置开始，在指定的输入字符串中搜索正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法是类似于<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>找到输入字符串，而不是单个匹配项中的方法，前者返回有关所有匹配项的信息。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 为其正则表达式模式<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法搜索定义之一调用<xref:System.Text.RegularExpressions.Regex>类构造函数。 有关元素构成的正则表达式模式的详细信息，请参阅[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回<xref:System.Text.RegularExpressions.MatchCollection>对象。 访问此集合的成员，如<xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType>和<xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>导致要立即填充的集合。 若要利用延迟计算，应遍历集合使用一个构造，如`foreach`C# 中和`For Each`...`Next` 口。  
  
 由于其迟缓计算中，调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法不会引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 但是，将引发异常，对执行操作时<xref:System.Text.RegularExpressions.MatchCollection>时，返回的此方法的对象<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>属性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和匹配的操作超出超时时间间隔。 
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法查找句子中以"es"结尾，然后调用的第一个单词<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>的方法来确定任何其他单词以"es"结尾的。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串"es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法是类似于<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>找到输入字符串，而不是单个匹配项中的方法，前者返回有关所有匹配项的信息。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 静态`Matches`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Matches`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回<xref:System.Text.RegularExpressions.MatchCollection>对象。 访问此集合的成员，如<xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType>和<xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>导致要立即填充的集合。 若要利用延迟计算，应遍历集合使用一个构造，如`foreach`C# 中和`For Each`...`Next` 口。  
  
 由于其迟缓计算中，调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法不会引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 但是，将引发异常，对执行操作时<xref:System.Text.RegularExpressions.MatchCollection>如果由当前的应用程序域和匹配操作的"REGEX_DEFAULT_MATCH_TIMEOUT"属性定义的超时间隔，则此方法，返回的对象超出了此超时间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>的方法来确定在"es"结尾的句子中的任何文字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串"es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法检索多个模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可用于指定超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的按位组合，这些枚举值指定用于匹配的选项。</param>
        <summary>使用指定的匹配选项在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法是类似于<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>找到输入字符串，而不是单个匹配项中的方法，前者返回有关所有匹配项的信息。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 静态`Matches`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Matches`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回<xref:System.Text.RegularExpressions.MatchCollection>对象。 访问此集合的成员，如<xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType>和<xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>导致要立即填充的集合。 若要利用延迟计算，应遍历集合使用一个构造，如`foreach`C# 中和`For Each`...`Next` 口。  
  
 由于其迟缓计算中，调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法不会引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 但是，将引发异常，对执行操作时<xref:System.Text.RegularExpressions.MatchCollection>如果由当前的应用程序域和匹配操作的"REGEX_DEFAULT_MATCH_TIMEOUT"属性定义的超时间隔，则此方法，返回的对象超出了此超时间隔。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>的方法来确定以"es"结尾，然后调用的句子中的任何文字<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法来执行不区分大小写的模式与输入字符串比较。 如输出所示，两种方法将返回不同的结果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串"es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法检索多个模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的按位组合，这些枚举值指定用于匹配的选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的匹配选项和超时间隔在指定的输入字符串中搜索指定的正则表达式的所有匹配项。</summary>
        <returns>搜索操作找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 对象的集合。 如果未找到匹配项，则此方法将返回一个空集合对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法是类似于<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>找到输入字符串，而不是单个匹配项中的方法，前者返回有关所有匹配项的信息。 它等效于以下代码：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 静态`Matches`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Matches`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法使用延迟计算来填充返回<xref:System.Text.RegularExpressions.MatchCollection>对象。 访问此集合的成员，如<xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType>和<xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>导致要立即填充的集合。 若要利用延迟计算，应遍历集合使用一个构造，如`foreach`C# 中和`For Each`...`Next` 口。  
  
 由于其迟缓计算中，调用<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法不会引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 但是，在执行操作时引发异常<xref:System.Text.RegularExpressions.MatchCollection>如果匹配操作超出指定的此超时时间间隔，此方法返回对象`matchTimeout`参数。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法来执行匹配任何单词以"es"结尾的句子中的区分大小写比较。 然后，它调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法来执行不区分大小写的模式与输入字符串比较。 在这两种情况下，超时间隔设置为 1 秒。 如输出所示，两种方法将返回不同的结果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 正则表达式模式 `\b\w+es\b` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|在单词边界处开始匹配。|  
|`\w+`|匹配一个或多个单词字符。|  
|`es`|匹配文本字符串"es"。|  
|`\b`|在单词边界处结束匹配。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前实例的超时间隔。</summary>
        <value>在 <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> 引发之前或如果时间超期被禁用 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> ，在样式匹配操作符中可以经过的最长时间间隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>属性定义的近似最大时间间隔<xref:System.Text.RegularExpressions.Regex>实例操作超时前执行单个匹配操作。正则表达式引擎会抛出<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>在经过超时间隔后其下一步计时检查过程中的异常。 这可以防止正则表达式引擎处理需要过多使用回溯的输入的字符串。 有关详细信息，请参阅[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)并[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)。  
  
 此属性是只读的。 其值设置为某个人的显式<xref:System.Text.RegularExpressions.Regex>对象通过调用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数; 并且可以将其值设置为所有<xref:System.Text.RegularExpressions.Regex>匹配应用程序域中的操作通过调用<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法并提供<xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT"属性值，如以下示例所示。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 如果你未显式设置的超时间隔，默认值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>是使用情况，以及匹配的操作就不会超时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传递给 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数的选项。</summary>
        <value><see cref="T:System.Text.RegularExpressions.RegexOptions" /> 枚举 的一个或多个成员表示传递至 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数的选项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Text.RegularExpressions.Regex.Options%2A>属性包含的一个或多个成员<xref:System.Text.RegularExpressions.RegexOptions>枚举。 如果在中不定义的任何选项<xref:System.Text.RegularExpressions.Regex>类构造函数，其值是<xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>。 中详细地讨论了可用的选项[正则表达式选项](~/docs/standard/base-types/regular-expression-options.md)主题。  
  
 请注意，<xref:System.Text.RegularExpressions.Regex.Options%2A>属性不会反映在正则表达式中定义的内联选项模式本身。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 是由创建的正则表达式的基类<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。 这些已编译的正则表达式使用的基类实现<see cref="P:System.Text.RegularExpressions.Regex.Options" />属性。 如果从派生类中，调用<see cref="P:System.Text.RegularExpressions.Regex.Options" />属性返回传递到的选项<paramref name="options" />参数的<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />用于定义正则表达式的类构造函数。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">正则表达式选项</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与某个正则表达式模式匹配的字符串。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与某个正则表达式模式匹配的所有的字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开头开始搜索的匹配项`input`字符串。 正则表达式是当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。  
  
 `replacement`参数指定是替换中的每个匹配项的字符串`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例定义正则表达式， `\s+`，匹配一个或多个空白字符。 替换字符串中，""，它们替换为单个空格字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 下面的示例定义正则表达式`(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`，并替换模式中， `$2`，从一个数值中删除前导或尾随的货币符号。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 正则表达式模式可以解释为下表中所示内容。  
  
|模式|描述|  
|-------------|-----------------|  
|`\p{Sc}`|与匹配货币符号。 `{Sc}` 表示任何字符的 Unicode 符号、 货币类别的成员。|  
|`\s?`|匹配零个或一个空白字符。|  
|`(\p{Sc}\s?)?`|匹配零个或一个匹配项的货币符号后跟零个或一个空白字符的组合。 这是第一个捕获组。|  
|`\d+`|匹配一个或多个十进制数字。|  
|`\.?`|匹配零个或一个匹配项的一段 （用作小数分隔符字符）。|  
|`((?<=\.)\d+)?`|如果一段是前一个字符，匹配一个或多个十进制数字。 此模式可以匹配零个或一个时间。|  
|`(\d+\.?((?<=\.)\d+)?)`|与一个或多个十进制数字，后面再跟一个可选的时间段和其他十进制数字的模式匹配。 这是第二个捕获组。 对调用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29>方法使用此捕获组的值替换整个匹配项。|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|如果第一个捕获的组存在，则匹配空字符串。 否则，匹配零个或一个空白字符后跟货币符号。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法可用于替换正则表达式匹配，如果以下条件为真：  
  
-   正则表达式替换模式不能轻松地指定替换字符串。  
  
-   替换字符串中匹配的字符串上进行某些处理结果。  
  
-   来自有条件处理的替换字符串结果。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法并传递每个<xref:System.Text.RegularExpressions.Match>在返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 正则表达式是当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的代码示例显示原始字符串、 匹配原始字符串中的每个单词，将转换后的字符串转换为大写，然后显示每个匹配项的第一个字符。  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <param name="count">可进行替换的最大次数。</param>
        <summary>在指定输入字符串内，使用指定替换字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开头开始搜索的匹配项`input`字符串。 正则表达式是由当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。 如果`count`为负，替换继续进行到字符串的末尾。 如果`count`超过了匹配项的数目，则替换所有匹配项。  
  
 `replacement`参数指定的字符串，用于替换第一个`count`一致`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例重复的字符的前五个匹配项替换单个字符。 正则表达式模式`(\w)\1`匹配单个字符的连续匹配项并将第一个匹配项分配给第一个捕获组。 替换模式`$1`替换整个匹配项替换为第一个捕获组。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态`Replace`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Replace`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 开头开始搜索的匹配项`input`字符串。  
  
 `replacement`参数指定是替换中的每个匹配项的字符串`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例定义正则表达式， `\s+`，匹配一个或多个空白字符。 替换字符串中，""，它们替换为单个空格字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法将替换本地文件路径的 UNC 路径中的本地计算机和驱动器名称。 使用正则表达式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性以包含本地计算机的名称和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法以包括的逻辑驱动器的名称。 若要成功运行该示例，应该替换你本地计算机的名称为"MyMachine"的文本字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 以下表达式所定义的正则表达式模式：  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续反斜杠 (`\`) 字符。 反斜杠字符解释为转义符，因为每个反斜杠必须使用另一个反斜杠进行转义。|  
|`(?i:" + Environment.MachineName + ")`|执行不区分大小写的匹配返回的字符串的<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 未捕获匹配的子表达式。|  
|`\\`|匹配一个反斜杠 (`\`) 字符。|  
|`((?i:[" + driveNames + "]))`|执行不区分大小写的匹配项的包含单个驱动器字母的字符类。 满足此匹配，第一个捕获的子表达式。|  
|`\$`|匹配文本的美元符号 (`$`) 字符。|  
  
 替换模式`$1`整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法，用于更换的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法可用于替换正则表达式匹配，如果以下条件为真：  
  
-   正则表达式替换模式不能轻松地指定替换字符串。  
  
-   替换字符串中匹配的字符串上进行某些处理结果。  
  
-   来自有条件处理的替换字符串结果。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法并传递每个<xref:System.Text.RegularExpressions.Match>在返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式，从字符串中提取的单个单词，然后使用<xref:System.Text.RegularExpressions.MatchEvaluator>委托来调用一个名为方法`WordScramble`打乱单词中的单个字母。 若要执行此操作，`WordScramble`方法创建一个数组，包含匹配项中的字符。 它还用随机浮点数创建一个并行数组，它将填充。 这些数组进行排序通过调用<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，并已排序的数组作为参数提供<xref:System.String>类构造函数。 然后返回此新创建的字符串`WordScramble`方法。 正则表达式模式`\w+`匹配一个或多个单词字符; 正则表达式引擎将继续将字符添加到匹配项，直到它遇到非单词字符，例如空格字符。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法，用于评估和替换模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="count">进行替换的最大次数。</param>
        <summary>在指定的输入字符串内，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType>方法可用于替换正则表达式匹配，如果以下条件为真：  
  
-   正则表达式替换模式不能轻松地指定替换字符串。  
  
-   替换字符串中匹配的字符串上进行某些处理结果。  
  
-   来自有条件处理的替换字符串结果。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法并传递第一个`count`<xref:System.Text.RegularExpressions.Match>中返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 正则表达式是当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 以下示例使用正则表达式来有意拼错的单词列表中的下半部分。 它使用正则表达式`\w*(ie|ei)\w*`与包含字符"ie"或"ei"的单词匹配。 它将传递第一个到匹配的单词的一半`ReverseLetter`方法，它反过来使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法，以撤消"i"和"e"中匹配的字符串。 剩余字词保持不变。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 正则表达式 `\w*(ie|ei)\w*` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\w*`|匹配零个或多个单词字符。|  
|<code>(ie&#124;ei)</code>|匹配"ie"或"ei"。|  
|`\w*`|匹配零个或多个单词字符。|  
  
 正则表达式模式`([ie])([ie])`在`ReverseLetter`方法 diphthong"ie"或"ei"中匹配的第一个"i"或"e"，并将字母分配给第一个捕获组。 它匹配的第二个"i"或"e"，并将号分配给第二个捕获组。 两个字符会接着反转通过调用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法使用替换模式`$2$1`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="replacement">替换字符串。</param>
        <param name="count">可进行替换的最大次数。</param>
        <param name="startat">输入字符串中开始执行搜索的字符位置。</param>
        <summary>在指定输入子字符串内，使用指定替换字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开始搜索的匹配项`input`字符串中指定的位置`startat`参数。 正则表达式是当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。 如果`count`为负，替换继续进行到字符串的末尾。 如果`count`超过了匹配项的数目，则替换所有匹配项。  
  
 `replacement`参数指定是替换中的每个匹配项的字符串`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 除字符串的第一行之外的所有 double-spaces 下面的示例。 它定义的正则表达式模式`^.*$`，与匹配的文本，调用行<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法以匹配的字符串，并使用第一行`Match.Index`和`Match.Count`属性以确定第二个的起始位置行。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 正则表达式模式 `^.*$` 的定义如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|匹配行的开头。 (请注意，<xref:System.Text.RegularExpressions.Regex>对象实例化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>选项; 否则，此字符类将仅匹配输入字符串的开头。)|  
|`.*`|匹配任一字符零次或多次。|  
|`$`|匹配行尾。 (请注意，<xref:System.Text.RegularExpressions.Regex>对象实例化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>选项; 否则，此字符类将仅匹配输入字符串的开头。)|  
  
 替换字符串 (`vbCrLf + "$&"`在 Visual Basic 中`"\n$&"`C# 中) 添加一个新行之前匹配的字符串。 请注意，`\n`在 C# 示例将解释为换行字符由 C# 编译器; 它不表示正则表达式字符转义符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。 指定的选项将修改匹配操作。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态`Replace`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Replace`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果指定<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>为`options`参数，搜索的匹配项从输入字符串的末尾处开始，并向左移动; 否则为搜索输入字符串的开头开始并向右移动。  
  
 `replacement`参数指定是替换中的每个匹配项的字符串`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法将替换本地文件路径的 UNC 路径中的本地计算机和驱动器名称。 使用正则表达式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性以包含本地计算机的名称和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法以包括的逻辑驱动器的名称。 所有正则表达式字符串比较不区分大小写。 若要成功运行该示例，应该替换你本地计算机的名称为"MyMachine"的文本字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 以下表达式所定义的正则表达式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续反斜杠 (`\`) 字符。 反斜杠字符解释为转义符，因为每个反斜杠必须使用另一个反斜杠进行转义。|  
|`+ Environment.MachineName +`|返回的字符串匹配<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 未捕获匹配的子表达式。|  
|`\\`|匹配一个反斜杠 (`\`) 字符。|  
|`([" + driveNames + "])`|匹配包含单个驱动器字母的字符类。 满足此匹配，第一个捕获的子表达式。|  
|`\$`|匹配文本的美元符号 (`$`) 字符。|  
  
 替换模式`$1`整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于调用它的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法，用于更换的模式匹配是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有字符串。 指定的选项将修改匹配操作。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法可用于替换中的正则表达式匹配项，如果以下条件为真：  
  
-   正则表达式替换模式不能轻松地指定替换字符串。  
  
-   替换字符串中匹配的字符串上进行某些处理结果。  
  
-   来自有条件处理的替换字符串结果。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法并传递每个<xref:System.Text.RegularExpressions.Match>在返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 如果指定<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>为`options`参数，搜索的匹配项从输入字符串的末尾处开始，并向左移动; 否则为搜索输入字符串的开头开始并向右移动。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式，从字符串中提取的单个单词，然后使用<xref:System.Text.RegularExpressions.MatchEvaluator>委托来调用一个名为方法`WordScramble`打乱单词中的单个字母。 若要执行此操作，`WordScramble`方法创建一个数组，包含匹配项中的字符。 它还用随机浮点数创建一个并行数组，它将填充。 这些数组进行排序通过调用<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，并已排序的数组作为参数提供<xref:System.String>类构造函数。 然后返回此新创建的字符串`WordScramble`方法。 正则表达式模式`\w+`匹配一个或多个单词字符; 正则表达式引擎将继续将字符添加到匹配项，直到它遇到非单词字符，例如空格字符。 在调用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包括<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>选项，以便在正则表达式模式中的注释`\w+  # Matches all the characters in a word.`忽略正则表达式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="count">进行替换的最大次数。</param>
        <param name="startat">输入字符串中开始执行搜索的字符位置。</param>
        <summary>在指定的输入子字符串内，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与某个正则表达式模式匹配的字符串（其数目为指定的最大数目）。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被一个替换字符串代替。 如果正则表达式模式与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法可用于替换正则表达式匹配，如果以下条件为真：  
  
-   正则表达式替换模式不能轻松地指定替换字符串。  
  
-   替换字符串中匹配的字符串上进行某些处理结果。  
  
-   来自有条件处理的替换字符串结果。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法并传递第一个`count`<xref:System.Text.RegularExpressions.Match>中返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 正则表达式是当前的构造函数定义的模式<xref:System.Text.RegularExpressions.Regex>对象。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果替换操作的执行时间超过指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="replacement">替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的输入字符串内，使用指定的替换字符串替换与指定正则表达式匹配的所有字符串。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态`Replace`方法是等效于构造<xref:System.Text.RegularExpressions.Regex>对象使用指定的正则表达式模式，并调用实例方法`Replace`。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果指定<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>为`options`参数，搜索的匹配项从输入字符串的末尾处开始，并向左移动; 否则为搜索输入字符串的开头开始并向右移动。  
  
 `replacement`参数指定是替换中的每个匹配项的字符串`input`。 `replacement` 可以包含文字文本的任意组合并[替换](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，替换模式`a*${test}b`插入字符串"*"匹配的子字符串后跟`test`捕获组，如果有后, 跟字符串"b"。 * 字符未被识别为元字符在替换模式中。  
  
> [!NOTE]
>  替换是替换模式中识别的唯一的正则表达式语言元素。 所有其他正则表达式语言元素，包括[字符转义符](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 仅正则表达式模式中允许和不识别在替换模式中。  
  
 `matchTimeout`参数指定如何长时间模式匹配方法应尝试超时之前找到匹配项。将设置的超时间隔可阻止依赖于过度回溯出现停止响应时它们处理输入的正则表达式，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果在该时间间隔内不找到任何匹配项，则该方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写应用程序域执行该方法定义的任何默认超时值。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法将替换本地文件路径的 UNC 路径中的本地计算机和驱动器名称。 使用正则表达式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性以包含本地计算机的名称和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法以包括的逻辑驱动器的名称。 所有正则表达式字符串比较是区分大小写，并在 0.5 秒内找不到匹配项，任何单个替换操作将会超时。 若要成功运行该示例，应该替换你本地计算机的名称为"MyMachine"的文本字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 以下表达式所定义的正则表达式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表演示了如何解释正则表达式模式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|匹配两个连续反斜杠 (`\`) 字符。 反斜杠字符解释为转义符，因为每个反斜杠必须使用另一个反斜杠进行转义。|  
|`+ Environment.MachineName +`|返回的字符串匹配<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性。|  
|`(?:\.\w+)*`|匹配句点 (`.`) 字符后跟一个或多个单词字符。 此匹配可以出现零次或多次。 未捕获匹配的子表达式。|  
|`\\`|匹配一个反斜杠 (`\`) 字符。|  
|`([" + driveNames + "])`|匹配包含单个驱动器字母的字符类。 满足此匹配，第一个捕获的子表达式。|  
|`\$`|匹配文本的美元符号 (`$`) 字符。|  
  
 替换模式`$1`整个匹配项替换为第一个捕获的子表达式。 也就是说，它将 UNC 计算机和驱动器名称替换为驱动器号。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">.NET Framework 中的正则表达式的最佳做法</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要搜索匹配项的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="evaluator">一个自定义方法，该方法检查每个匹配项，然后返回原始的匹配字符串或替换字符串。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的输入字符串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委托返回的字符串替换与指定的正则表达式匹配的所有子字符串。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>一个与输入字符串基本相同的新字符串，唯一的差别在于，其中的每个匹配字符串已被替换字符串代替。 如果 <paramref name="pattern" /> 与当前实例不匹配，则此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法可用于替换正则表达式匹配，如果以下条件为真：  
  
-   如果正则表达式替换模式不能轻松地指定替换字符串。  
  
-   如果替换字符串得到的一些处理执行匹配的字符串。  
  
-   如果替换字符串而得出的有条件处理。  
  
 该方法等效于调用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法并传递每个<xref:System.Text.RegularExpressions.Match>在返回的对象<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委托。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`参数是您定义的自定义方法的委托，用于检查每个匹配项。 自定义的方法必须具有以下签名以匹配<xref:System.Text.RegularExpressions.MatchEvaluator>委托。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 自定义方法返回的字符串可替换匹配的输入。  
  
 如果指定<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>为`options`参数，搜索的匹配项从输入字符串的末尾处开始，并向左移动; 否则为搜索输入字符串的开头开始并向右移动。  
  
 `matchTimeout`参数指定如何长时间模式匹配方法应尝试超时之前找到匹配项。设置超时间隔可防止正则表达式依赖于过度回溯到出现的"停止响应时它们处理输入，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果在该时间间隔内不找到任何匹配项，则该方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写应用程序域执行该方法定义的任何默认超时值。  
  
 因为该方法返回`input`如果没有匹配项保持不变，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以确定该方法是否已发生与输入字符串的任何替换。  
  
   
  
## Examples  
 下面的示例使用正则表达式，从字符串中提取的单个单词，然后使用<xref:System.Text.RegularExpressions.MatchEvaluator>委托来调用一个名为方法`WordScramble`打乱单词中的单个字母。 若要执行此操作，`WordScramble`方法创建一个数组，包含匹配项中的字符。 它还用随机浮点数创建一个并行数组，它将填充。 这些数组进行排序通过调用<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，并已排序的数组作为参数提供<xref:System.String>类构造函数。 然后返回此新创建的字符串`WordScramble`方法。 正则表达式模式`\w+`匹配一个或多个单词字符; 正则表达式引擎将继续将字符添加到匹配项，直到它遇到非单词字符，例如空格字符。 在调用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包括<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>选项，以便在正则表达式模式中的注释`\w+  # Matches all the characters in a word.`忽略正则表达式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">.NET Framework 中的正则表达式的最佳做法</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示正则表达式是否从右向左进行搜索。</summary>
        <value>如果正则表达式从右向左进行搜索，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> 是`true`如果<xref:System.Text.RegularExpressions.Regex>实例创建与<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>选项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在由正则表达式匹配定义的位置将输入字符串拆分为一个子字符串数组。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数指定的正则表达式模式所定义的位置，将输入字符串拆分为子字符串数组。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 将字符串拆分为多的次数。 如果不找到任何分隔符，则返回值包含一个其值为原始输入的字符串的元素。  
  
 如果多个匹配项是彼此相邻，则将空字符串插入到数组。 例如，拆分上一个连字符的字符串会导致返回的数组，若要在其中找到两个连续的连字符，如以下代码所示的位置中包括一个空字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 如果开头或输入字符串的末尾找到匹配项，则为空字符串是数组的包含开头或末尾返回。 下面的示例使用正则表达式模式`\d+`拆分输入的字符串对数字字符。 由于字符串开头和结尾匹配数字字符，则返回的数组的第一个和最后一个元素的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 如果在使用捕获括号，则<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>表达式中，任何捕获的文本包括在生成的字符串数组中。 例如，如果拆分"plum-pear"上一个连字符放在捕获括号的字符串，返回的数组包含一个包含连字符的字符串元素。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，如果捕获括号中的第一个集内找不到匹配项从其他捕获括号捕获的文本不包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本也添加到返回的数组。 例如，下面的代码使用两个组捕获括号来提取日期，包括日期分隔符，从日期字符串的元素。 第一捕获括号的组捕获连字符，并第二个集捕获正斜杠。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，它不包括反斜杠字符;如果它是编译并运行.NET Framework 2.0 或更高版本下，它包括它们。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%29>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 例如:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 请注意，在返回的数组还包含空字符串的开头和结尾的数组。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果拆分操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="count">可拆分的最大次数。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式定义的位置，将输入字符串拆分为子字符串数组指定的最大次数。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 `count`参数指定到其中的子字符串的最大数目`input`可以拆分字符串; 最后一个字符串包含拆分的字符串的其余部分。 一个`count`为零的值提供拆分为尽可能多的默认行为。  
  
 如果是彼此相邻的多个匹配项，或在开头或末尾找到匹配项`input`，并找到匹配项数目是至少两个小于`count`，空字符串插入到数组。 它是相邻的匹配项或位置的开头或输入字符串的末尾匹配项导致的空字符串是否会计算在内中确定的数目匹配子字符串等于`count`。 在下面的示例中，正则表达式`/d+`用于拆分输入的字符串到三个子字符串的最多包含一个或多个十进制数字。 因为输入字符串的开头与正则表达式模式相匹配，则第一个数组元素包含<xref:System.String.Empty?displayProperty=nameWithType>，第二个包含输入字符串中的字母字符的第一个集和第三个包含字符串的其余部分第三个匹配项后的。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 如果正则表达式中使用捕获括号，拆分的字符串数组中包含任何捕获的文本。 但是，包含捕获的文本的任何数组元素不会计入确定是否匹配项的数目已达到`count`。 例如，拆分到最多七个元素的数组，如以下代码中的四个子字符串结果的字符串"apple-apricot-plum-pear-banana"显示。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，仅从第一捕获括号的组捕获的文本包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本添加到返回的数组。 但是，返回的数组中包含捕获的文本的元素不会计入确定是否数匹配子字符串等于`count`。 例如，在下面的代码中，正则表达式使用两组捕获括号以从日期字符串中提取日期的元素。 第一捕获括号的组捕获连字符，并第二个集捕获正斜杠。 对调用<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>方法然后指定两个元素的最多返回的数组中。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，方法将返回两个元素的字符串数组。 如果编译和.NET Framework 2.0 或更高版本下运行，方法将返回三个元素的字符串数组。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 下面的示例将字符串"字符"拆分成，因为许多元素与输入字符串中。 Null 字符串与输入字符串的开头匹配，因为返回的数组开头位置插入一个 null 字符串。 这将导致第 10 个元素组成的输入字符串末尾的两个字符。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果拆分操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <summary>在由正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 `input`字符串拆分为尽可能多次。 如果`pattern`中找不到`input`字符串，返回值包含一个其值为原始元素`input`字符串。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  已编译的正则表达式中调用静态使用<xref:System.Text.RegularExpressions.Regex.Split%2A>自动缓存的方法。 若要自行管理的已编译的正则表达式的生存期，使用实例<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多个匹配项是彼此相邻，则将空字符串插入到数组。 例如，拆分上一个连字符的字符串会导致返回的数组，若要在其中找到两个连续的连字符，如以下代码所示的位置中包括一个空字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 如果开头或输入字符串的末尾找到匹配项，则为空字符串是数组的包含开头或末尾返回。 下面的示例使用正则表达式模式`\d+`拆分输入的字符串对数字字符。 由于字符串开头和结尾匹配数字字符，则返回的数组的第一个和最后一个元素的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 如果在使用捕获括号，则<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>表达式中，任何捕获的文本包括在生成的字符串数组中。 例如，如果拆分"plum-pear"上一个连字符放在捕获括号的字符串，返回的数组包含一个包含连字符的字符串元素。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，如果捕获括号中的第一个集内找不到匹配项从其他捕获括号捕获的文本不包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本也添加到返回的数组。 例如，下面的代码使用两个组捕获括号来提取日期，包括日期分隔符，从日期字符串的元素。 第一捕获括号的组捕获连字符，并第二个集捕获正斜杠。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，它不包括反斜杠字符;如果它是编译并运行.NET Framework 2.0 或更高版本下，它包括它们。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%2A>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 例如:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 请注意，在返回的数组还包含空字符串的开头和结尾的数组。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于在其中调用该方法的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法拆分模式匹配的文本是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="count">可拆分的最大次数。</param>
        <param name="startat">输入字符串中将开始搜索的字符位置。</param>
        <summary>在由 <see cref="T:System.Text.RegularExpressions.Regex" /> 构造函数中指定的正则表达式定义的位置，将输入字符串拆分为子字符串数组指定的最大次数。 从输入字符串的指定字符位置开始搜索正则表达式模式。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 `count`参数指定到其中的子字符串的最大数目`input`拆分字符串; 最后一个字符串包含拆分的字符串的其余部分。 一个`count`为零的值提供拆分为尽可能多的默认行为。 `startat`参数定义的第一个分隔符搜索开始处的点 （可用于跳过前导空格）。  
  
 如果没有找到匹配的来自`count`+ 1 位置的字符串中，该方法返回一个元素的数组，其中包含`input`字符串。 如果找到一个或多个匹配项，返回的数组的第一个元素将包含来自最多匹配项前一个字符的第一个字符的字符串的第一个部分。  
  
 如果多个匹配项是彼此相邻并找到匹配项数目是至少两个小于`count`，空字符串插入到数组。 同样，如果在找到匹配项`startat`，即在字符串中的第一个字符，则返回的数组的第一个元素为空字符串。 也就是说，所产生的相邻匹配空字符串是否会计算在内中确定的数目匹配子字符串等于`count`。 在下面的示例中，正则表达式`\d+`用于在字符串中，查找数字字符的第一个子字符串的起始位置，然后将字符串拆分的最多三次开始该位置。 正则表达式模式与输入字符串的开头匹配，因为返回的字符串数组包含空字符串、 五个字符的字母字符串，以及字符串的其余部分  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 如果正则表达式中使用捕获括号，拆分的字符串数组中包含任何捕获的文本。 但是，包含捕获的文本的任何数组元素不会计入确定是否匹配项的数目已达到`count`。 例如，拆分字符串"apple-apricot-plum-pear-pomegranate-pineapple-peach"到最多四个的子字符串开始字符 15 字符串导致七个元素的数组，如以下代码所示。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，如果捕获括号中的第一个集内找不到匹配项从其他捕获括号捕获的文本不包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本也添加到返回的数组。 例如，下面的代码使用捕获括号的两个集提取在字符串中的个别词。 第一捕获括号的组捕获连字符，并第二个集捕获垂直条。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，它不包括垂直条形字符;如果它是编译并运行.NET Framework 2.0 或更高版本下，它包括它们。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%2A>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。 下面的示例： 将字符串"字符"拆分成尽可能多的元素，因为输入的字符串包含，以字符为起始"a"。 Null 字符串与输入字符串的末尾匹配，因为返回数组的末尾插入一个 null 字符串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果拆分操作的执行时间超出了指定的超时间隔将引发异常<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>构造函数。 如果操作超过在其中应用程序域建立任何超时值时调用的构造函数未设置的超时间隔，如果引发异常<xref:System.Text.RegularExpressions.Regex>创建对象。 如果在中定义没有超时设定<xref:System.Text.RegularExpressions.Regex>构造函数调用或在应用程序域的属性中，或如果超时值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小于零或大于 <paramref name="input" /> 的长度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <summary>在由指定正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。 指定的选项将修改匹配操作。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 将字符串拆分为多的次数。 如果不找到任何分隔符，则返回值包含一个其值为原始元素`input`字符串。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  已编译的正则表达式中调用静态使用<xref:System.Text.RegularExpressions.Regex.Split%2A>自动缓存的方法。 若要自行管理的已编译的正则表达式的生存期，使用实例<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多个匹配项是彼此相邻，则将空字符串插入到数组。 例如，拆分上一个连字符的字符串会导致返回的数组，若要在其中找到两个连续的连字符的位置中包括一个空字符串。  
  
 如果开头或输入字符串的末尾找到匹配项，则为空字符串是数组的包含开头或末尾返回。 下面的示例使用正则表达式模式`[a-z]+`拆分输入的字符串上任意大写或小写的字母字符。 由于字符串开头和结尾匹配字母字符，则返回的数组的第一个和最后一个元素的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 如果在使用捕获括号，则<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>表达式中，任何捕获的文本包括在生成的字符串数组中。 例如，如果拆分"plum-pear"上一个连字符放在捕获括号的字符串，返回的数组包含一个包含连字符的字符串元素。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，如果捕获括号中的第一个集内找不到匹配项从其他捕获括号捕获的文本不包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本也添加到返回的数组。 例如，下面的代码使用两个组捕获括号来提取日期，包括日期分隔符，从日期字符串的元素。 第一捕获括号的组捕获连字符，并第二个集捕获正斜杠。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，它不包括反斜杠字符;如果它是编译并运行.NET Framework 2.0 或更高版本下，它包括它们。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%2A>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 操作的执行时间超过指定的方法称为应用程序域的超时间隔将引发异常。 如果在应用程序域的属性中，定义无超时或超时值，即<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，不会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>此方法等同于在其中调用该方法的应用程序域的默认超时值的时间间隔后将会超时。 如果不为应用程序域，值定义超时值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，这样可以防止不会超时，该方法使用。 推荐的静态方法拆分模式匹配的文本是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，它允许您设置的超时间隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要拆分的字符串。</param>
        <param name="pattern">要匹配的正则表达式模式。</param>
        <param name="options">枚举值的一个按位组合，这些枚举值提供匹配选项。</param>
        <param name="matchTimeout">超时间隔；若要指示该方法不应超时，则为 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在由指定正则表达式模式定义的位置将输入字符串拆分为一个子字符串数组。 如果未找到匹配项，则其他参数指定修改匹配操作的选项和超时间隔。</summary>
        <returns>字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是类似于<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之处在于<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>在由正则表达式而不是一组字符分隔符拆分字符串。 将字符串拆分为多的次数。 如果不找到任何分隔符，则返回值包含一个其值为原始元素`input`字符串。  
  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  已编译的正则表达式中调用静态使用<xref:System.Text.RegularExpressions.Regex.Split%2A>自动缓存的方法。 若要自行管理的已编译的正则表达式的生存期，使用实例<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多个匹配项是彼此相邻，则将空字符串插入到数组。 例如，拆分上一个连字符的字符串会导致返回的数组，若要在其中找到两个连续的连字符的位置中包括一个空字符串。  
  
 如果开头或输入字符串的末尾找到匹配项，则为空字符串是数组的包含开头或末尾返回。 下面的示例使用正则表达式模式`[a-z]+`拆分输入的字符串上任意大写或小写的字母字符。 由于字符串开头和结尾匹配字母字符，则返回的数组的第一个和最后一个元素的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 如果在使用捕获括号，则<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>表达式中，任何捕获的文本包括在生成的字符串数组中。 例如，如果拆分"plum-pear"上一个连字符放在捕获括号的字符串，返回的数组包含一个包含连字符的字符串元素。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 但是，如果正则表达式模式包含多组捕获括号，此方法的行为依赖于.NET Framework 的版本。 在.NET Framework 1.0 和 1.1 中，如果捕获括号中的第一个集内找不到匹配项从其他捕获括号捕获的文本不包含在返回的数组。 从.NET Framework 2.0 开始，所有捕获的文本也添加到返回的数组。 例如，下面的代码使用两个组捕获括号来提取日期，包括日期分隔符，从日期字符串的元素。 第一捕获括号的组捕获连字符，并第二个集捕获正斜杠。 如果示例代码编译和运行.NET Framework 1.0 或 1.1，它不包括反斜杠字符;如果它是编译并运行.NET Framework 2.0 或更高版本下，它包括它们。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果正则表达式可以匹配空字符串，<xref:System.Text.RegularExpressions.Regex.Split%2A>会将字符串拆分为一个单字符字符串数组，因为可以在每个位置找到空字符串分隔符。  
  
 `matchTimeout`参数指定如何长时间模式匹配方法应尝试超时之前找到匹配项。将设置的超时间隔可阻止依赖于过度回溯出现停止响应时它们处理输入的正则表达式，其中包含接近的匹配项。 有关详细信息，请参阅[正则表达式的最佳实践](~/docs/standard/base-types/best-practices.md)并[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果在该时间间隔内不找到任何匹配项，则该方法将引发<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>异常。 `matchTimeout` 重写应用程序域执行该方法定义的任何默认超时值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">出现正则表达式分析错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效按位组合。  
  
- 或 - 
 <paramref name="matchTimeout" /> 为负、零或大于 24 天左右。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">发生超时。 有关超时的详细信息，请参阅“备注”部分。</exception>
        <block subset="none" type="usage"><para>我们建议您将设置<paramref name="matchTimeout" />为适当的值，如两秒的参数。 如果通过指定禁用超时<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，正则表达式引擎提供了略有更好的性能。 但是，您应该禁用超时值仅在以下情况下： 
-当正则表达式处理输入派生自已知和受信任的来源或包含静态文本。 这不包括具有动态已由用户输入的文本。  
  
-当经过全面测试正则表达式模式以确保它有效地处理匹配，不匹配，并不久匹配。  
  
-当正则表达式模式不包含任何已知会导致过度回溯，处理接近的匹配项时的语言元素。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言元素</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 此参数保留以供将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回传入 <see langword="Regex" /> 构造函数的正则表达式模式。</summary>
        <returns>传入 <see langword="Regex" /> 构造函数的 <paramref name="pattern" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern`参数包含的符号描述要匹配的字符串的正则表达式语言元素。 有关正则表达式的详细信息，请参阅[.NET Framework 正则表达式](~/docs/standard/base-types/regular-expressions.md)并[正则表达式语言-快速参考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 是由创建的正则表达式的基类<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。 这些已编译的正则表达式使用<see cref="M:System.Text.RegularExpressions.Regex.ToString" />基的类的实现。 如果从派生类中，调用<see cref="M:System.Text.RegularExpressions.Regex.ToString" />方法返回的字符串传递给<paramref name="pattern" />参数的<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />用于定义正则表达式的类构造函数。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">包含要转换的文本的输入字符串。</param>
        <summary>转换输入字符串中的任何转义字符。</summary>
        <returns>包含任何转换为非转义形式的转义字符的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法执行以下两个转换之一：  
  
-   反转执行的转换<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法通过删除转义符 ("\\") 从该方法通过转义每个字符。 其中包括\\，*，+，？， &#124;，{，[，（、）、 ^、 $、。，# 和空白字符。 此外，<xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法反转义右括号 (]) 和右大括号 （}） 字符。  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 完全不能撤消已转义的字符串，因为它无法推导出的字符转义准确地说，  
  
-   它使用实际的可打印字符替换逐字字符串文本中的十六进制值。 例如，它将替换@"\x07"使用"\a"或@"\x0A"与"\n"。 它将转换为受支持的转义字符，如 \a，\b \e、 \n、 \r、 \f、 \t，\v 和字母数字字符。
  
 如果<xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法遇到无法转换，其他转义序列如 \w 或 \s，则会引发<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> 包括无法识别的转义序列。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">正则表达式语言 - 快速参考</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 属性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 选项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法生成的 <see cref="T:System.Text.RegularExpressions.Regex" /> 对象使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 属性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 选项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">要检查的超时间隔。</param>
        <summary>检查超时间隔是否在可接受的范围内。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的超时不在有效范围内。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
